let module_codes_data = {
  "3": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getEngineURL =\n  exports.TEST_ENGINE_PATHS =\n  exports.OPENAI_PROXY_HOST =\n    undefined;\nconst r = require(1133),\n  o = require(9189),\n  i = require(70);\nexports.OPENAI_PROXY_HOST = \"https://copilot-proxy.githubusercontent.com\";\nconst s = \"/v1/engines/copilot-codex\";\nexports.TEST_ENGINE_PATHS = [s];\nexports.getEngineURL = async function (e, n = \"\", a, c = \"\", l = \"\", u) {\n  return (function (e, n) {\n    let o = (function (e) {\n      return i.isRunningInTest(e)\n        ? r.getConfig(e, r.ConfigKey.DebugTestOverrideProxyUrl)\n        : r.getConfig(e, r.ConfigKey.DebugOverrideProxyUrl);\n    })(e);\n    if (0 == o.length) {\n      o = exports.OPENAI_PROXY_HOST;\n    }\n    return `${o}${n}`;\n  })(\n    e,\n    await (async function (e, t, n, i, a, c) {\n      const l = r.getConfig(e, r.ConfigKey.DebugOverrideEngine);\n      if (l) return `/v1/engines/${l}`;\n      const u = await e.get(o.Features).customEngine(t, n, i, a, c);\n      return \"\" !== u ? `/v1/engines/${u}` : s;\n    })(e, n, a, c, l, u)\n  );\n};",
  "19": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: !0,\n  code: require(412).validateUnion,\n  error: {\n    message: \"must match a schema in anyOf\",\n  },\n};\nexports.default = r;",
  "34": "var r;\nr = require(8249);\nrequire(4938);\n(function () {\n  var e = r,\n    t = e.lib.Hasher,\n    n = e.x64,\n    o = n.Word,\n    i = n.WordArray,\n    s = e.algo;\n  function a() {\n    return o.create.apply(o, arguments);\n  }\n  var c = [\n      a(1116352408, 3609767458),\n      a(1899447441, 602891725),\n      a(3049323471, 3964484399),\n      a(3921009573, 2173295548),\n      a(961987163, 4081628472),\n      a(1508970993, 3053834265),\n      a(2453635748, 2937671579),\n      a(2870763221, 3664609560),\n      a(3624381080, 2734883394),\n      a(310598401, 1164996542),\n      a(607225278, 1323610764),\n      a(1426881987, 3590304994),\n      a(1925078388, 4068182383),\n      a(2162078206, 991336113),\n      a(2614888103, 633803317),\n      a(3248222580, 3479774868),\n      a(3835390401, 2666613458),\n      a(4022224774, 944711139),\n      a(264347078, 2341262773),\n      a(604807628, 2007800933),\n      a(770255983, 1495990901),\n      a(1249150122, 1856431235),\n      a(1555081692, 3175218132),\n      a(1996064986, 2198950837),\n      a(2554220882, 3999719339),\n      a(2821834349, 766784016),\n      a(2952996808, 2566594879),\n      a(3210313671, 3203337956),\n      a(3336571891, 1034457026),\n      a(3584528711, 2466948901),\n      a(113926993, 3758326383),\n      a(338241895, 168717936),\n      a(666307205, 1188179964),\n      a(773529912, 1546045734),\n      a(1294757372, 1522805485),\n      a(1396182291, 2643833823),\n      a(1695183700, 2343527390),\n      a(1986661051, 1014477480),\n      a(2177026350, 1206759142),\n      a(2456956037, 344077627),\n      a(2730485921, 1290863460),\n      a(2820302411, 3158454273),\n      a(3259730800, 3505952657),\n      a(3345764771, 106217008),\n      a(3516065817, 3606008344),\n      a(3600352804, 1432725776),\n      a(4094571909, 1467031594),\n      a(275423344, 851169720),\n      a(430227734, 3100823752),\n      a(506948616, 1363258195),\n      a(659060556, 3750685593),\n      a(883997877, 3785050280),\n      a(958139571, 3318307427),\n      a(1322822218, 3812723403),\n      a(1537002063, 2003034995),\n      a(1747873779, 3602036899),\n      a(1955562222, 1575990012),\n      a(2024104815, 1125592928),\n      a(2227730452, 2716904306),\n      a(2361852424, 442776044),\n      a(2428436474, 593698344),\n      a(2756734187, 3733110249),\n      a(3204031479, 2999351573),\n      a(3329325298, 3815920427),\n      a(3391569614, 3928383900),\n      a(3515267271, 566280711),\n      a(3940187606, 3454069534),\n      a(4118630271, 4000239992),\n      a(116418474, 1914138554),\n      a(174292421, 2731055270),\n      a(289380356, 3203993006),\n      a(460393269, 320620315),\n      a(685471733, 587496836),\n      a(852142971, 1086792851),\n      a(1017036298, 365543100),\n      a(1126000580, 2618297676),\n      a(1288033470, 3409855158),\n      a(1501505948, 4234509866),\n      a(1607167915, 987167468),\n      a(1816402316, 1246189591),\n    ],\n    l = [];\n  !(function () {\n    for (var e = 0; e < 80; e++) l[e] = a();\n  })();\n  var u = (s.SHA512 = t.extend({\n    _doReset: function () {\n      this._hash = new i.init([\n        new o.init(1779033703, 4089235720),\n        new o.init(3144134277, 2227873595),\n        new o.init(1013904242, 4271175723),\n        new o.init(2773480762, 1595750129),\n        new o.init(1359893119, 2917565137),\n        new o.init(2600822924, 725511199),\n        new o.init(528734635, 4215389547),\n        new o.init(1541459225, 327033209),\n      ]);\n    },\n    _doProcessBlock: function (e, t) {\n      for (\n        var n = this._hash.words,\n          r = n[0],\n          o = n[1],\n          i = n[2],\n          s = n[3],\n          a = n[4],\n          u = n[5],\n          d = n[6],\n          p = n[7],\n          h = r.high,\n          f = r.low,\n          m = o.high,\n          g = o.low,\n          _ = i.high,\n          y = i.low,\n          v = s.high,\n          b = s.low,\n          w = a.high,\n          x = a.low,\n          E = u.high,\n          C = u.low,\n          S = d.high,\n          T = d.low,\n          k = p.high,\n          I = p.low,\n          P = h,\n          A = f,\n          O = m,\n          N = g,\n          R = _,\n          M = y,\n          L = v,\n          $ = b,\n          D = w,\n          F = x,\n          j = E,\n          q = C,\n          B = S,\n          U = T,\n          H = k,\n          z = I,\n          G = 0;\n        G < 80;\n        G++\n      ) {\n        var V,\n          W,\n          K = l[G];\n        if (G < 16) {\n          W = K.high = 0 | e[t + 2 * G];\n          V = K.low = 0 | e[t + 2 * G + 1];\n        } else {\n          var J = l[G - 15],\n            X = J.high,\n            Q = J.low,\n            Y = ((X >>> 1) | (Q << 31)) ^ ((X >>> 8) | (Q << 24)) ^ (X >>> 7),\n            Z =\n              ((Q >>> 1) | (X << 31)) ^\n              ((Q >>> 8) | (X << 24)) ^\n              ((Q >>> 7) | (X << 25)),\n            ee = l[G - 2],\n            te = ee.high,\n            ne = ee.low,\n            re =\n              ((te >>> 19) | (ne << 13)) ^\n              ((te << 3) | (ne >>> 29)) ^\n              (te >>> 6),\n            oe =\n              ((ne >>> 19) | (te << 13)) ^\n              ((ne << 3) | (te >>> 29)) ^\n              ((ne >>> 6) | (te << 26)),\n            ie = l[G - 7],\n            se = ie.high,\n            ae = ie.low,\n            ce = l[G - 16],\n            le = ce.high,\n            ue = ce.low;\n          W =\n            (W =\n              (W = Y + se + ((V = Z + ae) >>> 0 < Z >>> 0 ? 1 : 0)) +\n              re +\n              ((V += oe) >>> 0 < oe >>> 0 ? 1 : 0)) +\n            le +\n            ((V += ue) >>> 0 < ue >>> 0 ? 1 : 0);\n          K.high = W;\n          K.low = V;\n        }\n        var de,\n          pe = (D & j) ^ (~D & B),\n          he = (F & q) ^ (~F & U),\n          fe = (P & O) ^ (P & R) ^ (O & R),\n          me = (A & N) ^ (A & M) ^ (N & M),\n          ge =\n            ((P >>> 28) | (A << 4)) ^\n            ((P << 30) | (A >>> 2)) ^\n            ((P << 25) | (A >>> 7)),\n          _e =\n            ((A >>> 28) | (P << 4)) ^\n            ((A << 30) | (P >>> 2)) ^\n            ((A << 25) | (P >>> 7)),\n          ye =\n            ((D >>> 14) | (F << 18)) ^\n            ((D >>> 18) | (F << 14)) ^\n            ((D << 23) | (F >>> 9)),\n          ve =\n            ((F >>> 14) | (D << 18)) ^\n            ((F >>> 18) | (D << 14)) ^\n            ((F << 23) | (D >>> 9)),\n          be = c[G],\n          we = be.high,\n          xe = be.low,\n          Ee = H + ye + ((de = z + ve) >>> 0 < z >>> 0 ? 1 : 0),\n          Ce = _e + me;\n        H = B;\n        z = U;\n        B = j;\n        U = q;\n        j = D;\n        q = F;\n        D =\n          (L +\n            (Ee =\n              (Ee =\n                (Ee = Ee + pe + ((de += he) >>> 0 < he >>> 0 ? 1 : 0)) +\n                we +\n                ((de += xe) >>> 0 < xe >>> 0 ? 1 : 0)) +\n              W +\n              ((de += V) >>> 0 < V >>> 0 ? 1 : 0)) +\n            ((F = ($ + de) | 0) >>> 0 < $ >>> 0 ? 1 : 0)) |\n          0;\n        L = R;\n        $ = M;\n        R = O;\n        M = N;\n        O = P;\n        N = A;\n        P =\n          (Ee +\n            (ge + fe + (Ce >>> 0 < _e >>> 0 ? 1 : 0)) +\n            ((A = (de + Ce) | 0) >>> 0 < de >>> 0 ? 1 : 0)) |\n          0;\n      }\n      f = r.low = f + A;\n      r.high = h + P + (f >>> 0 < A >>> 0 ? 1 : 0);\n      g = o.low = g + N;\n      o.high = m + O + (g >>> 0 < N >>> 0 ? 1 : 0);\n      y = i.low = y + M;\n      i.high = _ + R + (y >>> 0 < M >>> 0 ? 1 : 0);\n      b = s.low = b + $;\n      s.high = v + L + (b >>> 0 < $ >>> 0 ? 1 : 0);\n      x = a.low = x + F;\n      a.high = w + D + (x >>> 0 < F >>> 0 ? 1 : 0);\n      C = u.low = C + q;\n      u.high = E + j + (C >>> 0 < q >>> 0 ? 1 : 0);\n      T = d.low = T + U;\n      d.high = S + B + (T >>> 0 < U >>> 0 ? 1 : 0);\n      I = p.low = I + z;\n      p.high = k + H + (I >>> 0 < z >>> 0 ? 1 : 0);\n    },\n    _doFinalize: function () {\n      var e = this._data,\n        t = e.words,\n        n = 8 * this._nDataBytes,\n        r = 8 * e.sigBytes;\n      t[r >>> 5] |= 128 << (24 - (r % 32));\n      t[30 + (((r + 128) >>> 10) << 5)] = Math.floor(n / 4294967296);\n      t[31 + (((r + 128) >>> 10) << 5)] = n;\n      e.sigBytes = 4 * t.length;\n      this._process();\n      return this._hash.toX32();\n    },\n    clone: function () {\n      var e = t.clone.call(this);\n      e._hash = this._hash.clone();\n      return e;\n    },\n    blockSize: 32,\n  }));\n  e.SHA512 = t._createHelper(u);\n  e.HmacSHA512 = t._createHmacHelper(u);\n})();\nmodule.exports = r.SHA512;",
  "39": "const r = require(\"tty\"),\n  o = require(\"util\");\nexports.init = function (e) {\n  e.inspectOpts = {};\n  const n = Object.keys(exports.inspectOpts);\n  for (let r = 0; r < n.length; r++)\n    e.inspectOpts[n[r]] = exports.inspectOpts[n[r]];\n};\nexports.log = function (...e) {\n  return process.stderr.write(o.format(...e) + \"\\n\");\n};\nexports.formatArgs = function (n) {\n  const { namespace: r, useColors: o } = this;\n  if (o) {\n    const t = this.color,\n      o = \"\u001b[3\" + (t < 8 ? t : \"8;5;\" + t),\n      i = `  ${o};1m${r} \u001b[0m`;\n    n[0] = i + n[0].split(\"\\n\").join(\"\\n\" + i);\n    n.push(o + \"m+\" + module.exports.humanize(this.diff) + \"\u001b[0m\");\n  } else\n    n[0] =\n      (exports.inspectOpts.hideDate ? \"\" : new Date().toISOString() + \" \") +\n      r +\n      \" \" +\n      n[0];\n};\nexports.save = function (e) {\n  if (e) {\n    process.env.DEBUG = e;\n  } else {\n    delete process.env.DEBUG;\n  }\n};\nexports.load = function () {\n  return process.env.DEBUG;\n};\nexports.useColors = function () {\n  return \"colors\" in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : r.isatty(process.stderr.fd);\n};\nexports.destroy = o.deprecate(() => {},\n\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\nexports.colors = [6, 2, 3, 4, 5, 1];\ntry {\n  const e = require(2130);\n  if (e && (e.stderr || e).level >= 2) {\n    exports.colors = [\n      20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63,\n      68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128,\n      129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169,\n      170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202,\n      203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221,\n    ];\n  }\n} catch (e) {}\nexports.inspectOpts = Object.keys(process.env)\n  .filter((e) => /^debug_/i.test(e))\n  .reduce((e, t) => {\n    const n = t\n      .substring(6)\n      .toLowerCase()\n      .replace(/_([a-z])/g, (e, t) => t.toUpperCase());\n    let r = process.env[t];\n    r =\n      !!/^(yes|on|true|enabled)$/i.test(r) ||\n      (!/^(no|off|false|disabled)$/i.test(r) &&\n        (\"null\" === r ? null : Number(r)));\n    e[n] = r;\n    return e;\n  }, {});\nmodule.exports = require(2447)(exports);\nconst { formatters: i } = module.exports;\ni.o = function (e) {\n  this.inspectOpts.colors = this.useColors;\n  return o\n    .inspect(e, this.inspectOpts)\n    .split(\"\\n\")\n    .map((e) => e.trim())\n    .join(\" \");\n};\ni.O = function (e) {\n  this.inspectOpts.colors = this.useColors;\n  return o.inspect(e, this.inspectOpts);\n};",
  "47": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getGithubAccount = exports.getSession = undefined;\nconst r = require(\"vscode\"),\n  o = [\"read:user\"];\nlet i,\n  s = !1;\nfunction a(e) {\n  if (\"true\" === process.env.CODESPACES && process.env.GITHUB_TOKEN) {\n    const e = process.env.GITHUB_USER || \"codespace-user\",\n      t = {\n        accessToken: process.env.GITHUB_TOKEN,\n        account: {\n          label: e,\n        },\n      };\n    return Promise.resolve(t);\n  }\n  return r.authentication.getSession(\"github\", o, {\n    createIfNone: e,\n  });\n}\nexports.getSession = async function () {\n  let e = await a(!1);\n  if (e || s) {\n    s = !0;\n    if (\n      \"Sign in to GitHub\" ===\n      (await r.window.showInformationMessage(\n        \"Sign in to access GitHub Copilot.\",\n        \"Sign in to GitHub\"\n      ))\n    ) {\n      e = await a(!0);\n    }\n  }\n  if (e) {\n    i = e.account;\n  }\n  return e;\n};\nexports.getGithubAccount = function () {\n  return i;\n};",
  "70": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.isVerboseLoggingEnabled =\n  exports.isDebugEnabled =\n  exports.shouldFailForDebugPurposes =\n  exports.isRunningInTest =\n  exports.RuntimeMode =\n    undefined;\nclass RuntimeMode {\n  constructor(e) {\n    this.flags = e;\n  }\n  static fromEnvironment(e) {\n    return new RuntimeMode({\n      debug:\n        ((t = process.argv),\n        (r = process.env),\n        t.includes(\"--debug\") ||\n          \"true\" ===\n            (null === (s = r.GITHUB_COPILOT_DEBUG) || undefined === s\n              ? undefined\n              : s.toLowerCase())),\n      verboseLogging: o(process.env),\n      testMode: e,\n      recordInput: i(process.argv, process.env),\n    });\n    var t, r, s;\n  }\n}\nfunction isRunningInTest(e) {\n  return e.get(RuntimeMode).flags.testMode;\n}\nfunction o(e) {\n  if (\"COPILOT_AGENT_VERBOSE\" in e) {\n    const t = e.COPILOT_AGENT_VERBOSE;\n    return \"1\" === t || \"true\" === t;\n  }\n  return !1;\n}\nfunction i(e, t) {\n  var n;\n  return (\n    e.includes(\"--record\") ||\n    \"true\" ===\n      (null === (n = t.GITHUB_COPILOT_RECORD) || undefined === n\n        ? undefined\n        : n.toLowerCase())\n  );\n}\nexports.RuntimeMode = RuntimeMode;\nexports.isRunningInTest = isRunningInTest;\nexports.shouldFailForDebugPurposes = function (e) {\n  return isRunningInTest(e);\n};\nexports.isDebugEnabled = function (e) {\n  return e.get(RuntimeMode).flags.debug;\n};\nexports.isVerboseLoggingEnabled = function (e) {\n  return e.get(RuntimeMode).flags.verboseLogging;\n};",
  "98": "module.exports = JSON.parse(\n  '{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"nonNegativeInteger\":{\"type\":\"integer\",\"minimum\":0},\"nonNegativeIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/nonNegativeInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"uniqueItems\":true,\"default\":[]}},\"type\":[\"object\",\"boolean\"],\"properties\":{\"$id\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$schema\":{\"type\":\"string\",\"format\":\"uri\"},\"$ref\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$comment\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":true,\"readOnly\":{\"type\":\"boolean\",\"default\":false},\"examples\":{\"type\":\"array\",\"items\":true},\"multipleOf\":{\"type\":\"number\",\"exclusiveMinimum\":0},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"number\"},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"number\"},\"maxLength\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minLength\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"$ref\":\"#\"},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":true},\"maxItems\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minItems\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"contains\":{\"$ref\":\"#\"},\"maxProperties\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"$ref\":\"#\"},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"propertyNames\":{\"format\":\"regex\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"propertyNames\":{\"$ref\":\"#\"},\"const\":true,\"enum\":{\"type\":\"array\",\"items\":true,\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"contentMediaType\":{\"type\":\"string\"},\"contentEncoding\":{\"type\":\"string\"},\"if\":{\"$ref\":\"#\"},\"then\":{\"$ref\":\"#\"},\"else\":{\"$ref\":\"#\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"default\":true}'\n);",
  "106": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.debounce = exports.Debouncer = undefined;\nexports.Debouncer = class {\n  async debounce(e) {\n    if (this.state) {\n      clearTimeout(this.state.timer);\n      this.state.reject();\n      this.state = undefined;\n    }\n    return new Promise((t, n) => {\n      this.state = {\n        timer: setTimeout(() => t(), e),\n        reject: n,\n      };\n    });\n  }\n};\nexports.debounce = function (e, t) {\n  let n;\n  return (...r) => (\n    n && clearTimeout(n),\n    new Promise((o) => {\n      n = setTimeout(() => {\n        const e = t(...r);\n        o(e);\n      }, e);\n    })\n  );\n};",
  "130": "module.exports = {\n  i8: \"0.2.0\",\n};",
  "219": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.ExpConfig = exports.ExpTreatmentVariables = undefined;\nconst r = require(6333),\n  o = require(6500);\nvar i;\n(i = exports.ExpTreatmentVariables || (exports.ExpTreatmentVariables = {})).AA =\n  \"copilotaa\";\ni.CustomEngine = \"copilotcustomengine\";\ni.Fetcher = \"copilotfetcher\";\ni.OverrideBlockMode = \"copilotoverrideblockmode\";\ni.OverrideNumGhostCompletions = \"copilotoverridednumghostcompletions\";\ni.SuffixPercent = \"CopilotSuffixPercent\";\ni.BeforeRequestWaitMs = \"copilotlms\";\ni.NeighboringTabsOption = \"copilotneighboringtabs\";\ni.DebounceMs = \"copilotdebouncems\";\ni.DebouncePredict = \"copilotdebouncepredict\";\ni.ContextualFilterEnable = \"copilotcontextualfilterenable\";\ni.ContextualFilterAcceptThreshold = \"copilotcontextualfilteracceptthreshold\";\ni.disableLogProb = \"copilotLogProb\";\ni.RepetitionFilterMode = \"copilotrepetitionfiltermode\";\ni.GranularityTimePeriodSizeInH = \"copilottimeperiodsizeinh\";\ni.GranularityByCallBuckets = \"copilotbycallbuckets\";\ni.SuffixStartMode = \"copilotsuffixstartmode\";\ni.SuffixMatchThreshold = \"copilotsuffixmatchthreshold\";\ni.FimSuffixLengthThreshold = \"copilotfimsuffixlenthreshold\";\ni.MultiLogitBias = \"copilotlbeot\";\nclass ExpConfig {\n  constructor(e, t, n) {\n    this.variables = e;\n    this.assignmentContext = t;\n    this.features = n;\n  }\n  static createFallbackConfig(e, t) {\n    r.telemetryExpProblem(e, {\n      reason: t,\n    });\n    return this.createEmptyConfig();\n  }\n  static createEmptyConfig() {\n    return new ExpConfig({}, \"\", \"\");\n  }\n  addToTelemetry(e) {\n    e.properties[o.ExpServiceTelemetryNames.featuresTelemetryPropertyName] =\n      this.features;\n    e.properties[\n      o.ExpServiceTelemetryNames.assignmentContextTelemetryPropertyName\n    ] = this.assignmentContext;\n  }\n}\nexports.ExpConfig = ExpConfig;",
  "256": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.decodeLocation =\n  exports.encodeLocation =\n  exports.completionContextForDocument =\n  exports.CompletionContext =\n  exports.completionTypeToString =\n  exports.CompletionType =\n    undefined;\nconst r = require(7373),\n  o = require(6403),\n  i = require(4197);\nvar s;\n!(function (e) {\n  e[(e.OPEN_COPILOT = 2)] = \"OPEN_COPILOT\";\n  e[(e.TODO_QUICK_FIX = 3)] = \"TODO_QUICK_FIX\";\n  e[(e.UNKNOWN_FUNCTION_QUICK_FIX = 4)] = \"UNKNOWN_FUNCTION_QUICK_FIX\";\n})((s = exports.CompletionType || (exports.CompletionType = {})));\nexports.completionTypeToString = function (e) {\n  switch (e) {\n    case s.OPEN_COPILOT:\n      return \"open copilot\";\n    case s.TODO_QUICK_FIX:\n      return \"todo quick fix\";\n    case s.UNKNOWN_FUNCTION_QUICK_FIX:\n      return \"unknown function quick fix\";\n    default:\n      return \"unknown\";\n  }\n};\nclass CompletionContext {\n  constructor(e, t, n) {\n    this.prependToCompletion = \"\";\n    this.appendToCompletion = \"\";\n    this.indentation = null;\n    this.completionType = s.OPEN_COPILOT;\n    this.insertPosition = e\n      .get(o.LocationFactory)\n      .position(t.line, t.character);\n    this.completionType = n;\n  }\n  static fromJSONParse(e, t) {\n    const n = e\n        .get(o.LocationFactory)\n        .position(t.insertPosition.line, t.insertPosition.character),\n      r = new CompletionContext(e, n, t.completionType);\n    r.prependToCompletion = t.prependToCompletion;\n    r.appendToCompletion = t.appendToCompletion;\n    r.indentation = t.indentation;\n    return r;\n  }\n}\nexports.CompletionContext = CompletionContext;\nexports.completionContextForDocument = function (e, t, n) {\n  let r = n;\n  const o = t.lineAt(n.line);\n  if (o.isEmptyOrWhitespace) {\n    r = o.range.end;\n  }\n  return new CompletionContext(e, r, s.OPEN_COPILOT);\n};\nlet c = 0;\nexports.encodeLocation = function (e, t) {\n  const n = e.toString().split(\"#\"),\n    o = n.length > 1 ? n[1] : \"\",\n    s = JSON.stringify([n[0], t, o]);\n  return r.URI.parse(`${i.CopilotScheme}:GitHub%20Copilot?${s}#${c++}`);\n};\nexports.decodeLocation = function (e, t) {\n  const [n, o, i] = JSON.parse(t.query);\n  return [\n    r.URI.parse(i.length > 0 ? n + \"#\" + i : n),\n    CompletionContext.fromJSONParse(e, o),\n  ];\n};",
  "298": "var r;\nr = require(8249);\n(function () {\n  var e = r,\n    t = e.lib.WordArray,\n    n = e.enc;\n  function o(e) {\n    return ((e << 8) & 4278255360) | ((e >>> 8) & 16711935);\n  }\n  n.Utf16 = n.Utf16BE = {\n    stringify: function (e) {\n      for (var t = e.words, n = e.sigBytes, r = [], o = 0; o < n; o += 2) {\n        var i = (t[o >>> 2] >>> (16 - (o % 4) * 8)) & 65535;\n        r.push(String.fromCharCode(i));\n      }\n      return r.join(\"\");\n    },\n    parse: function (e) {\n      for (var n = e.length, r = [], o = 0; o < n; o++)\n        r[o >>> 1] |= e.charCodeAt(o) << (16 - (o % 2) * 16);\n      return t.create(r, 2 * n);\n    },\n  };\n  n.Utf16LE = {\n    stringify: function (e) {\n      for (var t = e.words, n = e.sigBytes, r = [], i = 0; i < n; i += 2) {\n        var s = o((t[i >>> 2] >>> (16 - (i % 4) * 8)) & 65535);\n        r.push(String.fromCharCode(s));\n      }\n      return r.join(\"\");\n    },\n    parse: function (e) {\n      for (var n = e.length, r = [], i = 0; i < n; i++)\n        r[i >>> 1] |= o(e.charCodeAt(i) << (16 - (i % 2) * 16));\n      return t.create(r, 2 * n);\n    },\n  };\n})();\nmodule.exports = r.enc.Utf16;",
  "299": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.Clock = undefined;\nexports.Clock = class {\n  now() {\n    return new Date();\n  }\n};",
  "313": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.assignDefaults = undefined;\nconst r = require(3487),\n  o = require(6776);\nfunction i(e, t, n) {\n  const { gen: i, compositeRule: s, data: a, opts: c } = e;\n  if (undefined === n) return;\n  const l = r._`${a}${r.getProperty(t)}`;\n  if (s) return void o.checkStrictMode(e, `default is ignored for: ${l}`);\n  let u = r._`${l} === undefined`;\n  if (\"empty\" === c.useDefaults) {\n    u = r._`${u} || ${l} === null || ${l} === \"\"`;\n  }\n  i.if(u, r._`${l} = ${r.stringify(n)}`);\n}\nexports.assignDefaults = function (e, t) {\n  const { properties: n, items: r } = e.schema;\n  if (\"object\" === t && n) for (const t in n) i(e, t, n[t].default);\n  else if (\"array\" === t && Array.isArray(r)) {\n    r.forEach((t, n) => i(e, n, t.default));\n  }\n};",
  "320": "var r,\n  o =\n    (this && this.__extends) ||\n    ((r =\n      Object.setPrototypeOf ||\n      ({\n        __proto__: [],\n      } instanceof Array &&\n        function (e, t) {\n          e.__proto__ = t;\n        }) ||\n      function (e, t) {\n        for (var n in t)\n          if (t.hasOwnProperty(n)) {\n            e[n] = t[n];\n          }\n      }),\n    function (e, t) {\n      function n() {\n        this.constructor = e;\n      }\n      r(e, t);\n      e.prototype =\n        null === t ? Object.create(t) : ((n.prototype = t.prototype), new n());\n    }),\n  i = (function (e) {\n    function t() {\n      return e.call(this) || this;\n    }\n    o(t, e);\n    return t;\n  })(require(4101));\nmodule.exports = i;",
  "362": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.refreshToken =\n  exports.CopilotTokenManagerFromGitHubToken =\n  exports.FixedCopilotTokenManager =\n  exports.CopilotTokenManager =\n  exports.setTelemetryConfigFromTokenInfo =\n  exports.extractTrackingIdFromToken =\n  exports.authFromGitHubToken =\n  exports.nowSeconds =\n  exports.TOKEN_REFRESHED_EVENT =\n    undefined;\nconst r = require(\"events\"),\n  o = require(1133),\n  i = require(9899),\n  s = require(2279),\n  a = require(1547),\n  c = require(6333),\n  l = require(7057),\n  u = new i.Logger(i.LogLevel.INFO, \"auth\");\nlet d = 0;\nfunction nowSeconds() {\n  return Math.floor(Date.now() / 1e3);\n}\nasync function authFromGitHubToken(e, t) {\n  var n, r;\n  c.telemetry(e, \"auth.new_login\");\n  const i =\n      null !==\n        (r =\n          null === (n = t.devOverride) || undefined === n\n            ? undefined\n            : n.copilotTokenUrl) && undefined !== r\n        ? r\n        : \"https://api.github.com/copilot_internal/v2/token\",\n    a = await e.get(s.Fetcher).fetch(i, {\n      headers: {\n        Authorization: `token ${t.token}`,\n        ...o.editorVersionHeaders(e),\n      },\n    });\n  if (!a) {\n    u.info(e, \"Failed to get copilot token\");\n    c.telemetryError(e, \"auth.request_failed\");\n    return {\n      kind: \"failure\",\n      reason: \"FailedToGetToken\",\n    };\n  }\n  const l = await a.json();\n  if (!l) {\n    u.info(e, \"Failed to get copilot token\");\n    c.telemetryError(e, \"auth.request_read_failed\");\n    return {\n      kind: \"failure\",\n      reason: \"FailedToGetToken\",\n    };\n  }\n  m(e, l.user_notification, t);\n  if (401 === a.status)\n    return (\n      u.info(e, \"Failed to get copilot token due to 401 status\"),\n      (0, c.telemetryError)(e, \"auth.unknown_401\"),\n      {\n        kind: \"failure\",\n        reason: \"HTTP401\",\n      }\n    );\n  if (!a.ok || !l.token) {\n    u.info(\n      e,\n      `Invalid copilot token: missing token: ${a.status} ${a.statusText}`\n    );\n    c.telemetryError(\n      e,\n      \"auth.invalid_token\",\n      c.TelemetryData.createAndMarkAsIssued({\n        status: a.status.toString(),\n        status_text: a.statusText,\n      })\n    );\n    const n = l.error_details;\n    m(e, n, t);\n    return {\n      kind: \"failure\",\n      reason: \"NotAuthorized\",\n      ...n,\n    };\n  }\n  const d = l.expires_at;\n  l.expires_at = nowSeconds() + l.refresh_in + 60;\n  e.get(c.TelemetryReporters).setToken(l);\n  setTelemetryConfigFromTokenInfo(l);\n  c.telemetry(\n    e,\n    \"auth.new_token\",\n    c.TelemetryData.createAndMarkAsIssued(\n      {},\n      {\n        adjusted_expires_at: l.expires_at,\n        expires_at: d,\n        current_time: nowSeconds(),\n      }\n    )\n  );\n  return {\n    kind: \"success\",\n    ...l,\n  };\n}\nexports.TOKEN_REFRESHED_EVENT = \"token_refreshed\";\nexports.nowSeconds = nowSeconds;\nexports.authFromGitHubToken = authFromGitHubToken;\nconst f = new Map();\nfunction m(e, t, n) {\n  if (!t) return;\n  const r = nowSeconds();\n  if (f.get(t.message)) {\n    f.set(t.message, r);\n    e.get(a.NotificationSender)\n      .showWarningMessage(\n        t.message,\n        {\n          title: t.title,\n        },\n        {\n          title: \"Dismiss\",\n        }\n      )\n      .catch((t) => {\n        console.error(t);\n        u.error(e, `Error while sending notification: ${t.message}`);\n      })\n      .then(async (r) => {\n        const i = (null == r ? undefined : r.title) === t.title,\n          a = i || \"Dismiss\" === (null == r ? undefined : r.title);\n        if (i) {\n          const n = e.get(o.EditorAndPluginInfo).getEditorPluginInfo(e),\n            r = t.url.replace(\n              \"{EDITOR}\",\n              encodeURIComponent(n.name + \"_\" + n.version)\n            );\n          await e.get(l.UrlOpener).open(r);\n        }\n        if (\"notification_id\" in t && a) {\n          await (async function (e, t, n) {\n            var r, i;\n            const a =\n                null !==\n                  (i =\n                    null === (r = n.devOverride) || undefined === r\n                      ? undefined\n                      : r.notificationUrl) && undefined !== i\n                  ? i\n                  : \"https://api.github.com/copilot_internal/notification\",\n              c = await e.get(s.Fetcher).fetch(a, {\n                headers: {\n                  Authorization: `token ${n.token}`,\n                  ...o.editorVersionHeaders(e),\n                },\n                method: \"POST\",\n                body: JSON.stringify({\n                  notification_id: t,\n                }),\n              });\n            if (c && c.ok) {\n              u.error(\n                e,\n                `Failed to send notification result to GitHub: ${\n                  null == c ? undefined : c.status\n                } ${null == c ? undefined : c.statusText}`\n              );\n            }\n          })(e, t.notification_id, n);\n        }\n      });\n  }\n}\nfunction extractTrackingIdFromToken(e) {\n  const t = null == e ? undefined : e.split(\":\")[0],\n    n = null == t ? undefined : t.split(\";\");\n  for (const e of n) {\n    const [t, n] = e.split(\"=\");\n    if (\"tid\" === t) return n;\n  }\n}\nfunction setTelemetryConfigFromTokenInfo(e) {\n  const t = extractTrackingIdFromToken(e.token);\n  if (undefined !== t) {\n    c.setTelemetryConfig({\n      trackingId: t,\n      optedIn: \"enabled\" === e.telemetry || \"unconfigured\" === e.telemetry,\n    });\n  }\n}\nexports.extractTrackingIdFromToken = extractTrackingIdFromToken;\nexports.setTelemetryConfigFromTokenInfo = setTelemetryConfigFromTokenInfo;\nclass CopilotTokenManager {\n  constructor() {\n    this.tokenRefreshEventEmitter = new r.EventEmitter();\n  }\n}\nfunction refreshToken(e, n, r) {\n  const o = nowSeconds();\n  if (d > 0) {\n    d++;\n    setTimeout(async () => {\n      let r,\n        i = \"\";\n      try {\n        d--;\n        await n.getCopilotToken(e, !0);\n        r = \"success\";\n        n.tokenRefreshEventEmitter.emit(exports.TOKEN_REFRESHED_EVENT);\n      } catch (e) {\n        r = \"failure\";\n        i = e.toString();\n      }\n      const s = c.TelemetryData.createAndMarkAsIssued(\n        {\n          result: r,\n        },\n        {\n          time_taken: nowSeconds() - o,\n          refresh_count: d,\n        }\n      );\n      if (i) {\n        s.properties.reason = i;\n      }\n      c.telemetry(e, \"auth.token_refresh\", s);\n    }, 1e3 * r);\n  }\n}\nexports.CopilotTokenManager = CopilotTokenManager;\nexports.FixedCopilotTokenManager = class extends CopilotTokenManager {\n  constructor(e) {\n    super();\n    this.tokenInfo = e;\n    this.wasReset = !1;\n    setTelemetryConfigFromTokenInfo(e);\n  }\n  async getGitHubToken() {\n    return Promise.resolve(\"token\");\n  }\n  async getCopilotToken(e, t) {\n    return this.tokenInfo;\n  }\n  resetCopilotToken(e, t) {\n    this.wasReset = !0;\n  }\n  async checkCopilotToken(e) {\n    return {\n      status: \"OK\",\n      telemetry: this.tokenInfo.telemetry,\n    };\n  }\n};\nexports.CopilotTokenManagerFromGitHubToken = class extends CopilotTokenManager {\n  constructor(e) {\n    super();\n    this.githubToken = e;\n    this.copilotToken = undefined;\n  }\n  async getGitHubToken() {\n    return Promise.resolve(this.githubToken.token);\n  }\n  async getCopilotToken(e, t) {\n    var n;\n    if (\n      !this.copilotToken ||\n      this.copilotToken.expires_at < nowSeconds() ||\n      t\n    ) {\n      const t = await authFromGitHubToken(e, this.githubToken);\n      if (\"failure\" === t.kind)\n        throw Error(\n          `Failed to get copilot token: ${t.reason.toString()} ${\n            null !== (n = t.message) && undefined !== n ? n : \"\"\n          }`\n        );\n      this.copilotToken = {\n        ...t,\n      };\n      refreshToken(e, this, t.refresh_in);\n    }\n    return this.copilotToken;\n  }\n  async checkCopilotToken(e) {\n    if (!this.copilotToken || this.copilotToken.expires_at < nowSeconds()) {\n      const t = await authFromGitHubToken(e, this.githubToken);\n      if (\"failure\" === t.kind) return t;\n      this.copilotToken = {\n        ...t,\n      };\n      refreshToken(e, this, t.refresh_in);\n    }\n    return {\n      status: \"OK\",\n      telemetry: this.copilotToken.telemetry,\n    };\n  }\n  resetCopilotToken(e, t) {\n    if (undefined !== t) {\n      c.telemetry(e, \"auth.reset_token_\" + t);\n    }\n    u.debug(e, `Resetting copilot token on HTTP error ${t || \"unknown\"}`);\n    this.copilotToken = undefined;\n  }\n};\nexports.refreshToken = refreshToken;",
  "385": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.ExtensionTextDocumentManager = undefined;\nconst r = require(\"path\"),\n  o = require(\"vscode\"),\n  i = require(3136);\nclass ExtensionTextDocumentManager extends i.TextDocumentManager {\n  constructor() {\n    super(...arguments);\n    this.onDidFocusTextDocument = o.window.onDidChangeActiveTextEditor;\n    this.onDidChangeTextDocument = o.workspace.onDidChangeTextDocument;\n  }\n  get textDocuments() {\n    return o.workspace.textDocuments;\n  }\n  async getTextDocument(e) {\n    return o.workspace.openTextDocument(e);\n  }\n  async getRelativePath(e) {\n    var t, n, s;\n    const a = e;\n    if (a) {\n      if (a.isUntitled) return;\n      return null !==\n        (s = i.getRelativePath(\n          null !==\n            (n =\n              null === (t = o.workspace.workspaceFolders) || undefined === t\n                ? undefined\n                : t.map((e) => e.uri)) && undefined !== n\n            ? n\n            : [],\n          a.fileName\n        )) && undefined !== s\n        ? s\n        : r.basename(a.fileName);\n    }\n  }\n  findNotebook(e) {\n    const t = e;\n    return o.workspace.notebookDocuments.find((e) =>\n      e.getCells().some((e) => e.document === t)\n    );\n  }\n}\nexports.ExtensionTextDocumentManager = ExtensionTextDocumentManager;",
  "406": "require(6252).install();",
  "412": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.validateUnion =\n  exports.validateArray =\n  exports.usePattern =\n  exports.callValidateCode =\n  exports.schemaProperties =\n  exports.allSchemaProperties =\n  exports.noPropertyInData =\n  exports.propertyInData =\n  exports.isOwnProperty =\n  exports.hasPropFunc =\n  exports.reportMissingProp =\n  exports.checkMissingProp =\n  exports.checkReportMissingProp =\n    undefined;\nconst r = require(3487),\n  o = require(6776),\n  i = require(2141);\nfunction hasPropFunc(e) {\n  return e.scopeValue(\"func\", {\n    ref: Object.prototype.hasOwnProperty,\n    code: r._`Object.prototype.hasOwnProperty`,\n  });\n}\nfunction isOwnProperty(e, t, n) {\n  return r._`${hasPropFunc(e)}.call(${t}, ${n})`;\n}\nfunction noPropertyInData(e, t, n, o) {\n  const i = r._`${t}${r.getProperty(n)} === undefined`;\n  return o ? r.or(i, r.not(isOwnProperty(e, t, n))) : i;\n}\nfunction allSchemaProperties(e) {\n  return e ? Object.keys(e).filter((e) => \"__proto__\" !== e) : [];\n}\nexports.checkReportMissingProp = function (e, t) {\n  const { gen: n, data: o, it: i } = e;\n  n.if(noPropertyInData(n, o, t, i.opts.ownProperties), () => {\n    e.setParams(\n      {\n        missingProperty: r._`${t}`,\n      },\n      !0\n    );\n    e.error();\n  });\n};\nexports.checkMissingProp = function (\n  { gen: e, data: t, it: { opts: n } },\n  o,\n  i\n) {\n  return r.or(\n    ...o.map((o) =>\n      r.and(noPropertyInData(e, t, o, n.ownProperties), r._`${i} = ${o}`)\n    )\n  );\n};\nexports.reportMissingProp = function (e, t) {\n  e.setParams(\n    {\n      missingProperty: t,\n    },\n    !0\n  );\n  e.error();\n};\nexports.hasPropFunc = hasPropFunc;\nexports.isOwnProperty = isOwnProperty;\nexports.propertyInData = function (e, t, n, o) {\n  const i = r._`${t}${r.getProperty(n)} !== undefined`;\n  return o ? r._`${i} && ${isOwnProperty(e, t, n)}` : i;\n};\nexports.noPropertyInData = noPropertyInData;\nexports.allSchemaProperties = allSchemaProperties;\nexports.schemaProperties = function (e, t) {\n  return allSchemaProperties(t).filter((n) => !o.alwaysValidSchema(e, t[n]));\n};\nexports.callValidateCode = function (\n  {\n    schemaCode: e,\n    data: t,\n    it: { gen: n, topSchemaRef: o, schemaPath: s, errorPath: a },\n    it: c,\n  },\n  l,\n  u,\n  d\n) {\n  const p = d ? r._`${e}, ${t}, ${o}${s}` : t,\n    h = [\n      [i.default.instancePath, r.strConcat(i.default.instancePath, a)],\n      [i.default.parentData, c.parentData],\n      [i.default.parentDataProperty, c.parentDataProperty],\n      [i.default.rootData, i.default.rootData],\n    ];\n  if (c.opts.dynamicRef) {\n    h.push([i.default.dynamicAnchors, i.default.dynamicAnchors]);\n  }\n  const f = r._`${p}, ${n.object(...h)}`;\n  return u !== r.nil ? r._`${l}.call(${u}, ${f})` : r._`${l}(${f})`;\n};\nexports.usePattern = function ({ gen: e, it: { opts: t } }, n) {\n  const o = t.unicodeRegExp ? \"u\" : \"\";\n  return e.scopeValue(\"pattern\", {\n    key: n,\n    ref: new RegExp(n, o),\n    code: r._`new RegExp(${n}, ${o})`,\n  });\n};\nexports.validateArray = function (e) {\n  const { gen: t, data: n, keyword: i, it: s } = e,\n    a = t.name(\"valid\");\n  if (s.allErrors) {\n    const e = t.let(\"valid\", !0);\n    c(() => t.assign(e, !1));\n    return e;\n  }\n  t.var(a, !0);\n  c(() => t.break());\n  return a;\n  function c(s) {\n    const c = t.const(\"len\", r._`${n}.length`);\n    t.forRange(\"i\", 0, c, (n) => {\n      e.subschema(\n        {\n          keyword: i,\n          dataProp: n,\n          dataPropType: o.Type.Num,\n        },\n        a\n      );\n      t.if(r.not(a), s);\n    });\n  }\n};\nexports.validateUnion = function (e) {\n  const { gen: t, schema: n, keyword: i, it: s } = e;\n  if (!Array.isArray(n)) throw new Error(\"ajv implementation error\");\n  if (n.some((e) => o.alwaysValidSchema(s, e)) && !s.opts.unevaluated) return;\n  const a = t.let(\"valid\", !1),\n    c = t.name(\"_valid\");\n  t.block(() =>\n    n.forEach((n, o) => {\n      const s = e.subschema(\n        {\n          keyword: i,\n          schemaProp: o,\n          compositeRule: !0,\n        },\n        c\n      );\n      t.assign(a, r._`${a} || ${c}`);\n      if (e.mergeValidEvaluated(s, c)) {\n        t.if(r.not(a));\n      }\n    })\n  );\n  e.result(\n    a,\n    () => e.reset(),\n    () => e.error(!0)\n  );\n};",
  "420": "function t(e) {\n  var t = new Error(\"Cannot find module '\" + e + \"'\");\n  throw ((t.code = \"MODULE_NOT_FOUND\"), t);\n}\nt.keys = () => [];\nt.resolve = t;\nt.id = 420;\nmodule.exports = t;",
  "430": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = {\n    keyword: \"multipleOf\",\n    type: \"number\",\n    schemaType: \"number\",\n    $data: !0,\n    error: {\n      message: ({ schemaCode: e }) => r.str`must be multiple of ${e}`,\n      params: ({ schemaCode: e }) => r._`{multipleOf: ${e}}`,\n    },\n    code(e) {\n      const { gen: t, data: n, schemaCode: o, it: i } = e,\n        s = i.opts.multipleOfPrecision,\n        a = t.let(\"res\"),\n        c = s\n          ? r._`Math.abs(Math.round(${a}) - ${a}) > 1e-${s}`\n          : r._`${a} !== parseInt(${a})`;\n      e.fail$data(r._`(${o} === 0 || (${a} = ${n}/${o}, ${c}))`);\n    },\n  };\nexports.default = o;",
  "452": "var r;\nr = require(8249);\nrequire(8269);\nrequire(8214);\nrequire(888);\nrequire(5109);\n(function () {\n  var e = r,\n    t = e.lib.BlockCipher,\n    n = e.algo,\n    o = [],\n    i = [],\n    s = [],\n    a = [],\n    c = [],\n    l = [],\n    u = [],\n    d = [],\n    p = [],\n    h = [];\n  !(function () {\n    for (var e = [], t = 0; t < 256; t++)\n      e[t] = t < 128 ? t << 1 : (t << 1) ^ 283;\n    var n = 0,\n      r = 0;\n    for (t = 0; t < 256; t++) {\n      var f = r ^ (r << 1) ^ (r << 2) ^ (r << 3) ^ (r << 4);\n      f = (f >>> 8) ^ (255 & f) ^ 99;\n      o[n] = f;\n      i[f] = n;\n      var m = e[n],\n        g = e[m],\n        _ = e[g],\n        y = (257 * e[f]) ^ (16843008 * f);\n      s[n] = (y << 24) | (y >>> 8);\n      a[n] = (y << 16) | (y >>> 16);\n      c[n] = (y << 8) | (y >>> 24);\n      l[n] = y;\n      y = (16843009 * _) ^ (65537 * g) ^ (257 * m) ^ (16843008 * n);\n      u[f] = (y << 24) | (y >>> 8);\n      d[f] = (y << 16) | (y >>> 16);\n      p[f] = (y << 8) | (y >>> 24);\n      h[f] = y;\n      if (n) {\n        n = m ^ e[e[e[_ ^ m]]];\n        r ^= e[e[r]];\n      } else {\n        n = r = 1;\n      }\n    }\n  })();\n  var f = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],\n    m = (n.AES = t.extend({\n      _doReset: function () {\n        if (!this._nRounds || this._keyPriorReset !== this._key) {\n          for (\n            var e = (this._keyPriorReset = this._key),\n              t = e.words,\n              n = e.sigBytes / 4,\n              r = 4 * ((this._nRounds = n + 6) + 1),\n              i = (this._keySchedule = []),\n              s = 0;\n            s < r;\n            s++\n          )\n            if (s < n) {\n              i[s] = t[s];\n            } else {\n              l = i[s - 1];\n              if (s % n) {\n                if (n > 6 && s % n == 4) {\n                  l =\n                    (o[l >>> 24] << 24) |\n                    (o[(l >>> 16) & 255] << 16) |\n                    (o[(l >>> 8) & 255] << 8) |\n                    o[255 & l];\n                }\n              } else {\n                l =\n                  (o[(l = (l << 8) | (l >>> 24)) >>> 24] << 24) |\n                  (o[(l >>> 16) & 255] << 16) |\n                  (o[(l >>> 8) & 255] << 8) |\n                  o[255 & l];\n                l ^= f[(s / n) | 0] << 24;\n              }\n              i[s] = i[s - n] ^ l;\n            }\n          for (var a = (this._invKeySchedule = []), c = 0; c < r; c++) {\n            s = r - c;\n            if (c % 4) var l = i[s];\n            else l = i[s - 4];\n            a[c] =\n              c < 4 || s <= 4\n                ? l\n                : u[o[l >>> 24]] ^\n                  d[o[(l >>> 16) & 255]] ^\n                  p[o[(l >>> 8) & 255]] ^\n                  h[o[255 & l]];\n          }\n        }\n      },\n      encryptBlock: function (e, t) {\n        this._doCryptBlock(e, t, this._keySchedule, s, a, c, l, o);\n      },\n      decryptBlock: function (e, t) {\n        var n = e[t + 1];\n        e[t + 1] = e[t + 3];\n        e[t + 3] = n;\n        this._doCryptBlock(e, t, this._invKeySchedule, u, d, p, h, i);\n        n = e[t + 1];\n        e[t + 1] = e[t + 3];\n        e[t + 3] = n;\n      },\n      _doCryptBlock: function (e, t, n, r, o, i, s, a) {\n        for (\n          var c = this._nRounds,\n            l = e[t] ^ n[0],\n            u = e[t + 1] ^ n[1],\n            d = e[t + 2] ^ n[2],\n            p = e[t + 3] ^ n[3],\n            h = 4,\n            f = 1;\n          f < c;\n          f++\n        ) {\n          var m =\n              r[l >>> 24] ^\n              o[(u >>> 16) & 255] ^\n              i[(d >>> 8) & 255] ^\n              s[255 & p] ^\n              n[h++],\n            g =\n              r[u >>> 24] ^\n              o[(d >>> 16) & 255] ^\n              i[(p >>> 8) & 255] ^\n              s[255 & l] ^\n              n[h++],\n            _ =\n              r[d >>> 24] ^\n              o[(p >>> 16) & 255] ^\n              i[(l >>> 8) & 255] ^\n              s[255 & u] ^\n              n[h++],\n            y =\n              r[p >>> 24] ^\n              o[(l >>> 16) & 255] ^\n              i[(u >>> 8) & 255] ^\n              s[255 & d] ^\n              n[h++];\n          l = m;\n          u = g;\n          d = _;\n          p = y;\n        }\n        m =\n          ((a[l >>> 24] << 24) |\n            (a[(u >>> 16) & 255] << 16) |\n            (a[(d >>> 8) & 255] << 8) |\n            a[255 & p]) ^\n          n[h++];\n        g =\n          ((a[u >>> 24] << 24) |\n            (a[(d >>> 16) & 255] << 16) |\n            (a[(p >>> 8) & 255] << 8) |\n            a[255 & l]) ^\n          n[h++];\n        _ =\n          ((a[d >>> 24] << 24) |\n            (a[(p >>> 16) & 255] << 16) |\n            (a[(l >>> 8) & 255] << 8) |\n            a[255 & u]) ^\n          n[h++];\n        y =\n          ((a[p >>> 24] << 24) |\n            (a[(l >>> 16) & 255] << 16) |\n            (a[(u >>> 8) & 255] << 8) |\n            a[255 & d]) ^\n          n[h++];\n        e[t] = m;\n        e[t + 1] = g;\n        e[t + 2] = _;\n        e[t + 3] = y;\n      },\n      keySize: 8,\n    }));\n  e.AES = t._createHelper(m);\n})();\nmodule.exports = r.AES;",
  "453": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.reportTypeError =\n  exports.checkDataTypes =\n  exports.checkDataType =\n  exports.coerceAndCheckDataType =\n  exports.getJSONTypes =\n  exports.getSchemaTypes =\n  exports.DataType =\n    undefined;\nconst r = require(3141),\n  o = require(8876),\n  i = require(4181),\n  s = require(3487),\n  a = require(6776);\nvar c;\nfunction getJSONTypes(e) {\n  const t = Array.isArray(e) ? e : e ? [e] : [];\n  if (t.every(r.isJSONType)) return t;\n  throw new Error(\"type must be JSONType or JSONType[]: \" + t.join(\",\"));\n}\n!(function (e) {\n  e[(e.Correct = 0)] = \"Correct\";\n  e[(e.Wrong = 1)] = \"Wrong\";\n})((c = exports.DataType || (exports.DataType = {})));\nexports.getSchemaTypes = function (e) {\n  const t = getJSONTypes(e.type);\n  if (t.includes(\"null\")) {\n    if (!1 === e.nullable)\n      throw new Error(\"type: null contradicts nullable: false\");\n  } else {\n    if (!t.length && undefined !== e.nullable)\n      throw new Error('\"nullable\" cannot be used without \"type\"');\n    if (!0 === e.nullable) {\n      t.push(\"null\");\n    }\n  }\n  return t;\n};\nexports.getJSONTypes = getJSONTypes;\nexports.coerceAndCheckDataType = function (e, t) {\n  const { gen: n, data: r, opts: i } = e,\n    a = (function (e, t) {\n      return t\n        ? e.filter((e) => u.has(e) || (\"array\" === t && \"array\" === e))\n        : [];\n    })(t, i.coerceTypes),\n    l =\n      t.length > 0 &&\n      !(0 === a.length && 1 === t.length && o.schemaHasRulesForType(e, t[0]));\n  if (l) {\n    const o = checkDataTypes(t, r, i.strictNumbers, c.Wrong);\n    n.if(o, () => {\n      if (a.length) {\n        (function (e, t, n) {\n          const { gen: r, data: o, opts: i } = e,\n            a = r.let(\"dataType\", s._`typeof ${o}`),\n            c = r.let(\"coerced\", s._`undefined`);\n          if (\"array\" === i.coerceTypes) {\n            r.if(\n              s._`${a} == 'object' && Array.isArray(${o}) && ${o}.length == 1`,\n              () =>\n                r\n                  .assign(o, s._`${o}[0]`)\n                  .assign(a, s._`typeof ${o}`)\n                  .if(checkDataTypes(t, o, i.strictNumbers), () =>\n                    r.assign(c, o)\n                  )\n            );\n          }\n          r.if(s._`${c} !== undefined`);\n          for (const e of n)\n            if (u.has(e) || (\"array\" === e && \"array\" === i.coerceTypes)) {\n              l(e);\n            }\n          function l(e) {\n            switch (e) {\n              case \"string\":\n                return void r\n                  .elseIf(s._`${a} == \"number\" || ${a} == \"boolean\"`)\n                  .assign(c, s._`\"\" + ${o}`)\n                  .elseIf(s._`${o} === null`)\n                  .assign(c, s._`\"\"`);\n              case \"number\":\n                return void r\n                  .elseIf(\n                    s._`${a} == \"boolean\" || ${o} === null\n              || (${a} == \"string\" && ${o} && ${o} == +${o})`\n                  )\n                  .assign(c, s._`+${o}`);\n              case \"integer\":\n                return void r\n                  .elseIf(\n                    s._`${a} === \"boolean\" || ${o} === null\n              || (${a} === \"string\" && ${o} && ${o} == +${o} && !(${o} % 1))`\n                  )\n                  .assign(c, s._`+${o}`);\n              case \"boolean\":\n                return void r\n                  .elseIf(s._`${o} === \"false\" || ${o} === 0 || ${o} === null`)\n                  .assign(c, !1)\n                  .elseIf(s._`${o} === \"true\" || ${o} === 1`)\n                  .assign(c, !0);\n              case \"null\":\n                r.elseIf(s._`${o} === \"\" || ${o} === 0 || ${o} === false`);\n                return void r.assign(c, null);\n              case \"array\":\n                r.elseIf(\n                  s._`${a} === \"string\" || ${a} === \"number\"\n              || ${a} === \"boolean\" || ${o} === null`\n                ).assign(c, s._`[${o}]`);\n            }\n          }\n          r.else();\n          reportTypeError(e);\n          r.endIf();\n          r.if(s._`${c} !== undefined`, () => {\n            r.assign(o, c);\n            (function ({ gen: e, parentData: t, parentDataProperty: n }, r) {\n              e.if(s._`${t} !== undefined`, () => e.assign(s._`${t}[${n}]`, r));\n            })(e, c);\n          });\n        })(e, t, a);\n      } else {\n        reportTypeError(e);\n      }\n    });\n  }\n  return l;\n};\nconst u = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction checkDataType(e, t, n, r = c.Correct) {\n  const o = r === c.Correct ? s.operators.EQ : s.operators.NEQ;\n  let i;\n  switch (e) {\n    case \"null\":\n      return s._`${t} ${o} null`;\n    case \"array\":\n      i = s._`Array.isArray(${t})`;\n      break;\n    case \"object\":\n      i = s._`${t} && typeof ${t} == \"object\" && !Array.isArray(${t})`;\n      break;\n    case \"integer\":\n      i = a(s._`!(${t} % 1) && !isNaN(${t})`);\n      break;\n    case \"number\":\n      i = a();\n      break;\n    default:\n      return s._`typeof ${t} ${o} ${e}`;\n  }\n  return r === c.Correct ? i : s.not(i);\n  function a(e = s.nil) {\n    return s.and(\n      s._`typeof ${t} == \"number\"`,\n      e,\n      n ? s._`isFinite(${t})` : s.nil\n    );\n  }\n}\nfunction checkDataTypes(e, t, n, r) {\n  if (1 === e.length) return checkDataType(e[0], t, n, r);\n  let o;\n  const i = a.toHash(e);\n  if (i.array && i.object) {\n    const e = s._`typeof ${t} != \"object\"`;\n    o = i.null ? e : s._`!${t} || ${e}`;\n    delete i.null;\n    delete i.array;\n    delete i.object;\n  } else o = s.nil;\n  if (i.number) {\n    delete i.integer;\n  }\n  for (const e in i) o = s.and(o, checkDataType(e, t, n, r));\n  return o;\n}\nexports.checkDataType = checkDataType;\nexports.checkDataTypes = checkDataTypes;\nconst h = {\n  message: ({ schema: e }) => `must be ${e}`,\n  params: ({ schema: e, schemaValue: t }) =>\n    \"string\" == typeof e ? s._`{type: ${e}}` : s._`{type: ${t}}`,\n};\nfunction reportTypeError(e) {\n  const t = (function (e) {\n    const { gen: t, data: n, schema: r } = e,\n      o = a.schemaRefOrVal(e, r, \"type\");\n    return {\n      gen: t,\n      keyword: \"type\",\n      data: n,\n      schema: r.type,\n      schemaCode: o,\n      schemaValue: o,\n      parentSchema: r,\n      params: {},\n      it: e,\n    };\n  })(e);\n  i.reportError(t, h);\n}\nexports.reportTypeError = reportTypeError;",
  "454": "var r = require(5290),\n  o = require(4953),\n  i = [],\n  s = {\n    syslog: function (e) {\n      var t = {\n        emerg: r.SeverityLevel.Critical,\n        alert: r.SeverityLevel.Critical,\n        crit: r.SeverityLevel.Critical,\n        error: r.SeverityLevel.Error,\n        warning: r.SeverityLevel.Warning,\n        notice: r.SeverityLevel.Information,\n        info: r.SeverityLevel.Information,\n        debug: r.SeverityLevel.Verbose,\n      };\n      return undefined === t[e] ? r.SeverityLevel.Information : t[e];\n    },\n    npm: function (e) {\n      var t = {\n        error: r.SeverityLevel.Error,\n        warn: r.SeverityLevel.Warning,\n        info: r.SeverityLevel.Information,\n        verbose: r.SeverityLevel.Verbose,\n        debug: r.SeverityLevel.Verbose,\n        silly: r.SeverityLevel.Verbose,\n      };\n      return undefined === t[e] ? r.SeverityLevel.Information : t[e];\n    },\n    unknown: function (e) {\n      return r.SeverityLevel.Information;\n    },\n  },\n  a = function (e) {\n    var t = e.data.message;\n    i.forEach(function (n) {\n      if (t instanceof Error)\n        n.trackException({\n          exception: t,\n          properties: e.data.meta,\n        });\n      else {\n        var r = s[e.data.levelKind](e.data.level);\n        n.trackTrace({\n          message: t,\n          severity: r,\n          properties: e.data.meta,\n        });\n      }\n    });\n  };\nexports.wp = function (e, t) {\n  if (e) {\n    if (0 === i.length) {\n      o.channel.subscribe(\"winston\", a);\n    }\n    i.push(t);\n  } else {\n    if (\n      0 ===\n      (i = i.filter(function (e) {\n        return e != t;\n      })).length\n    ) {\n      o.channel.unsubscribe(\"winston\", a);\n    }\n  }\n};",
  "464": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getFunctionPositions =\n  exports.getFirstPrecedingComment =\n  exports.isFunctionDefinition =\n  exports.isFunction =\n  exports.getAncestorWithSiblingFunctions =\n  exports.queryPythonIsDocstring =\n  exports.queryGlobalVars =\n  exports.queryExports =\n  exports.queryImports =\n  exports.queryFunctions =\n  exports.getBlockCloseToken =\n  exports.parsesWithoutError =\n  exports.parseTree =\n  exports.getLanguage =\n  exports.languageIdToWasmLanguage =\n  exports.isSupportedLanguageId =\n  exports.WASMLanguage =\n    undefined;\nconst r = require(\"path\"),\n  o = require(4087),\n  i = require(4087);\nvar s;\n!(function (e) {\n  e.Python = \"python\";\n  e.JavaScript = \"javascript\";\n  e.TypeScript = \"typescript\";\n  e.Go = \"go\";\n  e.Ruby = \"ruby\";\n})((s = exports.WASMLanguage || (exports.WASMLanguage = {})));\nconst a = {\n  python: s.Python,\n  javascript: s.JavaScript,\n  javascriptreact: s.JavaScript,\n  jsx: s.JavaScript,\n  typescript: s.TypeScript,\n  typescriptreact: s.TypeScript,\n  go: s.Go,\n  ruby: s.Ruby,\n};\nfunction languageIdToWasmLanguage(e) {\n  if (!(e in a)) throw new Error(`Unrecognized language: ${e}`);\n  return a[e];\n}\nexports.isSupportedLanguageId = function (e) {\n  return e in a;\n};\nexports.languageIdToWasmLanguage = languageIdToWasmLanguage;\nconst l = {\n    python: [\n      [\n        \"(function_definition body: (block\\n             (expression_statement (string))? @docstring) @body) @function\",\n      ],\n      ['(ERROR (\"def\" (identifier) (parameters))) @function'],\n    ],\n    javascript: [\n      [\n        \"[\\n            (function body: (statement_block) @body)\\n            (function_declaration body: (statement_block) @body)\\n            (generator_function body: (statement_block) @body)\\n            (generator_function_declaration body: (statement_block) @body)\\n            (method_definition body: (statement_block) @body)\\n          ] @function\",\n      ],\n    ],\n    typescript: [\n      [\n        \"[\\n            (function body: (statement_block) @body)\\n            (function_declaration body: (statement_block) @body)\\n            (generator_function body: (statement_block) @body)\\n            (generator_function_declaration body: (statement_block) @body)\\n            (method_definition body: (statement_block) @body)\\n          ] @function\",\n      ],\n    ],\n    go: [\n      [\n        \"[\\n            (function_declaration body: (block) @body)\\n            (method_declaration body: (block) @body)\\n          ] @function\",\n      ],\n    ],\n    ruby: [\n      [\n        '[\\n            (method name: (_) parameters: (method_parameters)? @params [(_)+ \"end\"] @body)\\n            (singleton_method name: (_) parameters: (method_parameters)? @params [(_)+ \"end\"] @body)\\n          ] @function',\n      ],\n    ],\n  },\n  u =\n    '(variable_declarator value: (call_expression function: ((identifier) @req (#eq? @req \"require\"))))',\n  d = `\\n    (lexical_declaration ${u}+)\\n    (variable_declaration ${u}+)\\n`,\n  p = {\n    python: [\n      [\"(module (future_import_statement) @import)\"],\n      [\"(module (import_statement) @import)\"],\n      [\"(module (import_from_statement) @import)\"],\n    ],\n    javascript: [\n      [`(program [ ${d} ] @import)`],\n      [\"(program [ (import_statement) ] @import)\"],\n    ],\n    typescript: [\n      [`(program [ ${d} ] @import)`],\n      [\"(program [ (import_statement) (import_alias) ] @import)\"],\n    ],\n    go: [],\n    ruby: [],\n  },\n  h = {\n    python: [],\n    javascript: [[\"(program (export_statement) @export)\"]],\n    typescript: [[\"(program (export_statement) @export)\"]],\n    go: [],\n    ruby: [],\n  },\n  f = {\n    python: [\n      [\"(module (global_statement) @globalVar)\"],\n      [\"(module (expression_statement) @globalVar)\"],\n    ],\n    javascript: [],\n    typescript: [],\n    go: [],\n    ruby: [],\n  },\n  m = {\n    python: new Set([\"function_definition\"]),\n    javascript: new Set([\n      \"function\",\n      \"function_declaration\",\n      \"generator_function\",\n      \"generator_function_declaration\",\n      \"method_definition\",\n      \"arrow_function\",\n    ]),\n    typescript: new Set([\n      \"function\",\n      \"function_declaration\",\n      \"generator_function\",\n      \"generator_function_declaration\",\n      \"method_definition\",\n      \"arrow_function\",\n    ]),\n    go: new Set([\"function_declaration\", \"method_declaration\"]),\n    ruby: new Set([\"method\", \"singleton_method\"]),\n  },\n  g = {\n    python: (e) => {\n      var t;\n      return (\n        \"module\" === e.type ||\n        (\"block\" === e.type &&\n          \"class_definition\" ===\n            (null === (t = e.parent) || undefined === t ? undefined : t.type))\n      );\n    },\n    javascript: (e) => \"program\" === e.type || \"class_body\" === e.type,\n    typescript: (e) => \"program\" === e.type || \"class_body\" === e.type,\n    go: (e) => \"source_file\" === e.type,\n    ruby: (e) => \"program\" === e.type || \"class\" === e.type,\n  },\n  _ = new Map();\nasync function getLanguage(e) {\n  const t = languageIdToWasmLanguage(e);\n  if (!_.has(t)) {\n    const e = await (async function (e) {\n      await o.init();\n      const t = r.resolve(__dirname, \"..\", \"dist\", `tree-sitter-${e}.wasm`);\n      return i.Language.load(t);\n    })(t);\n    _.set(t, e);\n  }\n  return _.get(t);\n}\nasync function parseTree(e, t) {\n  let n = await getLanguage(e);\n  const r = new o();\n  r.setLanguage(n);\n  const i = r.parse(t);\n  r.delete();\n  return i;\n}\nfunction b(e, t) {\n  const n = [];\n  for (const r of e) {\n    if (!r[1]) {\n      const e = t.tree.getLanguage();\n      r[1] = e.query(r[0]);\n    }\n    n.push(...r[1].matches(t));\n  }\n  return n;\n}\nfunction queryFunctions(e, t) {\n  return b(l[languageIdToWasmLanguage(e)], t);\n}\nexports.getLanguage = getLanguage;\nexports.parseTree = parseTree;\nexports.parsesWithoutError = async function (e, t) {\n  const n = await parseTree(e, t),\n    r = !n.rootNode.hasError();\n  n.delete();\n  return r;\n};\nexports.getBlockCloseToken = function (e) {\n  switch (languageIdToWasmLanguage(e)) {\n    case s.Python:\n      return null;\n    case s.JavaScript:\n    case s.TypeScript:\n    case s.Go:\n      return \"}\";\n    case s.Ruby:\n      return \"end\";\n  }\n};\nexports.queryFunctions = queryFunctions;\nexports.queryImports = function (e, t) {\n  return b(p[languageIdToWasmLanguage(e)], t);\n};\nexports.queryExports = function (e, t) {\n  return b(h[languageIdToWasmLanguage(e)], t);\n};\nexports.queryGlobalVars = function (e, t) {\n  return b(f[languageIdToWasmLanguage(e)], t);\n};\nconst x = [\n  \"[\\n    (class_definition (block (expression_statement (string))))\\n    (function_definition (block (expression_statement (string))))\\n]\",\n];\nfunction isFunction(e, t) {\n  return m[languageIdToWasmLanguage(e)].has(t.type);\n}\nexports.queryPythonIsDocstring = function (e) {\n  return 1 == b([x], e).length;\n};\nexports.getAncestorWithSiblingFunctions = function (e, t) {\n  const n = g[languageIdToWasmLanguage(e)];\n  for (; t.parent; ) {\n    if (n(t.parent)) return t;\n    t = t.parent;\n  }\n  return t.parent ? t : null;\n};\nexports.isFunction = isFunction;\nexports.isFunctionDefinition = function (e, t) {\n  switch (languageIdToWasmLanguage(e)) {\n    case s.Python:\n    case s.Go:\n    case s.Ruby:\n      return isFunction(e, t);\n    case s.JavaScript:\n    case s.TypeScript:\n      if (\n        \"function_declaration\" === t.type ||\n        \"generator_function_declaration\" === t.type ||\n        \"method_definition\" === t.type\n      )\n        return !0;\n      if (\n        \"lexical_declaration\" === t.type ||\n        \"variable_declaration\" === t.type\n      ) {\n        if (t.namedChildCount > 1) return !1;\n        let n = t.namedChild(0);\n        if (null == n) return !1;\n        let r = n.namedChild(1);\n        return null !== r && isFunction(e, r);\n      }\n      if (\"expression_statement\" === t.type) {\n        let n = t.namedChild(0);\n        if (\"assignment_expression\" === (null == n ? undefined : n.type)) {\n          let t = n.namedChild(1);\n          return null !== t && isFunction(e, t);\n        }\n      }\n      return !1;\n  }\n};\nexports.getFirstPrecedingComment = function (e) {\n  var t;\n  let n = e;\n  for (\n    ;\n    \"comment\" ===\n    (null === (t = n.previousSibling) || undefined === t ? undefined : t.type);\n\n  ) {\n    let e = n.previousSibling;\n    if (e.endPosition.row < n.startPosition.row - 1) break;\n    n = e;\n  }\n  return \"comment\" === (null == n ? undefined : n.type) ? n : null;\n};\nexports.getFunctionPositions = async function (e, t) {\n  return queryFunctions(e, (await parseTree(e, t)).rootNode).map((e) => {\n    const t = e.captures.find((e) => \"function\" === e.name).node;\n    return {\n      startIndex: t.startIndex,\n      endIndex: t.endIndex,\n    };\n  });\n};",
  "465": "module.exports = function (e, t) {\n  var n = [];\n  n.push(\n    (function (e) {\n      try {\n        return Error.prototype.toString.call(e);\n      } catch (e) {\n        try {\n          return \"<error: \" + e + \">\";\n        } catch (e) {\n          return \"<error>\";\n        }\n      }\n    })(e)\n  );\n  for (var r = 0; r < t.length; r++) {\n    var o,\n      i = t[r];\n    try {\n      o = i.toString();\n    } catch (e) {\n      try {\n        o = \"<error: \" + e + \">\";\n      } catch (e) {\n        o = \"<error>\";\n      }\n    }\n    n.push(\"    at \" + o);\n  }\n  return n.join(\"\\n\");\n};",
  "495": "var t;\n!(function (e) {\n  e[(e.Measurement = 0)] = \"Measurement\";\n  e[(e.Aggregation = 1)] = \"Aggregation\";\n})(t || (t = {}));\nmodule.exports = t;",
  "498": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = {\n    keyword: [\"maxProperties\", \"minProperties\"],\n    type: \"object\",\n    schemaType: \"number\",\n    $data: !0,\n    error: {\n      message({ keyword: e, schemaCode: t }) {\n        const n = \"maxProperties\" === e ? \"more\" : \"fewer\";\n        return r.str`must NOT have ${n} than ${t} items`;\n      },\n      params: ({ schemaCode: e }) => r._`{limit: ${e}}`,\n    },\n    code(e) {\n      const { keyword: t, data: n, schemaCode: o } = e,\n        i = \"maxProperties\" === t ? r.operators.GT : r.operators.LT;\n      e.fail$data(r._`Object.keys(${n}).length ${i} ${o}`);\n    },\n  };\nexports.default = o;",
  "540": "!(function (e) {\n  \"use strict\";\n\n  function t() {\n    for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)\n      t[n] = arguments[n];\n    if (t.length > 1) {\n      t[0] = t[0].slice(0, -1);\n      for (var r = t.length - 1, o = 1; o < r; ++o) t[o] = t[o].slice(1, -1);\n      t[r] = t[r].slice(1);\n      return t.join(\"\");\n    }\n    return t[0];\n  }\n  function n(e) {\n    return \"(?:\" + e + \")\";\n  }\n  function r(e) {\n    return undefined === e\n      ? \"undefined\"\n      : null === e\n      ? \"null\"\n      : Object.prototype.toString\n          .call(e)\n          .split(\" \")\n          .pop()\n          .split(\"]\")\n          .shift()\n          .toLowerCase();\n  }\n  function o(e) {\n    return e.toUpperCase();\n  }\n  function i(e) {\n    var r = \"[A-Za-z]\",\n      o = \"[0-9]\",\n      i = t(o, \"[A-Fa-f]\"),\n      s = n(\n        n(\"%[EFef]\" + i + \"%\" + i + i + \"%\" + i + i) +\n          \"|\" +\n          n(\"%[89A-Fa-f]\" + i + \"%\" + i + i) +\n          \"|\" +\n          n(\"%\" + i + i)\n      ),\n      a = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n      c = t(\"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\", a),\n      l = e ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n      u = t(\n        r,\n        o,\n        \"[\\\\-\\\\.\\\\_\\\\~]\",\n        e\n          ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\"\n          : \"[]\"\n      ),\n      d = n(r + t(r, o, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n      p = n(n(s + \"|\" + t(u, a, \"[\\\\:]\")) + \"*\"),\n      h =\n        (n(\n          n(\"25[0-5]\") +\n            \"|\" +\n            n(\"2[0-4][0-9]\") +\n            \"|\" +\n            n(\"1[0-9][0-9]\") +\n            \"|\" +\n            n(\"[1-9][0-9]\") +\n            \"|\" +\n            o\n        ),\n        n(\n          n(\"25[0-5]\") +\n            \"|\" +\n            n(\"2[0-4][0-9]\") +\n            \"|\" +\n            n(\"1[0-9][0-9]\") +\n            \"|\" +\n            n(\"0?[1-9][0-9]\") +\n            \"|0?0?\" +\n            o\n        )),\n      f = n(h + \"\\\\.\" + h + \"\\\\.\" + h + \"\\\\.\" + h),\n      m = n(i + \"{1,4}\"),\n      g = n(n(m + \"\\\\:\" + m) + \"|\" + f),\n      _ = n(n(m + \"\\\\:\") + \"{6}\" + g),\n      y = n(\"\\\\:\\\\:\" + n(m + \"\\\\:\") + \"{5}\" + g),\n      v = n(n(m) + \"?\\\\:\\\\:\" + n(m + \"\\\\:\") + \"{4}\" + g),\n      b = n(\n        n(n(m + \"\\\\:\") + \"{0,1}\" + m) + \"?\\\\:\\\\:\" + n(m + \"\\\\:\") + \"{3}\" + g\n      ),\n      w = n(\n        n(n(m + \"\\\\:\") + \"{0,2}\" + m) + \"?\\\\:\\\\:\" + n(m + \"\\\\:\") + \"{2}\" + g\n      ),\n      x = n(n(n(m + \"\\\\:\") + \"{0,3}\" + m) + \"?\\\\:\\\\:\" + m + \"\\\\:\" + g),\n      E = n(n(n(m + \"\\\\:\") + \"{0,4}\" + m) + \"?\\\\:\\\\:\" + g),\n      C = n(n(n(m + \"\\\\:\") + \"{0,5}\" + m) + \"?\\\\:\\\\:\" + m),\n      S = n(n(n(m + \"\\\\:\") + \"{0,6}\" + m) + \"?\\\\:\\\\:\"),\n      T = n([_, y, v, b, w, x, E, C, S].join(\"|\")),\n      k = n(n(u + \"|\" + s) + \"+\"),\n      I = (n(T + \"\\\\%25\" + k), n(T + n(\"\\\\%25|\\\\%(?!\" + i + \"{2})\") + k)),\n      P = n(\"[vV]\" + i + \"+\\\\.\" + t(u, a, \"[\\\\:]\") + \"+\"),\n      A = n(\"\\\\[\" + n(I + \"|\" + T + \"|\" + P) + \"\\\\]\"),\n      O = n(n(s + \"|\" + t(u, a)) + \"*\"),\n      N = n(A + \"|\" + f + \"(?!\" + O + \")|\" + O),\n      R = n(\"[0-9]*\"),\n      M = n(n(p + \"@\") + \"?\" + N + n(\"\\\\:\" + R) + \"?\"),\n      L = n(s + \"|\" + t(u, a, \"[\\\\:\\\\@]\")),\n      $ = n(L + \"*\"),\n      D = n(L + \"+\"),\n      F = n(n(s + \"|\" + t(u, a, \"[\\\\@]\")) + \"+\"),\n      j = n(n(\"\\\\/\" + $) + \"*\"),\n      q = n(\"\\\\/\" + n(D + j) + \"?\"),\n      B = n(F + j),\n      U = n(D + j),\n      H = \"(?!\" + L + \")\",\n      z =\n        (n(j + \"|\" + q + \"|\" + B + \"|\" + U + \"|\" + H),\n        n(n(L + \"|\" + t(\"[\\\\/\\\\?]\", l)) + \"*\")),\n      G = n(n(L + \"|[\\\\/\\\\?]\") + \"*\"),\n      V = n(n(\"\\\\/\\\\/\" + M + j) + \"|\" + q + \"|\" + U + \"|\" + H),\n      W = n(d + \"\\\\:\" + V + n(\"\\\\?\" + z) + \"?\" + n(\"\\\\#\" + G) + \"?\"),\n      K = n(n(\"\\\\/\\\\/\" + M + j) + \"|\" + q + \"|\" + B + \"|\" + H),\n      J = n(K + n(\"\\\\?\" + z) + \"?\" + n(\"\\\\#\" + G) + \"?\");\n    n(W + \"|\" + J);\n    n(d + \"\\\\:\" + V + n(\"\\\\?\" + z) + \"?\");\n    n(\n      n(\n        \"\\\\/\\\\/(\" +\n          n(\"(\" + p + \")@\") +\n          \"?(\" +\n          N +\n          \")\" +\n          n(\"\\\\:(\" + R + \")\") +\n          \"?)\"\n      ) +\n        \"?(\" +\n        j +\n        \"|\" +\n        q +\n        \"|\" +\n        U +\n        \"|\" +\n        H +\n        \")\"\n    );\n    n(\"\\\\?(\" + z + \")\");\n    n(\"\\\\#(\" + G + \")\");\n    n(\n      n(\n        \"\\\\/\\\\/(\" +\n          n(\"(\" + p + \")@\") +\n          \"?(\" +\n          N +\n          \")\" +\n          n(\"\\\\:(\" + R + \")\") +\n          \"?)\"\n      ) +\n        \"?(\" +\n        j +\n        \"|\" +\n        q +\n        \"|\" +\n        B +\n        \"|\" +\n        H +\n        \")\"\n    );\n    n(\"\\\\?(\" + z + \")\");\n    n(\"\\\\#(\" + G + \")\");\n    n(\n      n(\n        \"\\\\/\\\\/(\" +\n          n(\"(\" + p + \")@\") +\n          \"?(\" +\n          N +\n          \")\" +\n          n(\"\\\\:(\" + R + \")\") +\n          \"?)\"\n      ) +\n        \"?(\" +\n        j +\n        \"|\" +\n        q +\n        \"|\" +\n        U +\n        \"|\" +\n        H +\n        \")\"\n    );\n    n(\"\\\\?(\" + z + \")\");\n    n(\"\\\\#(\" + G + \")\");\n    n(\"(\" + p + \")@\");\n    n(\"\\\\:(\" + R + \")\");\n    return {\n      NOT_SCHEME: new RegExp(t(\"[^]\", r, o, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n      NOT_USERINFO: new RegExp(t(\"[^\\\\%\\\\:]\", u, a), \"g\"),\n      NOT_HOST: new RegExp(t(\"[^\\\\%\\\\[\\\\]\\\\:]\", u, a), \"g\"),\n      NOT_PATH: new RegExp(t(\"[^\\\\%\\\\/\\\\:\\\\@]\", u, a), \"g\"),\n      NOT_PATH_NOSCHEME: new RegExp(t(\"[^\\\\%\\\\/\\\\@]\", u, a), \"g\"),\n      NOT_QUERY: new RegExp(t(\"[^\\\\%]\", u, a, \"[\\\\:\\\\@\\\\/\\\\?]\", l), \"g\"),\n      NOT_FRAGMENT: new RegExp(t(\"[^\\\\%]\", u, a, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n      ESCAPE: new RegExp(t(\"[^]\", u, a), \"g\"),\n      UNRESERVED: new RegExp(u, \"g\"),\n      OTHER_CHARS: new RegExp(t(\"[^\\\\%]\", u, c), \"g\"),\n      PCT_ENCODED: new RegExp(s, \"g\"),\n      IPV4ADDRESS: new RegExp(\"^(\" + f + \")$\"),\n      IPV6ADDRESS: new RegExp(\n        \"^\\\\[?(\" +\n          T +\n          \")\" +\n          n(n(\"\\\\%25|\\\\%(?!\" + i + \"{2})\") + \"(\" + k + \")\") +\n          \"?\\\\]?$\"\n      ),\n    };\n  }\n  var s = i(!1),\n    a = i(!0),\n    c = function (e, t) {\n      if (Array.isArray(e)) return e;\n      if (Symbol.iterator in Object(e))\n        return (function (e, t) {\n          var n = [],\n            r = !0,\n            o = !1,\n            i = undefined;\n          try {\n            for (\n              var s, a = e[Symbol.iterator]();\n              !(r = (s = a.next()).done) &&\n              (n.push(s.value), !t || n.length !== t);\n              r = !0\n            );\n          } catch (e) {\n            o = !0;\n            i = e;\n          } finally {\n            try {\n              if (!r && a.return) {\n                a.return();\n              }\n            } finally {\n              if (o) throw i;\n            }\n          }\n          return n;\n        })(e, t);\n      throw new TypeError(\n        \"Invalid attempt to destructure non-iterable instance\"\n      );\n    },\n    l = 2147483647,\n    u = 36,\n    d = /^xn--/,\n    p = /[^\\0-\\x7E]/,\n    h = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n    f = {\n      overflow: \"Overflow: input needs wider integers to process\",\n      \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n      \"invalid-input\": \"Invalid input\",\n    },\n    m = Math.floor,\n    g = String.fromCharCode;\n  function _(e) {\n    throw new RangeError(f[e]);\n  }\n  function y(e, t) {\n    var n = e.split(\"@\"),\n      r = \"\";\n    if (n.length > 1) {\n      r = n[0] + \"@\";\n      e = n[1];\n    }\n    return (\n      r +\n      (function (e, t) {\n        for (var n = [], r = e.length; r--; ) n[r] = t(e[r]);\n        return n;\n      })((e = e.replace(h, \".\")).split(\".\"), t).join(\".\")\n    );\n  }\n  function v(e) {\n    for (var t = [], n = 0, r = e.length; n < r; ) {\n      var o = e.charCodeAt(n++);\n      if (o >= 55296 && o <= 56319 && n < r) {\n        var i = e.charCodeAt(n++);\n        if (56320 == (64512 & i)) {\n          t.push(((1023 & o) << 10) + (1023 & i) + 65536);\n        } else {\n          t.push(o);\n          n--;\n        }\n      } else t.push(o);\n    }\n    return t;\n  }\n  var b = function (e, t) {\n      return e + 22 + 75 * (e < 26) - ((0 != t) << 5);\n    },\n    w = function (e, t, n) {\n      var r = 0;\n      for (e = n ? m(e / 700) : e >> 1, e += m(e / t); e > 455; r += u)\n        e = m(e / 35);\n      return m(r + (36 * e) / (e + 38));\n    },\n    x = function (e) {\n      var t,\n        n = [],\n        r = e.length,\n        o = 0,\n        i = 128,\n        s = 72,\n        a = e.lastIndexOf(\"-\");\n      if (a < 0) {\n        a = 0;\n      }\n      for (var c = 0; c < a; ++c) {\n        if (e.charCodeAt(c) >= 128) {\n          _(\"not-basic\");\n        }\n        n.push(e.charCodeAt(c));\n      }\n      for (var d = a > 0 ? a + 1 : 0; d < r; ) {\n        for (var p = o, h = 1, f = u; ; f += u) {\n          if (d >= r) {\n            _(\"invalid-input\");\n          }\n          var g =\n            (t = e.charCodeAt(d++)) - 48 < 10\n              ? t - 22\n              : t - 65 < 26\n              ? t - 65\n              : t - 97 < 26\n              ? t - 97\n              : u;\n          if (g >= u || g > m((l - o) / h)) {\n            _(\"overflow\");\n          }\n          o += g * h;\n          var y = f <= s ? 1 : f >= s + 26 ? 26 : f - s;\n          if (g < y) break;\n          var v = u - y;\n          if (h > m(l / v)) {\n            _(\"overflow\");\n          }\n          h *= v;\n        }\n        var b = n.length + 1;\n        s = w(o - p, b, 0 == p);\n        if (m(o / b) > l - i) {\n          _(\"overflow\");\n        }\n        i += m(o / b);\n        o %= b;\n        n.splice(o++, 0, i);\n      }\n      return String.fromCodePoint.apply(String, n);\n    },\n    E = function (e) {\n      var t = [],\n        n = (e = v(e)).length,\n        r = 128,\n        o = 0,\n        i = 72,\n        s = !0,\n        a = !1,\n        c = undefined;\n      try {\n        for (\n          var d, p = e[Symbol.iterator]();\n          !(s = (d = p.next()).done);\n          s = !0\n        ) {\n          var h = d.value;\n          if (h < 128) {\n            t.push(g(h));\n          }\n        }\n      } catch (e) {\n        a = !0;\n        c = e;\n      } finally {\n        try {\n          if (!s && p.return) {\n            p.return();\n          }\n        } finally {\n          if (a) throw c;\n        }\n      }\n      var f = t.length,\n        y = f;\n      for (f && t.push(\"-\"); y < n; ) {\n        var x = l,\n          E = !0,\n          C = !1,\n          S = undefined;\n        try {\n          for (\n            var T, k = e[Symbol.iterator]();\n            !(E = (T = k.next()).done);\n            E = !0\n          ) {\n            var I = T.value;\n            if (I >= r && I < x) {\n              x = I;\n            }\n          }\n        } catch (e) {\n          C = !0;\n          S = e;\n        } finally {\n          try {\n            if (!E && k.return) {\n              k.return();\n            }\n          } finally {\n            if (C) throw S;\n          }\n        }\n        var P = y + 1;\n        if (x - r > m((l - o) / P)) {\n          _(\"overflow\");\n        }\n        o += (x - r) * P;\n        r = x;\n        var A = !0,\n          O = !1,\n          N = undefined;\n        try {\n          for (\n            var R, M = e[Symbol.iterator]();\n            !(A = (R = M.next()).done);\n            A = !0\n          ) {\n            var L = R.value;\n            if (L < r && ++o > l) {\n              _(\"overflow\");\n            }\n            if (L == r) {\n              for (var $ = o, D = u; ; D += u) {\n                var F = D <= i ? 1 : D >= i + 26 ? 26 : D - i;\n                if ($ < F) break;\n                var j = $ - F,\n                  q = u - F;\n                t.push(g(b(F + (j % q), 0))), ($ = m(j / q));\n              }\n              t.push(g(b($, 0))), (i = w(o, P, y == f)), (o = 0), ++y;\n            }\n          }\n        } catch (e) {\n          O = !0;\n          N = e;\n        } finally {\n          try {\n            if (!A && M.return) {\n              M.return();\n            }\n          } finally {\n            if (O) throw N;\n          }\n        }\n        ++o;\n        ++r;\n      }\n      return t.join(\"\");\n    },\n    C = function (e) {\n      return y(e, function (e) {\n        return p.test(e) ? \"xn--\" + E(e) : e;\n      });\n    },\n    S = function (e) {\n      return y(e, function (e) {\n        return d.test(e) ? x(e.slice(4).toLowerCase()) : e;\n      });\n    },\n    T = {};\n  function k(e) {\n    var t = e.charCodeAt(0);\n    return t < 16\n      ? \"%0\" + t.toString(16).toUpperCase()\n      : t < 128\n      ? \"%\" + t.toString(16).toUpperCase()\n      : t < 2048\n      ? \"%\" +\n        ((t >> 6) | 192).toString(16).toUpperCase() +\n        \"%\" +\n        ((63 & t) | 128).toString(16).toUpperCase()\n      : \"%\" +\n        ((t >> 12) | 224).toString(16).toUpperCase() +\n        \"%\" +\n        (((t >> 6) & 63) | 128).toString(16).toUpperCase() +\n        \"%\" +\n        ((63 & t) | 128).toString(16).toUpperCase();\n  }\n  function I(e) {\n    for (var t = \"\", n = 0, r = e.length; n < r; ) {\n      var o = parseInt(e.substr(n + 1, 2), 16);\n      if (o < 128) {\n        t += String.fromCharCode(o);\n        n += 3;\n      } else if (o >= 194 && o < 224) {\n        if (r - n >= 6) {\n          var i = parseInt(e.substr(n + 4, 2), 16);\n          t += String.fromCharCode(((31 & o) << 6) | (63 & i));\n        } else t += e.substr(n, 6);\n        n += 6;\n      } else if (o >= 224) {\n        if (r - n >= 9) {\n          var s = parseInt(e.substr(n + 4, 2), 16),\n            a = parseInt(e.substr(n + 7, 2), 16);\n          t += String.fromCharCode(\n            ((15 & o) << 12) | ((63 & s) << 6) | (63 & a)\n          );\n        } else t += e.substr(n, 9);\n        n += 9;\n      } else {\n        t += e.substr(n, 3);\n        n += 3;\n      }\n    }\n    return t;\n  }\n  function P(e, t) {\n    function n(e) {\n      var n = I(e);\n      return n.match(t.UNRESERVED) ? n : e;\n    }\n    if (e.scheme) {\n      e.scheme = String(e.scheme)\n        .replace(t.PCT_ENCODED, n)\n        .toLowerCase()\n        .replace(t.NOT_SCHEME, \"\");\n    }\n    if (undefined !== e.userinfo) {\n      e.userinfo = String(e.userinfo)\n        .replace(t.PCT_ENCODED, n)\n        .replace(t.NOT_USERINFO, k)\n        .replace(t.PCT_ENCODED, o);\n    }\n    if (undefined !== e.host) {\n      e.host = String(e.host)\n        .replace(t.PCT_ENCODED, n)\n        .toLowerCase()\n        .replace(t.NOT_HOST, k)\n        .replace(t.PCT_ENCODED, o);\n    }\n    if (undefined !== e.path) {\n      e.path = String(e.path)\n        .replace(t.PCT_ENCODED, n)\n        .replace(e.scheme ? t.NOT_PATH : t.NOT_PATH_NOSCHEME, k)\n        .replace(t.PCT_ENCODED, o);\n    }\n    if (undefined !== e.query) {\n      e.query = String(e.query)\n        .replace(t.PCT_ENCODED, n)\n        .replace(t.NOT_QUERY, k)\n        .replace(t.PCT_ENCODED, o);\n    }\n    if (undefined !== e.fragment) {\n      e.fragment = String(e.fragment)\n        .replace(t.PCT_ENCODED, n)\n        .replace(t.NOT_FRAGMENT, k)\n        .replace(t.PCT_ENCODED, o);\n    }\n    return e;\n  }\n  function A(e) {\n    return e.replace(/^0*(.*)/, \"$1\") || \"0\";\n  }\n  function O(e, t) {\n    var n = e.match(t.IPV4ADDRESS) || [],\n      r = c(n, 2)[1];\n    return r ? r.split(\".\").map(A).join(\".\") : e;\n  }\n  function N(e, t) {\n    var n = e.match(t.IPV6ADDRESS) || [],\n      r = c(n, 3),\n      o = r[1],\n      i = r[2];\n    if (o) {\n      for (\n        var s = o.toLowerCase().split(\"::\").reverse(),\n          a = c(s, 2),\n          l = a[0],\n          u = a[1],\n          d = u ? u.split(\":\").map(A) : [],\n          p = l.split(\":\").map(A),\n          h = t.IPV4ADDRESS.test(p[p.length - 1]),\n          f = h ? 7 : 8,\n          m = p.length - f,\n          g = Array(f),\n          _ = 0;\n        _ < f;\n        ++_\n      )\n        g[_] = d[_] || p[m + _] || \"\";\n      if (h) {\n        g[f - 1] = O(g[f - 1], t);\n      }\n      var y = g\n          .reduce(function (e, t, n) {\n            if (!t || \"0\" === t) {\n              var r = e[e.length - 1];\n              if (r && r.index + r.length === n) {\n                r.length++;\n              } else {\n                e.push({\n                  index: n,\n                  length: 1,\n                });\n              }\n            }\n            return e;\n          }, [])\n          .sort(function (e, t) {\n            return t.length - e.length;\n          })[0],\n        v = undefined;\n      if (y && y.length > 1) {\n        var b = g.slice(0, y.index),\n          w = g.slice(y.index + y.length);\n        v = b.join(\":\") + \"::\" + w.join(\":\");\n      } else v = g.join(\":\");\n      if (i) {\n        v += \"%\" + i;\n      }\n      return v;\n    }\n    return e;\n  }\n  var R =\n      /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i,\n    M = undefined === \"\".match(/(){0}/)[1];\n  function L(e) {\n    var t =\n        arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : {},\n      n = {},\n      r = !1 !== t.iri ? a : s;\n    if (\"suffix\" === t.reference) {\n      e = (t.scheme ? t.scheme + \":\" : \"\") + \"//\" + e;\n    }\n    var o = e.match(R);\n    if (o) {\n      if (M) {\n        n.scheme = o[1];\n        n.userinfo = o[3];\n        n.host = o[4];\n        n.port = parseInt(o[5], 10);\n        n.path = o[6] || \"\";\n        n.query = o[7];\n        n.fragment = o[8];\n        if (isNaN(n.port)) {\n          n.port = o[5];\n        }\n      } else {\n        n.scheme = o[1] || undefined;\n        n.userinfo = -1 !== e.indexOf(\"@\") ? o[3] : undefined;\n        n.host = -1 !== e.indexOf(\"//\") ? o[4] : undefined;\n        n.port = parseInt(o[5], 10);\n        n.path = o[6] || \"\";\n        n.query = -1 !== e.indexOf(\"?\") ? o[7] : undefined;\n        n.fragment = -1 !== e.indexOf(\"#\") ? o[8] : undefined;\n        if (isNaN(n.port)) {\n          n.port = e.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? o[4] : undefined;\n        }\n      }\n      if (n.host) {\n        n.host = N(O(n.host, r), r);\n      }\n      if (\n        undefined !== n.scheme ||\n        undefined !== n.userinfo ||\n        undefined !== n.host ||\n        undefined !== n.port ||\n        n.path ||\n        undefined !== n.query\n      ) {\n        if (undefined === n.scheme) {\n          n.reference = \"relative\";\n        } else {\n          if (undefined === n.fragment) {\n            n.reference = \"absolute\";\n          } else {\n            n.reference = \"uri\";\n          }\n        }\n      } else {\n        n.reference = \"same-document\";\n      }\n      if (\n        t.reference &&\n        \"suffix\" !== t.reference &&\n        t.reference !== n.reference\n      ) {\n        n.error = n.error || \"URI is not a \" + t.reference + \" reference.\";\n      }\n      var i = T[(t.scheme || n.scheme || \"\").toLowerCase()];\n      if (t.unicodeSupport || (i && i.unicodeSupport)) P(n, r);\n      else {\n        if (n.host && (t.domainHost || (i && i.domainHost)))\n          try {\n            n.host = C(n.host.replace(r.PCT_ENCODED, I).toLowerCase());\n          } catch (e) {\n            n.error =\n              n.error ||\n              \"Host's domain name can not be converted to ASCII via punycode: \" +\n                e;\n          }\n        P(n, s);\n      }\n      if (i && i.parse) {\n        i.parse(n, t);\n      }\n    } else n.error = n.error || \"URI can not be parsed.\";\n    return n;\n  }\n  function $(e, t) {\n    var n = !1 !== t.iri ? a : s,\n      r = [];\n    if (undefined !== e.userinfo) {\n      r.push(e.userinfo);\n      r.push(\"@\");\n    }\n    if (undefined !== e.host) {\n      r.push(\n        N(O(String(e.host), n), n).replace(n.IPV6ADDRESS, function (e, t, n) {\n          return \"[\" + t + (n ? \"%25\" + n : \"\") + \"]\";\n        })\n      );\n    }\n    if (\"number\" != typeof e.port && \"string\" != typeof e.port) {\n      r.push(\":\");\n      r.push(String(e.port));\n    }\n    return r.length ? r.join(\"\") : undefined;\n  }\n  var D = /^\\.\\.?\\//,\n    F = /^\\/\\.(\\/|$)/,\n    j = /^\\/\\.\\.(\\/|$)/,\n    q = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n  function B(e) {\n    for (var t = []; e.length; )\n      if (e.match(D)) e = e.replace(D, \"\");\n      else if (e.match(F)) e = e.replace(F, \"/\");\n      else if (e.match(j)) {\n        e = e.replace(j, \"/\");\n        t.pop();\n      } else if (\".\" === e || \"..\" === e) e = \"\";\n      else {\n        var n = e.match(q);\n        if (!n) throw new Error(\"Unexpected dot segment condition\");\n        var r = n[0];\n        e = e.slice(r.length);\n        t.push(r);\n      }\n    return t.join(\"\");\n  }\n  function U(e) {\n    var t =\n        arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : {},\n      n = t.iri ? a : s,\n      r = [],\n      o = T[(t.scheme || e.scheme || \"\").toLowerCase()];\n    if (o && o.serialize) {\n      o.serialize(e, t);\n    }\n    if (e.host)\n      if (n.IPV6ADDRESS.test(e.host));\n      else if (t.domainHost || (o && o.domainHost))\n        try {\n          e.host = t.iri\n            ? S(e.host)\n            : C(e.host.replace(n.PCT_ENCODED, I).toLowerCase());\n        } catch (n) {\n          e.error =\n            e.error ||\n            \"Host's domain name can not be converted to \" +\n              (t.iri ? \"Unicode\" : \"ASCII\") +\n              \" via punycode: \" +\n              n;\n        }\n    P(e, n);\n    if (\"suffix\" !== t.reference && e.scheme) {\n      r.push(e.scheme);\n      r.push(\":\");\n    }\n    var i = $(e, t);\n    if (undefined !== i) {\n      if (\"suffix\" !== t.reference) {\n        r.push(\"//\");\n      }\n      r.push(i);\n      if (e.path && \"/\" !== e.path.charAt(0)) {\n        r.push(\"/\");\n      }\n    }\n    if (void 0 !== e.path) {\n      var c = e.path;\n      t.absolutePath || (o && o.absolutePath) || (c = B(c)),\n        void 0 === i && (c = c.replace(/^\\/\\//, \"/%2F\")),\n        r.push(c);\n    }\n    if (undefined !== e.query) {\n      r.push(\"?\");\n      r.push(e.query);\n    }\n    if (undefined !== e.fragment) {\n      r.push(\"#\");\n      r.push(e.fragment);\n    }\n    return r.join(\"\");\n  }\n  function H(e, t) {\n    var n =\n        arguments.length > 2 && undefined !== arguments[2] ? arguments[2] : {},\n      r = {};\n    if (arguments[3]) {\n      e = L(U(e, n), n);\n      t = L(U(t, n), n);\n    }\n    if (!(n = n || {}).tolerant && t.scheme) {\n      r.scheme = t.scheme;\n      r.userinfo = t.userinfo;\n      r.host = t.host;\n      r.port = t.port;\n      r.path = B(t.path || \"\");\n      r.query = t.query;\n    } else {\n      if (\n        undefined !== t.userinfo ||\n        undefined !== t.host ||\n        undefined !== t.port\n      ) {\n        r.userinfo = t.userinfo;\n        r.host = t.host;\n        r.port = t.port;\n        r.path = B(t.path || \"\");\n        r.query = t.query;\n      } else {\n        if (t.path) {\n          if (\"/\" === t.path.charAt(0)) {\n            r.path = B(t.path);\n          } else {\n            if (\n              (undefined === e.userinfo &&\n                undefined === e.host &&\n                undefined === e.port) ||\n              e.path\n            ) {\n              if (e.path) {\n                r.path = e.path.slice(0, e.path.lastIndexOf(\"/\") + 1) + t.path;\n              } else {\n                r.path = t.path;\n              }\n            } else {\n              r.path = \"/\" + t.path;\n            }\n            r.path = B(r.path);\n          }\n          r.query = t.query;\n        } else {\n          r.path = e.path;\n          if (undefined !== t.query) {\n            r.query = t.query;\n          } else {\n            r.query = e.query;\n          }\n        }\n        r.userinfo = e.userinfo;\n        r.host = e.host;\n        r.port = e.port;\n      }\n      r.scheme = e.scheme;\n    }\n    r.fragment = t.fragment;\n    return r;\n  }\n  function z(e, t) {\n    return (\n      e && e.toString().replace(t && t.iri ? a.PCT_ENCODED : s.PCT_ENCODED, I)\n    );\n  }\n  var G = {\n      scheme: \"http\",\n      domainHost: !0,\n      parse: function (e, t) {\n        if (e.host) {\n          e.error = e.error || \"HTTP URIs must have a host.\";\n        }\n        return e;\n      },\n      serialize: function (e, t) {\n        var n = \"https\" === String(e.scheme).toLowerCase();\n        if (e.port !== (n ? 443 : 80) && \"\" !== e.port) {\n          e.port = undefined;\n        }\n        if (e.path) {\n          e.path = \"/\";\n        }\n        return e;\n      },\n    },\n    V = {\n      scheme: \"https\",\n      domainHost: G.domainHost,\n      parse: G.parse,\n      serialize: G.serialize,\n    };\n  function W(e) {\n    return \"boolean\" == typeof e.secure\n      ? e.secure\n      : \"wss\" === String(e.scheme).toLowerCase();\n  }\n  var K = {\n      scheme: \"ws\",\n      domainHost: !0,\n      parse: function (e, t) {\n        var n = e;\n        n.secure = W(n);\n        n.resourceName = (n.path || \"/\") + (n.query ? \"?\" + n.query : \"\");\n        n.path = undefined;\n        n.query = undefined;\n        return n;\n      },\n      serialize: function (e, t) {\n        if (e.port !== (W(e) ? 443 : 80) && \"\" !== e.port) {\n          e.port = undefined;\n        }\n        if (\"boolean\" == typeof e.secure) {\n          e.scheme = e.secure ? \"wss\" : \"ws\";\n          e.secure = undefined;\n        }\n        if (e.resourceName) {\n          var n = e.resourceName.split(\"?\"),\n            r = c(n, 2),\n            o = r[0],\n            i = r[1];\n          (e.path = o && \"/\" !== o ? o : void 0),\n            (e.query = i),\n            (e.resourceName = void 0);\n        }\n        e.fragment = undefined;\n        return e;\n      },\n    },\n    J = {\n      scheme: \"wss\",\n      domainHost: K.domainHost,\n      parse: K.parse,\n      serialize: K.serialize,\n    },\n    X = {},\n    Q =\n      \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\",\n    Y = \"[0-9A-Fa-f]\",\n    Z = n(\n      n(\"%[EFef][0-9A-Fa-f]%\" + Y + Y + \"%\" + Y + Y) +\n        \"|\" +\n        n(\"%[89A-Fa-f][0-9A-Fa-f]%\" + Y + Y) +\n        \"|\" +\n        n(\"%\" + Y + Y)\n    ),\n    ee = t(\n      \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\",\n      '[\\\\\"\\\\\\\\]'\n    ),\n    te = new RegExp(Q, \"g\"),\n    ne = new RegExp(Z, \"g\"),\n    re = new RegExp(\n      t(\n        \"[^]\",\n        \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\",\n        \"[\\\\.]\",\n        '[\\\\\"]',\n        ee\n      ),\n      \"g\"\n    ),\n    oe = new RegExp(t(\"[^]\", Q, \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\"), \"g\"),\n    ie = oe;\n  function se(e) {\n    var t = I(e);\n    return t.match(te) ? t : e;\n  }\n  var ae = {\n      scheme: \"mailto\",\n      parse: function (e, t) {\n        var n = e,\n          r = (n.to = n.path ? n.path.split(\",\") : []);\n        n.path = undefined;\n        if (n.query) {\n          for (\n            var o = !1, i = {}, s = n.query.split(\"&\"), a = 0, c = s.length;\n            a < c;\n            ++a\n          ) {\n            var l = s[a].split(\"=\");\n            switch (l[0]) {\n              case \"to\":\n                for (var u = l[1].split(\",\"), d = 0, p = u.length; d < p; ++d)\n                  r.push(u[d]);\n                break;\n              case \"subject\":\n                n.subject = z(l[1], t);\n                break;\n              case \"body\":\n                n.body = z(l[1], t);\n                break;\n              default:\n                (o = !0), (i[z(l[0], t)] = z(l[1], t));\n            }\n          }\n          o && (n.headers = i);\n        }\n        n.query = undefined;\n        for (var h = 0, f = r.length; h < f; ++h) {\n          var m = r[h].split(\"@\");\n          m[0] = z(m[0]);\n          if (t.unicodeSupport) m[1] = z(m[1], t).toLowerCase();\n          else\n            try {\n              m[1] = C(z(m[1], t).toLowerCase());\n            } catch (e) {\n              n.error =\n                n.error ||\n                \"Email address's domain name can not be converted to ASCII via punycode: \" +\n                  e;\n            }\n          r[h] = m.join(\"@\");\n        }\n        return n;\n      },\n      serialize: function (e, t) {\n        var n,\n          r = e,\n          i =\n            null != (n = e.to)\n              ? n instanceof Array\n                ? n\n                : \"number\" != typeof n.length ||\n                  n.split ||\n                  n.setInterval ||\n                  n.call\n                ? [n]\n                : Array.prototype.slice.call(n)\n              : [];\n        if (i) {\n          for (var s = 0, a = i.length; s < a; ++s) {\n            var c = String(i[s]),\n              l = c.lastIndexOf(\"@\"),\n              u = c.slice(0, l).replace(ne, se).replace(ne, o).replace(re, k),\n              d = c.slice(l + 1);\n            try {\n              d = t.iri ? S(d) : C(z(d, t).toLowerCase());\n            } catch (e) {\n              r.error =\n                r.error ||\n                \"Email address's domain name can not be converted to \" +\n                  (t.iri ? \"Unicode\" : \"ASCII\") +\n                  \" via punycode: \" +\n                  e;\n            }\n            i[s] = u + \"@\" + d;\n          }\n          r.path = i.join(\",\");\n        }\n        var p = (e.headers = e.headers || {});\n        if (e.subject) {\n          p.subject = e.subject;\n        }\n        if (e.body) {\n          p.body = e.body;\n        }\n        var h = [];\n        for (var f in p)\n          if (p[f] !== X[f]) {\n            h.push(\n              f.replace(ne, se).replace(ne, o).replace(oe, k) +\n                \"=\" +\n                p[f].replace(ne, se).replace(ne, o).replace(ie, k)\n            );\n          }\n        if (h.length) {\n          r.query = h.join(\"&\");\n        }\n        return r;\n      },\n    },\n    ce = /^([^\\:]+)\\:(.*)/,\n    le = {\n      scheme: \"urn\",\n      parse: function (e, t) {\n        var n = e.path && e.path.match(ce),\n          r = e;\n        if (n) {\n          var o = t.scheme || r.scheme || \"urn\",\n            i = n[1].toLowerCase(),\n            s = n[2],\n            a = o + \":\" + (t.nid || i),\n            c = T[a];\n          r.nid = i;\n          r.nss = s;\n          r.path = undefined;\n          if (c) {\n            r = c.parse(r, t);\n          }\n        } else r.error = r.error || \"URN can not be parsed.\";\n        return r;\n      },\n      serialize: function (e, t) {\n        var n = t.scheme || e.scheme || \"urn\",\n          r = e.nid,\n          o = n + \":\" + (t.nid || r),\n          i = T[o];\n        if (i) {\n          e = i.serialize(e, t);\n        }\n        var s = e,\n          a = e.nss;\n        s.path = (r || t.nid) + \":\" + a;\n        return s;\n      },\n    },\n    ue = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/,\n    de = {\n      scheme: \"urn:uuid\",\n      parse: function (e, t) {\n        var n = e;\n        n.uuid = n.nss;\n        n.nss = undefined;\n        if (t.tolerant || (n.uuid && n.uuid.match(ue))) {\n          n.error = n.error || \"UUID is not valid.\";\n        }\n        return n;\n      },\n      serialize: function (e, t) {\n        var n = e;\n        n.nss = (e.uuid || \"\").toLowerCase();\n        return n;\n      },\n    };\n  T[G.scheme] = G;\n  T[V.scheme] = V;\n  T[K.scheme] = K;\n  T[J.scheme] = J;\n  T[ae.scheme] = ae;\n  T[le.scheme] = le;\n  T[de.scheme] = de;\n  e.SCHEMES = T;\n  e.pctEncChar = k;\n  e.pctDecChars = I;\n  e.parse = L;\n  e.removeDotSegments = B;\n  e.serialize = U;\n  e.resolveComponents = H;\n  e.resolve = function (e, t, n) {\n    var r = (function (e, t) {\n      var n = e;\n      if (t) for (var r in t) n[r] = t[r];\n      return n;\n    })(\n      {\n        scheme: \"null\",\n      },\n      n\n    );\n    return U(H(L(e, r), L(t, r), r, !0), r);\n  };\n  e.normalize = function (e, t) {\n    if (\"string\" == typeof e) {\n      e = U(L(e, t), t);\n    } else {\n      if (\"object\" === r(e)) {\n        e = L(U(e, t), t);\n      }\n    }\n    return e;\n  };\n  e.equal = function (e, t, n) {\n    if (\"string\" == typeof e) {\n      e = U(L(e, n), n);\n    } else {\n      if (\"object\" === r(e)) {\n        e = U(e, n);\n      }\n    }\n    if (\"string\" == typeof t) {\n      t = U(L(t, n), n);\n    } else {\n      if (\"object\" === r(t)) {\n        t = U(t, n);\n      }\n    }\n    return e === t;\n  };\n  e.escapeComponent = function (e, t) {\n    return e && e.toString().replace(t && t.iri ? a.ESCAPE : s.ESCAPE, k);\n  };\n  e.unescapeComponent = z;\n  Object.defineProperty(e, \"__esModule\", {\n    value: !0,\n  });\n})(exports);",
  "569": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.computeScore =\n  exports.IndentationBasedJaccardMatcher =\n  exports.FixedWindowSizeJaccardMatcher =\n    undefined;\nconst r = require(4855),\n  o = require(1016);\nclass FixedWindowSizeJaccardMatcher extends o.WindowedMatcher {\n  constructor(e, t) {\n    super(e);\n    this.windowLength = t;\n  }\n  id() {\n    return \"fixed:\" + this.windowLength;\n  }\n  getWindowsDelineations(e) {\n    const t = [],\n      n = e.length;\n    for (let e = 0; 0 == e || e < n - this.windowLength; e++) {\n      const r = Math.min(e + this.windowLength, n);\n      t.push([e, r]);\n    }\n    return t;\n  }\n  trimDocument(e) {\n    return e.source\n      .slice(0, e.offset)\n      .split(\"\\n\")\n      .slice(-this.windowLength)\n      .join(\"\\n\");\n  }\n  similarityScore(e, t) {\n    return computeScore(e, t);\n  }\n}\nexports.FixedWindowSizeJaccardMatcher = FixedWindowSizeJaccardMatcher;\nFixedWindowSizeJaccardMatcher.FACTORY = (e) => ({\n  to: (t) => new FixedWindowSizeJaccardMatcher(t, e),\n});\nclass IndentationBasedJaccardMatcher extends o.WindowedMatcher {\n  constructor(e, t, n) {\n    super(e);\n    this.indentationMinLength = t;\n    this.indentationMaxLength = n;\n    this.languageId = e.languageId;\n  }\n  id() {\n    return `indent:${this.indentationMinLength}:${this.indentationMaxLength}:${this.languageId}`;\n  }\n  getWindowsDelineations(e) {\n    return r.getWindowsDelineations(\n      e,\n      this.languageId,\n      this.indentationMinLength,\n      this.indentationMaxLength\n    );\n  }\n  trimDocument(e) {\n    return e.source\n      .slice(0, e.offset)\n      .split(\"\\n\")\n      .slice(-this.indentationMaxLength)\n      .join(\"\\n\");\n  }\n  similarityScore(e, t) {\n    return computeScore(e, t);\n  }\n}\nfunction computeScore(e, t) {\n  const n = new Set();\n  e.forEach((e) => {\n    if (t.has(e)) {\n      n.add(e);\n    }\n  });\n  return n.size / (e.size + t.size - n.size);\n}\nexports.IndentationBasedJaccardMatcher = IndentationBasedJaccardMatcher;\nIndentationBasedJaccardMatcher.FACTORY = (e, t) => ({\n  to: (n) => new IndentationBasedJaccardMatcher(n, e, t),\n});\nexports.computeScore = computeScore;",
  "608": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r = require(5290);\nfunction getSamplingHashCode(e) {\n  var t = 2147483647,\n    n = 5381;\n  if (!e) return 0;\n  for (; e.length < 8; ) e += e;\n  for (var r = 0; r < e.length; r++)\n    n = ((((n << 5) + n) | 0) + e.charCodeAt(r)) | 0;\n  return ((n = n <= -2147483648 ? t : Math.abs(n)) / t) * 100;\n}\nexports.samplingTelemetryProcessor = function (e, t) {\n  var n = e.sampleRate;\n  return (\n    null == n ||\n    n >= 100 ||\n    !(\n      !e.data ||\n      r.TelemetryType.Metric !== r.baseTypeToTelemetryType(e.data.baseType)\n    ) ||\n    (t.correlationContext && t.correlationContext.operation\n      ? getSamplingHashCode(t.correlationContext.operation.id) < n\n      : 100 * Math.random() < n)\n  );\n};\nexports.getSamplingHashCode = getSamplingHashCode;",
  "706": "var r;\nr = require(8249);\n(function (e) {\n  var t = r,\n    n = t.lib,\n    o = n.WordArray,\n    i = n.Hasher,\n    s = t.algo,\n    a = o.create([\n      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6,\n      15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6,\n      13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0,\n      5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,\n    ]),\n    c = o.create([\n      5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13,\n      5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2,\n      10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12,\n      15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,\n    ]),\n    l = o.create([\n      11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11,\n      9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8,\n      13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5,\n      12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,\n    ]),\n    u = o.create([\n      8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12,\n      8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13,\n      5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15,\n      8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,\n    ]),\n    d = o.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),\n    p = o.create([1352829926, 1548603684, 1836072691, 2053994217, 0]),\n    h = (s.RIPEMD160 = i.extend({\n      _doReset: function () {\n        this._hash = o.create([\n          1732584193, 4023233417, 2562383102, 271733878, 3285377520,\n        ]);\n      },\n      _doProcessBlock: function (e, t) {\n        for (var n = 0; n < 16; n++) {\n          var r = t + n,\n            o = e[r];\n          e[r] =\n            (16711935 & ((o << 8) | (o >>> 24))) |\n            (4278255360 & ((o << 24) | (o >>> 8)));\n        }\n        var i,\n          s,\n          h,\n          b,\n          w,\n          x,\n          E,\n          C,\n          S,\n          T,\n          k,\n          I = this._hash.words,\n          P = d.words,\n          A = p.words,\n          O = a.words,\n          N = c.words,\n          R = l.words,\n          M = u.words;\n        for (\n          x = i = I[0],\n            E = s = I[1],\n            C = h = I[2],\n            S = b = I[3],\n            T = w = I[4],\n            n = 0;\n          n < 80;\n          n += 1\n        ) {\n          k = (i + e[t + O[n]]) | 0;\n          k +=\n            n < 16\n              ? f(s, h, b) + P[0]\n              : n < 32\n              ? m(s, h, b) + P[1]\n              : n < 48\n              ? g(s, h, b) + P[2]\n              : n < 64\n              ? _(s, h, b) + P[3]\n              : y(s, h, b) + P[4];\n          k = ((k = v((k |= 0), R[n])) + w) | 0;\n          i = w;\n          w = b;\n          b = v(h, 10);\n          h = s;\n          s = k;\n          k = (x + e[t + N[n]]) | 0;\n          k +=\n            n < 16\n              ? y(E, C, S) + A[0]\n              : n < 32\n              ? _(E, C, S) + A[1]\n              : n < 48\n              ? g(E, C, S) + A[2]\n              : n < 64\n              ? m(E, C, S) + A[3]\n              : f(E, C, S) + A[4];\n          k = ((k = v((k |= 0), M[n])) + T) | 0;\n          x = T;\n          T = S;\n          S = v(C, 10);\n          C = E;\n          E = k;\n        }\n        k = (I[1] + h + S) | 0;\n        I[1] = (I[2] + b + T) | 0;\n        I[2] = (I[3] + w + x) | 0;\n        I[3] = (I[4] + i + E) | 0;\n        I[4] = (I[0] + s + C) | 0;\n        I[0] = k;\n      },\n      _doFinalize: function () {\n        var e = this._data,\n          t = e.words,\n          n = 8 * this._nDataBytes,\n          r = 8 * e.sigBytes;\n        t[r >>> 5] |= 128 << (24 - (r % 32));\n        t[14 + (((r + 64) >>> 9) << 4)] =\n          (16711935 & ((n << 8) | (n >>> 24))) |\n          (4278255360 & ((n << 24) | (n >>> 8)));\n        e.sigBytes = 4 * (t.length + 1);\n        this._process();\n        for (var o = this._hash, i = o.words, s = 0; s < 5; s++) {\n          var a = i[s];\n          i[s] =\n            (16711935 & ((a << 8) | (a >>> 24))) |\n            (4278255360 & ((a << 24) | (a >>> 8)));\n        }\n        return o;\n      },\n      clone: function () {\n        var e = i.clone.call(this);\n        e._hash = this._hash.clone();\n        return e;\n      },\n    }));\n  function f(e, t, n) {\n    return e ^ t ^ n;\n  }\n  function m(e, t, n) {\n    return (e & t) | (~e & n);\n  }\n  function g(e, t, n) {\n    return (e | ~t) ^ n;\n  }\n  function _(e, t, n) {\n    return (e & n) | (t & ~n);\n  }\n  function y(e, t, n) {\n    return e ^ (t | ~n);\n  }\n  function v(e, t) {\n    return (e << t) | (e >>> (32 - t));\n  }\n  t.RIPEMD160 = i._createHelper(h);\n  t.HmacRIPEMD160 = i._createHmacHelper(h);\n})(Math);\nmodule.exports = r.RIPEMD160;",
  "731": "var r = require(\"http\"),\n  o = require(\"https\"),\n  i = require(5282),\n  s = require(5740),\n  a = require(9036),\n  c = require(6694),\n  l = require(894),\n  u = require(4350),\n  d = (function () {\n    function e(t) {\n      if (e.INSTANCE)\n        throw new Error(\n          \"Server request tracking should be configured from the applicationInsights object\"\n        );\n      e.INSTANCE = this;\n      this._client = t;\n    }\n    e.prototype.enable = function (e) {\n      this._isEnabled = e;\n      if (\n        (this._isAutoCorrelating || this._isEnabled || u.isEnabled()) &&\n        !this._isInitialized\n      ) {\n        this.useAutoCorrelation(this._isAutoCorrelating);\n        this._initialize();\n      }\n    };\n    e.prototype.useAutoCorrelation = function (e, t) {\n      if (e && !this._isAutoCorrelating) {\n        l.CorrelationContextManager.enable(t);\n      } else {\n        if (!e && this._isAutoCorrelating) {\n          l.CorrelationContextManager.disable();\n        }\n      }\n      this._isAutoCorrelating = e;\n    };\n    e.prototype.isInitialized = function () {\n      return this._isInitialized;\n    };\n    e.prototype.isAutoCorrelating = function () {\n      return this._isAutoCorrelating;\n    };\n    e.prototype._generateCorrelationContext = function (e) {\n      if (this._isAutoCorrelating)\n        return l.CorrelationContextManager.generateContextObject(\n          e.getOperationId(this._client.context.tags),\n          e.getRequestId(),\n          e.getOperationName(this._client.context.tags),\n          e.getCorrelationContextHeader(),\n          e.getTraceparent(),\n          e.getTracestate()\n        );\n    };\n    e.prototype._initialize = function () {\n      var t = this;\n      this._isInitialized = !0;\n      var n = function (n) {\n          if (n) {\n            if (\"function\" != typeof n)\n              throw new Error(\"onRequest handler must be a function\");\n            return function (r, o) {\n              l.CorrelationContextManager.wrapEmitter(r);\n              l.CorrelationContextManager.wrapEmitter(o);\n              var i = r && !r[e.alreadyAutoCollectedFlag];\n              if (r && i) {\n                var s = new c(r),\n                  a = t._generateCorrelationContext(s);\n                l.CorrelationContextManager.runWithContext(a, function () {\n                  if (t._isEnabled) {\n                    r[e.alreadyAutoCollectedFlag] = !0;\n                    e.trackRequest(\n                      t._client,\n                      {\n                        request: r,\n                        response: o,\n                      },\n                      s\n                    );\n                  }\n                  if (\"function\" == typeof n) {\n                    n(r, o);\n                  }\n                });\n              } else if (\"function\" == typeof n) {\n                n(r, o);\n              }\n            };\n          }\n        },\n        i = function (e) {\n          var t = e.addListener.bind(e);\n          e.addListener = function (e, r) {\n            switch (e) {\n              case \"request\":\n              case \"checkContinue\":\n                return t(e, n(r));\n              default:\n                return t(e, r);\n            }\n          };\n          e.on = e.addListener;\n        },\n        s = r.createServer;\n      r.createServer = function (e) {\n        var t = s(n(e));\n        i(t);\n        return t;\n      };\n      var a = o.createServer;\n      o.createServer = function (e, t) {\n        var r = a(e, n(t));\n        i(r);\n        return r;\n      };\n    };\n    e.trackRequestSync = function (t, n) {\n      if (n.request && n.response && t) {\n        e.addResponseCorrelationIdHeader(t, n.response);\n        var r = l.CorrelationContextManager.getCurrentContext(),\n          o = new c(n.request, r && r.operation.parentId);\n        if (r) {\n          r.operation.id = o.getOperationId(t.context.tags) || r.operation.id;\n          r.operation.name =\n            o.getOperationName(t.context.tags) || r.operation.name;\n          r.operation.parentId = o.getRequestId() || r.operation.parentId;\n          r.customProperties.addHeaderData(o.getCorrelationContextHeader());\n        }\n        e.endRequest(t, o, n, n.duration, n.error);\n      } else\n        i.info(\n          \"AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: \",\n          !n.request,\n          !n.response,\n          !t\n        );\n    };\n    e.trackRequest = function (t, n, r) {\n      if (n.request && n.response && t) {\n        var o = l.CorrelationContextManager.getCurrentContext(),\n          a = r || new c(n.request, o && o.operation.parentId);\n        if (s.canIncludeCorrelationHeader(t, a.getUrl())) {\n          e.addResponseCorrelationIdHeader(t, n.response);\n        }\n        if (o && !r) {\n          o.operation.id = a.getOperationId(t.context.tags) || o.operation.id;\n          o.operation.name =\n            a.getOperationName(t.context.tags) || o.operation.name;\n          o.operation.parentId =\n            a.getOperationParentId(t.context.tags) || o.operation.parentId;\n          o.customProperties.addHeaderData(a.getCorrelationContextHeader());\n        }\n        if (n.response.once) {\n          n.response.once(\"finish\", function () {\n            e.endRequest(t, a, n, null, null);\n          });\n        }\n        if (n.request.on) {\n          n.request.on(\"error\", function (r) {\n            e.endRequest(t, a, n, null, r);\n          });\n        }\n      } else\n        i.info(\n          \"AutoCollectHttpRequests.trackRequest was called with invalid parameters: \",\n          !n.request,\n          !n.response,\n          !t\n        );\n    };\n    e.addResponseCorrelationIdHeader = function (e, t) {\n      if (\n        e.config &&\n        e.config.correlationId &&\n        t.getHeader &&\n        t.setHeader &&\n        !t.headersSent\n      ) {\n        var n = t.getHeader(a.requestContextHeader);\n        s.safeIncludeCorrelationHeader(e, t, n);\n      }\n    };\n    e.endRequest = function (e, t, n, r, o) {\n      if (o) {\n        t.onError(o, r);\n      } else {\n        t.onResponse(n.response, r);\n      }\n      var i = t.getRequestTelemetry(n);\n      i.tagOverrides = t.getRequestTags(e.context.tags);\n      if (n.tagOverrides)\n        for (var s in n.tagOverrides) i.tagOverrides[s] = n.tagOverrides[s];\n      var a = t.getLegacyRootId();\n      if (a) {\n        i.properties.ai_legacyRootId = a;\n      }\n      i.contextObjects = i.contextObjects || {};\n      i.contextObjects[\"http.ServerRequest\"] = n.request;\n      i.contextObjects[\"http.ServerResponse\"] = n.response;\n      e.trackRequest(i);\n    };\n    e.prototype.dispose = function () {\n      e.INSTANCE = null;\n      this.enable(!1);\n      this._isInitialized = !1;\n      l.CorrelationContextManager.disable();\n      this._isAutoCorrelating = !1;\n    };\n    e.alreadyAutoCollectedFlag = \"_appInsightsAutoCollected\";\n    return e;\n  })();\nmodule.exports = d;",
  "750": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.handleGhostTextResultTelemetry =\n  exports.mkBasicResultTelemetry =\n  exports.mkCanceledResultTelemetry =\n  exports.telemetryRejected =\n  exports.telemetryAccepted =\n  exports.telemetryShown =\n    undefined;\nconst r = require(6333),\n  o = require(8965);\nexports.telemetryShown = function (e, t, n, o) {\n  n.markAsDisplayed();\n  const i = o ? `${t}.shownFromCache` : `${t}.shown`;\n  r.telemetry(e, i, n);\n};\nexports.telemetryAccepted = function (e, t, n) {\n  const i = t + \".accepted\",\n    s = e.get(o.ContextualFilterManager);\n  s.previousLabel = 1;\n  s.previousLabelTimestamp = Date.now();\n  r.telemetry(e, i, n);\n};\nexports.telemetryRejected = function (e, t, n) {\n  const i = t + \".rejected\",\n    s = e.get(o.ContextualFilterManager);\n  s.previousLabel = 0;\n  s.previousLabelTimestamp = Date.now();\n  r.telemetry(e, i, n);\n};\nexports.mkCanceledResultTelemetry = function (e, t = {}) {\n  return {\n    ...t,\n    telemetryBlob: e,\n  };\n};\nexports.mkBasicResultTelemetry = function (e) {\n  return {\n    headerRequestId: e.properties.headerRequestId,\n    copilot_trackingId: e.properties.copilot_trackingId,\n  };\n};\nexports.handleGhostTextResultTelemetry = async function (e, t) {\n  if (\"success\" === t.type) {\n    r.telemetryRaw(e, \"ghostText.produced\", t.telemetryData, {});\n    return t.value;\n  }\n  if (\"abortedBeforeIssued\" !== t.type) {\n    if (\"canceled\" !== t.type) {\n      r.telemetryRaw(\n        e,\n        `ghostText.${t.type}`,\n        {\n          ...t.telemetryData,\n          reason: t.reason,\n        },\n        {}\n      );\n    } else {\n      r.telemetry(\n        e,\n        \"ghostText.canceled\",\n        t.telemetryData.telemetryBlob.extendedBy({\n          reason: t.reason,\n          cancelledNetworkRequest: t.telemetryData.cancelledNetworkRequest\n            ? \"true\"\n            : \"false\",\n        })\n      );\n    }\n  }\n};",
  "766": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.ComputationStatus =\n  exports.getRepoUrlFromConfigText =\n  exports.parseRepoUrl =\n  exports.extractRepoInfoForTesting =\n  exports.extractRepoInfoInBackground =\n  exports.tryGetGitHubNWO =\n  exports.getDogFood =\n  exports.Dogfood =\n  exports.getUserKind =\n  exports.isNotRepo =\n  exports.isRepoInfo =\n    undefined;\nconst r = require(3055563),\n  o = require(3458),\n  i = require(\"path\"),\n  s = require(362),\n  a = require(3076);\nvar c;\nfunction tryGetGitHubNWO(e) {\n  if (undefined !== e && e !== f.PENDING)\n    return \"github.com\" === e.hostname ? e.owner + \"/\" + e.repo : undefined;\n}\nexports.isRepoInfo = function (e) {\n  return undefined !== e && e !== f.PENDING;\n};\nexports.isNotRepo = function (e) {\n  return undefined === e;\n};\nexports.getUserKind = async function (e) {\n  var t, n;\n  const r =\n    null !==\n      (t = (await e.get(s.CopilotTokenManager).getCopilotToken(e, !1))\n        .organization_list) && undefined !== t\n      ? t\n      : [];\n  return null !==\n    (n = [\n      \"a5db0bcaae94032fe715fb34a5e4bce2\",\n      \"4535c7beffc844b46bb1ed4aa04d759a\",\n    ].find((e) => r.includes(e))) && undefined !== n\n    ? n\n    : \"\";\n};\n(function (e) {\n  e.GITHUB = \"github\";\n  e.MICROSOFT = \"microsoft\";\n  e.UNKNOWN = \"\";\n})((c = exports.Dogfood || (exports.Dogfood = {})));\nexports.getDogFood = function (e) {\n  return undefined === e || e === f.PENDING\n    ? c.UNKNOWN\n    : \"github/github\" === tryGetGitHubNWO(e)\n    ? c.GITHUB\n    : \"ssh.dev.azure.com\" === e.hostname ||\n      \"vs-ssh.visualstudio.com\" === e.hostname ||\n      \"dev.azure.com\" === e.hostname ||\n      \"domoreexp.visualstudio.com\" === e.hostname ||\n      \"office.visualstudio.com\" === e.hostname\n    ? c.MICROSOFT\n    : c.UNKNOWN;\n};\nexports.tryGetGitHubNWO = tryGetGitHubNWO;\nexports.extractRepoInfoInBackground = function (e, t) {\n  if (!t) return;\n  const n = i.dirname(t);\n  return u(e, n);\n};\nconst u = (function (e, t) {\n  const n = new a.LRUCache(1e4),\n    r = new Set();\n  return (t, ...o) => {\n    const i = JSON.stringify(o),\n      s = n.get(i);\n    if (s) return s.result;\n    if (r.has(i)) return f.PENDING;\n    const a = e(t, ...o);\n    r.add(i);\n    a.then((e) => {\n      n.put(i, new m(e));\n      r.delete(i);\n    });\n    return f.PENDING;\n  };\n})(d);\nasync function d(e, t) {\n  var n;\n  const o = await (async function (e, t) {\n    let n = t + \"_add_to_make_longer\";\n    const o = e.get(r.FileSystem);\n    for (; t.length > 1 && t.length < n.length; ) {\n      const e = i.join(t, \".git\", \"config\");\n      let r = !1;\n      try {\n        await o.stat(e);\n        r = !0;\n      } catch (e) {\n        r = !1;\n      }\n      if (r) return t;\n      n = t;\n      t = i.dirname(t);\n    }\n  })(e, t);\n  if (!o) return;\n  const s = e.get(r.FileSystem),\n    a = i.join(o, \".git\", \"config\"),\n    c =\n      null !==\n        (n = getRepoUrlFromConfigText((await s.readFile(a)).toString())) &&\n      undefined !== n\n        ? n\n        : \"\",\n    l = parseRepoUrl(c);\n  return undefined === l\n    ? {\n        baseFolder: o,\n        url: c,\n        hostname: \"\",\n        owner: \"\",\n        repo: \"\",\n        pathname: \"\",\n      }\n    : {\n        baseFolder: o,\n        url: c,\n        ...l,\n      };\n}\nfunction parseRepoUrl(e) {\n  let t = {};\n  try {\n    t = o(e);\n    if (\"\" == t.host || \"\" == t.owner || \"\" == t.name || \"\" == t.pathname)\n      return;\n  } catch (e) {\n    return;\n  }\n  return {\n    hostname: t.host,\n    owner: t.owner,\n    repo: t.name,\n    pathname: t.pathname,\n  };\n}\nfunction getRepoUrlFromConfigText(e) {\n  var t;\n  const n = /^\\s*\\[\\s*remote\\s+\"((\\\\\\\\|\\\\\"|[^\\\\\"])+)\"/,\n    r = /^\\s*\\[remote.([^\"\\s]+)/,\n    o = /^\\s*url\\s*=\\s*([^\\s#;]+)/,\n    i = /^\\s*\\[/;\n  let s,\n    a,\n    c = !1;\n  for (const l of e.split(\"\\n\"))\n    if (c && undefined !== s) {\n      s += l;\n      if (l.endsWith(\"\\\\\")) s = s.substring(0, s.length - 1);\n      else if (((c = !1), \"origin\" === a)) return s;\n    } else {\n      const e = null !== (t = l.match(n)) && undefined !== t ? t : l.match(r);\n      if (e) a = e[1];\n      else if (l.match(i)) a = undefined;\n      else {\n        if (s && \"origin\" !== a) continue;\n        {\n          const e = l.match(o);\n          if (e) {\n            s = e[1];\n            if (s.endsWith(\"\\\\\")) {\n              s = s.substring(0, s.length - 1);\n              c = !0;\n            } else if (\"origin\" === a) return s;\n          }\n        }\n      }\n    }\n  return s;\n}\nvar f;\nexports.extractRepoInfoForTesting = async function (e, t) {\n  return d(e, t);\n};\nexports.parseRepoUrl = parseRepoUrl;\nexports.getRepoUrlFromConfigText = getRepoUrlFromConfigText;\n(function (e) {\n  e[(e.PENDING = 0)] = \"PENDING\";\n})((f = exports.ComputationStatus || (exports.ComputationStatus = {})));\nclass m {\n  constructor(e) {\n    this.result = e;\n  }\n}",
  "820": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getSiblingFunctionStart = exports.getSiblingFunctions = undefined;\nconst r = require(1747),\n  o = require(464);\nexports.getSiblingFunctions = async function ({\n  source: e,\n  offset: t,\n  languageId: n,\n}) {\n  var i, s;\n  const a = [];\n  let c = \"\",\n    l = e.substring(0, t);\n  if (o.isSupportedLanguageId(n)) {\n    const u = await o.parseTree(n, e);\n    try {\n      let d = t;\n      for (; d >= 0 && /\\s/.test(e[d]); ) d--;\n      const p = u.rootNode.descendantForIndex(d),\n        h = o.getAncestorWithSiblingFunctions(n, p);\n      if (h) {\n        const u = o.getFirstPrecedingComment(h),\n          d =\n            null !== (i = null == u ? undefined : u.startIndex) &&\n            undefined !== i\n              ? i\n              : h.startIndex;\n        let p,\n          f = 0;\n        for (; \" \" == (p = e[d - f - 1]) || \"\\t\" == p; ) f++;\n        const m = e.substring(d - f, d);\n        for (let i = h.nextSibling; i; i = i.nextSibling)\n          if (o.isFunctionDefinition(n, i)) {\n            const n = o.getFirstPrecedingComment(i),\n              c =\n                null !== (s = null == n ? undefined : n.startIndex) &&\n                undefined !== s\n                  ? s\n                  : i.startIndex;\n            if (c < t) continue;\n            const l = e.substring(c, i.endIndex),\n              u = r.newLineEnded(l) + \"\\n\" + m;\n            a.push(u);\n          }\n        c = e.substring(0, d);\n        l = e.substring(d, t);\n      }\n    } finally {\n      u.delete();\n    }\n  }\n  return {\n    siblings: a,\n    beforeInsertion: c,\n    afterInsertion: l,\n  };\n};\nexports.getSiblingFunctionStart = async function ({\n  source: e,\n  offset: t,\n  languageId: n,\n}) {\n  var r;\n  if (o.isSupportedLanguageId(n)) {\n    const i = await o.parseTree(n, e);\n    try {\n      let s = t;\n      for (; s >= 0 && /\\s/.test(e[s]); ) s--;\n      const a = i.rootNode.descendantForIndex(s),\n        c = o.getAncestorWithSiblingFunctions(n, a);\n      if (c) {\n        for (let e = c.nextSibling; e; e = e.nextSibling)\n          if (o.isFunctionDefinition(n, e)) {\n            const n = o.getFirstPrecedingComment(e),\n              i =\n                null !== (r = null == n ? undefined : n.startIndex) &&\n                undefined !== r\n                  ? r\n                  : e.startIndex;\n            if (i < t) continue;\n            return i;\n          }\n        if (c.endIndex >= t) return c.endIndex;\n      }\n    } finally {\n      i.delete();\n    }\n  }\n  return t;\n};",
  "862": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.TimeBucketGranularity =\n  exports.DEFAULT_GRANULARITY =\n  exports.GranularityImplementation =\n    undefined;\nclass GranularityImplementation {\n  constructor(e) {\n    this.prefix = e;\n  }\n  getCurrentAndUpComingValues(e) {\n    return [this.getValue(e), this.getUpcomingValues(e)];\n  }\n}\nexports.GranularityImplementation = GranularityImplementation;\nclass r extends GranularityImplementation {\n  getValue(e) {\n    return this.prefix;\n  }\n  getUpcomingValues(e) {\n    return [];\n  }\n}\nexports.DEFAULT_GRANULARITY = (e) => new r(e);\nexports.TimeBucketGranularity = class extends GranularityImplementation {\n  constructor(e, t = 0.5, n = new Date().setUTCHours(0, 0, 0, 0)) {\n    super(e);\n    this.prefix = e;\n    this.fetchBeforeFactor = t;\n    this.anchor = n;\n  }\n  setTimePeriod(e) {\n    if (isNaN(e)) {\n      this.timePeriodLengthMs = undefined;\n    } else {\n      this.timePeriodLengthMs = e;\n    }\n  }\n  setByCallBuckets(e) {\n    if (isNaN(e)) {\n      this.numByCallBuckets = undefined;\n    } else {\n      this.numByCallBuckets = e;\n    }\n  }\n  getValue(e) {\n    return (\n      this.prefix +\n      this.getTimePeriodBucketString(e) +\n      (this.numByCallBuckets ? this.timeHash(e) : \"\")\n    );\n  }\n  getTimePeriodBucketString(e) {\n    return this.timePeriodLengthMs ? this.dateToTimePartString(e) : \"\";\n  }\n  getUpcomingValues(e) {\n    const t = [],\n      n = this.getUpcomingTimePeriodBucketStrings(e),\n      r = this.getUpcomingByCallBucketStrings();\n    for (const e of n) for (const n of r) t.push(this.prefix + e + n);\n    return t;\n  }\n  getUpcomingTimePeriodBucketStrings(e) {\n    if (undefined === this.timePeriodLengthMs) return [\"\"];\n    if (\n      (e.getTime() - this.anchor) % this.timePeriodLengthMs <\n      this.fetchBeforeFactor * this.timePeriodLengthMs\n    )\n      return [this.getTimePeriodBucketString(e)];\n    {\n      const t = new Date(e.getTime() + this.timePeriodLengthMs);\n      return [\n        this.getTimePeriodBucketString(e),\n        this.getTimePeriodBucketString(t),\n      ];\n    }\n  }\n  getUpcomingByCallBucketStrings() {\n    return undefined === this.numByCallBuckets\n      ? [\"\"]\n      : Array.from(Array(this.numByCallBuckets).keys()).map((e) =>\n          e.toString()\n        );\n  }\n  timeHash(e) {\n    return null == this.numByCallBuckets\n      ? 0\n      : ((e.getTime() % this.numByCallBuckets) * 7883) % this.numByCallBuckets;\n  }\n  dateToTimePartString(e) {\n    return null == this.timePeriodLengthMs\n      ? \"\"\n      : Math.floor(\n          (e.getTime() - this.anchor) / this.timePeriodLengthMs\n        ).toString();\n  }\n};",
  "888": "var r, o, i, s, a, c, l, u;\nu = require(8249);\nrequire(2783);\nrequire(9824);\ni = (o = (r = u).lib).Base;\ns = o.WordArray;\nc = (a = r.algo).MD5;\nl = a.EvpKDF = i.extend({\n  cfg: i.extend({\n    keySize: 4,\n    hasher: c,\n    iterations: 1,\n  }),\n  init: function (e) {\n    this.cfg = this.cfg.extend(e);\n  },\n  compute: function (e, t) {\n    for (\n      var n,\n        r = this.cfg,\n        o = r.hasher.create(),\n        i = s.create(),\n        a = i.words,\n        c = r.keySize,\n        l = r.iterations;\n      a.length < c;\n\n    ) {\n      if (n) {\n        o.update(n);\n      }\n      n = o.update(e).finalize(t);\n      o.reset();\n      for (var u = 1; u < l; u++) {\n        n = o.finalize(n);\n        o.reset();\n      }\n      i.concat(n);\n    }\n    i.sigBytes = 4 * c;\n    return i;\n  },\n});\nr.EvpKDF = function (e, t, n) {\n  return l.create(n).compute(e, t);\n};\nmodule.exports = u.EvpKDF;",
  "893": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.CopilotListDocument = undefined;\nconst r = require(106),\n  o = require(1133),\n  i = require(6333),\n  s = require(2388);\nclass CopilotListDocument {\n  constructor(e, t, n, s, a, c) {\n    this.targetDocument = n;\n    this.completionContext = s;\n    this.token = c;\n    this._solutionCount = 0;\n    this.solutionCountTarget = 0;\n    this._solutions = [];\n    this._wasCancelled = !1;\n    this._updateHandlers = new Set();\n    this.savedTelemetryData = i.TelemetryData.createAndMarkAsIssued();\n    this.debouncedEventFire = r.debounce(10, () =>\n      this._updateHandlers.forEach((e) => e(this._uri))\n    );\n    this.onDidResultUpdated = (e) => (\n      this._updateHandlers.add(e),\n      {\n        dispose: () => {\n          this._updateHandlers.delete(e);\n        },\n      }\n    );\n    this.solutionCountTarget = a;\n    this._ctx = e;\n    this._uri = t;\n    this._showLogprobs = o.getConfig(e, o.ConfigKey.DebugShowScores);\n    this.startPosition = this.completionContext.insertPosition;\n    this.numberHeaderLines = Math.max(\n      1,\n      this.formatDisplayLines(\"\").length - 1\n    );\n  }\n  async getDocument() {\n    return this.targetDocument;\n  }\n  get targetUri() {\n    return this.targetDocument.uri;\n  }\n  header() {\n    if (this._wasCancelled) return \"No synthesized solutions found.\";\n    {\n      const e =\n        this._solutionCount - this._solutions.length > 0\n          ? \" (Duplicates hidden)\"\n          : \"\";\n      return `Synthesizing ${this._solutionCount}/${this.solutionCountTarget} solutions${e}`;\n    }\n  }\n  areSolutionsDuplicates(e, t) {\n    return (\n      s.normalizeCompletionText(e.completionText) ===\n      s.normalizeCompletionText(t.completionText)\n    );\n  }\n  insertSorted(e, t, n) {\n    if (!/^\\s*$/.test(t.completionText)) {\n      for (let r = 0; r < e.length; r++) {\n        const o = e[r];\n        if (this.areSolutionsDuplicates(o, t)) {\n          if (n(o) < n(t)) {\n            e.splice(r, 1);\n            break;\n          }\n          return;\n        }\n      }\n      for (let r = 0; r < e.length; r++)\n        if (n(e[r]) < n(t)) return void e.splice(r, 0, t);\n      e.push(t);\n    }\n  }\n  reportCancelled() {\n    this._wasCancelled = !0;\n    this.debouncedEventFire();\n  }\n  getCancellationToken() {\n    return this.token;\n  }\n  insertSolution(e) {\n    const t = {\n      displayLines: this.formatDisplayLines(\n        e.displayText,\n        e.meanProb,\n        e.meanLogProb\n      ),\n      completionText: e.completionText,\n      meanLogProb: e.meanLogProb,\n      meanProb: e.meanProb,\n      prependToCompletion: e.prependToCompletion,\n      requestId: e.requestId,\n      choiceIndex: e.choiceIndex,\n    };\n    this.insertSorted(this._solutions, t, (e) => e.meanProb);\n    this._solutionCount++;\n    this.debouncedEventFire();\n  }\n  formatDisplayLines(e, t, n) {\n    let r = \"\";\n    if (this._showLogprobs) {\n      n = n || 0;\n      r += `\\n\\t# mean prob: ${t}`;\n    }\n    return `${CopilotListDocument.separator}${r}\\n\\n${e}`.split(\"\\n\");\n  }\n  async runQuery() {\n    const e = await s.launchSolutions(this._ctx, this);\n    this.processNextSolution(e);\n  }\n  async processNextSolution(e) {\n    switch (e.status) {\n      case \"FinishedNormally\":\n      case \"FinishedWithError\":\n        return;\n      case \"Solution\":\n        this.insertSolution(e.solution);\n        this.processNextSolution(await e.next);\n    }\n  }\n  solutionsReceived() {\n    return this._solutionCount;\n  }\n  solutions() {\n    return this._solutions;\n  }\n  get value() {\n    return [this.header()]\n      .concat(this._solutions.flatMap((e) => e.displayLines))\n      .concat(\"\")\n      .join(\"\\n\");\n  }\n}\nexports.CopilotListDocument = CopilotListDocument;\nCopilotListDocument.separator = \"\\n=======\";",
  "894": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r = require(5282),\n  o = require(7396),\n  CorrelationContextManager = (function () {\n    function e() {}\n    e.getCurrentContext = function () {\n      if (!e.enabled) return null;\n      var t = e.session.get(e.CONTEXT_NAME);\n      return undefined === t ? null : t;\n    };\n    e.generateContextObject = function (e, t, n, r, o, i) {\n      t = t || e;\n      return this.enabled\n        ? {\n            operation: {\n              name: n,\n              id: e,\n              parentId: t,\n              traceparent: o,\n              tracestate: i,\n            },\n            customProperties: new s(r),\n          }\n        : null;\n    };\n    e.runWithContext = function (t, n) {\n      return e.enabled\n        ? e.session.bind(n, (((r = {})[e.CONTEXT_NAME] = t), r))()\n        : n();\n      var r;\n    };\n    e.wrapEmitter = function (t) {\n      if (e.enabled) {\n        e.session.bindEmitter(t);\n      }\n    };\n    e.wrapCallback = function (t) {\n      return e.enabled ? e.session.bind(t) : t;\n    };\n    e.enable = function (t) {\n      if (this.enabled) {\n        if (this.isNodeVersionCompatible()) {\n          if (e.hasEverEnabled) {\n            this.forceClsHooked = t;\n            this.hasEverEnabled = !0;\n            if (undefined === this.cls) {\n              if (\n                !0 === e.forceClsHooked ||\n                (undefined === e.forceClsHooked && e.shouldUseClsHooked())\n              ) {\n                this.cls = require(9562);\n              } else {\n                this.cls = require(3057);\n              }\n            }\n            e.session = this.cls.createNamespace(\"AI-CLS-Session\");\n            o.registerContextPreservation(function (t) {\n              return e.session.bind(t);\n            });\n          }\n          this.enabled = !0;\n        } else {\n          this.enabled = !1;\n        }\n      }\n    };\n    e.disable = function () {\n      this.enabled = !1;\n    };\n    e.reset = function () {\n      if (e.hasEverEnabled) {\n        e.session = null;\n        e.session = this.cls.createNamespace(\"AI-CLS-Session\");\n      }\n    };\n    e.isNodeVersionCompatible = function () {\n      var e = process.versions.node.split(\".\");\n      return parseInt(e[0]) > 3 || (parseInt(e[0]) > 2 && parseInt(e[1]) > 2);\n    };\n    e.shouldUseClsHooked = function () {\n      var e = process.versions.node.split(\".\");\n      return parseInt(e[0]) > 8 || (parseInt(e[0]) >= 8 && parseInt(e[1]) >= 2);\n    };\n    e.canUseClsHooked = function () {\n      var e = process.versions.node.split(\".\"),\n        t = parseInt(e[0]) > 8 || (parseInt(e[0]) >= 8 && parseInt(e[1]) >= 0),\n        n = parseInt(e[0]) < 8 || (parseInt(e[0]) <= 8 && parseInt(e[1]) < 2),\n        r = parseInt(e[0]) > 4 || (parseInt(e[0]) >= 4 && parseInt(e[1]) >= 7);\n      return !(t && n) && r;\n    };\n    e.enabled = !1;\n    e.hasEverEnabled = !1;\n    e.forceClsHooked = undefined;\n    e.CONTEXT_NAME = \"ApplicationInsights-Context\";\n    return e;\n  })();\nexports.CorrelationContextManager = CorrelationContextManager;\nvar s = (function () {\n  function e(e) {\n    this.props = [];\n    this.addHeaderData(e);\n  }\n  e.prototype.addHeaderData = function (e) {\n    var t = e ? e.split(\", \") : [];\n    this.props = t\n      .map(function (e) {\n        var t = e.split(\"=\");\n        return {\n          key: t[0],\n          value: t[1],\n        };\n      })\n      .concat(this.props);\n  };\n  e.prototype.serializeToHeader = function () {\n    return this.props\n      .map(function (e) {\n        return e.key + \"=\" + e.value;\n      })\n      .join(\", \");\n  };\n  e.prototype.getProperty = function (e) {\n    for (var t = 0; t < this.props.length; ++t) {\n      var n = this.props[t];\n      if (n.key === e) return n.value;\n    }\n  };\n  e.prototype.setProperty = function (t, n) {\n    if (e.bannedCharacters.test(t) || e.bannedCharacters.test(n))\n      r.warn(\n        \"Correlation context property keys and values must not contain ',' or '='. setProperty was called with key: \" +\n          t +\n          \" and value: \" +\n          n\n      );\n    else {\n      for (var o = 0; o < this.props.length; ++o) {\n        var i = this.props[o];\n        if (i.key === t) return void (i.value = n);\n      }\n      this.props.push({\n        key: t,\n        value: n,\n      });\n    }\n  };\n  e.bannedCharacters = /[,=]/;\n  return e;\n})();",
  "901": "var r,\n  o =\n    (this && this.__extends) ||\n    ((r =\n      Object.setPrototypeOf ||\n      ({\n        __proto__: [],\n      } instanceof Array &&\n        function (e, t) {\n          e.__proto__ = t;\n        }) ||\n      function (e, t) {\n        for (var n in t)\n          if (t.hasOwnProperty(n)) {\n            e[n] = t[n];\n          }\n      }),\n    function (e, t) {\n      function n() {\n        this.constructor = e;\n      }\n      r(e, t);\n      e.prototype =\n        null === t ? Object.create(t) : ((n.prototype = t.prototype), new n());\n    }),\n  i = (function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.properties = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  })(require(8934));\nmodule.exports = i;",
  "935": "var r,\n  o =\n    (this && this.__extends) ||\n    ((r =\n      Object.setPrototypeOf ||\n      ({\n        __proto__: [],\n      } instanceof Array &&\n        function (e, t) {\n          e.__proto__ = t;\n        }) ||\n      function (e, t) {\n        for (var n in t)\n          if (t.hasOwnProperty(n)) {\n            e[n] = t[n];\n          }\n      }),\n    function (e, t) {\n      function n() {\n        this.constructor = e;\n      }\n      r(e, t);\n      e.prototype =\n        null === t ? Object.create(t) : ((n.prototype = t.prototype), new n());\n    }),\n  i = (function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.exceptions = [];\n      t.properties = {};\n      t.measurements = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  })(require(8934));\nmodule.exports = i;",
  "937": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getTemperatureForSamples =\n  exports.calculateMeanAlternativeLogProb =\n  exports.calculateMeanLogProb =\n  exports.cleanupIndentChoices =\n  exports.convertToAPIChoice =\n  exports.DEFAULT_CHARACTER_MULTIPLIER =\n  exports.MAX_PROMPT_LENGTH =\n  exports.OpenAIFetcher =\n  exports.LiveOpenAIFetcher =\n  exports.getRequestId =\n  exports.CopilotUiKind =\n    undefined;\nconst r = require(1133),\n  o = require(9899),\n  i = require(6333),\n  s = require(70);\nvar a = require(4419);\nfunction calculateMeanLogProb(e, t) {\n  var n;\n  if (\n    null === (n = null == t ? undefined : t.logprobs) || undefined === n\n      ? undefined\n      : n.token_logprobs\n  )\n    try {\n      let e = 0,\n        n = 0,\n        r = 50;\n      for (\n        let o = 0;\n        o < t.logprobs.token_logprobs.length - 1 && r > 0;\n        o++, r--\n      ) {\n        e += t.logprobs.token_logprobs[o];\n        n += 1;\n      }\n      return n > 0 ? e / n : undefined;\n    } catch (t) {\n      o.logger.error(e, `Error calculating mean prob: ${t}`);\n    }\n}\nfunction calculateMeanAlternativeLogProb(e, t) {\n  var n;\n  if (\n    null === (n = null == t ? undefined : t.logprobs) || undefined === n\n      ? undefined\n      : n.top_logprobs\n  )\n    try {\n      let e = 0,\n        n = 0,\n        r = 50;\n      for (\n        let o = 0;\n        o < t.logprobs.token_logprobs.length - 1 && r > 0;\n        o++, r--\n      ) {\n        const r = {\n          ...t.logprobs.top_logprobs[o],\n        };\n        delete r[t.logprobs.tokens[o]];\n        e += Math.max(...Object.values(r));\n        n += 1;\n      }\n      return n > 0 ? e / n : undefined;\n    } catch (t) {\n      o.logger.error(e, `Error calculating mean prob: ${t}`);\n    }\n}\nexports.CopilotUiKind = a.CopilotUiKind;\nexports.getRequestId = a.getRequestId;\nexports.LiveOpenAIFetcher = a.LiveOpenAIFetcher;\nexports.OpenAIFetcher = a.OpenAIFetcher;\nexports.MAX_PROMPT_LENGTH = 1500;\nexports.DEFAULT_CHARACTER_MULTIPLIER = 3;\nexports.convertToAPIChoice = function (e, t, n, r, o, s, a, u) {\n  i.logEngineCompletion(e, t, n, o, r);\n  return {\n    completionText: t,\n    meanLogProb: calculateMeanLogProb(e, n),\n    meanAlternativeLogProb: calculateMeanAlternativeLogProb(e, n),\n    choiceIndex: r,\n    requestId: o,\n    modelInfo: u,\n    blockFinished: s,\n    tokens: n.tokens,\n    numTokens: n.tokens.length,\n    telemetryData: a,\n  };\n};\nexports.cleanupIndentChoices = async function* (e, t) {\n  for await (const n of e) {\n    const e = {\n        ...n,\n      },\n      r = e.completionText.split(\"\\n\");\n    for (let e = 0; e < r.length; ++e) {\n      const n = r[e].trimLeft();\n      r[e] = \"\" === n ? n : t + n;\n    }\n    e.completionText = r.join(\"\\n\");\n    yield e;\n  }\n};\nexports.calculateMeanLogProb = calculateMeanLogProb;\nexports.calculateMeanAlternativeLogProb = calculateMeanAlternativeLogProb;\nexports.getTemperatureForSamples = function (e, t) {\n  if (s.isRunningInTest(e)) return 0;\n  const n = parseFloat(r.getConfig(e, r.ConfigKey.Temperature));\n  return n >= 0 && n <= 1 ? n : t <= 1 ? 0 : t < 10 ? 0.2 : t < 20 ? 0.4 : 0.8;\n};",
  "956": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.readTestingGitHubToken = exports.makeTestingCopilotTokenManager =\n  undefined;\nconst r = require(\"fs\"),\n  o = require(362);\nfunction readTestingGitHubToken() {\n  const e = `${process.env.HOME}/.copilot-testing-gh-token`;\n  if (r.existsSync(e)) return r.readFileSync(e).toString();\n  throw new Error(\n    `Tests: either GH_COPILOT_TOKEN, or GITHUB_TOKEN, must be set, or there must be a GitHub token from an app with access to Copilot in ${e}. Run \"npm run get_token\" to get one.`\n  );\n}\nexports.makeTestingCopilotTokenManager = function () {\n  if (process.env.GH_COPILOT_TOKEN)\n    return new o.FixedCopilotTokenManager({\n      token: process.env.GH_COPILOT_TOKEN,\n      telemetry: \"enabled\",\n    });\n  if (process.env.GITHUB_TOKEN)\n    return new o.CopilotTokenManagerFromGitHubToken({\n      token: process.env.GITHUB_TOKEN,\n    });\n  const e = readTestingGitHubToken();\n  process.env.GITHUB_TOKEN = e;\n  return new o.CopilotTokenManagerFromGitHubToken({\n    token: e,\n  });\n};\nexports.readTestingGitHubToken = readTestingGitHubToken;",
  "966": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = require(6776),\n  i = require(3510),\n  s = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: !0,\n    error: {\n      message: \"must be equal to one of the allowed values\",\n      params: ({ schemaCode: e }) => r._`{allowedValues: ${e}}`,\n    },\n    code(e) {\n      const { gen: t, data: n, $data: s, schema: a, schemaCode: c, it: l } = e;\n      if (!s && 0 === a.length)\n        throw new Error(\"enum must have non-empty array\");\n      const u = a.length >= l.opts.loopEnum,\n        d = o.useFunc(t, i.default);\n      let p;\n      if (u || s) {\n        p = t.let(\"valid\");\n        e.block$data(p, function () {\n          t.assign(p, !1);\n          t.forOf(\"v\", c, (e) =>\n            t.if(r._`${d}(${n}, ${e})`, () => t.assign(p, !0).break())\n          );\n        });\n      } else {\n        if (!Array.isArray(a)) throw new Error(\"ajv implementation error\");\n        const e = t.const(\"vSchema\", c);\n        p = r.or(\n          ...a.map((t, o) =>\n            (function (e, t) {\n              const o = a[t];\n              return \"object\" == typeof o && null !== o\n                ? r._`${d}(${n}, ${e}[${t}])`\n                : r._`${n} === ${o}`;\n            })(e, o)\n          )\n        );\n      }\n      e.pass(p);\n    },\n  };\nexports.default = s;",
  "1006": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.ghostTextScoreQuantile = exports.ghostTextScoreConfidence = undefined;\nconst r = require(9899),\n  o = require(7481),\n  i =\n    (new r.Logger(r.LogLevel.INFO, \"restraint\"),\n    {\n      link: (e) => Math.exp(e) / (1 + Math.exp(e)),\n      unlink: (e) => Math.log(e / (1 - e)),\n    });\nclass s {\n  constructor(e, t, n) {\n    this.name = e;\n    this.coefficient = t;\n    this.transformation = n || ((e) => e);\n  }\n  contribution(e) {\n    return this.coefficient * this.transformation(e);\n  }\n}\nconst a = new (class {\n  constructor(e, t, n) {\n    this.link = i;\n    this.intercept = e;\n    this.coefficients = t;\n    this.logitsToQuantiles = new Map();\n    this.logitsToQuantiles.set(0, 0);\n    this.logitsToQuantiles.set(1, 1);\n    if (n) for (const e in n) this.logitsToQuantiles.set(n[e], Number(e));\n  }\n  predict(e, t) {\n    let n = this.intercept;\n    for (const e of this.coefficients) {\n      const r = t[e.name];\n      if (undefined === r) return NaN;\n      n += e.contribution(r);\n    }\n    return this.link.link(n);\n  }\n  quantile(e, t) {\n    return (function (e, t) {\n      const n = Math.min(...Array.from(t.keys()).filter((t) => t >= e)),\n        r = Math.max(...Array.from(t.keys()).filter((t) => t < e)),\n        o = t.get(n),\n        i = t.get(r);\n      return i + ((o - i) * (e - r)) / (n - r);\n    })(this.predict(e, t), this.logitsToQuantiles);\n  }\n})(\n  o.ghostTextDisplayInterceptParameter,\n  [\n    new s(\"compCharLen\", o.ghostTextDisplayLog1pcompCharLenParameter, (e) =>\n      Math.log(1 + e)\n    ),\n    new s(\"meanLogProb\", o.ghostTextDisplayMeanLogProbParameter),\n    new s(\n      \"meanAlternativeLogProb\",\n      o.ghostTextDisplayMeanAlternativeLogProbParameter\n    ),\n  ].concat(\n    Object.entries(o.ghostTextDisplayLanguageParameters).map(\n      (e) => new s(e[0], e[1])\n    )\n  ),\n  o.ghostTextDisplayQuantiles\n);\nexports.ghostTextScoreConfidence = function (e, t) {\n  const n = {\n    ...t.measurements,\n  };\n  Object.keys(o.ghostTextDisplayLanguageParameters).forEach((e) => {\n    n[e] = t.properties[\"customDimensions.languageId\"] == e ? 1 : 0;\n  });\n  return a.predict(e, n);\n};\nexports.ghostTextScoreQuantile = function (e, t) {\n  const n = {\n    ...t.measurements,\n  };\n  Object.keys(o.ghostTextDisplayLanguageParameters).forEach((e) => {\n    n[e] = t.properties[\"customDimensions.languageId\"] == e ? 1 : 0;\n  });\n  return a.quantile(e, n);\n};",
  "1016": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.splitIntoWords =\n  exports.WindowedMatcher =\n  exports.SortOptions =\n    undefined;\nconst r = require(1747);\nvar o;\n!(function (e) {\n  e.Ascending = \"ascending\";\n  e.Descending = \"descending\";\n  e.None = \"none\";\n})((o = exports.SortOptions || (exports.SortOptions = {})));\nclass i {\n  constructor(e) {\n    var t;\n    this.stopsForLanguage =\n      null !== (t = u.get(e.languageId)) && undefined !== t ? t : l;\n  }\n  tokenize(e) {\n    return new Set(\n      splitIntoWords(e).filter((e) => !this.stopsForLanguage.has(e))\n    );\n  }\n}\nconst s = new (class {\n  constructor(e) {\n    this.keys = [];\n    this.cache = {};\n    this.size = e;\n  }\n  put(e, t) {\n    var n;\n    this.cache[e] = t;\n    if (this.keys.length > this.size) {\n      this.keys.push(e);\n      const t = null !== (n = this.keys.shift()) && void 0 !== n ? n : \"\";\n      delete this.cache[t];\n    }\n  }\n  get(e) {\n    return this.cache[e];\n  }\n})(20);\nfunction splitIntoWords(e) {\n  return e.split(/[^a-zA-Z0-9]/).filter((e) => e.length > 0);\n}\nexports.WindowedMatcher = class {\n  constructor(e) {\n    this.tokenizer = new i(e);\n    this.referenceTokens = this.tokenizer.tokenize(this.trimDocument(e));\n  }\n  sortScoredSnippets(e, t = o.Descending) {\n    return t == o.Ascending\n      ? e.sort((e, t) => (e.score > t.score ? 1 : -1))\n      : t == o.Descending\n      ? e.sort((e, t) => (e.score > t.score ? -1 : 1))\n      : e;\n  }\n  retrieveAllSnippets(e, t = o.Descending) {\n    var n;\n    const r = [];\n    if (0 === e.source.length || 0 === this.referenceTokens.size) return r;\n    const i = e.source.split(\"\\n\"),\n      a = this.id() + \":\" + e.source,\n      c = null !== (n = s.get(a)) && undefined !== n ? n : [],\n      l = 0 == c.length,\n      u = l ? i.map(this.tokenizer.tokenize, this.tokenizer) : [];\n    for (const [e, [t, n]] of this.getWindowsDelineations(i).entries()) {\n      if (l) {\n        const e = new Set();\n        u.slice(t, n).forEach((t) => t.forEach(e.add, e));\n        c.push(e);\n      }\n      const o = c[e],\n        i = this.similarityScore(o, this.referenceTokens);\n      r.push({\n        score: i,\n        startLine: t,\n        endLine: n,\n      });\n    }\n    if (l) {\n      s.put(a, c);\n    }\n    return this.sortScoredSnippets(r, t);\n  }\n  findMatches(e, t = r.SnippetSelectionOption.BestMatch, n) {\n    if (t == r.SnippetSelectionOption.BestMatch) {\n      const t = this.findBestMatch(e);\n      return t ? [t] : [];\n    }\n    return (\n      (t == r.SnippetSelectionOption.TopK && this.findTopKMatches(e, n)) || []\n    );\n  }\n  findBestMatch(e) {\n    if (0 === e.source.length || 0 === this.referenceTokens.size) return;\n    const t = e.source.split(\"\\n\"),\n      n = this.retrieveAllSnippets(e, o.Descending);\n    return 0 !== n.length && 0 !== n[0].score\n      ? {\n          snippet: t.slice(n[0].startLine, n[0].endLine).join(\"\\n\"),\n          ...n[0],\n        }\n      : undefined;\n  }\n  findTopKMatches(e, t = 1) {\n    if (0 === e.source.length || 0 === this.referenceTokens.size || t < 1)\n      return;\n    const n = e.source.split(\"\\n\"),\n      r = this.retrieveAllSnippets(e, o.Descending);\n    if (0 === r.length || 0 === r[0].score) return;\n    const i = [r[0]];\n    for (let e = 1; e < r.length && i.length < t; e++)\n      if (\n        -1 ==\n        i.findIndex(\n          (t) => r[e].startLine < t.endLine && r[e].endLine > t.startLine\n        )\n      ) {\n        i.push(r[e]);\n      }\n    return i.map((e) => ({\n      snippet: n.slice(e.startLine, e.endLine).join(\"\\n\"),\n      ...e,\n    }));\n  }\n};\nexports.splitIntoWords = splitIntoWords;\nconst c = new Set([\n    \"we\",\n    \"our\",\n    \"you\",\n    \"it\",\n    \"its\",\n    \"they\",\n    \"them\",\n    \"their\",\n    \"this\",\n    \"that\",\n    \"these\",\n    \"those\",\n    \"is\",\n    \"are\",\n    \"was\",\n    \"were\",\n    \"be\",\n    \"been\",\n    \"being\",\n    \"have\",\n    \"has\",\n    \"had\",\n    \"having\",\n    \"do\",\n    \"does\",\n    \"did\",\n    \"doing\",\n    \"can\",\n    \"don\",\n    \"t\",\n    \"s\",\n    \"will\",\n    \"would\",\n    \"should\",\n    \"what\",\n    \"which\",\n    \"who\",\n    \"when\",\n    \"where\",\n    \"why\",\n    \"how\",\n    \"a\",\n    \"an\",\n    \"the\",\n    \"and\",\n    \"or\",\n    \"not\",\n    \"no\",\n    \"but\",\n    \"because\",\n    \"as\",\n    \"until\",\n    \"again\",\n    \"further\",\n    \"then\",\n    \"once\",\n    \"here\",\n    \"there\",\n    \"all\",\n    \"any\",\n    \"both\",\n    \"each\",\n    \"few\",\n    \"more\",\n    \"most\",\n    \"other\",\n    \"some\",\n    \"such\",\n    \"above\",\n    \"below\",\n    \"to\",\n    \"during\",\n    \"before\",\n    \"after\",\n    \"of\",\n    \"at\",\n    \"by\",\n    \"about\",\n    \"between\",\n    \"into\",\n    \"through\",\n    \"from\",\n    \"up\",\n    \"down\",\n    \"in\",\n    \"out\",\n    \"on\",\n    \"off\",\n    \"over\",\n    \"under\",\n    \"only\",\n    \"own\",\n    \"same\",\n    \"so\",\n    \"than\",\n    \"too\",\n    \"very\",\n    \"just\",\n    \"now\",\n  ]),\n  l = new Set([\n    \"if\",\n    \"then\",\n    \"else\",\n    \"for\",\n    \"while\",\n    \"with\",\n    \"def\",\n    \"function\",\n    \"return\",\n    \"TODO\",\n    \"import\",\n    \"try\",\n    \"catch\",\n    \"raise\",\n    \"finally\",\n    \"repeat\",\n    \"switch\",\n    \"case\",\n    \"match\",\n    \"assert\",\n    \"continue\",\n    \"break\",\n    \"const\",\n    \"class\",\n    \"enum\",\n    \"struct\",\n    \"static\",\n    \"new\",\n    \"super\",\n    \"this\",\n    \"var\",\n    ...c,\n  ]),\n  u = new Map([]);",
  "1077": "var r;\nr = require(8249);\nrequire(5109);\nr.pad.Iso97971 = {\n  pad: function (e, t) {\n    e.concat(r.lib.WordArray.create([2147483648], 1));\n    r.pad.ZeroPadding.pad(e, t);\n  },\n  unpad: function (e) {\n    r.pad.ZeroPadding.unpad(e);\n    e.sigBytes--;\n  },\n};\nmodule.exports = r.pad.Iso97971;",
  "1119": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = require(6776),\n  i = require(412),\n  s = require(4783),\n  a = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    error: {\n      message: ({ params: { len: e } }) =>\n        r.str`must NOT have more than ${e} items`,\n      params: ({ params: { len: e } }) => r._`{limit: ${e}}`,\n    },\n    code(e) {\n      const { schema: t, parentSchema: n, it: r } = e,\n        { prefixItems: a } = n;\n      r.items = !0;\n      if (o.alwaysValidSchema(r, t)) {\n        if (a) {\n          s.validateAdditionalItems(e, a);\n        } else {\n          e.ok(i.validateArray(e));\n        }\n      }\n    },\n  };\nexports.default = a;",
  "1124": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.checkSuffix = exports.postProcessChoice = undefined;\nconst r = require(9189),\n  o = require(2533),\n  i = require(6333),\n  s = require(70),\n  a = require(9657);\nexports.postProcessChoice = async function (e, t, n, c, l, u, d) {\n  if (\n    a.isRepetitive(l.tokens, await e.get(r.Features).repetitionFilterMode())\n  ) {\n    const t = i.TelemetryData.createAndMarkAsIssued();\n    t.extendWithRequestId(l.requestId);\n    i.telemetry(e, \"repetition.detected\", t, !0);\n    return void d.info(e, \"Filtered out repetitive solution\");\n  }\n  const p = {\n    ...l,\n  };\n  if (\n    (function (e, t, n) {\n      let r = \"\",\n        o = t.line + 1;\n      for (; \"\" === r && o < e.lineCount; ) {\n        r = e.lineAt(o).text.trim();\n        if (r === n.trim()) return !0;\n        o++;\n      }\n      return !1;\n    })(n, c, p.completionText)\n  ) {\n    const t = i.TelemetryData.createAndMarkAsIssued();\n    t.extendWithRequestId(l.requestId);\n    i.telemetry(e, \"completion.alreadyInDocument\", t);\n    i.telemetry(\n      e,\n      \"completion.alreadyInDocument\",\n      t.extendedBy({\n        completionTextJson: JSON.stringify(p.completionText),\n      }),\n      !0\n    );\n    return void d.info(e, \"Filtered out solution matching next line\");\n  }\n  p.completionText = await (async function (e, t, n, r, i) {\n    var a;\n    if (\"\" === r) return r;\n    let c = \"}\";\n    try {\n      c =\n        null !== (a = o.getBlockCloseToken(t.languageId)) && undefined !== a\n          ? a\n          : \"}\";\n    } catch (e) {}\n    let l = r.length;\n    do {\n      const o = r.lastIndexOf(\"\\n\", l - 2) + 1,\n        a = r.substring(o, l);\n      if (a.trim() === c) {\n        for (let e = n.line; e < t.lineCount; e++) {\n          let s = t.lineAt(e).text;\n          if (e === n.line) {\n            s = s.substr(n.character);\n          }\n          if (s.startsWith(a.trimRight()))\n            return r.substring(0, Math.max(0, i ? o : o - 1));\n          if (\"\" !== s.trim()) break;\n        }\n        break;\n      }\n      if (l === o) {\n        if (s.shouldFailForDebugPurposes(e))\n          throw Error(\n            `Aborting: maybeSnipCompletion would have looped on completion: ${r}`\n          );\n        break;\n      }\n      l = o;\n    } while (l > 1);\n    return r;\n  })(e, n, c, p.completionText, u);\n  return p.completionText ? p : undefined;\n};\nexports.checkSuffix = function (e, t, n) {\n  const r = e.lineAt(t.line).text.substring(t.character);\n  if (r.length > 0) {\n    if (-1 !== n.completionText.indexOf(r)) return !0;\n    {\n      let e = 0;\n      for (const t of r) {\n        const r = n.completionText.indexOf(t, e + 1);\n        if (!(r > e)) {\n          e = -1;\n          break;\n        }\n        e = r;\n      }\n      return -1 !== e;\n    }\n  }\n  return !1;\n};",
  "1125": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(6776),\n  o = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code(e) {\n      const { gen: t, schema: n, it: o } = e;\n      if (!Array.isArray(n)) throw new Error(\"ajv implementation error\");\n      const i = t.name(\"valid\");\n      n.forEach((t, n) => {\n        if (r.alwaysValidSchema(o, t)) return;\n        const s = e.subschema(\n          {\n            keyword: \"allOf\",\n            schemaProp: n,\n          },\n          i\n        );\n        e.ok(i);\n        e.mergeEvaluated(s);\n      });\n    },\n  };\nexports.default = o;",
  "1133": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.editorVersionHeaders =\n  exports.EditorAndPluginInfo =\n  exports.formatNameAndVersion =\n  exports.getTestVscInfo =\n  exports.VscInfo =\n  exports.getVersion =\n  exports.getBuild =\n  exports.getBuildType =\n  exports.isProduction =\n  exports.BuildInfo =\n  exports.fimSuffixLengthThreshold =\n  exports.suffixMatchThreshold =\n  exports.suffixPercent =\n  exports.getEnabledConfig =\n  exports.getLanguageConfig =\n  exports.dumpConfig =\n  exports.getHiddenConfig =\n  exports.isDefaultSettingOverwritten =\n  exports.getConfig =\n  exports.getConfigDefaultForObjectKey =\n  exports.getConfigDefaultForKey =\n  exports.InMemoryConfigProvider =\n  exports.DefaultsOnlyConfigProvider =\n  exports.ConfigProvider =\n  exports.ConfigBlockModeConfig =\n  exports.BlockModeConfig =\n  exports.BuildType =\n  exports.shouldDoServerTrimming =\n  exports.shouldDoParsingTrimming =\n  exports.BlockMode =\n  exports.ConfigKey =\n    undefined;\nconst r = require(3055563),\n  o = require(4197),\n  i = require(9189),\n  s = require(4147);\nvar a, c;\nexports.ConfigKey = {\n  Enable: \"enable\",\n  InlineSuggestEnable: \"inlineSuggest.enable\",\n  ShowEditorCompletions: [\"editor\", \"showEditorCompletions\"],\n  EnableAutoCompletions: [\"editor\", \"enableAutoCompletions\"],\n  DelayCompletions: [\"editor\", \"delayCompletions\"],\n  FilterCompletions: [\"editor\", \"filterCompletions\"],\n  DisplayStyle: [\"advanced\", \"displayStyle\"],\n  SecretKey: [\"advanced\", \"secret_key\"],\n  SolutionLength: [\"advanced\", \"length\"],\n  Stops: [\"advanced\", \"stops\"],\n  Temperature: [\"advanced\", \"temperature\"],\n  TopP: [\"advanced\", \"top_p\"],\n  IndentationMode: [\"advanced\", \"indentationMode\"],\n  InlineSuggestCount: [\"advanced\", \"inlineSuggestCount\"],\n  ListCount: [\"advanced\", \"listCount\"],\n  DebugOverrideProxyUrl: [\"advanced\", \"debug.overrideProxyUrl\"],\n  DebugTestOverrideProxyUrl: [\"advanced\", \"debug.testOverrideProxyUrl\"],\n  DebugOverrideEngine: [\"advanced\", \"debug.overrideEngine\"],\n  DebugShowScores: [\"advanced\", \"debug.showScores\"],\n  DebugOverrideLogLevels: [\"advanced\", \"debug.overrideLogLevels\"],\n  DebugFilterLogCategories: [\"advanced\", \"debug.filterLogCategories\"],\n  DebugUseSuffix: [\"advanced\", \"debug.useSuffix\"],\n};\n(function (e) {\n  e.Parsing = \"parsing\";\n  e.Server = \"server\";\n  e.ParsingAndServer = \"parsingandserver\";\n})((a = exports.BlockMode || (exports.BlockMode = {})));\nexports.shouldDoParsingTrimming = function (e) {\n  return [a.Parsing, a.ParsingAndServer].includes(e);\n};\nexports.shouldDoServerTrimming = function (e) {\n  return [a.Server, a.ParsingAndServer].includes(e);\n};\n(c = exports.BuildType || (exports.BuildType = {})).DEV = \"dev\";\nc.PROD = \"prod\";\nc.NIGHTLY = \"nightly\";\nclass BlockModeConfig {}\nfunction u(e, t) {\n  return e !== a.ParsingAndServer || r.isSupportedLanguageId(t) ? e : a.Server;\n}\nexports.BlockModeConfig = BlockModeConfig;\nexports.ConfigBlockModeConfig = class extends BlockModeConfig {\n  async forLanguage(e, n) {\n    if (\n      e\n        .get(ConfigProvider)\n        .isDefaultSettingOverwritten(exports.ConfigKey.IndentationMode)\n    )\n      switch (\n        e\n          .get(ConfigProvider)\n          .getLanguageConfig(exports.ConfigKey.IndentationMode, n)\n      ) {\n        case \"client\":\n        case !0:\n        case \"server\":\n          return a.Server;\n        case \"clientandserver\":\n          return u(a.ParsingAndServer, n);\n        default:\n          return a.Parsing;\n      }\n    const o = await e.get(i.Features).overrideBlockMode();\n    return o ? u(o, n) : r.isSupportedLanguageId(n) ? a.Parsing : a.Server;\n  }\n};\nclass ConfigProvider {}\nfunction getConfigDefaultForKey(e) {\n  try {\n    const t =\n      s.contributes.configuration[0].properties[`${o.CopilotConfigPrefix}.${e}`]\n        .default;\n    if (undefined === t)\n      throw new Error(\n        `Missing config default value: ${o.CopilotConfigPrefix}.${e}`\n      );\n    return t;\n  } catch (t) {\n    throw new Error(\n      `Error inspecting config default value ${o.CopilotConfigPrefix}.${e}: ${t}`\n    );\n  }\n}\nfunction getConfigDefaultForObjectKey(e, t) {\n  try {\n    const n =\n      s.contributes.configuration[0].properties[`${o.CopilotConfigPrefix}.${e}`]\n        .properties[t].default;\n    if (undefined === n)\n      throw new Error(\n        `Missing config default value: ${o.CopilotConfigPrefix}.${e}`\n      );\n    return n;\n  } catch (n) {\n    throw new Error(\n      `Error inspecting config default value ${o.CopilotConfigPrefix}.${e}.${t}: ${n}`\n    );\n  }\n}\nfunction getConfig(e, t) {\n  return e.get(ConfigProvider).getConfig(t);\n}\nfunction isDefaultSettingOverwritten(e, t) {\n  return e.get(ConfigProvider).isDefaultSettingOverwritten(t);\n}\nfunction getHiddenConfig(e, t, n) {\n  return isDefaultSettingOverwritten(e, t) ? getConfig(e, t) : n.default;\n}\nfunction getLanguageConfig(e, t, n) {\n  return e.get(ConfigProvider).getLanguageConfig(t, n);\n}\nexports.ConfigProvider = ConfigProvider;\nexports.DefaultsOnlyConfigProvider = class extends ConfigProvider {\n  getConfig(e) {\n    return Array.isArray(e)\n      ? getConfigDefaultForObjectKey(e[0], e[1])\n      : getConfigDefaultForKey(e);\n  }\n  isDefaultSettingOverwritten(e) {\n    return !1;\n  }\n  dumpConfig() {\n    return {};\n  }\n  getLanguageConfig(e, t) {\n    const n = this.getConfig(e);\n    return t && t in n ? n[t] : n[\"*\"];\n  }\n};\nexports.InMemoryConfigProvider = class {\n  constructor(e, t) {\n    this.baseConfigProvider = e;\n    this.overrides = t;\n  }\n  getConfig(e) {\n    const t = this.overrides.get(e);\n    return undefined !== t ? t : this.baseConfigProvider.getConfig(e);\n  }\n  setConfig(e, t) {\n    if (undefined !== t) {\n      this.overrides.set(e, t);\n    } else {\n      this.overrides.delete(e);\n    }\n  }\n  setLanguageEnablement(e, n) {\n    this.overrides.set(exports.ConfigKey.Enable, {\n      [e]: n,\n    });\n  }\n  isDefaultSettingOverwritten(e) {\n    return (\n      !!this.overrides.has(e) ||\n      this.baseConfigProvider.isDefaultSettingOverwritten(e)\n    );\n  }\n  keyAsString(e) {\n    return Array.isArray(e) ? e.join(\".\") : e;\n  }\n  dumpConfig() {\n    const e = this.baseConfigProvider.dumpConfig();\n    this.overrides.forEach((t, n) => {\n      e[this.keyAsString(n)] = JSON.stringify(t);\n    });\n    return e;\n  }\n  getLanguageConfig(e, t) {\n    const n = this.overrides.get(e);\n    return undefined !== n\n      ? undefined !== t\n        ? n[t]\n        : n[\"*\"]\n      : this.baseConfigProvider.getLanguageConfig(e, t);\n  }\n};\nexports.getConfigDefaultForKey = getConfigDefaultForKey;\nexports.getConfigDefaultForObjectKey = getConfigDefaultForObjectKey;\nexports.getConfig = getConfig;\nexports.isDefaultSettingOverwritten = isDefaultSettingOverwritten;\nexports.getHiddenConfig = getHiddenConfig;\nexports.dumpConfig = function (e) {\n  return e.get(ConfigProvider).dumpConfig();\n};\nexports.getLanguageConfig = getLanguageConfig;\nexports.getEnabledConfig = function (e, n) {\n  return getLanguageConfig(e, exports.ConfigKey.Enable, n);\n};\nexports.suffixPercent = async function (e, n, r) {\n  return getHiddenConfig(e, exports.ConfigKey.DebugUseSuffix, {\n    default: !1,\n  })\n    ? 15\n    : e.get(i.Features).suffixPercent(n, r);\n};\nexports.suffixMatchThreshold = async function (e, n, r) {\n  return getHiddenConfig(e, exports.ConfigKey.DebugUseSuffix, {\n    default: !1,\n  })\n    ? 0\n    : e.get(i.Features).suffixMatchThreshold(n, r);\n};\nexports.fimSuffixLengthThreshold = async function (e, n, r) {\n  return getHiddenConfig(e, exports.ConfigKey.DebugUseSuffix, {\n    default: !1,\n  })\n    ? -1\n    : e.get(i.Features).fimSuffixLengthThreshold(n, r);\n};\nclass BuildInfo {\n  constructor() {\n    this.packageJson = s;\n  }\n  isProduction() {\n    return \"dev\" != this.getBuildType();\n  }\n  getBuildType() {\n    return this.packageJson.buildType;\n  }\n  getVersion() {\n    return this.packageJson.version;\n  }\n  getBuild() {\n    return this.packageJson.build;\n  }\n  getName() {\n    return this.packageJson.name;\n  }\n}\nexports.BuildInfo = BuildInfo;\nexports.isProduction = function (e) {\n  return e.get(BuildInfo).isProduction();\n};\nexports.getBuildType = function (e) {\n  return e.get(BuildInfo).getBuildType();\n};\nexports.getBuild = function (e) {\n  return e.get(BuildInfo).getBuild();\n};\nexports.getVersion = function (e) {\n  return e.get(BuildInfo).getVersion();\n};\nclass VscInfo {\n  constructor(e, t, n) {\n    this.sessionId = e;\n    this.machineId = t;\n    this.vsCodeVersion = n;\n  }\n}\nfunction formatNameAndVersion({ name: e, version: t }) {\n  return `${e}/${t}`;\n}\nexports.VscInfo = VscInfo;\nexports.getTestVscInfo = function () {\n  return new VscInfo(\n    \"test-session-id\",\n    \"test-machine-id\",\n    \"test-vscode-version\"\n  );\n};\nexports.formatNameAndVersion = formatNameAndVersion;\nclass EditorAndPluginInfo {}\nexports.EditorAndPluginInfo = EditorAndPluginInfo;\nexports.editorVersionHeaders = function (e) {\n  const t = e.get(EditorAndPluginInfo);\n  return {\n    \"Editor-Version\": formatNameAndVersion(t.getEditorInfo(e)),\n    \"Editor-Plugin-Version\": formatNameAndVersion(t.getEditorPluginInfo(e)),\n  };\n};",
  "1148": "var r, o;\no = require(8249);\nrequire(5109);\n(r = o.lib.BlockCipherMode.extend()).Encryptor = r.extend({\n  processBlock: function (e, t) {\n    this._cipher.encryptBlock(e, t);\n  },\n});\nr.Decryptor = r.extend({\n  processBlock: function (e, t) {\n    this._cipher.decryptBlock(e, t);\n  },\n});\no.mode.ECB = r;\nmodule.exports = o.mode.ECB;",
  "1188": "var r = require(2728);\nfunction H() {\n  this._array = [];\n  this._sorted = !0;\n  this._last = {\n    generatedLine: -1,\n    generatedColumn: 0,\n  };\n}\nH.prototype.unsortedForEach = function (e, t) {\n  this._array.forEach(e, t);\n};\nH.prototype.add = function (e) {\n  var t, n, o, i, s, a;\n  n = e;\n  o = (t = this._last).generatedLine;\n  i = n.generatedLine;\n  s = t.generatedColumn;\n  a = n.generatedColumn;\n  if (\n    i > o ||\n    (i == o && a >= s) ||\n    r.compareByGeneratedPositionsInflated(t, n) <= 0\n  ) {\n    this._last = e;\n    this._array.push(e);\n  } else {\n    this._sorted = !1;\n    this._array.push(e);\n  }\n};\nH.prototype.toArray = function () {\n  if (this._sorted) {\n    this._array.sort(r.compareByGeneratedPositionsInflated);\n    this._sorted = !0;\n  }\n  return this._array;\n};\nexports.H = H;",
  "1227": "var r = require(4953),\n  o = [];\nexports.qP = function (e) {\n  o.forEach(function (t) {\n    var n = e.data.query,\n      r =\n        (n.preparable && n.preparable.text) ||\n        n.plan ||\n        n.text ||\n        \"unknown query\",\n      o = !e.data.error,\n      i = e.data.database.host + \":\" + e.data.database.port;\n    t.trackDependency({\n      target: i,\n      data: r,\n      name: r,\n      duration: e.data.duration,\n      success: o,\n      resultCode: o ? \"0\" : \"1\",\n      dependencyTypeName: \"postgres\",\n    });\n  });\n};\nexports.wp = function (e, n) {\n  if (e) {\n    if (0 === o.length) {\n      r.channel.subscribe(\"postgres\", exports.qP);\n    }\n    o.push(n);\n  } else {\n    if (\n      0 ===\n      (o = o.filter(function (e) {\n        return e != n;\n      })).length\n    ) {\n      r.channel.unsubscribe(\"postgres\", exports.qP);\n    }\n  }\n};",
  "1240": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = require(9306),\n  i = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: {\n      message: ({ params: { discrError: e, tagName: t } }) =>\n        e === o.DiscrError.Tag\n          ? `tag \"${t}\" must be string`\n          : `value of tag \"${t}\" must be in oneOf`,\n      params: ({ params: { discrError: e, tag: t, tagName: n } }) =>\n        r._`{error: ${e}, tag: ${n}, tagValue: ${t}}`,\n    },\n    code(e) {\n      const { gen: t, data: n, schema: i, parentSchema: s, it: a } = e,\n        { oneOf: c } = s;\n      if (!a.opts.discriminator)\n        throw new Error(\"discriminator: requires discriminator option\");\n      const l = i.propertyName;\n      if (\"string\" != typeof l)\n        throw new Error(\"discriminator: requires propertyName\");\n      if (i.mapping) throw new Error(\"discriminator: mapping is not supported\");\n      if (!c) throw new Error(\"discriminator: requires oneOf keyword\");\n      const u = t.let(\"valid\", !1),\n        d = t.const(\"tag\", r._`${n}${r.getProperty(l)}`);\n      function p(n) {\n        const o = t.name(\"valid\"),\n          i = e.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: n,\n            },\n            o\n          );\n        e.mergeEvaluated(i, r.Name);\n        return o;\n      }\n      t.if(\n        r._`typeof ${d} == \"string\"`,\n        () =>\n          (function () {\n            const n = (function () {\n              var e;\n              const t = {},\n                n = o(s);\n              let r = !0;\n              for (let t = 0; t < c.length; t++) {\n                const s = c[t],\n                  a =\n                    null === (e = s.properties) || undefined === e\n                      ? undefined\n                      : e[l];\n                if (\"object\" != typeof a)\n                  throw new Error(\n                    `discriminator: oneOf schemas must have \"properties/${l}\"`\n                  );\n                r = r && (n || o(s));\n                i(a, t);\n              }\n              if (!r) throw new Error(`discriminator: \"${l}\" must be required`);\n              return t;\n              function o({ required: e }) {\n                return Array.isArray(e) && e.includes(l);\n              }\n              function i(e, t) {\n                if (e.const) a(e.const, t);\n                else {\n                  if (!e.enum)\n                    throw new Error(\n                      `discriminator: \"properties/${l}\" must have \"const\" or \"enum\"`\n                    );\n                  for (const n of e.enum) a(n, t);\n                }\n              }\n              function a(e, n) {\n                if (\"string\" != typeof e || e in t)\n                  throw new Error(\n                    `discriminator: \"${l}\" values must be unique strings`\n                  );\n                t[e] = n;\n              }\n            })();\n            t.if(!1);\n            for (const e in n) {\n              t.elseIf(r._`${d} === ${e}`);\n              t.assign(u, p(n[e]));\n            }\n            t.else();\n            e.error(!1, {\n              discrError: o.DiscrError.Mapping,\n              tag: d,\n              tagName: l,\n            });\n            t.endIf();\n          })(),\n        () =>\n          e.error(!1, {\n            discrError: o.DiscrError.Tag,\n            tag: d,\n            tagName: l,\n          })\n      );\n      e.ok(u);\n    },\n  };\nexports.default = i;",
  "1259": "var r,\n  o =\n    (this && this.__extends) ||\n    ((r =\n      Object.setPrototypeOf ||\n      ({\n        __proto__: [],\n      } instanceof Array &&\n        function (e, t) {\n          e.__proto__ = t;\n        }) ||\n      function (e, t) {\n        for (var n in t)\n          if (t.hasOwnProperty(n)) {\n            e[n] = t[n];\n          }\n      }),\n    function (e, t) {\n      function n() {\n        this.constructor = e;\n      }\n      r(e, t);\n      e.prototype =\n        null === t ? Object.create(t) : ((n.prototype = t.prototype), new n());\n    }),\n  i = require(7625),\n  s = require(731),\n  a = require(8723),\n  c = require(5282),\n  l = (function (e) {\n    function t() {\n      return (null !== e && e.apply(this, arguments)) || this;\n    }\n    o(t, e);\n    t.prototype.trackNodeHttpRequestSync = function (e) {\n      if (e && e.request && e.response && e.duration) {\n        s.trackRequestSync(this, e);\n      } else {\n        c.warn(\n          \"trackNodeHttpRequestSync requires NodeHttpRequestTelemetry object with request, response and duration specified.\"\n        );\n      }\n    };\n    t.prototype.trackNodeHttpRequest = function (e) {\n      if (e.duration || e.error) {\n        c.warn(\n          \"trackNodeHttpRequest will ignore supplied duration and error parameters. These values are collected from the request and response objects.\"\n        );\n      }\n      if (e && e.request && e.response) {\n        s.trackRequest(this, e);\n      } else {\n        c.warn(\n          \"trackNodeHttpRequest requires NodeHttpRequestTelemetry object with request and response specified.\"\n        );\n      }\n    };\n    t.prototype.trackNodeHttpDependency = function (e) {\n      if (e && e.request) {\n        a.trackRequest(this, e);\n      } else {\n        c.warn(\n          \"trackNodeHttpDependency requires NodeHttpDependencyTelemetry object with request specified.\"\n        );\n      }\n    };\n    return t;\n  })(i);\nmodule.exports = l;",
  "1354": "var r;\nr = require(8249);\nrequire(4938);\nrequire(2422);\nrequire(298);\nrequire(8269);\nrequire(8214);\nrequire(2783);\nrequire(2153);\nrequire(7792);\nrequire(34);\nrequire(7460);\nrequire(3327);\nrequire(706);\nrequire(9824);\nrequire(2112);\nrequire(888);\nrequire(5109);\nrequire(8568);\nrequire(4242);\nrequire(9968);\nrequire(7660);\nrequire(1148);\nrequire(3615);\nrequire(2807);\nrequire(1077);\nrequire(6475);\nrequire(6991);\nrequire(2209);\nrequire(452);\nrequire(4253);\nrequire(1857);\nrequire(4454);\nrequire(3974);\nmodule.exports = r;",
  "1547": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.NotificationSender = undefined;\nexports.NotificationSender = class {};",
  "1581": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.CodeGen =\n  exports.Name =\n  exports.nil =\n  exports.stringify =\n  exports.str =\n  exports._ =\n  exports.KeywordCxt =\n    undefined;\nconst r = require(7159),\n  o = require(3924),\n  i = require(1240),\n  s = require(98),\n  a = [\"/properties\"],\n  c = \"http://json-schema.org/draft-07/schema\";\nclass l extends r.default {\n  _addVocabularies() {\n    super._addVocabularies();\n    o.default.forEach((e) => this.addVocabulary(e));\n    if (this.opts.discriminator) {\n      this.addKeyword(i.default);\n    }\n  }\n  _addDefaultMetaSchema() {\n    super._addDefaultMetaSchema();\n    if (!this.opts.meta) return;\n    const e = this.opts.$data ? this.$dataMetaSchema(s, a) : s;\n    this.addMetaSchema(e, c, !1);\n    this.refs[\"http://json-schema.org/schema\"] = c;\n  }\n  defaultMeta() {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(c) ? c : undefined));\n  }\n}\nmodule.exports = exports = l;\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.default = l;\nvar u = require(4815);\nexports.KeywordCxt = u.KeywordCxt;\nvar d = require(3487);\nexports._ = d._;\nexports.str = d.str;\nexports.stringify = d.stringify;\nexports.nil = d.nil;\nexports.Name = d.Name;\nexports.CodeGen = d.CodeGen;",
  "1595": "const r = require(\"fs\");\nlet o;\nmodule.exports = () => (\n  undefined === o &&\n    (o =\n      (function () {\n        try {\n          r.statSync(\"/.dockerenv\");\n          return !0;\n        } catch (e) {\n          return !1;\n        }\n      })() ||\n      (function () {\n        try {\n          return r.readFileSync(\"/proc/self/cgroup\", \"utf8\").includes(\"docker\");\n        } catch (e) {\n          return !1;\n        }\n      })()),\n  o\n);",
  "1629": "var r =\n  (this && this.__assign) ||\n  Object.assign ||\n  function (e) {\n    for (var t, n = 1, r = arguments.length; n < r; n++)\n      for (var o in (t = arguments[n]))\n        if (Object.prototype.hasOwnProperty.call(t, o)) {\n          e[o] = t[o];\n        }\n    return e;\n  };\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar o = require(9253),\n  i = require(4470),\n  s = require(5282),\n  AutoCollectNativePerformance = (function () {\n    function e(t) {\n      this._disabledMetrics = {};\n      if (e.INSTANCE) {\n        e.INSTANCE.dispose();\n      }\n      e.INSTANCE = this;\n      this._client = t;\n    }\n    e.isNodeVersionCompatible = function () {\n      var e = process.versions.node.split(\".\");\n      return parseInt(e[0]) >= 6;\n    };\n    e.prototype.enable = function (t, r, o) {\n      var i = this;\n      if (undefined === r) {\n        r = {};\n      }\n      if (undefined === o) {\n        o = 6e4;\n      }\n      if (e.isNodeVersionCompatible()) {\n        if (null == e._metricsAvailable && t && !this._isInitialized)\n          try {\n            var a = require(\"applicationinsights-native-metrics\");\n            (e._emitter = new a()),\n              (e._metricsAvailable = !0),\n              s.info(\"Native metrics module successfully loaded!\");\n          } catch (t) {\n            return void (e._metricsAvailable = !1);\n          }\n        (this._isEnabled = t),\n          (this._disabledMetrics = r),\n          this._isEnabled && !this._isInitialized && (this._isInitialized = !0),\n          this._isEnabled && e._emitter\n            ? (e._emitter.enable(!0, o),\n              (this._handle = setInterval(function () {\n                return i._trackNativeMetrics();\n              }, o)),\n              this._handle.unref())\n            : e._emitter &&\n              (e._emitter.enable(!1),\n              this._handle &&\n                (clearInterval(this._handle), (this._handle = void 0)));\n      }\n    };\n    e.prototype.dispose = function () {\n      this.enable(!1);\n    };\n    e.parseEnabled = function (e) {\n      var t = process.env[o.ENV_nativeMetricsDisableAll],\n        n = process.env[o.ENV_nativeMetricsDisablers];\n      if (t)\n        return {\n          isEnabled: !1,\n          disabledMetrics: {},\n        };\n      if (n) {\n        var i = n.split(\",\"),\n          s = {};\n        if (i.length > 0)\n          for (var a = 0, c = i; a < c.length; a++) s[c[a]] = !0;\n        return \"object\" == typeof e\n          ? {\n              isEnabled: !0,\n              disabledMetrics: r({}, e, s),\n            }\n          : {\n              isEnabled: e,\n              disabledMetrics: s,\n            };\n      }\n      return \"boolean\" == typeof e\n        ? {\n            isEnabled: e,\n            disabledMetrics: {},\n          }\n        : {\n            isEnabled: !0,\n            disabledMetrics: e,\n          };\n    };\n    e.prototype._trackNativeMetrics = function () {\n      var e = !0;\n      if (\"object\" != typeof this._isEnabled) {\n        e = this._isEnabled;\n      }\n      if (e) {\n        this._trackGarbageCollection();\n        this._trackEventLoop();\n        this._trackHeapUsage();\n      }\n    };\n    e.prototype._trackGarbageCollection = function () {\n      if (!this._disabledMetrics.gc) {\n        var t,\n          n = e._emitter.getGCData();\n        for (var r in n) {\n          var o = n[r].metrics,\n            s = r + \" Garbage Collection Duration\",\n            a =\n              Math.sqrt(\n                o.sumSquares / o.count - Math.pow(o.total / o.count, 2)\n              ) || 0;\n          this._client.trackMetric({\n            name: s,\n            value: o.total,\n            count: o.count,\n            max: o.max,\n            min: o.min,\n            stdDev: a,\n            tagOverrides:\n              ((t = {}),\n              (t[this._client.context.keys.internalSdkVersion] =\n                \"node-nativeperf:\" + i.sdkVersion),\n              t),\n          });\n        }\n      }\n    };\n    e.prototype._trackEventLoop = function () {\n      if (!this._disabledMetrics.loop) {\n        var t = e._emitter.getLoopData().loopUsage;\n        if (0 != t.count) {\n          var n,\n            r =\n              Math.sqrt(\n                t.sumSquares / t.count - Math.pow(t.total / t.count, 2)\n              ) || 0;\n          this._client.trackMetric({\n            name: \"Event Loop CPU Time\",\n            value: t.total,\n            count: t.count,\n            min: t.min,\n            max: t.max,\n            stdDev: r,\n            tagOverrides:\n              ((n = {}),\n              (n[this._client.context.keys.internalSdkVersion] =\n                \"node-nativeperf:\" + i.sdkVersion),\n              n),\n          });\n        }\n      }\n    };\n    e.prototype._trackHeapUsage = function () {\n      if (!this._disabledMetrics.heap) {\n        var e,\n          t,\n          n,\n          r = process.memoryUsage(),\n          o = r.heapUsed,\n          s = r.heapTotal,\n          a = r.rss;\n        this._client.trackMetric({\n          name: \"Memory Usage (Heap)\",\n          value: o,\n          count: 1,\n          tagOverrides:\n            ((e = {}),\n            (e[this._client.context.keys.internalSdkVersion] =\n              \"node-nativeperf:\" + i.sdkVersion),\n            e),\n        });\n        this._client.trackMetric({\n          name: \"Memory Total (Heap)\",\n          value: s,\n          count: 1,\n          tagOverrides:\n            ((t = {}),\n            (t[this._client.context.keys.internalSdkVersion] =\n              \"node-nativeperf:\" + i.sdkVersion),\n            t),\n        });\n        this._client.trackMetric({\n          name: \"Memory Usage (Non-Heap)\",\n          value: a - s,\n          count: 1,\n          tagOverrides:\n            ((n = {}),\n            (n[this._client.context.keys.internalSdkVersion] =\n              \"node-nativeperf:\" + i.sdkVersion),\n            n),\n        });\n      }\n    };\n    return e;\n  })();\nexports.AutoCollectNativePerformance = AutoCollectNativePerformance;",
  "1687": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = {\n    keyword: [\"maxItems\", \"minItems\"],\n    type: \"array\",\n    schemaType: \"number\",\n    $data: !0,\n    error: {\n      message({ keyword: e, schemaCode: t }) {\n        const n = \"maxItems\" === e ? \"more\" : \"fewer\";\n        return r.str`must NOT have ${n} than ${t} items`;\n      },\n      params: ({ schemaCode: e }) => r._`{limit: ${e}}`,\n    },\n    code(e) {\n      const { keyword: t, data: n, schemaCode: o } = e,\n        i = \"maxItems\" === t ? r.operators.GT : r.operators.LT;\n      e.fail$data(r._`${n}.length ${i} ${o}`);\n    },\n  };\nexports.default = o;",
  "1747": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getPrompt =\n  exports.newLineEnded =\n  exports.normalizeLanguageId =\n  exports.PromptOptions =\n  exports.SuffixStartMode =\n  exports.SuffixMatchOption =\n  exports.SuffixOption =\n  exports.LineEndingOptions =\n  exports.LocalImportContextOption =\n  exports.SnippetSelectionOption =\n  exports.NeighboringTabsPositionOption =\n  exports.NeighboringTabsOption =\n  exports.SiblingOption =\n  exports.PathMarkerOption =\n  exports.LanguageMarkerOption =\n  exports.TOKENS_RESERVED_FOR_SUFFIX_ENCODING =\n  exports.MAX_EDIT_DISTANCE_LENGTH =\n  exports.MAX_PROMPT_LENGTH =\n    undefined;\nconst r = require(1788),\n  o = require(3507),\n  i = require(9931),\n  s = require(820),\n  a = require(9852),\n  c = require(7408),\n  l = require(4431);\nlet u = {\n  text: \"\",\n  tokens: [],\n};\nvar d, p, h, f, m, g, _, y, v, b, w;\nexports.MAX_PROMPT_LENGTH = 1500;\nexports.MAX_EDIT_DISTANCE_LENGTH = 50;\nexports.TOKENS_RESERVED_FOR_SUFFIX_ENCODING = 5;\n(function (e) {\n  e.NoMarker = \"nomarker\";\n  e.Top = \"top\";\n  e.Always = \"always\";\n})((d = exports.LanguageMarkerOption || (exports.LanguageMarkerOption = {})));\n(function (e) {\n  e.NoMarker = \"nomarker\";\n  e.Top = \"top\";\n  e.Always = \"always\";\n})((p = exports.PathMarkerOption || (exports.PathMarkerOption = {})));\n(function (e) {\n  e.NoSiblings = \"nosiblings\";\n  e.SiblingsOverContext = \"siblingabove\";\n  e.ContextOverSiblings = \"contextabove\";\n})((h = exports.SiblingOption || (exports.SiblingOption = {})));\n(function (e) {\n  e.None = \"none\";\n  e.Conservative = \"conservative\";\n  e.Medium = \"medium\";\n  e.Eager = \"eager\";\n  e.EagerButLittle = \"eagerButLittle\";\n})((f = exports.NeighboringTabsOption || (exports.NeighboringTabsOption = {})));\n(function (e) {\n  e.TopOfText = \"top\";\n  e.DirectlyAboveCursor = \"aboveCursor\";\n  e.AfterSiblings = \"afterSiblings\";\n})(\n  (m =\n    exports.NeighboringTabsPositionOption ||\n    (exports.NeighboringTabsPositionOption = {}))\n);\n(function (e) {\n  e.BestMatch = \"bestMatch\";\n  e.TopK = \"topK\";\n})(\n  (g = exports.SnippetSelectionOption || (exports.SnippetSelectionOption = {}))\n);\n(function (e) {\n  e.NoContext = \"nocontext\";\n  e.Declarations = \"declarations\";\n})(\n  (_ =\n    exports.LocalImportContextOption || (exports.LocalImportContextOption = {}))\n);\n(function (e) {\n  e.ConvertToUnix = \"unix\";\n  e.KeepOriginal = \"keep\";\n})((y = exports.LineEndingOptions || (exports.LineEndingOptions = {})));\n(w = exports.SuffixOption || (exports.SuffixOption = {})).None = \"none\";\nw.FifteenPercent = \"fifteenPercent\";\n(function (e) {\n  e.Equal = \"equal\";\n  e.Levenshtein = \"levenshteineditdistance\";\n})((v = exports.SuffixMatchOption || (exports.SuffixMatchOption = {})));\n(function (e) {\n  e.Cursor = \"cursor\";\n  e.CursorTrimStart = \"cursortrimstart\";\n  e.SiblingBlock = \"siblingblock\";\n  e.SiblingBlockTrimStart = \"siblingblocktrimstart\";\n})((b = exports.SuffixStartMode || (exports.SuffixStartMode = {})));\nclass PromptOptions {\n  constructor(e, n) {\n    this.fs = e;\n    this.maxPromptLength = exports.MAX_PROMPT_LENGTH;\n    this.languageMarker = d.Top;\n    this.pathMarker = p.Top;\n    this.includeSiblingFunctions = h.ContextOverSiblings;\n    this.localImportContext = _.Declarations;\n    this.neighboringTabs = f.Eager;\n    this.neighboringTabsPosition = m.TopOfText;\n    this.lineEnding = y.ConvertToUnix;\n    this.suffixPercent = 0;\n    this.suffixStartMode = b.Cursor;\n    this.suffixMatchThreshold = 0;\n    this.suffixMatchCriteria = v.Levenshtein;\n    this.fimSuffixLengthThreshold = 0;\n    if (n) for (const e in n) this[e] = n[e];\n    if (this.suffixPercent < 0 || this.suffixPercent > 100)\n      throw new Error(\n        `suffixPercent must be between 0 and 100, but was ${this.suffixPercent}`\n      );\n    if (this.suffixPercent > 0 && this.includeSiblingFunctions != h.NoSiblings)\n      throw new Error(\n        `Invalid option combination. Cannot set suffixPercent > 0 (${this.suffixPercent}) and includeSiblingFunctions ${this.includeSiblingFunctions}`\n      );\n    if (this.suffixMatchThreshold < 0 || this.suffixMatchThreshold > 100)\n      throw new Error(\n        `suffixMatchThreshold must be at between 0 and 100, but was ${this.suffixMatchThreshold}`\n      );\n    if (this.fimSuffixLengthThreshold < -1)\n      throw new Error(\n        `fimSuffixLengthThreshold must be at least -1, but was ${this.fimSuffixLengthThreshold}`\n      );\n    if (\n      null != this.indentationMinLength &&\n      null != this.indentationMaxLength &&\n      this.indentationMinLength > this.indentationMaxLength\n    )\n      throw new Error(\n        `indentationMinLength must be less than or equal to indentationMaxLength, but was ${this.indentationMinLength} and ${this.indentationMaxLength}`\n      );\n    if (\n      this.snippetSelection === g.TopK &&\n      undefined === this.snippetSelectionK\n    )\n      throw new Error(\"snippetSelectionK must be defined.\");\n    if (\n      this.snippetSelection === g.TopK &&\n      this.snippetSelectionK &&\n      this.snippetSelectionK <= 0\n    )\n      throw new Error(\n        `snippetSelectionK must be greater than 0, but was ${this.snippetSelectionK}`\n      );\n  }\n}\nexports.PromptOptions = PromptOptions;\nconst E = {\n  javascriptreact: \"javascript\",\n  jsx: \"javascript\",\n  typescriptreact: \"typescript\",\n  jade: \"pug\",\n  cshtml: \"razor\",\n};\nfunction normalizeLanguageId(e) {\n  var t;\n  e = e.toLowerCase();\n  return null !== (t = E[e]) && undefined !== t ? t : e;\n}\nfunction newLineEnded(e) {\n  return \"\" == e || e.endsWith(\"\\n\") ? e : e + \"\\n\";\n}\nexports.normalizeLanguageId = normalizeLanguageId;\nexports.newLineEnded = newLineEnded;\nexports.getPrompt = async function (e, n, g = {}, y = []) {\n  var w;\n  const E = new PromptOptions(e, g);\n  let T = !1;\n  const { source: k, offset: I } = n;\n  if (I < 0 || I > k.length) throw new Error(`Offset ${I} is out of range.`);\n  n.languageId = normalizeLanguageId(n.languageId);\n  const P = new c.Priorities(),\n    A = P.justBelow(c.Priorities.TOP),\n    O =\n      E.languageMarker == d.Always\n        ? P.justBelow(c.Priorities.TOP)\n        : P.justBelow(A),\n    N =\n      E.pathMarker == p.Always ? P.justBelow(c.Priorities.TOP) : P.justBelow(A),\n    R =\n      E.includeSiblingFunctions == h.ContextOverSiblings\n        ? P.justBelow(A)\n        : P.justAbove(A),\n    M = P.justBelow(A, R),\n    L = P.justBelow(M),\n    $ = new c.PromptWishlist(E.lineEnding);\n  let D, F;\n  if (E.languageMarker != d.NoMarker) {\n    const e = newLineEnded(r.getLanguageMarker(n));\n    D = $.append(e, c.PromptElementKind.LanguageMarker, O);\n  }\n  if (E.pathMarker != p.NoMarker) {\n    const e = newLineEnded(r.getPathMarker(n));\n    if (e.length > 0) {\n      F = $.append(e, c.PromptElementKind.PathMarker, N);\n    }\n  }\n  if (E.localImportContext != _.NoContext)\n    for (const e of await o.extractLocalImportContext(n, E.fs))\n      $.append(newLineEnded(e), c.PromptElementKind.ImportedFile, M);\n  const j =\n    E.neighboringTabs == f.None || 0 == y.length\n      ? []\n      : await i.getNeighborSnippets(\n          n,\n          y,\n          E.neighboringTabs,\n          E.indentationMinLength,\n          E.indentationMaxLength,\n          E.snippetSelectionOption,\n          E.snippetSelectionK\n        );\n  function q() {\n    j.forEach((e) =>\n      $.append(\n        e.snippet,\n        c.PromptElementKind.SimilarFile,\n        L,\n        a.tokenLength(e.snippet),\n        e.score\n      )\n    );\n  }\n  if (E.neighboringTabsPosition == m.TopOfText) {\n    q();\n  }\n  const B = [];\n  let U;\n  if (E.includeSiblingFunctions == h.NoSiblings) U = k.substring(0, I);\n  else {\n    const {\n      siblings: e,\n      beforeInsertion: t,\n      afterInsertion: r,\n    } = await s.getSiblingFunctions(n);\n    $.appendLineForLine(t, c.PromptElementKind.BeforeCursor, A).forEach((e) =>\n      B.push(e)\n    );\n    let o = R;\n    e.forEach((e) => {\n      $.append(e, c.PromptElementKind.AfterCursor, o);\n      o = P.justBelow(o);\n    });\n    if (E.neighboringTabsPosition == m.AfterSiblings) {\n      q();\n    }\n    U = r;\n  }\n  if (E.neighboringTabsPosition == m.DirectlyAboveCursor) {\n    const e = U.lastIndexOf(\"\\n\") + 1,\n      t = U.substring(0, e),\n      n = U.substring(e);\n    $.appendLineForLine(t, c.PromptElementKind.BeforeCursor, A).forEach((e) =>\n      B.push(e)\n    );\n    q();\n    if (n.length > 0) {\n      B.push($.append(n, c.PromptElementKind.AfterCursor, A));\n      if (B.length > 1) {\n        $.require(B[B.length - 2], B[B.length - 1]);\n      }\n    }\n  } else\n    $.appendLineForLine(U, c.PromptElementKind.BeforeCursor, A).forEach((e) =>\n      B.push(e)\n    );\n  if (d.Top == E.languageMarker && B.length > 0 && undefined !== D) {\n    $.require(D, B[0]);\n  }\n  if (p.Top == E.pathMarker && B.length > 0 && undefined !== F) {\n    if (D) {\n      $.require(F, D);\n    } else {\n      $.require(F, B[0]);\n    }\n  }\n  if (undefined !== D && undefined !== F) {\n    $.exclude(F, D);\n  }\n  let H = k.slice(I);\n  if (0 == E.suffixPercent || H.length <= E.fimSuffixLengthThreshold)\n    return $.fulfill(E.maxPromptLength);\n  {\n    let e = n.offset;\n    if (\n      E.suffixStartMode !== b.Cursor &&\n      E.suffixStartMode !== b.CursorTrimStart\n    ) {\n      e = await s.getSiblingFunctionStart(n);\n    }\n    const r = E.maxPromptLength - exports.TOKENS_RESERVED_FOR_SUFFIX_ENCODING;\n    let o = Math.floor((r * (100 - E.suffixPercent)) / 100),\n      i = $.fulfill(o);\n    const c = r - i.prefixLength;\n    let d = k.slice(e);\n    if (\n      E.suffixStartMode != b.SiblingBlockTrimStart &&\n      E.suffixStartMode != b.CursorTrimStart\n    ) {\n      d = d.trimStart();\n    }\n    const p = a.takeFirstTokens(d, c);\n    if (p.tokens.length <= c - 3) {\n      o = r - p.tokens.length;\n      i = $.fulfill(o);\n    }\n    if (E.suffixMatchCriteria == v.Equal) {\n      if (\n        p.tokens.length === u.tokens.length &&\n        p.tokens.every((e, t) => e === u.tokens[t])\n      ) {\n        T = !0;\n      }\n    } else {\n      if (\n        E.suffixMatchCriteria == v.Levenshtein &&\n        p.tokens.length > 0 &&\n        E.suffixMatchThreshold > 0 &&\n        100 *\n          (null ===\n            (w = l.findEditDistanceScore(\n              p.tokens.slice(0, exports.MAX_EDIT_DISTANCE_LENGTH),\n              u.tokens.slice(0, exports.MAX_EDIT_DISTANCE_LENGTH)\n            )) || undefined === w\n            ? undefined\n            : w.score) <\n          E.suffixMatchThreshold *\n            Math.min(exports.MAX_EDIT_DISTANCE_LENGTH, p.tokens.length)\n      ) {\n        T = !0;\n      }\n    }\n    if (!0 === T && u.tokens.length <= c) {\n      if (u.tokens.length <= c - 3) {\n        o = r - u.tokens.length;\n        i = $.fulfill(o);\n      }\n      i.suffix = u.text;\n      i.suffixLength = u.tokens.length;\n    } else {\n      i.suffix = p.text;\n      i.suffixLength = p.tokens.length;\n      u = p;\n    }\n    return i;\n  }\n};",
  "1758": "exports.formatArgs = function (t) {\n  t[0] =\n    (this.useColors ? \"%c\" : \"\") +\n    this.namespace +\n    (this.useColors ? \" %c\" : \" \") +\n    t[0] +\n    (this.useColors ? \"%c \" : \" \") +\n    \"+\" +\n    module.exports.humanize(this.diff);\n  if (!this.useColors) return;\n  const n = \"color: \" + this.color;\n  t.splice(1, 0, n, \"color: inherit\");\n  let r = 0,\n    o = 0;\n  t[0].replace(/%[a-zA-Z%]/g, (e) => {\n    if (\"%%\" !== e) {\n      r++;\n      if (\"%c\" === e) {\n        o = r;\n      }\n    }\n  });\n  t.splice(o, 0, n);\n};\nexports.save = function (e) {\n  try {\n    if (e) {\n      exports.storage.setItem(\"debug\", e);\n    } else {\n      exports.storage.removeItem(\"debug\");\n    }\n  } catch (e) {}\n};\nexports.load = function () {\n  let e;\n  try {\n    e = exports.storage.getItem(\"debug\");\n  } catch (e) {}\n  if (!e && \"undefined\" != typeof process && \"env\" in process) {\n    e = process.env.DEBUG;\n  }\n  return e;\n};\nexports.useColors = function () {\n  return (\n    !(\n      \"undefined\" == typeof window ||\n      !window.process ||\n      (\"renderer\" !== window.process.type && !window.process.__nwjs)\n    ) ||\n    ((\"undefined\" == typeof navigator ||\n      !navigator.userAgent ||\n      !navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) &&\n      ((\"undefined\" != typeof document &&\n        document.documentElement &&\n        document.documentElement.style &&\n        document.documentElement.style.WebkitAppearance) ||\n        (\"undefined\" != typeof window &&\n          window.console &&\n          (window.console.firebug ||\n            (window.console.exception && window.console.table))) ||\n        (\"undefined\" != typeof navigator &&\n          navigator.userAgent &&\n          navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) &&\n          parseInt(RegExp.$1, 10) >= 31) ||\n        (\"undefined\" != typeof navigator &&\n          navigator.userAgent &&\n          navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/))))\n  );\n};\nexports.storage = (function () {\n  try {\n    return localStorage;\n  } catch (e) {}\n})();\nexports.destroy = (() => {\n  let e = !1;\n  return () => {\n    if (e) {\n      e = !0;\n      console.warn(\n        \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"\n      );\n    }\n  };\n})();\nexports.colors = [\n  \"#0000CC\",\n  \"#0000FF\",\n  \"#0033CC\",\n  \"#0033FF\",\n  \"#0066CC\",\n  \"#0066FF\",\n  \"#0099CC\",\n  \"#0099FF\",\n  \"#00CC00\",\n  \"#00CC33\",\n  \"#00CC66\",\n  \"#00CC99\",\n  \"#00CCCC\",\n  \"#00CCFF\",\n  \"#3300CC\",\n  \"#3300FF\",\n  \"#3333CC\",\n  \"#3333FF\",\n  \"#3366CC\",\n  \"#3366FF\",\n  \"#3399CC\",\n  \"#3399FF\",\n  \"#33CC00\",\n  \"#33CC33\",\n  \"#33CC66\",\n  \"#33CC99\",\n  \"#33CCCC\",\n  \"#33CCFF\",\n  \"#6600CC\",\n  \"#6600FF\",\n  \"#6633CC\",\n  \"#6633FF\",\n  \"#66CC00\",\n  \"#66CC33\",\n  \"#9900CC\",\n  \"#9900FF\",\n  \"#9933CC\",\n  \"#9933FF\",\n  \"#99CC00\",\n  \"#99CC33\",\n  \"#CC0000\",\n  \"#CC0033\",\n  \"#CC0066\",\n  \"#CC0099\",\n  \"#CC00CC\",\n  \"#CC00FF\",\n  \"#CC3300\",\n  \"#CC3333\",\n  \"#CC3366\",\n  \"#CC3399\",\n  \"#CC33CC\",\n  \"#CC33FF\",\n  \"#CC6600\",\n  \"#CC6633\",\n  \"#CC9900\",\n  \"#CC9933\",\n  \"#CCCC00\",\n  \"#CCCC33\",\n  \"#FF0000\",\n  \"#FF0033\",\n  \"#FF0066\",\n  \"#FF0099\",\n  \"#FF00CC\",\n  \"#FF00FF\",\n  \"#FF3300\",\n  \"#FF3333\",\n  \"#FF3366\",\n  \"#FF3399\",\n  \"#FF33CC\",\n  \"#FF33FF\",\n  \"#FF6600\",\n  \"#FF6633\",\n  \"#FF9900\",\n  \"#FF9933\",\n  \"#FFCC00\",\n  \"#FFCC33\",\n];\nexports.log = console.debug || console.log || (() => {});\nmodule.exports = require(2447)(exports);\nconst { formatters: r } = module.exports;\nr.j = function (e) {\n  try {\n    return JSON.stringify(e);\n  } catch (e) {\n    return \"[UnexpectedJSONParseError]: \" + e.message;\n  }\n};",
  "1787": "class t extends Error {\n  get name() {\n    return this.constructor.name;\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\nmodule.exports = {\n  RequestAbortedError: t,\n};",
  "1788": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getPathMarker =\n  exports.getLanguageMarker =\n  exports.comment =\n  exports.hasLanguageMarker =\n  exports.languageCommentMarkers =\n    undefined;\nexports.languageCommentMarkers = {\n  abap: {\n    start: '\"',\n    end: \"\",\n  },\n  bat: {\n    start: \"REM\",\n    end: \"\",\n  },\n  bibtex: {\n    start: \"%\",\n    end: \"\",\n  },\n  blade: {\n    start: \"#\",\n    end: \"\",\n  },\n  c: {\n    start: \"//\",\n    end: \"\",\n  },\n  clojure: {\n    start: \";\",\n    end: \"\",\n  },\n  coffeescript: {\n    start: \"//\",\n    end: \"\",\n  },\n  cpp: {\n    start: \"//\",\n    end: \"\",\n  },\n  csharp: {\n    start: \"//\",\n    end: \"\",\n  },\n  css: {\n    start: \"/*\",\n    end: \"*/\",\n  },\n  dart: {\n    start: \"//\",\n    end: \"\",\n  },\n  dockerfile: {\n    start: \"#\",\n    end: \"\",\n  },\n  elixir: {\n    start: \"#\",\n    end: \"\",\n  },\n  erb: {\n    start: \"<%#\",\n    end: \"%>\",\n  },\n  erlang: {\n    start: \"%\",\n    end: \"\",\n  },\n  fsharp: {\n    start: \"//\",\n    end: \"\",\n  },\n  go: {\n    start: \"//\",\n    end: \"\",\n  },\n  groovy: {\n    start: \"//\",\n    end: \"\",\n  },\n  haml: {\n    start: \"-#\",\n    end: \"\",\n  },\n  handlebars: {\n    start: \"{{!\",\n    end: \"}}\",\n  },\n  haskell: {\n    start: \"--\",\n    end: \"\",\n  },\n  html: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\",\n  },\n  ini: {\n    start: \";\",\n    end: \"\",\n  },\n  java: {\n    start: \"//\",\n    end: \"\",\n  },\n  javascript: {\n    start: \"//\",\n    end: \"\",\n  },\n  javascriptreact: {\n    start: \"//\",\n    end: \"\",\n  },\n  jsonc: {\n    start: \"//\",\n    end: \"\",\n  },\n  jsx: {\n    start: \"//\",\n    end: \"\",\n  },\n  julia: {\n    start: \"#\",\n    end: \"\",\n  },\n  kotlin: {\n    start: \"//\",\n    end: \"\",\n  },\n  latex: {\n    start: \"%\",\n    end: \"\",\n  },\n  less: {\n    start: \"//\",\n    end: \"\",\n  },\n  lua: {\n    start: \"--\",\n    end: \"\",\n  },\n  makefile: {\n    start: \"#\",\n    end: \"\",\n  },\n  markdown: {\n    start: \"[]: #\",\n    end: \"\",\n  },\n  \"objective-c\": {\n    start: \"//\",\n    end: \"\",\n  },\n  \"objective-cpp\": {\n    start: \"//\",\n    end: \"\",\n  },\n  perl: {\n    start: \"#\",\n    end: \"\",\n  },\n  php: {\n    start: \"//\",\n    end: \"\",\n  },\n  powershell: {\n    start: \"#\",\n    end: \"\",\n  },\n  pug: {\n    start: \"//\",\n    end: \"\",\n  },\n  python: {\n    start: \"#\",\n    end: \"\",\n  },\n  ql: {\n    start: \"//\",\n    end: \"\",\n  },\n  r: {\n    start: \"#\",\n    end: \"\",\n  },\n  razor: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\",\n  },\n  ruby: {\n    start: \"#\",\n    end: \"\",\n  },\n  rust: {\n    start: \"//\",\n    end: \"\",\n  },\n  sass: {\n    start: \"//\",\n    end: \"\",\n  },\n  scala: {\n    start: \"//\",\n    end: \"\",\n  },\n  scss: {\n    start: \"//\",\n    end: \"\",\n  },\n  shellscript: {\n    start: \"#\",\n    end: \"\",\n  },\n  slim: {\n    start: \"/\",\n    end: \"\",\n  },\n  solidity: {\n    start: \"//\",\n    end: \"\",\n  },\n  sql: {\n    start: \"--\",\n    end: \"\",\n  },\n  stylus: {\n    start: \"//\",\n    end: \"\",\n  },\n  svelte: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\",\n  },\n  swift: {\n    start: \"//\",\n    end: \"\",\n  },\n  terraform: {\n    start: \"#\",\n    end: \"\",\n  },\n  tex: {\n    start: \"%\",\n    end: \"\",\n  },\n  typescript: {\n    start: \"//\",\n    end: \"\",\n  },\n  typescriptreact: {\n    start: \"//\",\n    end: \"\",\n  },\n  vb: {\n    start: \"'\",\n    end: \"\",\n  },\n  verilog: {\n    start: \"//\",\n    end: \"\",\n  },\n  \"vue-html\": {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\",\n  },\n  vue: {\n    start: \"//\",\n    end: \"\",\n  },\n  xml: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\",\n  },\n  xsl: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\",\n  },\n  yaml: {\n    start: \"#\",\n    end: \"\",\n  },\n};\nconst n = [\"php\", \"plaintext\"],\n  r = {\n    html: \"<!DOCTYPE html>\",\n    python: \"#!/usr/bin/env python3\",\n    ruby: \"#!/usr/bin/env ruby\",\n    shellscript: \"#!/bin/sh\",\n    yaml: \"# YAML data\",\n  };\nfunction hasLanguageMarker({ source: e }) {\n  return e.startsWith(\"#!\") || e.startsWith(\"<!DOCTYPE\");\n}\nfunction comment(e, n) {\n  const r = exports.languageCommentMarkers[n];\n  if (r) {\n    const t = \"\" == r.end ? \"\" : \" \" + r.end;\n    return `${r.start} ${e}${t}`;\n  }\n  return \"\";\n}\nexports.hasLanguageMarker = hasLanguageMarker;\nexports.comment = comment;\nexports.getLanguageMarker = function (e) {\n  const { languageId: t } = e;\n  return -1 !== n.indexOf(t) || hasLanguageMarker(e)\n    ? \"\"\n    : t in r\n    ? r[t]\n    : comment(`Language: ${t}`, t);\n};\nexports.getPathMarker = function (e) {\n  return e.relativePath ? comment(`Path: ${e.relativePath}`, e.languageId) : \"\";\n};",
  "1839": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.registerDocumentTracker = exports.sortByAccessTimes = undefined;\nconst r = require(3136),\n  o = new Map();\nexports.sortByAccessTimes = function (e) {\n  return [...e].sort((e, t) => {\n    var n, r;\n    const i = null !== (n = o.get(e.uri.toString())) && undefined !== n ? n : 0;\n    return (\n      (null !== (r = o.get(t.uri.toString())) && undefined !== r ? r : 0) - i\n    );\n  });\n};\nexports.registerDocumentTracker = (e) =>\n  e.get(r.TextDocumentManager).onDidFocusTextDocument((e) => {\n    if (e) {\n      o.set(e.document.uri.toString(), Date.now());\n    }\n  });",
  "1857": "var r;\nr = require(8249);\nrequire(8269);\nrequire(8214);\nrequire(888);\nrequire(5109);\n(function () {\n  var e = r,\n    t = e.lib.StreamCipher,\n    n = e.algo,\n    o = (n.RC4 = t.extend({\n      _doReset: function () {\n        for (\n          var e = this._key,\n            t = e.words,\n            n = e.sigBytes,\n            r = (this._S = []),\n            o = 0;\n          o < 256;\n          o++\n        )\n          r[o] = o;\n        o = 0;\n        for (var i = 0; o < 256; o++) {\n          var s = o % n,\n            a = (t[s >>> 2] >>> (24 - (s % 4) * 8)) & 255;\n          i = (i + r[o] + a) % 256;\n          var c = r[o];\n          r[o] = r[i];\n          r[i] = c;\n        }\n        this._i = this._j = 0;\n      },\n      _doProcessBlock: function (e, t) {\n        e[t] ^= i.call(this);\n      },\n      keySize: 8,\n      ivSize: 0,\n    }));\n  function i() {\n    for (var e = this._S, t = this._i, n = this._j, r = 0, o = 0; o < 4; o++) {\n      n = (n + e[(t = (t + 1) % 256)]) % 256;\n      var i = e[t];\n      e[t] = e[n];\n      e[n] = i;\n      r |= e[(e[t] + e[n]) % 256] << (24 - 8 * o);\n    }\n    this._i = t;\n    this._j = n;\n    return r;\n  }\n  e.RC4 = t._createHelper(o);\n  var s = (n.RC4Drop = o.extend({\n    cfg: o.cfg.extend({\n      drop: 192,\n    }),\n    _doReset: function () {\n      o._doReset.call(this);\n      for (var e = this.cfg.drop; e > 0; e--) i.call(this);\n    },\n  }));\n  e.RC4Drop = t._createHelper(s);\n})();\nmodule.exports = r.RC4;",
  "1862": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.VSCodeCopilotTokenManager =\n  exports.ExtensionNotificationSender =\n  exports.setExtensionContext =\n  exports.telemetryAcceptanceKey =\n    undefined;\nconst r = require(\"vscode\"),\n  o = require(362),\n  i = require(6794),\n  s = require(9899),\n  a = require(6333),\n  c = require(47);\nexports.telemetryAcceptanceKey = `github.copilot.telemetryAccepted.${i.LAST_TELEMETRY_TERMS_UPDATE}`;\nconst l = new s.Logger(s.LogLevel.INFO, \"auth\");\nlet u,\n  d = !1;\nexports.setExtensionContext = function (e) {\n  u = e;\n};\nexports.ExtensionNotificationSender = class {\n  async showWarningMessage(e, ...t) {\n    return {\n      title: await r.window.showWarningMessage(e, ...t.map((e) => e.title)),\n    };\n  }\n};\nclass VSCodeCopilotTokenManager extends o.CopilotTokenManager {\n  constructor() {\n    super();\n    this.copilotToken = undefined;\n  }\n  async getGitHubToken() {\n    const e = await c.getSession();\n    return null == e ? undefined : e.accessToken;\n  }\n  async getCopilotToken(e, n) {\n    if (\n      !this.copilotToken ||\n      this.copilotToken.expires_at < o.nowSeconds() ||\n      n\n    ) {\n      this.copilotToken = await (async function (e) {\n        var n;\n        const s = await (async function (e) {\n          const t = await c.getSession();\n          if (!t) {\n            l.info(e, \"GitHub login failed\");\n            a.telemetryError(e, \"auth.github_login_failed\");\n            return {\n              kind: \"failure\",\n              reason: \"GitHubLoginFailed\",\n            };\n          }\n          l.debug(\n            e,\n            `Logged in as ${t.account.label}, oauth token ${t.accessToken}`\n          );\n          const n = await o.authFromGitHubToken(e, {\n            token: t.accessToken,\n          });\n          if (\"success\" == n.kind) {\n            const r = n.token;\n            l.debug(e, `Copilot HMAC for ${t.account.label}: ${r}`);\n          }\n          return n;\n        })(e);\n        if (\"failure\" === s.kind && \"NotAuthorized\" === s.reason)\n          throw Error(\n            null !== (n = s.message) && undefined !== n\n              ? n\n              : \"User not authorized\"\n          );\n        if (\"failure\" === s.kind && \"HTTP401\" === s.reason) {\n          const e =\n            \"Your GitHub token is invalid. Please sign out from your GitHub account using VSCode UI and try again.\";\n          throw (d || ((d = !0), r.window.showWarningMessage(e)), Error(e));\n        }\n        if (\"failure\" === s.kind) throw Error(\"Failed to get copilot token\");\n        if (\n          \"unconfigured\" === s.telemetry &&\n          !(await (async function (e) {\n            var n;\n            const o = null == u ? undefined : u.globalState;\n            if (!o) return !1;\n            const s =\n              null === (n = c.getGithubAccount()) || undefined === n\n                ? undefined\n                : n.label;\n            if (!s) return !1;\n            const l = s,\n              d = o.get(exports.telemetryAcceptanceKey, undefined);\n            if (d && d === s) return !0;\n            const p = await r.window.showWarningMessage(\n              `I agree to these [telemetry terms](${i.TELEMETRY_TERMS_URL}) as part of the GitHub Copilot technical preview.`,\n              \"Cancel\",\n              \"Agree\"\n            );\n            if (\"Agree\" !== p) {\n              const t = a.TelemetryData.createAndMarkAsIssued({\n                choice: null != p ? p : \"undefined\",\n              });\n              a.telemetry(e, \"auth.telemetry_terms_rejected\", t);\n              return !1;\n            }\n            o.update(exports.telemetryAcceptanceKey, l);\n            const h = a.TelemetryData.createAndMarkAsIssued({\n              terms_date: i.LAST_TELEMETRY_TERMS_UPDATE,\n            });\n            a.telemetry(e, \"auth.telemetry_terms_accepted\", h);\n            return !0;\n          })(e))\n        )\n          throw Error(\"User did not agree to telemetry\");\n        return s;\n      })(e);\n      o.refreshToken(e, this, this.copilotToken.refresh_in);\n    }\n    return this.copilotToken;\n  }\n  resetCopilotToken(e, t) {\n    if (undefined !== t) {\n      a.telemetry(e, \"auth.reset_token_\" + t);\n    }\n    l.debug(e, `Resetting copilot token on HTTP error ${t || \"unknown\"}`);\n    this.copilotToken = undefined;\n  }\n}\nexports.VSCodeCopilotTokenManager = VSCodeCopilotTokenManager;",
  "1906": "module.exports = (e, t, n) => {\n  const r = (n) =>\n    Object.defineProperty(e, t, {\n      value: n,\n      enumerable: !0,\n      writable: !0,\n    });\n  Object.defineProperty(e, t, {\n    configurable: !0,\n    enumerable: !0,\n    get() {\n      const e = n();\n      r(e);\n      return e;\n    },\n    set(e) {\n      r(e);\n    },\n  });\n  return e;\n};",
  "1929": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.OpenCopilotActionProvider = undefined;\nconst r = require(\"vscode\"),\n  o = require(256),\n  i = require(6333),\n  s = require(3060),\n  a = require(4540);\nexports.OpenCopilotActionProvider = class {\n  constructor(e) {\n    this.ctx = e;\n    this.lastVersion = 0;\n    this.lastRange = undefined;\n  }\n  indexOfGroup(e, t) {\n    let n = e.index;\n    for (let r = 1; r < t; r++) n += e[r].length;\n    return n;\n  }\n  telemetryCodeAction(e, t) {\n    const n = {\n      languageId: e.languageId,\n      codeActionType: o.completionTypeToString(t),\n    };\n    i.telemetry(\n      this.ctx,\n      \"codeAction.displayed\",\n      i.TelemetryData.createAndMarkAsIssued(n)\n    );\n  }\n  async provideCodeActions(e, t, n, i) {\n    var c;\n    if (a.ignoreDocument(this.ctx, e)) return;\n    const l = e.lineAt(t.start);\n    if (\n      e.version === this.lastVersion &&\n      this.lastRange &&\n      this.lastRange.isEqual(t)\n    )\n      return;\n    this.lastVersion = e.version;\n    this.lastRange = t;\n    const u = /^(\\W+)(todo)/i.exec(l.text);\n    if (u) {\n      const n = u[u.length - 1],\n        i = this.indexOfGroup(u, u.length - 1);\n      if (\n        new r.Range(\n          new r.Position(t.start.line, i),\n          new r.Position(t.start.line, i + n.length)\n        ).contains(t.start)\n      ) {\n        const t = new r.CodeAction(\n            \"Implement with GitHub Copilot\",\n            r.CodeActionKind.QuickFix\n          ),\n          n = {\n            title: \"Implement with GitHub Copilot\",\n            command: s.CMDOpenPanelForRange,\n            arguments: [\n              new o.CompletionContext(\n                this.ctx,\n                l.rangeIncludingLineBreak.end,\n                o.CompletionType.TODO_QUICK_FIX\n              ),\n            ],\n          };\n        t.command = n;\n        this.telemetryCodeAction(e, o.CompletionType.TODO_QUICK_FIX);\n        return [t];\n      }\n    }\n    const d = n.diagnostics.find((e) => \"ts\" === e.source && 2304 === e.code);\n    if (d) {\n      const t = await r.commands.executeCommand(\n          \"vscode.executeCodeActionProvider\",\n          e.uri,\n          d.range\n        ),\n        n =\n          null == t\n            ? undefined\n            : t.find((e) =>\n                e.title.startsWith(\"Add missing function declaration\")\n              ),\n        i =\n          null === (c = null == n ? undefined : n.edit) || undefined === c\n            ? undefined\n            : c.get(e.uri).pop();\n      if (i) {\n        const t = new r.CodeAction(\n            \"Implement with GitHub Copilot\",\n            r.CodeActionKind.QuickFix\n          ),\n          n = new o.CompletionContext(\n            this.ctx,\n            i.range.start,\n            o.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX\n          ),\n          a = i.newText.trim().split(\"\\n\")[0];\n        n.prependToCompletion = \"\\n\" + a;\n        const c = {\n          title: \"Implement with GitHub Copilot\",\n          command: s.CMDOpenPanelForRange,\n          arguments: [n],\n        };\n        t.command = c;\n        this.telemetryCodeAction(\n          e,\n          o.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX\n        );\n        return [t];\n      }\n    }\n  }\n};",
  "1974": "var t = (function () {\n  function e(e) {\n    this.fieldmap = [];\n    if (e) {\n      this.fieldmap = this.parseHeader(e);\n    }\n  }\n  e.prototype.toString = function () {\n    var e = this.fieldmap;\n    return e && 0 != e.length ? e.join(\", \") : null;\n  };\n  e.validateKeyChars = function (e) {\n    var t = e.split(\"@\");\n    if (2 == t.length) {\n      var n = t[0].trim(),\n        r = t[1].trim(),\n        o = Boolean(n.match(/^[\\ ]?[a-z0-9\\*\\-\\_/]{1,241}$/)),\n        i = Boolean(r.match(/^[\\ ]?[a-z0-9\\*\\-\\_/]{1,14}$/));\n      return o && i;\n    }\n    return 1 == t.length && Boolean(e.match(/^[\\ ]?[a-z0-9\\*\\-\\_/]{1,256}$/));\n  };\n  e.prototype.parseHeader = function (t) {\n    var n = [],\n      r = {},\n      o = t.split(\",\");\n    if (o.length > 32) return null;\n    for (var i = 0, s = o; i < s.length; i++) {\n      var a = s[i].trim();\n      if (0 !== a.length) {\n        var c = a.split(\"=\");\n        if (2 !== c.length) return null;\n        if (!e.validateKeyChars(c[0])) return null;\n        if (r[c[0]]) return null;\n        r[c[0]] = !0;\n        n.push(a);\n      }\n    }\n    return n;\n  };\n  e.strict = !0;\n  return e;\n})();\nmodule.exports = t;",
  "2028": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r = require(4953);\nexports.mongoCore = {\n  versionSpecifier: \">= 2.0.0 < 4.0.0\",\n  patch: function (e) {\n    var t = e.Server.prototype.connect;\n    e.Server.prototype.connect = function () {\n      var e = t.apply(this, arguments),\n        n = this.s.pool.write;\n      this.s.pool.write = function () {\n        var e = \"function\" == typeof arguments[1] ? 1 : 2;\n        if (\"function\" == typeof arguments[e]) {\n          arguments[e] = r.channel.bindToContext(arguments[e]);\n        }\n        return n.apply(this, arguments);\n      };\n      var o = this.s.pool.logout;\n      this.s.pool.logout = function () {\n        if (\"function\" == typeof arguments[1]) {\n          arguments[1] = r.channel.bindToContext(arguments[1]);\n        }\n        return o.apply(this, arguments);\n      };\n      return e;\n    };\n    return e;\n  },\n};\nexports.enable = function () {\n  r.channel.registerMonkeyPatch(\"mongodb-core\", exports.mongoCore);\n};",
  "2112": "var r, o, i, s, a, c, l, u, d;\nd = require(8249);\nrequire(2783);\nrequire(9824);\ni = (o = (r = d).lib).Base;\ns = o.WordArray;\nc = (a = r.algo).SHA1;\nl = a.HMAC;\nu = a.PBKDF2 = i.extend({\n  cfg: i.extend({\n    keySize: 4,\n    hasher: c,\n    iterations: 1,\n  }),\n  init: function (e) {\n    this.cfg = this.cfg.extend(e);\n  },\n  compute: function (e, t) {\n    for (\n      var n = this.cfg,\n        r = l.create(n.hasher, e),\n        o = s.create(),\n        i = s.create([1]),\n        a = o.words,\n        c = i.words,\n        u = n.keySize,\n        d = n.iterations;\n      a.length < u;\n\n    ) {\n      var p = r.update(t).finalize(i);\n      r.reset();\n      for (var h = p.words, f = h.length, m = p, g = 1; g < d; g++) {\n        m = r.finalize(m);\n        r.reset();\n        for (var _ = m.words, y = 0; y < f; y++) h[y] ^= _[y];\n      }\n      o.concat(p);\n      c[0]++;\n    }\n    o.sigBytes = 4 * u;\n    return o;\n  },\n});\nr.PBKDF2 = function (e, t, n) {\n  return u.create(n).compute(e, t);\n};\nmodule.exports = d.PBKDF2;",
  "2130": "const r = require(\"os\"),\n  o = require(6560),\n  i = process.env;\nlet s;\nfunction a(e) {\n  const t = (function (e) {\n    if (!1 === s) return 0;\n    if (o(\"color=16m\") || o(\"color=full\") || o(\"color=truecolor\")) return 3;\n    if (o(\"color=256\")) return 2;\n    if (e && !e.isTTY && !0 !== s) return 0;\n    const t = s ? 1 : 0;\n    if (\"win32\" === process.platform) {\n      const e = r.release().split(\".\");\n      return Number(process.versions.node.split(\".\")[0]) >= 8 &&\n        Number(e[0]) >= 10 &&\n        Number(e[2]) >= 10586\n        ? Number(e[2]) >= 14931\n          ? 3\n          : 2\n        : 1;\n    }\n    if (\"CI\" in i)\n      return [\"TRAVIS\", \"CIRCLECI\", \"APPVEYOR\", \"GITLAB_CI\"].some(\n        (e) => e in i\n      ) || \"codeship\" === i.CI_NAME\n        ? 1\n        : t;\n    if (\"TEAMCITY_VERSION\" in i)\n      return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(i.TEAMCITY_VERSION) ? 1 : 0;\n    if (\"truecolor\" === i.COLORTERM) return 3;\n    if (\"TERM_PROGRAM\" in i) {\n      const e = parseInt((i.TERM_PROGRAM_VERSION || \"\").split(\".\")[0], 10);\n      switch (i.TERM_PROGRAM) {\n        case \"iTerm.app\":\n          return e >= 3 ? 3 : 2;\n        case \"Apple_Terminal\":\n          return 2;\n      }\n    }\n    return /-256(color)?$/i.test(i.TERM)\n      ? 2\n      : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(\n          i.TERM\n        ) || \"COLORTERM\" in i\n      ? 1\n      : (i.TERM, t);\n  })(e);\n  return (function (e) {\n    return (\n      0 !== e && {\n        level: e,\n        hasBasic: !0,\n        has256: e >= 2,\n        has16m: e >= 3,\n      }\n    );\n  })(t);\n}\nif (o(\"no-color\") || o(\"no-colors\") || o(\"color=false\")) {\n  s = !1;\n} else {\n  if (o(\"color\") || o(\"colors\") || o(\"color=true\") || o(\"color=always\")) {\n    s = !0;\n  }\n}\nif (\"FORCE_COLOR\" in i) {\n  s = 0 === i.FORCE_COLOR.length || 0 !== parseInt(i.FORCE_COLOR, 10);\n}\nmodule.exports = {\n  supportsColor: a,\n  stdout: a(process.stdout),\n  stderr: a(process.stderr),\n};",
  "2141": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = {\n    data: new r.Name(\"data\"),\n    valCxt: new r.Name(\"valCxt\"),\n    instancePath: new r.Name(\"instancePath\"),\n    parentData: new r.Name(\"parentData\"),\n    parentDataProperty: new r.Name(\"parentDataProperty\"),\n    rootData: new r.Name(\"rootData\"),\n    dynamicAnchors: new r.Name(\"dynamicAnchors\"),\n    vErrors: new r.Name(\"vErrors\"),\n    errors: new r.Name(\"errors\"),\n    this: new r.Name(\"this\"),\n    self: new r.Name(\"self\"),\n    scope: new r.Name(\"scope\"),\n    json: new r.Name(\"json\"),\n    jsonPos: new r.Name(\"jsonPos\"),\n    jsonLen: new r.Name(\"jsonLen\"),\n    jsonPart: new r.Name(\"jsonPart\"),\n  };\nexports.default = o;",
  "2153": "var r;\nr = require(8249);\n(function (e) {\n  var t = r,\n    n = t.lib,\n    o = n.WordArray,\n    i = n.Hasher,\n    s = t.algo,\n    a = [],\n    c = [];\n  !(function () {\n    function t(t) {\n      for (var n = e.sqrt(t), r = 2; r <= n; r++) if (!(t % r)) return !1;\n      return !0;\n    }\n    function n(e) {\n      return (4294967296 * (e - (0 | e))) | 0;\n    }\n    for (var r = 2, o = 0; o < 64; ) {\n      if (t(r)) {\n        if (o < 8) {\n          a[o] = n(e.pow(r, 0.5));\n        }\n        c[o] = n(e.pow(r, 1 / 3));\n        o++;\n      }\n      r++;\n    }\n  })();\n  var l = [],\n    u = (s.SHA256 = i.extend({\n      _doReset: function () {\n        this._hash = new o.init(a.slice(0));\n      },\n      _doProcessBlock: function (e, t) {\n        for (\n          var n = this._hash.words,\n            r = n[0],\n            o = n[1],\n            i = n[2],\n            s = n[3],\n            a = n[4],\n            u = n[5],\n            d = n[6],\n            p = n[7],\n            h = 0;\n          h < 64;\n          h++\n        ) {\n          if (h < 16) l[h] = 0 | e[t + h];\n          else {\n            var f = l[h - 15],\n              m =\n                ((f << 25) | (f >>> 7)) ^ ((f << 14) | (f >>> 18)) ^ (f >>> 3),\n              g = l[h - 2],\n              _ =\n                ((g << 15) | (g >>> 17)) ^\n                ((g << 13) | (g >>> 19)) ^\n                (g >>> 10);\n            l[h] = m + l[h - 7] + _ + l[h - 16];\n          }\n          var y = (r & o) ^ (r & i) ^ (o & i),\n            v =\n              ((r << 30) | (r >>> 2)) ^\n              ((r << 19) | (r >>> 13)) ^\n              ((r << 10) | (r >>> 22)),\n            b =\n              p +\n              (((a << 26) | (a >>> 6)) ^\n                ((a << 21) | (a >>> 11)) ^\n                ((a << 7) | (a >>> 25))) +\n              ((a & u) ^ (~a & d)) +\n              c[h] +\n              l[h];\n          p = d;\n          d = u;\n          u = a;\n          a = (s + b) | 0;\n          s = i;\n          i = o;\n          o = r;\n          r = (b + (v + y)) | 0;\n        }\n        n[0] = (n[0] + r) | 0;\n        n[1] = (n[1] + o) | 0;\n        n[2] = (n[2] + i) | 0;\n        n[3] = (n[3] + s) | 0;\n        n[4] = (n[4] + a) | 0;\n        n[5] = (n[5] + u) | 0;\n        n[6] = (n[6] + d) | 0;\n        n[7] = (n[7] + p) | 0;\n      },\n      _doFinalize: function () {\n        var t = this._data,\n          n = t.words,\n          r = 8 * this._nDataBytes,\n          o = 8 * t.sigBytes;\n        n[o >>> 5] |= 128 << (24 - (o % 32));\n        n[14 + (((o + 64) >>> 9) << 4)] = e.floor(r / 4294967296);\n        n[15 + (((o + 64) >>> 9) << 4)] = r;\n        t.sigBytes = 4 * n.length;\n        this._process();\n        return this._hash;\n      },\n      clone: function () {\n        var e = i.clone.call(this);\n        e._hash = this._hash.clone();\n        return e;\n      },\n    }));\n  t.SHA256 = i._createHelper(u);\n  t.HmacSHA256 = i._createHmacHelper(u);\n})(Math);\nmodule.exports = r.SHA256;",
  "2209": "var r, o, i, s;\ns = require(8249);\nrequire(5109);\no = (r = s).lib.CipherParams;\ni = r.enc.Hex;\nr.format.Hex = {\n  stringify: function (e) {\n    return e.ciphertext.toString(i);\n  },\n  parse: function (e) {\n    var t = i.parse(e);\n    return o.create({\n      ciphertext: t,\n    });\n  },\n};\nmodule.exports = s.format.Hex;",
  "2218": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.completionsFromGhostTextResults = undefined;\nconst r = require(2277),\n  o = require(6403),\n  i = require(9334),\n  s = require(3286);\nexports.completionsFromGhostTextResults = function (e, t, n, a, c, l, u) {\n  const d = e.get(o.LocationFactory),\n    p = a.lineAt(c);\n  let h = t.map((e) => {\n    let t,\n      o = \"\";\n    if (l) {\n      e.completion = s.normalizeIndentCharacter(\n        l,\n        e.completion,\n        p.isEmptyOrWhitespace\n      );\n    }\n    if (e.completion.displayNeedsWsOffset && p.isEmptyOrWhitespace)\n      (t = d.range(d.position(c.line, 0), c)),\n        (o = e.completion.completionText);\n    else if (\n      p.isEmptyOrWhitespace &&\n      e.completion.completionText.startsWith(p.text)\n    )\n      (t = d.range(d.position(c.line, 0), c)),\n        (o = e.completion.completionText);\n    else {\n      const n = a.getWordRangeAtPosition(c);\n      if (e.isMiddleOfTheLine) {\n        const n = a.lineAt(c),\n          r = d.range(d.position(c.line, 0), c),\n          i = a.getText(r);\n        (t = e.coversSuffix ? n.range : r), (o = i + e.completion.displayText);\n      } else if (n) {\n        const r = a.getText(n);\n        (t = d.range(n.start, c)), (o = r + e.completion.completionText);\n      } else {\n        const n = d.range(d.position(c.line, 0), c);\n        (t = n), (o = a.getText(n) + e.completion.displayText);\n      }\n    }\n    return {\n      uuid: r.v4(),\n      text: o,\n      range: t,\n      file: a.uri,\n      index: e.completion.completionIndex,\n      telemetry: e.telemetry,\n      displayText: e.completion.displayText,\n      position: c,\n      offset: a.offsetAt(c),\n      resultType: n,\n    };\n  });\n  if (n === i.ResultType.TypingAsSuggested && undefined !== u) {\n    const e = h.find((e) => e.index === u);\n    if (e) {\n      const t = h.filter((e) => e.index !== u);\n      h = [e, ...t];\n    }\n  }\n  return h;\n};",
  "2249": "var n;\nexports = module.exports = SemVer;\nn =\n  \"object\" == typeof process &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n    ? function () {\n        var e = Array.prototype.slice.call(arguments, 0);\n        e.unshift(\"SEMVER\");\n        console.log.apply(console, e);\n      }\n    : function () {};\nexports.SEMVER_SPEC_VERSION = \"2.0.0\";\nvar r = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  o = (exports.re = []),\n  i = (exports.src = []),\n  s = 0,\n  a = s++;\ni[a] = \"0|[1-9]\\\\d*\";\nvar c = s++;\ni[c] = \"[0-9]+\";\nvar l = s++;\ni[l] = \"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\";\nvar u = s++;\ni[u] = \"(\" + i[a] + \")\\\\.(\" + i[a] + \")\\\\.(\" + i[a] + \")\";\nvar d = s++;\ni[d] = \"(\" + i[c] + \")\\\\.(\" + i[c] + \")\\\\.(\" + i[c] + \")\";\nvar p = s++;\ni[p] = \"(?:\" + i[a] + \"|\" + i[l] + \")\";\nvar h = s++;\ni[h] = \"(?:\" + i[c] + \"|\" + i[l] + \")\";\nvar f = s++;\ni[f] = \"(?:-(\" + i[p] + \"(?:\\\\.\" + i[p] + \")*))\";\nvar m = s++;\ni[m] = \"(?:-?(\" + i[h] + \"(?:\\\\.\" + i[h] + \")*))\";\nvar g = s++;\ni[g] = \"[0-9A-Za-z-]+\";\nvar _ = s++;\ni[_] = \"(?:\\\\+(\" + i[g] + \"(?:\\\\.\" + i[g] + \")*))\";\nvar y = s++,\n  v = \"v?\" + i[u] + i[f] + \"?\" + i[_] + \"?\";\ni[y] = \"^\" + v + \"$\";\nvar b = \"[v=\\\\s]*\" + i[d] + i[m] + \"?\" + i[_] + \"?\",\n  w = s++;\ni[w] = \"^\" + b + \"$\";\nvar x = s++;\ni[x] = \"((?:<|>)?=?)\";\nvar E = s++;\ni[E] = i[c] + \"|x|X|\\\\*\";\nvar C = s++;\ni[C] = i[a] + \"|x|X|\\\\*\";\nvar S = s++;\ni[S] =\n  \"[v=\\\\s]*(\" +\n  i[C] +\n  \")(?:\\\\.(\" +\n  i[C] +\n  \")(?:\\\\.(\" +\n  i[C] +\n  \")(?:\" +\n  i[f] +\n  \")?\" +\n  i[_] +\n  \"?)?)?\";\nvar T = s++;\ni[T] =\n  \"[v=\\\\s]*(\" +\n  i[E] +\n  \")(?:\\\\.(\" +\n  i[E] +\n  \")(?:\\\\.(\" +\n  i[E] +\n  \")(?:\" +\n  i[m] +\n  \")?\" +\n  i[_] +\n  \"?)?)?\";\nvar k = s++;\ni[k] = \"^\" + i[x] + \"\\\\s*\" + i[S] + \"$\";\nvar I = s++;\ni[I] = \"^\" + i[x] + \"\\\\s*\" + i[T] + \"$\";\nvar P = s++;\ni[P] =\n  \"(?:^|[^\\\\d])(\\\\d{1,16})(?:\\\\.(\\\\d{1,16}))?(?:\\\\.(\\\\d{1,16}))?(?:$|[^\\\\d])\";\nvar A = s++;\ni[A] = \"(?:~>?)\";\nvar O = s++;\ni[O] = \"(\\\\s*)\" + i[A] + \"\\\\s+\";\no[O] = new RegExp(i[O], \"g\");\nvar N = s++;\ni[N] = \"^\" + i[A] + i[S] + \"$\";\nvar R = s++;\ni[R] = \"^\" + i[A] + i[T] + \"$\";\nvar M = s++;\ni[M] = \"(?:\\\\^)\";\nvar L = s++;\ni[L] = \"(\\\\s*)\" + i[M] + \"\\\\s+\";\no[L] = new RegExp(i[L], \"g\");\nvar $ = s++;\ni[$] = \"^\" + i[M] + i[S] + \"$\";\nvar D = s++;\ni[D] = \"^\" + i[M] + i[T] + \"$\";\nvar F = s++;\ni[F] = \"^\" + i[x] + \"\\\\s*(\" + b + \")$|^$\";\nvar j = s++;\ni[j] = \"^\" + i[x] + \"\\\\s*(\" + v + \")$|^$\";\nvar q = s++;\ni[q] = \"(\\\\s*)\" + i[x] + \"\\\\s*(\" + b + \"|\" + i[S] + \")\";\no[q] = new RegExp(i[q], \"g\");\nvar B = s++;\ni[B] = \"^\\\\s*(\" + i[S] + \")\\\\s+-\\\\s+(\" + i[S] + \")\\\\s*$\";\nvar U = s++;\ni[U] = \"^\\\\s*(\" + i[T] + \")\\\\s+-\\\\s+(\" + i[T] + \")\\\\s*$\";\nvar H = s++;\ni[H] = \"(<|>)?=?\\\\s*\\\\*\";\nfor (var z = 0; z < 35; z++) {\n  n(z, i[z]);\n  if (o[z]) {\n    o[z] = new RegExp(i[z]);\n  }\n}\nfunction parse(e, t) {\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (e instanceof SemVer) return e;\n  if (\"string\" != typeof e) return null;\n  if (e.length > 256) return null;\n  if (!(t.loose ? o[w] : o[y]).test(e)) return null;\n  try {\n    return new SemVer(e, t);\n  } catch (e) {\n    return null;\n  }\n}\nfunction SemVer(e, t) {\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (e instanceof SemVer) {\n    if (e.loose === t.loose) return e;\n    e = e.version;\n  } else if (\"string\" != typeof e) throw new TypeError(\"Invalid Version: \" + e);\n  if (e.length > 256)\n    throw new TypeError(\"version is longer than 256 characters\");\n  if (!(this instanceof SemVer)) return new SemVer(e, t);\n  n(\"SemVer\", e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  var i = e.trim().match(t.loose ? o[w] : o[y]);\n  if (!i) throw new TypeError(\"Invalid Version: \" + e);\n  this.raw = e;\n  this.major = +i[1];\n  this.minor = +i[2];\n  this.patch = +i[3];\n  if (this.major > r || this.major < 0)\n    throw new TypeError(\"Invalid major version\");\n  if (this.minor > r || this.minor < 0)\n    throw new TypeError(\"Invalid minor version\");\n  if (this.patch > r || this.patch < 0)\n    throw new TypeError(\"Invalid patch version\");\n  if (i[4]) {\n    this.prerelease = i[4].split(\".\").map(function (e) {\n      if (/^[0-9]+$/.test(e)) {\n        var t = +e;\n        if (t >= 0 && t < r) return t;\n      }\n      return e;\n    });\n  } else {\n    this.prerelease = [];\n  }\n  this.build = i[5] ? i[5].split(\".\") : [];\n  this.format();\n}\nexports.parse = parse;\nexports.valid = function (e, t) {\n  var n = parse(e, t);\n  return n ? n.version : null;\n};\nexports.clean = function (e, t) {\n  var n = parse(e.trim().replace(/^[=v]+/, \"\"), t);\n  return n ? n.version : null;\n};\nexports.SemVer = SemVer;\nSemVer.prototype.format = function () {\n  this.version = this.major + \".\" + this.minor + \".\" + this.patch;\n  if (this.prerelease.length) {\n    this.version += \"-\" + this.prerelease.join(\".\");\n  }\n  return this.version;\n};\nSemVer.prototype.toString = function () {\n  return this.version;\n};\nSemVer.prototype.compare = function (e) {\n  n(\"SemVer.compare\", this.version, this.options, e);\n  if (e instanceof SemVer) {\n    e = new SemVer(e, this.options);\n  }\n  return this.compareMain(e) || this.comparePre(e);\n};\nSemVer.prototype.compareMain = function (e) {\n  if (e instanceof SemVer) {\n    e = new SemVer(e, this.options);\n  }\n  return (\n    compareIdentifiers(this.major, e.major) ||\n    compareIdentifiers(this.minor, e.minor) ||\n    compareIdentifiers(this.patch, e.patch)\n  );\n};\nSemVer.prototype.comparePre = function (e) {\n  if (e instanceof SemVer) {\n    e = new SemVer(e, this.options);\n  }\n  if (this.prerelease.length && !e.prerelease.length) return -1;\n  if (!this.prerelease.length && e.prerelease.length) return 1;\n  if (!this.prerelease.length && !e.prerelease.length) return 0;\n  var t = 0;\n  do {\n    var r = this.prerelease[t],\n      o = e.prerelease[t];\n    n(\"prerelease compare\", t, r, o);\n    if (void 0 === r && void 0 === o) return 0;\n    if (undefined === o) return 1;\n    if (undefined === r) return -1;\n    if (r !== o) return compareIdentifiers(r, o);\n  } while (++t);\n};\nSemVer.prototype.inc = function (e, t) {\n  switch (e) {\n    case \"premajor\":\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc(\"pre\", t);\n      break;\n    case \"preminor\":\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc(\"pre\", t);\n      break;\n    case \"prepatch\":\n      this.prerelease.length = 0;\n      this.inc(\"patch\", t);\n      this.inc(\"pre\", t);\n      break;\n    case \"prerelease\":\n      if (0 === this.prerelease.length) {\n        this.inc(\"patch\", t);\n      }\n      this.inc(\"pre\", t);\n      break;\n    case \"major\":\n      if (\n        0 === this.minor &&\n        0 === this.patch &&\n        0 !== this.prerelease.length\n      ) {\n        this.major++;\n      }\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case \"minor\":\n      if (0 === this.patch && 0 !== this.prerelease.length) {\n        this.minor++;\n      }\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case \"patch\":\n      if (0 === this.prerelease.length) {\n        this.patch++;\n      }\n      this.prerelease = [];\n      break;\n    case \"pre\":\n      if (0 === this.prerelease.length) this.prerelease = [0];\n      else {\n        for (var n = this.prerelease.length; --n >= 0; )\n          if (\"number\" == typeof this.prerelease[n]) {\n            this.prerelease[n]++;\n            n = -2;\n          }\n        if (-1 === n) {\n          this.prerelease.push(0);\n        }\n      }\n      if (t) {\n        if (this.prerelease[0] === t) {\n          if (isNaN(this.prerelease[1])) {\n            this.prerelease = [t, 0];\n          }\n        } else {\n          this.prerelease = [t, 0];\n        }\n      }\n      break;\n    default:\n      throw new Error(\"invalid increment argument: \" + e);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\nexports.inc = function (e, t, n, r) {\n  if (\"string\" == typeof n) {\n    r = n;\n    n = undefined;\n  }\n  try {\n    return new SemVer(e, n).inc(t, r).version;\n  } catch (e) {\n    return null;\n  }\n};\nexports.diff = function (e, t) {\n  if (eq(e, t)) return null;\n  var n = parse(e),\n    r = parse(t),\n    o = \"\";\n  if (n.prerelease.length || r.prerelease.length) {\n    o = \"pre\";\n    var i = \"prerelease\";\n  }\n  for (var s in n)\n    if ((\"major\" === s || \"minor\" === s || \"patch\" === s) && n[s] !== r[s])\n      return o + s;\n  return i;\n};\nexports.compareIdentifiers = compareIdentifiers;\nvar W = /^[0-9]+$/;\nfunction compareIdentifiers(e, t) {\n  var n = W.test(e),\n    r = W.test(t);\n  if (n && r) {\n    e = +e;\n    t = +t;\n  }\n  return e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1;\n}\nfunction compare(e, t, n) {\n  return new SemVer(e, n).compare(new SemVer(t, n));\n}\nfunction gt(e, t, n) {\n  return compare(e, t, n) > 0;\n}\nfunction lt(e, t, n) {\n  return compare(e, t, n) < 0;\n}\nfunction eq(e, t, n) {\n  return 0 === compare(e, t, n);\n}\nfunction neq(e, t, n) {\n  return 0 !== compare(e, t, n);\n}\nfunction ee(e, t, n) {\n  return compare(e, t, n) >= 0;\n}\nfunction te(e, t, n) {\n  return compare(e, t, n) <= 0;\n}\nfunction ne(e, t, n, r) {\n  switch (t) {\n    case \"===\":\n      if (\"object\" == typeof e) {\n        e = e.version;\n      }\n      if (\"object\" == typeof n) {\n        n = n.version;\n      }\n      return e === n;\n    case \"!==\":\n      if (\"object\" == typeof e) {\n        e = e.version;\n      }\n      if (\"object\" == typeof n) {\n        n = n.version;\n      }\n      return e !== n;\n    case \"\":\n    case \"=\":\n    case \"==\":\n      return eq(e, n, r);\n    case \"!=\":\n      return neq(e, n, r);\n    case \">\":\n      return gt(e, n, r);\n    case \">=\":\n      return ee(e, n, r);\n    case \"<\":\n      return lt(e, n, r);\n    case \"<=\":\n      return te(e, n, r);\n    default:\n      throw new TypeError(\"Invalid operator: \" + t);\n  }\n}\nfunction re(e, t) {\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (e instanceof re) {\n    if (e.loose === !!t.loose) return e;\n    e = e.value;\n  }\n  if (!(this instanceof re)) return new re(e, t);\n  n(\"comparator\", e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  this.parse(e);\n  if (this.semver === oe) {\n    this.value = \"\";\n  } else {\n    this.value = this.operator + this.semver.version;\n  }\n  n(\"comp\", this);\n}\nexports.rcompareIdentifiers = function (e, t) {\n  return compareIdentifiers(t, e);\n};\nexports.major = function (e, t) {\n  return new SemVer(e, t).major;\n};\nexports.minor = function (e, t) {\n  return new SemVer(e, t).minor;\n};\nexports.patch = function (e, t) {\n  return new SemVer(e, t).patch;\n};\nexports.compare = compare;\nexports.compareLoose = function (e, t) {\n  return compare(e, t, !0);\n};\nexports.rcompare = function (e, t, n) {\n  return compare(t, e, n);\n};\nexports.sort = function (e, n) {\n  return e.sort(function (e, r) {\n    return exports.compare(e, r, n);\n  });\n};\nexports.rsort = function (e, n) {\n  return e.sort(function (e, r) {\n    return exports.rcompare(e, r, n);\n  });\n};\nexports.gt = gt;\nexports.lt = lt;\nexports.eq = eq;\nexports.neq = neq;\nexports.gte = ee;\nexports.lte = te;\nexports.cmp = ne;\nexports.Comparator = re;\nvar oe = {};\nfunction ie(e, t) {\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (e instanceof ie)\n    return e.loose === !!t.loose &&\n      e.includePrerelease === !!t.includePrerelease\n      ? e\n      : new ie(e.raw, t);\n  if (e instanceof re) return new ie(e.value, t);\n  if (!(this instanceof ie)) return new ie(e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  this.includePrerelease = !!t.includePrerelease;\n  this.raw = e;\n  this.set = e\n    .split(/\\s*\\|\\|\\s*/)\n    .map(function (e) {\n      return this.parseRange(e.trim());\n    }, this)\n    .filter(function (e) {\n      return e.length;\n    });\n  if (!this.set.length) throw new TypeError(\"Invalid SemVer Range: \" + e);\n  this.format();\n}\nfunction se(e) {\n  return !e || \"x\" === e.toLowerCase() || \"*\" === e;\n}\nfunction ae(e, t, n, r, o, i, s, a, c, l, u, d, p) {\n  return (\n    (t = se(n)\n      ? \"\"\n      : se(r)\n      ? \">=\" + n + \".0.0\"\n      : se(o)\n      ? \">=\" + n + \".\" + r + \".0\"\n      : \">=\" + t) +\n    \" \" +\n    (a = se(c)\n      ? \"\"\n      : se(l)\n      ? \"<\" + (+c + 1) + \".0.0\"\n      : se(u)\n      ? \"<\" + c + \".\" + (+l + 1) + \".0\"\n      : d\n      ? \"<=\" + c + \".\" + l + \".\" + u + \"-\" + d\n      : \"<=\" + a)\n  ).trim();\n}\nfunction ce(e, t, r) {\n  for (var o = 0; o < e.length; o++) if (!e[o].test(t)) return !1;\n  if (t.prerelease.length && !r.includePrerelease) {\n    for (o = 0; o < e.length; o++) {\n      n(e[o].semver);\n      if (e[o].semver !== oe && e[o].semver.prerelease.length > 0) {\n        var i = e[o].semver;\n        if (i.major === t.major && i.minor === t.minor && i.patch === t.patch)\n          return !0;\n      }\n    }\n    return !1;\n  }\n  return !0;\n}\nfunction le(e, t, n) {\n  try {\n    t = new ie(t, n);\n  } catch (e) {\n    return !1;\n  }\n  return t.test(e);\n}\nfunction ue(e, t, n, r) {\n  var o, i, s, a, c;\n  switch (((e = new SemVer(e, r)), (t = new ie(t, r)), n)) {\n    case \">\":\n      o = gt;\n      i = te;\n      s = lt;\n      a = \">\";\n      c = \">=\";\n      break;\n    case \"<\":\n      o = lt;\n      i = ee;\n      s = gt;\n      a = \"<\";\n      c = \"<=\";\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n  if (le(e, t, r)) return !1;\n  for (var l = 0; l < t.set.length; ++l) {\n    var u = t.set[l],\n      d = null,\n      p = null;\n    u.forEach(function (e) {\n      if (e.semver === oe) {\n        e = new re(\">=0.0.0\");\n      }\n      d = d || e;\n      p = p || e;\n      if (o(e.semver, d.semver, r)) {\n        d = e;\n      } else {\n        if (s(e.semver, p.semver, r)) {\n          p = e;\n        }\n      }\n    });\n    if (d.operator === a || d.operator === c) return !1;\n    if ((!p.operator || p.operator === a) && i(e, p.semver)) return !1;\n    if (p.operator === c && s(e, p.semver)) return !1;\n  }\n  return !0;\n}\nre.prototype.parse = function (e) {\n  var t = this.options.loose ? o[F] : o[j],\n    n = e.match(t);\n  if (!n) throw new TypeError(\"Invalid comparator: \" + e);\n  this.operator = n[1];\n  if (\"=\" === this.operator) {\n    this.operator = \"\";\n  }\n  if (n[2]) {\n    this.semver = new SemVer(n[2], this.options.loose);\n  } else {\n    this.semver = oe;\n  }\n};\nre.prototype.toString = function () {\n  return this.value;\n};\nre.prototype.test = function (e) {\n  n(\"Comparator.test\", e, this.options.loose);\n  return (\n    this.semver === oe ||\n    (\"string\" == typeof e && (e = new SemVer(e, this.options)),\n    ne(e, this.operator, this.semver, this.options))\n  );\n};\nre.prototype.intersects = function (e, t) {\n  if (!(e instanceof re)) throw new TypeError(\"a Comparator is required\");\n  var n;\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (\"\" === this.operator)\n    return (n = new ie(e.value, t)), le(this.value, n, t);\n  if (\"\" === e.operator) {\n    n = new ie(this.value, t);\n    return le(e.semver, n, t);\n  }\n  var r = !(\n      (\">=\" !== this.operator && \">\" !== this.operator) ||\n      (\">=\" !== e.operator && \">\" !== e.operator)\n    ),\n    o = !(\n      (\"<=\" !== this.operator && \"<\" !== this.operator) ||\n      (\"<=\" !== e.operator && \"<\" !== e.operator)\n    ),\n    i = this.semver.version === e.semver.version,\n    s = !(\n      (\">=\" !== this.operator && \"<=\" !== this.operator) ||\n      (\">=\" !== e.operator && \"<=\" !== e.operator)\n    ),\n    a =\n      ne(this.semver, \"<\", e.semver, t) &&\n      (\">=\" === this.operator || \">\" === this.operator) &&\n      (\"<=\" === e.operator || \"<\" === e.operator),\n    c =\n      ne(this.semver, \">\", e.semver, t) &&\n      (\"<=\" === this.operator || \"<\" === this.operator) &&\n      (\">=\" === e.operator || \">\" === e.operator);\n  return r || o || (i && s) || a || c;\n};\nexports.Range = ie;\nie.prototype.format = function () {\n  this.range = this.set\n    .map(function (e) {\n      return e.join(\" \").trim();\n    })\n    .join(\"||\")\n    .trim();\n  return this.range;\n};\nie.prototype.toString = function () {\n  return this.range;\n};\nie.prototype.parseRange = function (e) {\n  var t = this.options.loose;\n  e = e.trim();\n  var r = t ? o[U] : o[B];\n  e = e.replace(r, ae);\n  n(\"hyphen replace\", e);\n  e = e.replace(o[q], \"$1$2$3\");\n  n(\"comparator trim\", e, o[q]);\n  e = (e = (e = e.replace(o[O], \"$1~\")).replace(o[L], \"$1^\"))\n    .split(/\\s+/)\n    .join(\" \");\n  var i = t ? o[F] : o[j],\n    s = e\n      .split(\" \")\n      .map(function (e) {\n        return (function (e, t) {\n          n(\"comp\", e, t);\n          e = (function (e, t) {\n            return e\n              .trim()\n              .split(/\\s+/)\n              .map(function (e) {\n                return (function (e, t) {\n                  n(\"caret\", e, t);\n                  var r = t.loose ? o[D] : o[$];\n                  return e.replace(r, function (t, r, o, i, s) {\n                    var a;\n                    n(\"caret\", e, t, r, o, i, s);\n                    if (se(r)) {\n                      a = \"\";\n                    } else {\n                      if (se(o)) {\n                        a = \">=\" + r + \".0.0 <\" + (+r + 1) + \".0.0\";\n                      } else {\n                        if (se(i)) {\n                          a =\n                            \"0\" === r\n                              ? \">=\" +\n                                r +\n                                \".\" +\n                                o +\n                                \".0 <\" +\n                                r +\n                                \".\" +\n                                (+o + 1) +\n                                \".0\"\n                              : \">=\" + r + \".\" + o + \".0 <\" + (+r + 1) + \".0.0\";\n                        } else {\n                          if (s) {\n                            n(\"replaceCaret pr\", s);\n                            a =\n                              \"0\" === r\n                                ? \"0\" === o\n                                  ? \">=\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    i +\n                                    \"-\" +\n                                    s +\n                                    \" <\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    (+i + 1)\n                                  : \">=\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    i +\n                                    \"-\" +\n                                    s +\n                                    \" <\" +\n                                    r +\n                                    \".\" +\n                                    (+o + 1) +\n                                    \".0\"\n                                : \">=\" +\n                                  r +\n                                  \".\" +\n                                  o +\n                                  \".\" +\n                                  i +\n                                  \"-\" +\n                                  s +\n                                  \" <\" +\n                                  (+r + 1) +\n                                  \".0.0\";\n                          } else {\n                            n(\"no pr\");\n                            a =\n                              \"0\" === r\n                                ? \"0\" === o\n                                  ? \">=\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    i +\n                                    \" <\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    (+i + 1)\n                                  : \">=\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    i +\n                                    \" <\" +\n                                    r +\n                                    \".\" +\n                                    (+o + 1) +\n                                    \".0\"\n                                : \">=\" +\n                                  r +\n                                  \".\" +\n                                  o +\n                                  \".\" +\n                                  i +\n                                  \" <\" +\n                                  (+r + 1) +\n                                  \".0.0\";\n                          }\n                        }\n                      }\n                    }\n                    n(\"caret return\", a);\n                    return a;\n                  });\n                })(e, t);\n              })\n              .join(\" \");\n          })(e, t);\n          n(\"caret\", e);\n          e = (function (e, t) {\n            return e\n              .trim()\n              .split(/\\s+/)\n              .map(function (e) {\n                return (function (e, t) {\n                  var r = t.loose ? o[R] : o[N];\n                  return e.replace(r, function (t, r, o, i, s) {\n                    var a;\n                    n(\"tilde\", e, t, r, o, i, s);\n                    if (se(r)) {\n                      a = \"\";\n                    } else {\n                      if (se(o)) {\n                        a = \">=\" + r + \".0.0 <\" + (+r + 1) + \".0.0\";\n                      } else {\n                        if (se(i)) {\n                          a =\n                            \">=\" +\n                            r +\n                            \".\" +\n                            o +\n                            \".0 <\" +\n                            r +\n                            \".\" +\n                            (+o + 1) +\n                            \".0\";\n                        } else {\n                          if (s) {\n                            n(\"replaceTilde pr\", s);\n                            a =\n                              \">=\" +\n                              r +\n                              \".\" +\n                              o +\n                              \".\" +\n                              i +\n                              \"-\" +\n                              s +\n                              \" <\" +\n                              r +\n                              \".\" +\n                              (+o + 1) +\n                              \".0\";\n                          } else {\n                            a =\n                              \">=\" +\n                              r +\n                              \".\" +\n                              o +\n                              \".\" +\n                              i +\n                              \" <\" +\n                              r +\n                              \".\" +\n                              (+o + 1) +\n                              \".0\";\n                          }\n                        }\n                      }\n                    }\n                    n(\"tilde return\", a);\n                    return a;\n                  });\n                })(e, t);\n              })\n              .join(\" \");\n          })(e, t);\n          n(\"tildes\", e);\n          e = (function (e, t) {\n            n(\"replaceXRanges\", e, t);\n            return e\n              .split(/\\s+/)\n              .map(function (e) {\n                return (function (e, t) {\n                  e = e.trim();\n                  var r = t.loose ? o[I] : o[k];\n                  return e.replace(r, function (t, r, o, i, s, a) {\n                    n(\"xRange\", e, t, r, o, i, s, a);\n                    var c = se(o),\n                      l = c || se(i),\n                      u = l || se(s);\n                    if (\"=\" === r && u) {\n                      r = \"\";\n                    }\n                    if (c) {\n                      t = \">\" === r || \"<\" === r ? \"<0.0.0\" : \"*\";\n                    } else {\n                      if (r && u) {\n                        if (l) {\n                          i = 0;\n                        }\n                        s = 0;\n                        if (\">\" === r) {\n                          r = \">=\";\n                          if (l) {\n                            o = +o + 1;\n                            i = 0;\n                            s = 0;\n                          } else {\n                            i = +i + 1;\n                            s = 0;\n                          }\n                        } else {\n                          if (\"<=\" === r) {\n                            r = \"<\";\n                            if (l) {\n                              o = +o + 1;\n                            } else {\n                              i = +i + 1;\n                            }\n                          }\n                        }\n                        t = r + o + \".\" + i + \".\" + s;\n                      } else {\n                        if (l) {\n                          t = \">=\" + o + \".0.0 <\" + (+o + 1) + \".0.0\";\n                        } else {\n                          if (u) {\n                            t =\n                              \">=\" +\n                              o +\n                              \".\" +\n                              i +\n                              \".0 <\" +\n                              o +\n                              \".\" +\n                              (+i + 1) +\n                              \".0\";\n                          }\n                        }\n                      }\n                    }\n                    n(\"xRange return\", t);\n                    return t;\n                  });\n                })(e, t);\n              })\n              .join(\" \");\n          })(e, t);\n          n(\"xrange\", e);\n          e = (function (e, t) {\n            n(\"replaceStars\", e, t);\n            return e.trim().replace(o[H], \"\");\n          })(e, t);\n          n(\"stars\", e);\n          return e;\n        })(e, this.options);\n      }, this)\n      .join(\" \")\n      .split(/\\s+/);\n  if (this.options.loose) {\n    s = s.filter(function (e) {\n      return !!e.match(i);\n    });\n  }\n  return s.map(function (e) {\n    return new re(e, this.options);\n  }, this);\n};\nie.prototype.intersects = function (e, t) {\n  if (!(e instanceof ie)) throw new TypeError(\"a Range is required\");\n  return this.set.some(function (n) {\n    return n.every(function (n) {\n      return e.set.some(function (e) {\n        return e.every(function (e) {\n          return n.intersects(e, t);\n        });\n      });\n    });\n  });\n};\nexports.toComparators = function (e, t) {\n  return new ie(e, t).set.map(function (e) {\n    return e\n      .map(function (e) {\n        return e.value;\n      })\n      .join(\" \")\n      .trim()\n      .split(\" \");\n  });\n};\nie.prototype.test = function (e) {\n  if (!e) return !1;\n  if (\"string\" == typeof e) {\n    e = new SemVer(e, this.options);\n  }\n  for (var t = 0; t < this.set.length; t++)\n    if (ce(this.set[t], e, this.options)) return !0;\n  return !1;\n};\nexports.satisfies = le;\nexports.maxSatisfying = function (e, t, n) {\n  var r = null,\n    o = null;\n  try {\n    var i = new ie(t, n);\n  } catch (e) {\n    return null;\n  }\n  e.forEach(function (e) {\n    if (i.test(e)) {\n      if (r && -1 !== o.compare(e)) {\n        o = new SemVer((r = e), n);\n      }\n    }\n  });\n  return r;\n};\nexports.minSatisfying = function (e, t, n) {\n  var r = null,\n    o = null;\n  try {\n    var i = new ie(t, n);\n  } catch (e) {\n    return null;\n  }\n  e.forEach(function (e) {\n    if (i.test(e)) {\n      if (r && 1 !== o.compare(e)) {\n        o = new SemVer((r = e), n);\n      }\n    }\n  });\n  return r;\n};\nexports.minVersion = function (e, t) {\n  e = new ie(e, t);\n  var n = new SemVer(\"0.0.0\");\n  if (e.test(n)) return n;\n  n = new SemVer(\"0.0.0-0\");\n  if (e.test(n)) return n;\n  n = null;\n  for (var r = 0; r < e.set.length; ++r)\n    e.set[r].forEach(function (e) {\n      var t = new SemVer(e.semver.version);\n      switch (e.operator) {\n        case \">\":\n          if (0 === t.prerelease.length) {\n            t.patch++;\n          } else {\n            t.prerelease.push(0);\n          }\n          t.raw = t.format();\n        case \"\":\n        case \">=\":\n          if (n && !gt(n, t)) {\n            n = t;\n          }\n          break;\n        case \"<\":\n        case \"<=\":\n          break;\n        default:\n          throw new Error(\"Unexpected operation: \" + e.operator);\n      }\n    });\n  return n && e.test(n) ? n : null;\n};\nexports.validRange = function (e, t) {\n  try {\n    return new ie(e, t).range || \"*\";\n  } catch (e) {\n    return null;\n  }\n};\nexports.ltr = function (e, t, n) {\n  return ue(e, t, \"<\", n);\n};\nexports.gtr = function (e, t, n) {\n  return ue(e, t, \">\", n);\n};\nexports.outside = ue;\nexports.prerelease = function (e, t) {\n  var n = parse(e, t);\n  return n && n.prerelease.length ? n.prerelease : null;\n};\nexports.intersects = function (e, t, n) {\n  e = new ie(e, n);\n  t = new ie(t, n);\n  return e.intersects(t);\n};\nexports.coerce = function (e) {\n  if (e instanceof SemVer) return e;\n  if (\"string\" != typeof e) return null;\n  var t = e.match(o[P]);\n  return null == t\n    ? null\n    : parse(t[1] + \".\" + (t[2] || \"0\") + \".\" + (t[3] || \"0\"));\n};",
  "2277": "require.r(exports);\nrequire.d(exports, {\n  NIL: () => x,\n  parse: () => _,\n  stringify: () => d,\n  v1: () => g,\n  v3: () => v,\n  v4: () => b,\n  v5: () => w,\n  validate: () => l,\n  version: () => E,\n});\nvar r = require(\"crypto\"),\n  o = require.n(r);\nconst i = new Uint8Array(256);\nlet s = i.length;\nfunction a() {\n  if (s > i.length - 16) {\n    o().randomFillSync(i);\n    s = 0;\n  }\n  return i.slice(s, (s += 16));\n}\nconst c =\n    /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i,\n  l = function (e) {\n    return \"string\" == typeof e && c.test(e);\n  },\n  u = [];\nfor (let e = 0; e < 256; ++e) u.push((e + 256).toString(16).substr(1));\nconst d = function (e, t = 0) {\n  const n = (\n    u[e[t + 0]] +\n    u[e[t + 1]] +\n    u[e[t + 2]] +\n    u[e[t + 3]] +\n    \"-\" +\n    u[e[t + 4]] +\n    u[e[t + 5]] +\n    \"-\" +\n    u[e[t + 6]] +\n    u[e[t + 7]] +\n    \"-\" +\n    u[e[t + 8]] +\n    u[e[t + 9]] +\n    \"-\" +\n    u[e[t + 10]] +\n    u[e[t + 11]] +\n    u[e[t + 12]] +\n    u[e[t + 13]] +\n    u[e[t + 14]] +\n    u[e[t + 15]]\n  ).toLowerCase();\n  if (!l(n)) throw TypeError(\"Stringified UUID is invalid\");\n  return n;\n};\nlet p,\n  h,\n  f = 0,\n  m = 0;\nconst g = function (e, t, n) {\n    let r = (t && n) || 0;\n    const o = t || new Array(16);\n    let i = (e = e || {}).node || p,\n      s = undefined !== e.clockseq ? e.clockseq : h;\n    if (null == i || null == s) {\n      const t = e.random || (e.rng || a)();\n      if (null == i) {\n        i = p = [1 | t[0], t[1], t[2], t[3], t[4], t[5]];\n      }\n      if (null == s) {\n        s = h = 16383 & ((t[6] << 8) | t[7]);\n      }\n    }\n    let c = undefined !== e.msecs ? e.msecs : Date.now(),\n      l = undefined !== e.nsecs ? e.nsecs : m + 1;\n    const u = c - f + (l - m) / 1e4;\n    if (u < 0 && undefined === e.clockseq) {\n      s = (s + 1) & 16383;\n    }\n    if ((u < 0 || c > f) && undefined === e.nsecs) {\n      l = 0;\n    }\n    if (l >= 1e4)\n      throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n    f = c;\n    m = l;\n    h = s;\n    c += 122192928e5;\n    const g = (1e4 * (268435455 & c) + l) % 4294967296;\n    o[r++] = (g >>> 24) & 255;\n    o[r++] = (g >>> 16) & 255;\n    o[r++] = (g >>> 8) & 255;\n    o[r++] = 255 & g;\n    const _ = ((c / 4294967296) * 1e4) & 268435455;\n    o[r++] = (_ >>> 8) & 255;\n    o[r++] = 255 & _;\n    o[r++] = ((_ >>> 24) & 15) | 16;\n    o[r++] = (_ >>> 16) & 255;\n    o[r++] = (s >>> 8) | 128;\n    o[r++] = 255 & s;\n    for (let e = 0; e < 6; ++e) o[r + e] = i[e];\n    return t || d(o);\n  },\n  _ = function (e) {\n    if (!l(e)) throw TypeError(\"Invalid UUID\");\n    let t;\n    const n = new Uint8Array(16);\n    n[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24;\n    n[1] = (t >>> 16) & 255;\n    n[2] = (t >>> 8) & 255;\n    n[3] = 255 & t;\n    n[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8;\n    n[5] = 255 & t;\n    n[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8;\n    n[7] = 255 & t;\n    n[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8;\n    n[9] = 255 & t;\n    n[10] = ((t = parseInt(e.slice(24, 36), 16)) / 1099511627776) & 255;\n    n[11] = (t / 4294967296) & 255;\n    n[12] = (t >>> 24) & 255;\n    n[13] = (t >>> 16) & 255;\n    n[14] = (t >>> 8) & 255;\n    n[15] = 255 & t;\n    return n;\n  };\nfunction y(e, t, n) {\n  function r(e, r, o, i) {\n    if (\"string\" == typeof e) {\n      e = (function (e) {\n        e = unescape(encodeURIComponent(e));\n        const t = [];\n        for (let n = 0; n < e.length; ++n) t.push(e.charCodeAt(n));\n        return t;\n      })(e);\n    }\n    if (\"string\" == typeof r) {\n      r = _(r);\n    }\n    if (16 !== r.length)\n      throw TypeError(\n        \"Namespace must be array-like (16 iterable integer values, 0-255)\"\n      );\n    let s = new Uint8Array(16 + e.length);\n    s.set(r);\n    s.set(e, r.length);\n    s = n(s);\n    s[6] = (15 & s[6]) | t;\n    s[8] = (63 & s[8]) | 128;\n    if (o) {\n      i = i || 0;\n      for (let e = 0; e < 16; ++e) o[i + e] = s[e];\n      return o;\n    }\n    return d(s);\n  }\n  try {\n    r.name = e;\n  } catch (e) {}\n  r.DNS = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\";\n  r.URL = \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\";\n  return r;\n}\nconst v = y(\"v3\", 48, function (e) {\n    if (Array.isArray(e)) {\n      e = Buffer.from(e);\n    } else {\n      if (\"string\" == typeof e) {\n        e = Buffer.from(e, \"utf8\");\n      }\n    }\n    return o().createHash(\"md5\").update(e).digest();\n  }),\n  b = function (e, t, n) {\n    const r = (e = e || {}).random || (e.rng || a)();\n    r[6] = (15 & r[6]) | 64;\n    r[8] = (63 & r[8]) | 128;\n    if (t) {\n      n = n || 0;\n      for (let e = 0; e < 16; ++e) t[n + e] = r[e];\n      return t;\n    }\n    return d(r);\n  },\n  w = y(\"v5\", 80, function (e) {\n    if (Array.isArray(e)) {\n      e = Buffer.from(e);\n    } else {\n      if (\"string\" == typeof e) {\n        e = Buffer.from(e, \"utf8\");\n      }\n    }\n    return o().createHash(\"sha1\").update(e).digest();\n  }),\n  x = \"00000000-0000-0000-0000-000000000000\",\n  E = function (e) {\n    if (!l(e)) throw TypeError(\"Invalid UUID\");\n    return parseInt(e.substr(14, 1), 16);\n  };",
  "2279": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.postRequest =\n  exports.Response =\n  exports.HelixFetcher =\n  exports.isAbortError =\n  exports.Fetcher =\n  exports.init =\n    undefined;\nconst r = require(6143),\n  o = require(5468),\n  i = require(\"util\"),\n  s = require(1133),\n  a = require(5413),\n  c = require(6333);\nlet l,\n  u = !1;\nexports.init = function (e) {\n  if (u) {\n    if (e !== l)\n      throw new Error(\n        `Networking re-initialized with mismatched version (old: ${l}, new: ${e})`\n      );\n  } else {\n    l = e;\n    u = !0;\n  }\n};\nclass Fetcher {}\nexports.Fetcher = Fetcher;\nexports.isAbortError = function (e) {\n  return e instanceof r.AbortError;\n};\nexports.HelixFetcher = class extends Fetcher {\n  constructor(e) {\n    super();\n    this.ctx = e;\n    this.createSocketFactory = (e) => {\n      const t = o.httpOverHttp({\n        proxy: e,\n      });\n      return (e) =>\n        new Promise((n) => {\n          t.createSocket(e, (e) => {\n            n(e);\n          });\n        });\n    };\n    this.fetchApi = this.createFetchApi(e);\n  }\n  set proxySettings(e) {\n    this._proxySettings = e;\n    this.fetchApi = this.createFetchApi(this.ctx);\n  }\n  get proxySettings() {\n    return this._proxySettings;\n  }\n  createFetchApi(e) {\n    var t;\n    const n = e.get(s.BuildInfo);\n    if (\n      !1 ===\n      (null === (t = this._proxySettings) || undefined === t\n        ? undefined\n        : t.rejectUnauthorized)\n    ) {\n      process.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\";\n    }\n    return r.context({\n      userAgent: `GithubCopilot/${n.getVersion()}`,\n      socketFactory: this._proxySettings\n        ? this.createSocketFactory(this._proxySettings)\n        : undefined,\n    });\n  }\n  async fetch(e, t) {\n    const n = {\n        ...t,\n        body: t.body ? t.body : t.json,\n        signal: t.signal,\n      },\n      r = await this.fetchApi.fetch(e, n);\n    return new Response(\n      r.status,\n      r.statusText,\n      r.headers,\n      () => r.text(),\n      () => r.json(),\n      async () => r.body\n    );\n  }\n  disconnectAll() {\n    return this.fetchApi.reset();\n  }\n  makeAbortController() {\n    return new r.AbortController();\n  }\n};\nclass Response {\n  constructor(e, t, n, r, o, i) {\n    this.status = e;\n    this.statusText = t;\n    this.headers = n;\n    this.getText = r;\n    this.getJson = o;\n    this.getBody = i;\n    this.ok = this.status >= 200 && this.status < 300;\n  }\n  async text() {\n    return this.getText();\n  }\n  async json() {\n    return this.getJson();\n  }\n  async body() {\n    return this.getBody();\n  }\n}\nexports.Response = Response;\nexports.postRequest = function (e, t, n, r, o, l, p) {\n  if (!u) throw new Error(\"Networking must be initialized before being used\");\n  const h = {\n    Authorization: i.format(\"Bearer %s\", n),\n    \"X-Request-Id\": o,\n    \"Openai-Organization\": \"github-copilot\",\n    \"VScode-SessionId\": e.get(s.VscInfo).sessionId,\n    \"VScode-MachineId\": e.get(s.VscInfo).machineId,\n    ...s.editorVersionHeaders(e),\n  };\n  if (r) {\n    h[\"OpenAI-Intent\"] = r;\n  }\n  const f = e.get(a.GhostTextDebounceManager).forceDelayMs;\n  if (f) {\n    h[\"X-Copilot-Force-Delay\"] = f.toString();\n  }\n  const m = {\n      method: \"POST\",\n      headers: h,\n      json: l,\n      timeout: 3e4,\n    },\n    g = e.get(Fetcher);\n  if (p) {\n    const t = g.makeAbortController();\n    p.onCancellationRequested(() => {\n      c.telemetry(\n        e,\n        \"networking.cancelRequest\",\n        c.TelemetryData.createAndMarkAsIssued({\n          headerRequestId: o,\n        })\n      );\n      t.abort();\n    });\n    m.signal = t.signal;\n  }\n  return g.fetch(t, m).catch((n) => {\n    if (\n      \"ECONNRESET\" == n.code ||\n      \"ETIMEDOUT\" == n.code ||\n      \"ERR_HTTP2_INVALID_SESSION\" == n.code ||\n      \"ERR_HTTP2_GOAWAY_SESSION\" == n.message\n    ) {\n      c.telemetry(e, \"networking.disconnectAll\");\n      return g.disconnectAll().then(() => g.fetch(t, m));\n    }\n    throw n;\n  });\n};",
  "2296": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(412),\n  o = require(3487),\n  i = require(6776),\n  s = require(6776),\n  a = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(e) {\n      const { gen: t, schema: n, data: a, parentSchema: c, it: l } = e,\n        { opts: u } = l,\n        d = r.allSchemaProperties(n),\n        p = d.filter((e) => i.alwaysValidSchema(l, n[e]));\n      if (\n        0 === d.length ||\n        (p.length === d.length && (!l.opts.unevaluated || !0 === l.props))\n      )\n        return;\n      const h = u.strictSchema && !u.allowMatchingProperties && c.properties,\n        f = t.name(\"valid\");\n      if (!0 === l.props || l.props instanceof o.Name) {\n        l.props = s.evaluatedPropsToName(t, l.props);\n      }\n      const { props: m } = l;\n      function g(e) {\n        for (const t in h)\n          if (new RegExp(e).test(t)) {\n            i.checkStrictMode(\n              l,\n              `property ${t} matches pattern ${e} (use allowMatchingProperties)`\n            );\n          }\n      }\n      function _(n) {\n        t.forIn(\"key\", a, (i) => {\n          t.if(o._`${r.usePattern(e, n)}.test(${i})`, () => {\n            const r = p.includes(n);\n            if (r) {\n              e.subschema(\n                {\n                  keyword: \"patternProperties\",\n                  schemaProp: n,\n                  dataProp: i,\n                  dataPropType: s.Type.Str,\n                },\n                f\n              );\n            }\n            if (l.opts.unevaluated && !0 !== m) {\n              t.assign(o._`${m}[${i}]`, !0);\n            } else {\n              if (r || l.allErrors) {\n                t.if(o.not(f), () => t.break());\n              }\n            }\n          });\n        });\n      }\n      !(function () {\n        for (const e of d) {\n          if (h) {\n            g(e);\n          }\n          if (l.allErrors) {\n            _(e);\n          } else {\n            t.var(f, !0);\n            _(e);\n            t.if(f);\n          }\n        }\n      })();\n    },\n  };\nexports.default = a;",
  "2301": "module.exports = {\n  i8: \"1.3.7\",\n};",
  "2337": "module.exports = function (e, t) {\n  if (!0 === t) {\n    t = 0;\n  }\n  var n = \"\";\n  if (\"string\" == typeof e)\n    try {\n      n = new URL(e).protocol;\n    } catch (e) {}\n  else if (e && e.constructor === URL) {\n    n = e.protocol;\n  }\n  var r = n.split(/\\:|\\+/).filter(Boolean);\n  return \"number\" == typeof t ? r[t] : r;\n};",
  "2388": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.launchSolutions = exports.normalizeCompletionText = undefined;\nconst r = require(2277),\n  o = require(6932),\n  i = require(1133),\n  s = require(256),\n  a = require(9899),\n  c = require(3),\n  l = require(937),\n  u = require(6722),\n  d = require(7727),\n  p = require(4969),\n  h = require(2533),\n  f = require(766),\n  m = require(1124),\n  g = require(6333),\n  _ = require(6403),\n  y = new a.Logger(a.LogLevel.INFO, \"solutions\");\nfunction v(e, t, n, r) {\n  return async (o) => {\n    if (r instanceof Array) {\n      const [i, s] = r;\n      return d.isBlockBodyFinishedWithPrefix(e, t, n, o, s);\n    }\n    return d.isBlockBodyFinished(e, t, n, o);\n  };\n}\nasync function b(e, t, n) {\n  if (t.isCancellationRequested) {\n    e.removeProgress();\n    return {\n      status: \"FinishedWithError\",\n      error: \"Cancelled\",\n    };\n  }\n  const r = await n.next();\n  return !0 === r.done\n    ? (e.removeProgress(),\n      {\n        status: \"FinishedNormally\",\n      })\n    : {\n        status: \"Solution\",\n        solution: r.value,\n        next: b(e, t, n),\n      };\n}\nexports.normalizeCompletionText = function (e) {\n  return e.replace(/\\s+/g, \"\");\n};\nexports.launchSolutions = async function (e, t) {\n  var n, a, w;\n  const x = t.completionContext.insertPosition,\n    E = t.completionContext.prependToCompletion,\n    C = t.completionContext.indentation,\n    S = e.get(_.LocationFactory),\n    T = await t.getDocument(),\n    k = await p.extractPrompt(e, T, x);\n  if (\"contextTooShort\" === k.type) {\n    t.reportCancelled();\n    return {\n      status: \"FinishedWithError\",\n      error: \"Context too short\",\n    };\n  }\n  const I = k.prompt,\n    P = k.trailingWs;\n  if (P.length > 0) {\n    t.startPosition = S.position(\n      t.startPosition.line,\n      t.startPosition.character - P.length\n    );\n  }\n  const A = t.getCancellationToken(),\n    O = r.v4();\n  t.savedTelemetryData = g.TelemetryData.createAndMarkAsIssued(\n    {\n      headerRequestId: O,\n      languageId: T.languageId,\n      source: s.completionTypeToString(t.completionContext.completionType),\n    },\n    {\n      ...g.telemetrizePromptLength(I),\n      solutionCount: t.solutionCountTarget,\n      promptEndPos: T.offsetAt(x),\n    }\n  );\n  if (t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX) {\n    const e = I.prefix.split(\"\\n\"),\n      t = e.pop(),\n      n = e.pop();\n    if (n) {\n      const r = /^\\W+(todo:?\\s+)/i.exec(n);\n      if (r) {\n        const o = r[1],\n          i = n.replace(o, \"\");\n        I.prefix = e.join(\"\\n\") + \"\\n\" + i + \"\\n\" + t;\n      }\n    }\n  }\n  if (\n    t.completionContext.completionType ===\n    s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX\n  ) {\n    I.prefix += t.completionContext.prependToCompletion;\n  }\n  y.info(e, `prompt: ${JSON.stringify(I)}`);\n  y.debug(e, `prependToCompletion: ${E}`);\n  g.telemetry(e, \"solution.requested\", t.savedTelemetryData);\n  const N = await e.get(i.BlockModeConfig).forLanguage(e, T.languageId),\n    R = h.isSupportedLanguageId(T.languageId),\n    M = d.contextIndentation(T, x),\n    L = {\n      stream: !0,\n      extra: {\n        language: T.languageId,\n        next_indent: null !== (n = M.next) && undefined !== n ? n : 0,\n      },\n    };\n  if (\"parsing\" !== N || R) {\n    L.stop = [\"\\n\\n\", \"\\r\\n\\r\\n\"];\n  }\n  const $ = f.extractRepoInfoInBackground(e, T.fileName),\n    D = {\n      prompt: I,\n      languageId: T.languageId,\n      repoInfo: $,\n      ourRequestId: O,\n      engineUrl: await c.getEngineURL(\n        e,\n        f.tryGetGitHubNWO($),\n        T.languageId,\n        f.getDogFood($),\n        await f.getUserKind(e),\n        t.savedTelemetryData\n      ),\n      count: t.solutionCountTarget,\n      uiKind: l.CopilotUiKind.Panel,\n      postOptions: L,\n      requestLogProbs: !0,\n    };\n  let F;\n  const j =\n    t.completionContext.completionType ===\n    s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX\n      ? [\n          s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX,\n          t.completionContext.prependToCompletion,\n        ]\n      : t.completionContext.completionType;\n  switch (N) {\n    case i.BlockMode.Server:\n      F = async (e) => {};\n      L.extra.force_indent = null !== (a = M.prev) && undefined !== a ? a : -1;\n      L.extra.trim_by_indentation = !0;\n      break;\n    case i.BlockMode.ParsingAndServer:\n      F = R ? v(e, T, t.startPosition, j) : async (e) => {};\n      L.extra.force_indent = null !== (w = M.prev) && undefined !== w ? w : -1;\n      L.extra.trim_by_indentation = !0;\n      break;\n    case i.BlockMode.Parsing:\n    default:\n      F = R ? v(e, T, t.startPosition, j) : async (e) => {};\n  }\n  e.get(u.StatusReporter).setProgress();\n  const q = await e\n    .get(l.OpenAIFetcher)\n    .fetchAndStreamCompletions(\n      e,\n      D,\n      g.TelemetryData.createAndMarkAsIssued(),\n      F,\n      A\n    );\n  if (\"failed\" === q.type || \"canceled\" === q.type) {\n    t.reportCancelled();\n    e.get(u.StatusReporter).removeProgress();\n    return {\n      status: \"FinishedWithError\",\n      error: `${q.type}: ${q.reason}`,\n    };\n  }\n  let B = q.choices;\n  B = (async function* (e, t) {\n    for await (const n of e) {\n      const e = {\n        ...n,\n      };\n      e.completionText = t + e.completionText.trimRight();\n      yield e;\n    }\n  })(B, E);\n  if (null !== C) {\n    B = l.cleanupIndentChoices(B, C);\n  }\n  B = o.asyncIterableMapFilter(B, async (t) =>\n    m.postProcessChoice(e, \"solution\", T, x, t, !1, y)\n  );\n  const U = o.asyncIterableMapFilter(B, async (n) => {\n    let r = n.completionText;\n    y.info(e, `Open Copilot completion: [${n.completionText}]`);\n    if (\n      t.completionContext.completionType === s.CompletionType.OPEN_COPILOT ||\n      t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX\n    ) {\n      let t = \"\";\n      const o = await (0, d.getNodeStart)(e, T, x, n.completionText);\n      if (o)\n        [t] = (0, p.trimLastLine)(\n          T.getText(S.range(S.position(o.line, o.character), x))\n        );\n      else {\n        const e = S.position(x.line, 0);\n        t = T.getText(S.range(e, x));\n      }\n      r = t + r;\n    }\n    let o = n.completionText;\n    if (\n      t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX\n    ) {\n      if (T.lineAt(x.line).isEmptyOrWhitespace) {\n        o += \"\\n\";\n      }\n    }\n    if (P.length > 0 && o.startsWith(P)) {\n      o = o.substring(P.length);\n    }\n    const i = n.meanLogProb;\n    return {\n      displayText: r,\n      meanProb: undefined !== i ? Math.exp(i) : 0,\n      meanLogProb: i || 0,\n      completionText: o,\n      requestId: n.requestId,\n      choiceIndex: n.choiceIndex,\n      prependToCompletion: E,\n    };\n  });\n  return b(e.get(u.StatusReporter), A, U[Symbol.asyncIterator]());\n};",
  "2422": "var r;\nr = require(8249);\n(function () {\n  if (\"function\" == typeof ArrayBuffer) {\n    var e = r.lib.WordArray,\n      t = e.init,\n      n = (e.init = function (e) {\n        if (e instanceof ArrayBuffer) {\n          e = new Uint8Array(e);\n        }\n        if (\n          e instanceof Int8Array ||\n          (\"undefined\" != typeof Uint8ClampedArray &&\n            e instanceof Uint8ClampedArray) ||\n          e instanceof Int16Array ||\n          e instanceof Uint16Array ||\n          e instanceof Int32Array ||\n          e instanceof Uint32Array ||\n          e instanceof Float32Array ||\n          e instanceof Float64Array\n        ) {\n          e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength);\n        }\n        if (e instanceof Uint8Array) {\n          for (var n = e.byteLength, r = [], o = 0; o < n; o++)\n            r[o >>> 2] |= e[o] << (24 - (o % 4) * 8);\n          t.call(this, r, n);\n        } else t.apply(this, arguments);\n      });\n    n.prototype = e;\n  }\n})();\nmodule.exports = r.lib.WordArray;",
  "2447": "module.exports = function (e) {\n  function t(e) {\n    let n,\n      o,\n      i,\n      s = null;\n    function a(...e) {\n      if (!a.enabled) return;\n      const r = a,\n        o = Number(new Date()),\n        i = o - (n || o);\n      r.diff = i;\n      r.prev = n;\n      r.curr = o;\n      n = o;\n      e[0] = t.coerce(e[0]);\n      if (\"string\" != typeof e[0]) {\n        e.unshift(\"%O\");\n      }\n      let s = 0;\n      e[0] = e[0].replace(/%([a-zA-Z%])/g, (n, o) => {\n        if (\"%%\" === n) return \"%\";\n        s++;\n        const i = t.formatters[o];\n        if (\"function\" == typeof i) {\n          const t = e[s];\n          n = i.call(r, t);\n          e.splice(s, 1);\n          s--;\n        }\n        return n;\n      });\n      t.formatArgs.call(r, e);\n      (r.log || t.log).apply(r, e);\n    }\n    a.namespace = e;\n    a.useColors = t.useColors();\n    a.color = t.selectColor(e);\n    a.extend = r;\n    a.destroy = t.destroy;\n    Object.defineProperty(a, \"enabled\", {\n      enumerable: !0,\n      configurable: !1,\n      get: () =>\n        null !== s\n          ? s\n          : (o !== t.namespaces && ((o = t.namespaces), (i = t.enabled(e))), i),\n      set: (e) => {\n        s = e;\n      },\n    });\n    if (\"function\" == typeof t.init) {\n      t.init(a);\n    }\n    return a;\n  }\n  function r(e, n) {\n    const r = t(this.namespace + (undefined === n ? \":\" : n) + e);\n    r.log = this.log;\n    return r;\n  }\n  function o(e) {\n    return e\n      .toString()\n      .substring(2, e.toString().length - 2)\n      .replace(/\\.\\*\\?$/, \"*\");\n  }\n  t.debug = t;\n  t.default = t;\n  t.coerce = function (e) {\n    return e instanceof Error ? e.stack || e.message : e;\n  };\n  t.disable = function () {\n    const e = [...t.names.map(o), ...t.skips.map(o).map((e) => \"-\" + e)].join(\n      \",\"\n    );\n    t.enable(\"\");\n    return e;\n  };\n  t.enable = function (e) {\n    let n;\n    t.save(e);\n    t.namespaces = e;\n    t.names = [];\n    t.skips = [];\n    const r = (\"string\" == typeof e ? e : \"\").split(/[\\s,]+/),\n      o = r.length;\n    for (n = 0; n < o; n++)\n      if (r[n]) {\n        if (\"-\" === (e = r[n].replace(/\\*/g, \".*?\"))[0]) {\n          t.skips.push(new RegExp(\"^\" + e.slice(1) + \"$\"));\n        } else {\n          t.names.push(new RegExp(\"^\" + e + \"$\"));\n        }\n      }\n  };\n  t.enabled = function (e) {\n    if (\"*\" === e[e.length - 1]) return !0;\n    let n, r;\n    for (n = 0, r = t.skips.length; n < r; n++)\n      if (t.skips[n].test(e)) return !1;\n    for (n = 0, r = t.names.length; n < r; n++)\n      if (t.names[n].test(e)) return !0;\n    return !1;\n  };\n  t.humanize = require(7824);\n  t.destroy = function () {\n    console.warn(\n      \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"\n    );\n  };\n  Object.keys(e).forEach((n) => {\n    t[n] = e[n];\n  });\n  t.names = [];\n  t.skips = [];\n  t.formatters = {};\n  t.selectColor = function (e) {\n    let n = 0;\n    for (let t = 0; t < e.length; t++) {\n      n = (n << 5) - n + e.charCodeAt(t);\n      n |= 0;\n    }\n    return t.colors[Math.abs(n) % t.colors.length];\n  };\n  t.enable(t.load());\n  return t;\n};",
  "2495": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r = require(4953),\n  o = require(\"stream\");\nexports.console = {\n  versionSpecifier: \">= 4.0.0\",\n  patch: function (e) {\n    var t = new o.Writable(),\n      n = new o.Writable();\n    t.write = function (e) {\n      if (!e) return !0;\n      var t = e.toString();\n      r.channel.publish(\"console\", {\n        message: t,\n      });\n      return !0;\n    };\n    n.write = function (e) {\n      if (!e) return !0;\n      var t = e.toString();\n      r.channel.publish(\"console\", {\n        message: t,\n        stderr: !0,\n      });\n      return !0;\n    };\n    for (\n      var i = new e.Console(t, n),\n        s = function (t) {\n          var n = e[t];\n          if (n) {\n            e[t] = function () {\n              if (i[t])\n                try {\n                  i[t].apply(i, arguments);\n                } catch (e) {}\n              return n.apply(e, arguments);\n            };\n          }\n        },\n        a = 0,\n        c = [\n          \"log\",\n          \"info\",\n          \"warn\",\n          \"error\",\n          \"dir\",\n          \"time\",\n          \"timeEnd\",\n          \"trace\",\n          \"assert\",\n        ];\n      a < c.length;\n      a++\n    )\n      s(c[a]);\n    return e;\n  },\n};\nexports.enable = function () {\n  r.channel.registerMonkeyPatch(\"console\", exports.console);\n  require(\"console\");\n};",
  "2499": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.redactPaths = undefined;\nexports.redactPaths = function (e) {\n  return e\n    .replace(/([\\s|(]|file:\\/\\/)(\\/[^\\s]+)/g, \"$1[redacted]\")\n    .replace(\n      /([\\s|(]|file:\\/\\/)([a-zA-Z]:[(\\\\|/){1,2}][^\\s]+)/gi,\n      \"$1[redacted]\"\n    )\n    .replace(/([\\s|(]|file:\\/\\/)(\\\\[^\\s]+)/gi, \"$1[redacted]\");\n};",
  "2500": "const { Readable: r } = require(\"stream\"),\n  { Headers: o } = require(9872),\n  { Response: i } = require(2981),\n  s = Symbol(\"CacheableResponse internals\");\nclass a extends i {\n  constructor(e, t) {\n    super(e, t);\n    const n = new o(t.headers);\n    this[s] = {\n      headers: n,\n      bufferedBody: e,\n    };\n  }\n  get headers() {\n    return this[s].headers;\n  }\n  set headers(e) {\n    if (!(e instanceof o)) throw new TypeError(\"instance of Headers expected\");\n    this[s].headers = e;\n  }\n  get body() {\n    return r.from(this[s].bufferedBody);\n  }\n  get bodyUsed() {\n    return !1;\n  }\n  async buffer() {\n    return this[s].bufferedBody;\n  }\n  async arrayBuffer() {\n    return (e = this[s].bufferedBody).buffer.slice(\n      e.byteOffset,\n      e.byteOffset + e.byteLength\n    );\n    var e;\n  }\n  async text() {\n    return this[s].bufferedBody.toString();\n  }\n  async json() {\n    return JSON.parse(await this.text());\n  }\n  clone() {\n    const {\n      url: e,\n      status: t,\n      statusText: n,\n      headers: r,\n      httpVersion: o,\n      decoded: i,\n      counter: c,\n    } = this;\n    return new a(this[s].bufferedBody, {\n      url: e,\n      status: t,\n      statusText: n,\n      headers: r,\n      httpVersion: o,\n      decoded: i,\n      counter: c,\n    });\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\nmodule.exports = {\n  cacheableResponse: async (e) => {\n    const t = await e.buffer(),\n      {\n        url: n,\n        status: r,\n        statusText: o,\n        headers: i,\n        httpVersion: s,\n        decoded: c,\n        counter: l,\n      } = e;\n    return new a(t, {\n      url: n,\n      status: r,\n      statusText: o,\n      headers: i,\n      httpVersion: s,\n      decoded: c,\n      counter: l,\n    });\n  },\n};",
  "2512": "if (global._stackChain) {\n  if (global._stackChain.version !== require(2301).i8)\n    throw new Error(\"Conflicting version of stack-chain found\");\n  module.exports = global._stackChain;\n} else module.exports = global._stackChain = require(7898);",
  "2531": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getSchemaRefs =\n  exports.resolveUrl =\n  exports.normalizeId =\n  exports._getFullPath =\n  exports.getFullPath =\n  exports.inlineRef =\n    undefined;\nconst r = require(6776),\n  o = require(4063),\n  i = require(9461),\n  s = require(540),\n  a = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\",\n  ]);\nexports.inlineRef = function (e, t = !0) {\n  return \"boolean\" == typeof e || (!0 === t ? !l(e) : !!t && u(e) <= t);\n};\nconst c = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n]);\nfunction l(e) {\n  for (const t in e) {\n    if (c.has(t)) return !0;\n    const n = e[t];\n    if (Array.isArray(n) && n.some(l)) return !0;\n    if (\"object\" == typeof n && l(n)) return !0;\n  }\n  return !1;\n}\nfunction u(e) {\n  let t = 0;\n  for (const n in e) {\n    if (\"$ref\" === n) return 1 / 0;\n    t++;\n    if (\n      !a.has(n) &&\n      (\"object\" == typeof e[n] && (0, r.eachItem)(e[n], (e) => (t += u(e))),\n      t === 1 / 0)\n    )\n      return 1 / 0;\n  }\n  return t;\n}\nfunction getFullPath(e = \"\", t) {\n  if (!1 !== t) {\n    e = normalizeId(e);\n  }\n  return _getFullPath(s.parse(e));\n}\nfunction _getFullPath(e) {\n  return s.serialize(e).split(\"#\")[0] + \"#\";\n}\nexports.getFullPath = getFullPath;\nexports._getFullPath = _getFullPath;\nconst h = /#\\/?$/;\nfunction normalizeId(e) {\n  return e ? e.replace(h, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nexports.resolveUrl = function (e, t) {\n  t = normalizeId(t);\n  return s.resolve(e, t);\n};\nconst m = /^[a-z_][-a-z0-9._]*$/i;\nexports.getSchemaRefs = function (e, t) {\n  if (\"boolean\" == typeof e) return {};\n  const { schemaId: n } = this.opts,\n    r = normalizeId(e[n] || t),\n    a = {\n      \"\": r,\n    },\n    c = getFullPath(r, !1),\n    l = {},\n    u = new Set();\n  i(\n    e,\n    {\n      allKeys: !0,\n    },\n    (e, t, r, o) => {\n      if (undefined === o) return;\n      const i = c + t;\n      let d = a[o];\n      function g(t) {\n        t = normalizeId(d ? s.resolve(d, t) : t);\n        if (u.has(t)) throw h(t);\n        u.add(t);\n        let n = this.refs[t];\n        if (\"string\" == typeof n) {\n          n = this.refs[n];\n        }\n        if (\"object\" == typeof n) {\n          p(e, n.schema, t);\n        } else {\n          if (t !== normalizeId(i)) {\n            if (\"#\" === t[0]) {\n              p(e, l[t], t);\n              l[t] = e;\n            } else {\n              this.refs[t] = i;\n            }\n          }\n        }\n        return t;\n      }\n      function _(e) {\n        if (\"string\" == typeof e) {\n          if (!m.test(e)) throw new Error(`invalid anchor \"${e}\"`);\n          g.call(this, `#${e}`);\n        }\n      }\n      if (\"string\" == typeof e[n]) {\n        d = g.call(this, e[n]);\n      }\n      _.call(this, e.$anchor);\n      _.call(this, e.$dynamicAnchor);\n      a[t] = d;\n    }\n  );\n  return l;\n  function p(e, t, n) {\n    if (undefined !== t && !o(e, t)) throw h(n);\n  }\n  function h(e) {\n    return new Error(`reference \"${e}\" resolves to more than one schema`);\n  }\n};",
  "2533": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.parsesWithoutError =\n  exports.getPrompt =\n  exports.getNodeStart =\n  exports.getFunctionPositions =\n  exports.getBlockCloseToken =\n  exports.isSupportedLanguageId =\n  exports.isBlockBodyFinished =\n  exports.isEmptyBlockStart =\n  exports.terminate =\n  exports.init =\n    undefined;\nconst r = require(3055563);\nlet o = null;\nconst i = new Map();\nlet s = 0;\nexports.init = function (t, u, d) {\n  if (!u) {\n    const t = require(4723);\n    for (const n of [...a, ...c]) module.exports[n] = t[n];\n    return;\n  }\n  for (const n of a) module.exports[n] = l(t, d, n);\n  module.exports.getPrompt = (function (e, t) {\n    return function (n, ...r) {\n      const a = s++;\n      return new Promise((n, s) => {\n        i.set(a, {\n          resolve: n,\n          reject: s,\n        });\n        t.debug(e, `Proxy getPrompt - ${a}`);\n        if (null == o) {\n          o.postMessage({\n            id: a,\n            fn: \"getPrompt\",\n            args: r,\n          });\n        }\n      });\n    };\n  })(t, d);\n  o = r.createWorker();\n  i.clear();\n  s = 0;\n  const p = t.get(r.FileSystem);\n  function h(e) {\n    d.error(t, e);\n    for (const t of i.values()) t.reject(e);\n    i.clear();\n  }\n  o.on(\"message\", ({ id: e, err: n, res: r }) => {\n    const o = i.get(e);\n    d.debug(t, `Response ${e} - ${r}, ${n}`);\n    if (o) {\n      i.delete(e);\n      if (n) {\n        o.reject(n);\n      } else {\n        o.resolve(r);\n      }\n    }\n  });\n  o.on(\"error\", h);\n  o.on(\"exit\", (e) => {\n    if (0 !== e) {\n      h(new Error(`Worker thread exited with code ${e}.`));\n    }\n  });\n  o.on(\"readFileReq\", (e) => {\n    d.debug(t, `READ_FILE_REQ - ${e}`);\n    p.readFile(e)\n      .then((e) => {\n        if (null == o) {\n          o.emit(\"readFileRes\", e);\n        }\n      })\n      .catch(h);\n  });\n  o.on(\"mtimeRes\", (e) => {\n    d.debug(t, `mTime_REQ - ${e}`);\n    p.mtime(e)\n      .then((e) => {\n        if (null == o) {\n          o.emit(\"mtimeRes\", e);\n        }\n      })\n      .catch(h);\n  });\n};\nexports.terminate = function () {\n  if (o) {\n    o.removeAllListeners();\n    o.terminate();\n    o = null;\n    i.clear();\n  }\n};\nconst a = [\n    \"getFunctionPositions\",\n    \"isEmptyBlockStart\",\n    \"isBlockBodyFinished\",\n    \"getNodeStart\",\n    \"parsesWithoutError\",\n  ],\n  c = [\"isSupportedLanguageId\", \"getBlockCloseToken\"];\nfunction l(e, t, n) {\n  return function (...r) {\n    const a = s++;\n    return new Promise((s, c) => {\n      i.set(a, {\n        resolve: s,\n        reject: c,\n      });\n      t.debug(e, `Proxy ${n}`);\n      if (null == o) {\n        o.postMessage({\n          id: a,\n          fn: n,\n          args: r,\n        });\n      }\n    });\n  };\n}\nexports.isEmptyBlockStart = r.isEmptyBlockStart;\nexports.isBlockBodyFinished = r.isBlockBodyFinished;\nexports.isSupportedLanguageId = r.isSupportedLanguageId;\nexports.getBlockCloseToken = r.getBlockCloseToken;\nexports.getFunctionPositions = r.getFunctionPositions;\nexports.getNodeStart = r.getNodeStart;\nexports.getPrompt = r.getPrompt;\nexports.parsesWithoutError = r.parsesWithoutError;",
  "2588": "var r = require(\"fs\"),\n  o = require(\"os\"),\n  i = require(\"path\"),\n  s = require(\"zlib\"),\n  a = require(\"child_process\"),\n  c = require(5282),\n  l = require(8723),\n  u = require(5740),\n  d = (function () {\n    function e(t, n, o) {\n      this._config = t;\n      this._onSuccess = n;\n      this._onError = o;\n      this._enableDiskRetryMode = !1;\n      this._resendInterval = e.WAIT_BETWEEN_RESEND;\n      this._maxBytesOnDisk = e.MAX_BYTES_ON_DISK;\n      this._numConsecutiveFailures = 0;\n      if (!e.OS_PROVIDES_FILE_PROTECTION)\n        if (e.USE_ICACLS) {\n          try {\n            e.OS_PROVIDES_FILE_PROTECTION = r.existsSync(e.ICACLS_PATH);\n          } catch (e) {}\n          e.OS_PROVIDES_FILE_PROTECTION ||\n            c.warn(\n              e.TAG,\n              \"Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.\"\n            );\n        } else e.OS_PROVIDES_FILE_PROTECTION = !0;\n    }\n    e.prototype.setDiskRetryMode = function (t, n, r) {\n      this._enableDiskRetryMode = e.OS_PROVIDES_FILE_PROTECTION && t;\n      if (\"number\" == typeof n && n >= 0) {\n        this._resendInterval = Math.floor(n);\n      }\n      if (\"number\" == typeof r && r >= 0) {\n        this._maxBytesOnDisk = Math.floor(r);\n      }\n      if (t && !e.OS_PROVIDES_FILE_PROTECTION) {\n        this._enableDiskRetryMode = !1;\n        c.warn(\n          e.TAG,\n          \"Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.\"\n        );\n      }\n    };\n    e.prototype.send = function (t, n) {\n      var r = this,\n        o = this._config.endpointUrl,\n        i = {\n          method: \"POST\",\n          withCredentials: !1,\n          headers: {\n            \"Content-Type\": \"application/x-json-stream\",\n          },\n        };\n      s.gzip(t, function (s, a) {\n        var d = a;\n        if (s) {\n          c.warn(s);\n          d = t;\n          i.headers[\"Content-Length\"] = t.length.toString();\n        } else {\n          i.headers[\"Content-Encoding\"] = \"gzip\";\n          i.headers[\"Content-Length\"] = a.length;\n        }\n        c.info(e.TAG, i);\n        i[l.disableCollectionRequestOption] = !0;\n        var p = u.makeRequest(r._config, o, i, function (o) {\n          o.setEncoding(\"utf-8\");\n          var i = \"\";\n          o.on(\"data\", function (e) {\n            i += e;\n          });\n          o.on(\"end\", function () {\n            r._numConsecutiveFailures = 0;\n            c.info(e.TAG, i);\n            if (\"function\" == typeof r._onSuccess) {\n              r._onSuccess(i);\n            }\n            if (\"function\" == typeof n) {\n              n(i);\n            }\n            if (r._enableDiskRetryMode) {\n              if (200 === o.statusCode) {\n                setTimeout(function () {\n                  return r._sendFirstFileOnDisk();\n                }, r._resendInterval).unref();\n              } else {\n                if (\n                  408 !== o.statusCode &&\n                  429 !== o.statusCode &&\n                  439 !== o.statusCode &&\n                  500 !== o.statusCode &&\n                  503 !== o.statusCode\n                ) {\n                  r._storeToDisk(t);\n                }\n              }\n            }\n          });\n        });\n        p.on(\"error\", function (o) {\n          r._numConsecutiveFailures++;\n          if (\n            !r._enableDiskRetryMode ||\n            (r._numConsecutiveFailures > 0 &&\n              r._numConsecutiveFailures %\n                e.MAX_CONNECTION_FAILURES_BEFORE_WARN ==\n                0)\n          ) {\n            var i =\n              \"Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:\";\n            r._enableDiskRetryMode &&\n              (i =\n                \"Ingestion endpoint could not be reached \" +\n                r._numConsecutiveFailures +\n                \" consecutive times. There may be resulting telemetry loss. Most recent error:\"),\n              c.warn(e.TAG, i, o);\n          } else (i = \"Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:\"), c.info(e.TAG, i, o);\n          r._onErrorHelper(o);\n          if (\"function\" == typeof n) {\n            var s = \"error sending telemetry\";\n            o && \"function\" == typeof o.toString && (s = o.toString()), n(s);\n          }\n          if (r._enableDiskRetryMode) {\n            r._storeToDisk(t);\n          }\n        });\n        p.write(d);\n        p.end();\n      });\n    };\n    e.prototype.saveOnCrash = function (e) {\n      if (this._enableDiskRetryMode) {\n        this._storeToDiskSync(e);\n      }\n    };\n    e.prototype._runICACLS = function (t, n) {\n      var r = a.spawn(e.ICACLS_PATH, t, {\n        windowsHide: !0,\n      });\n      r.on(\"error\", function (e) {\n        return n(e);\n      });\n      r.on(\"close\", function (e, t) {\n        return n(\n          0 === e\n            ? null\n            : new Error(\n                \"Setting ACL restrictions did not succeed (ICACLS returned code \" +\n                  e +\n                  \")\"\n              )\n        );\n      });\n    };\n    e.prototype._runICACLSSync = function (t) {\n      if (!a.spawnSync)\n        throw new Error(\n          \"Could not synchronously call ICACLS under current version of Node.js\"\n        );\n      var n = a.spawnSync(e.ICACLS_PATH, t, {\n        windowsHide: !0,\n      });\n      if (n.error) throw n.error;\n      if (0 !== n.status)\n        throw new Error(\n          \"Setting ACL restrictions did not succeed (ICACLS returned code \" +\n            n.status +\n            \")\"\n        );\n    };\n    e.prototype._getACLIdentity = function (t) {\n      if (e.ACL_IDENTITY) return t(null, e.ACL_IDENTITY);\n      var n = a.spawn(\n          e.POWERSHELL_PATH,\n          [\n            \"-Command\",\n            \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\",\n          ],\n          {\n            windowsHide: !0,\n            stdio: [\"ignore\", \"pipe\", \"pipe\"],\n          }\n        ),\n        r = \"\";\n      n.stdout.on(\"data\", function (e) {\n        return (r += e);\n      });\n      n.on(\"error\", function (e) {\n        return t(e, null);\n      });\n      n.on(\"close\", function (n, o) {\n        e.ACL_IDENTITY = r && r.trim();\n        return t(\n          0 === n\n            ? null\n            : new Error(\n                \"Getting ACL identity did not succeed (PS returned code \" +\n                  n +\n                  \")\"\n              ),\n          e.ACL_IDENTITY\n        );\n      });\n    };\n    e.prototype._getACLIdentitySync = function () {\n      if (e.ACL_IDENTITY) return e.ACL_IDENTITY;\n      if (a.spawnSync) {\n        var t = a.spawnSync(\n          e.POWERSHELL_PATH,\n          [\n            \"-Command\",\n            \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\",\n          ],\n          {\n            windowsHide: !0,\n            stdio: [\"ignore\", \"pipe\", \"pipe\"],\n          }\n        );\n        if (t.error) throw t.error;\n        if (0 !== t.status)\n          throw new Error(\n            \"Getting ACL identity did not succeed (PS returned code \" +\n              t.status +\n              \")\"\n          );\n        e.ACL_IDENTITY = t.stdout && t.stdout.toString().trim();\n        return e.ACL_IDENTITY;\n      }\n      throw new Error(\n        \"Could not synchronously get ACL identity under current version of Node.js\"\n      );\n    };\n    e.prototype._getACLArguments = function (e, t) {\n      return [\n        e,\n        \"/grant\",\n        \"*S-1-5-32-544:(OI)(CI)F\",\n        \"/grant\",\n        t + \":(OI)(CI)F\",\n        \"/inheritance:r\",\n      ];\n    };\n    e.prototype._applyACLRules = function (t, n) {\n      var r = this;\n      return e.USE_ICACLS\n        ? undefined !== e.ACLED_DIRECTORIES[t]\n          ? n(\n              e.ACLED_DIRECTORIES[t]\n                ? null\n                : new Error(\n                    \"Setting ACL restrictions did not succeed (cached result)\"\n                  )\n            )\n          : ((e.ACLED_DIRECTORIES[t] = !1),\n            void this._getACLIdentity(function (o, i) {\n              if (o) {\n                e.ACLED_DIRECTORIES[t] = !1;\n                return n(o);\n              }\n              r._runICACLS(r._getACLArguments(t, i), function (r) {\n                e.ACLED_DIRECTORIES[t] = !r;\n                return n(r);\n              });\n            }))\n        : n(null);\n    };\n    e.prototype._applyACLRulesSync = function (t) {\n      if (e.USE_ICACLS) {\n        if (undefined === e.ACLED_DIRECTORIES[t]) {\n          this._runICACLSSync(\n            this._getACLArguments(t, this._getACLIdentitySync())\n          );\n          return void (e.ACLED_DIRECTORIES[t] = !0);\n        }\n        if (!e.ACLED_DIRECTORIES[t])\n          throw new Error(\n            \"Setting ACL restrictions did not succeed (cached result)\"\n          );\n      }\n    };\n    e.prototype._confirmDirExists = function (e, t) {\n      var n = this;\n      r.lstat(e, function (o, i) {\n        if (o && \"ENOENT\" === o.code) {\n          r.mkdir(e, function (r) {\n            if (r && \"EEXIST\" !== r.code) {\n              t(r);\n            } else {\n              n._applyACLRules(e, t);\n            }\n          });\n        } else {\n          if (!o && i.isDirectory()) {\n            n._applyACLRules(e, t);\n          } else {\n            t(o || new Error(\"Path existed but was not a directory\"));\n          }\n        }\n      });\n    };\n    e.prototype._getShallowDirectorySize = function (e, t) {\n      r.readdir(e, function (n, o) {\n        if (n) return t(n, -1);\n        var s = null,\n          a = 0,\n          c = 0;\n        if (0 !== o.length)\n          for (var l = 0; l < o.length; l++)\n            r.stat(i.join(e, o[l]), function (e, n) {\n              c++;\n              if (e) {\n                s = e;\n              } else {\n                if (n.isFile()) {\n                  a += n.size;\n                }\n              }\n              if (c === o.length) {\n                t(s, s ? -1 : a);\n              }\n            });\n        else t(null, 0);\n      });\n    };\n    e.prototype._getShallowDirectorySizeSync = function (e) {\n      for (var t = r.readdirSync(e), n = 0, o = 0; o < t.length; o++)\n        n += r.statSync(i.join(e, t[o])).size;\n      return n;\n    };\n    e.prototype._storeToDisk = function (t) {\n      var n = this,\n        s = i.join(\n          o.tmpdir(),\n          e.TEMPDIR_PREFIX + this._config.instrumentationKey\n        );\n      c.info(e.TAG, \"Checking existance of data storage directory: \" + s);\n      this._confirmDirExists(s, function (o) {\n        if (o) {\n          c.warn(\n            e.TAG,\n            \"Error while checking/creating directory: \" + (o && o.message)\n          );\n          return void n._onErrorHelper(o);\n        }\n        n._getShallowDirectorySize(s, function (o, a) {\n          if (o || a < 0) {\n            c.warn(\n              e.TAG,\n              \"Error while checking directory size: \" + (o && o.message)\n            );\n            return void n._onErrorHelper(o);\n          }\n          if (a > n._maxBytesOnDisk)\n            c.warn(\n              e.TAG,\n              \"Not saving data due to max size limit being met. Directory size in bytes is: \" +\n                a\n            );\n          else {\n            var l = new Date().getTime() + \".ai.json\",\n              u = i.join(s, l);\n            c.info(e.TAG, \"saving data to disk at: \" + u);\n            r.writeFile(\n              u,\n              t,\n              {\n                mode: 384,\n              },\n              function (e) {\n                return n._onErrorHelper(e);\n              }\n            );\n          }\n        });\n      });\n    };\n    e.prototype._storeToDiskSync = function (t) {\n      var n = i.join(\n        o.tmpdir(),\n        e.TEMPDIR_PREFIX + this._config.instrumentationKey\n      );\n      try {\n        c.info(e.TAG, \"Checking existance of data storage directory: \" + n);\n        if (r.existsSync(n)) {\n          r.mkdirSync(n);\n        }\n        this._applyACLRulesSync(n);\n        var s = this._getShallowDirectorySizeSync(n);\n        if (s > this._maxBytesOnDisk)\n          return void c.info(\n            e.TAG,\n            \"Not saving data due to max size limit being met. Directory size in bytes is: \" +\n              s\n          );\n        var a = new Date().getTime() + \".ai.json\",\n          l = i.join(n, a);\n        c.info(e.TAG, \"saving data before crash to disk at: \" + l);\n        r.writeFileSync(l, t, {\n          mode: 384,\n        });\n      } catch (t) {\n        c.warn(e.TAG, \"Error while saving data to disk: \" + (t && t.message));\n        this._onErrorHelper(t);\n      }\n    };\n    e.prototype._sendFirstFileOnDisk = function () {\n      var t = this,\n        n = i.join(\n          o.tmpdir(),\n          e.TEMPDIR_PREFIX + this._config.instrumentationKey\n        );\n      r.exists(n, function (e) {\n        if (e) {\n          r.readdir(n, function (e, o) {\n            if (e) t._onErrorHelper(e);\n            else if (\n              (o = o.filter(function (e) {\n                return i.basename(e).indexOf(\".ai.json\") > -1;\n              })).length > 0\n            ) {\n              var s = o[0],\n                a = i.join(n, s);\n              r.readFile(a, function (e, n) {\n                if (e) {\n                  t._onErrorHelper(e);\n                } else {\n                  r.unlink(a, function (e) {\n                    if (e) {\n                      t._onErrorHelper(e);\n                    } else {\n                      t.send(n);\n                    }\n                  });\n                }\n              });\n            }\n          });\n        }\n      });\n    };\n    e.prototype._onErrorHelper = function (e) {\n      if (\"function\" == typeof this._onError) {\n        this._onError(e);\n      }\n    };\n    e.TAG = \"Sender\";\n    e.ICACLS_PATH = process.env.systemdrive + \"/windows/system32/icacls.exe\";\n    e.POWERSHELL_PATH =\n      process.env.systemdrive +\n      \"/windows/system32/windowspowershell/v1.0/powershell.exe\";\n    e.ACLED_DIRECTORIES = {};\n    e.ACL_IDENTITY = null;\n    e.WAIT_BETWEEN_RESEND = 6e4;\n    e.MAX_BYTES_ON_DISK = 5e7;\n    e.MAX_CONNECTION_FAILURES_BEFORE_WARN = 5;\n    e.TEMPDIR_PREFIX = \"appInsights-node\";\n    e.OS_PROVIDES_FILE_PROTECTION = !1;\n    e.USE_ICACLS = \"Windows_NT\" === o.type();\n    return e;\n  })();\nmodule.exports = d;",
  "2626": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\n(function (e) {\n  for (var n in e)\n    if (exports.hasOwnProperty(n)) {\n      exports[n] = e[n];\n    }\n})(require(5481));",
  "2649": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3983),\n  o = require(430),\n  i = require(3229),\n  s = require(4336),\n  a = require(498),\n  c = require(3301),\n  l = require(1687),\n  u = require(2958),\n  d = require(4693),\n  p = require(966),\n  h = [\n    r.default,\n    o.default,\n    i.default,\n    s.default,\n    a.default,\n    c.default,\n    l.default,\n    u.default,\n    {\n      keyword: \"type\",\n      schemaType: [\"string\", \"array\"],\n    },\n    {\n      keyword: \"nullable\",\n      schemaType: \"boolean\",\n    },\n    d.default,\n    p.default,\n  ];\nexports.default = h;",
  "2728": "exports.getArg = function (e, t, n) {\n  if (t in e) return e[t];\n  if (3 === arguments.length) return n;\n  throw new Error('\"' + t + '\" is a required argument.');\n};\nvar n = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/,\n  r = /^data:.+\\,.+$/;\nfunction urlParse(e) {\n  var t = e.match(n);\n  return t\n    ? {\n        scheme: t[1],\n        auth: t[2],\n        host: t[3],\n        port: t[4],\n        path: t[5],\n      }\n    : null;\n}\nfunction urlGenerate(e) {\n  var t = \"\";\n  if (e.scheme) {\n    t += e.scheme + \":\";\n  }\n  t += \"//\";\n  if (e.auth) {\n    t += e.auth + \"@\";\n  }\n  if (e.host) {\n    t += e.host;\n  }\n  if (e.port) {\n    t += \":\" + e.port;\n  }\n  if (e.path) {\n    t += e.path;\n  }\n  return t;\n}\nfunction normalize(e) {\n  var n = e,\n    r = urlParse(e);\n  if (r) {\n    if (!r.path) return e;\n    n = r.path;\n  }\n  for (\n    var s,\n      a = exports.isAbsolute(n),\n      c = n.split(/\\/+/),\n      l = 0,\n      u = c.length - 1;\n    u >= 0;\n    u--\n  )\n    if (\".\" === (s = c[u])) {\n      c.splice(u, 1);\n    } else {\n      if (\"..\" === s) {\n        l++;\n      } else {\n        if (l > 0) {\n          if (\"\" === s) {\n            c.splice(u + 1, l);\n            l = 0;\n          } else {\n            c.splice(u, 2);\n            l--;\n          }\n        }\n      }\n    }\n  if (\"\" === (n = c.join(\"/\"))) {\n    n = a ? \"/\" : \".\";\n  }\n  return r ? ((r.path = n), urlGenerate(r)) : n;\n}\nfunction join(e, t) {\n  if (\"\" === e) {\n    e = \".\";\n  }\n  if (\"\" === t) {\n    t = \".\";\n  }\n  var n = urlParse(t),\n    a = urlParse(e);\n  if (a) {\n    e = a.path || \"/\";\n  }\n  if (n && !n.scheme) return a && (n.scheme = a.scheme), urlGenerate(n);\n  if (n || t.match(r)) return t;\n  if (a && !a.host && !a.path) {\n    a.host = t;\n    return urlGenerate(a);\n  }\n  var c = \"/\" === t.charAt(0) ? t : normalize(e.replace(/\\/+$/, \"\") + \"/\" + t);\n  return a ? ((a.path = c), urlGenerate(a)) : c;\n}\nexports.urlParse = urlParse;\nexports.urlGenerate = urlGenerate;\nexports.normalize = normalize;\nexports.join = join;\nexports.isAbsolute = function (e) {\n  return \"/\" === e.charAt(0) || n.test(e);\n};\nexports.relative = function (e, t) {\n  if (\"\" === e) {\n    e = \".\";\n  }\n  e = e.replace(/\\/$/, \"\");\n  for (var n = 0; 0 !== t.indexOf(e + \"/\"); ) {\n    var r = e.lastIndexOf(\"/\");\n    if (r < 0) return t;\n    if ((e = e.slice(0, r)).match(/^([^\\/]+:\\/)?\\/*$/)) return t;\n    ++n;\n  }\n  return Array(n + 1).join(\"../\") + t.substr(e.length + 1);\n};\nvar c = !(\"__proto__\" in Object.create(null));\nfunction l(e) {\n  return e;\n}\nfunction u(e) {\n  if (!e) return !1;\n  var t = e.length;\n  if (t < 9) return !1;\n  if (\n    95 !== e.charCodeAt(t - 1) ||\n    95 !== e.charCodeAt(t - 2) ||\n    111 !== e.charCodeAt(t - 3) ||\n    116 !== e.charCodeAt(t - 4) ||\n    111 !== e.charCodeAt(t - 5) ||\n    114 !== e.charCodeAt(t - 6) ||\n    112 !== e.charCodeAt(t - 7) ||\n    95 !== e.charCodeAt(t - 8) ||\n    95 !== e.charCodeAt(t - 9)\n  )\n    return !1;\n  for (var n = t - 10; n >= 0; n--) if (36 !== e.charCodeAt(n)) return !1;\n  return !0;\n}\nfunction d(e, t) {\n  return e === t ? 0 : null === e ? 1 : null === t ? -1 : e > t ? 1 : -1;\n}\nexports.toSetString = c\n  ? l\n  : function (e) {\n      return u(e) ? \"$\" + e : e;\n    };\nexports.fromSetString = c\n  ? l\n  : function (e) {\n      return u(e) ? e.slice(1) : e;\n    };\nexports.compareByOriginalPositions = function (e, t, n) {\n  var r = d(e.source, t.source);\n  return 0 !== r ||\n    0 != (r = e.originalLine - t.originalLine) ||\n    0 != (r = e.originalColumn - t.originalColumn) ||\n    n ||\n    0 != (r = e.generatedColumn - t.generatedColumn) ||\n    0 != (r = e.generatedLine - t.generatedLine)\n    ? r\n    : d(e.name, t.name);\n};\nexports.compareByGeneratedPositionsDeflated = function (e, t, n) {\n  var r = e.generatedLine - t.generatedLine;\n  return 0 !== r ||\n    0 != (r = e.generatedColumn - t.generatedColumn) ||\n    n ||\n    0 !== (r = d(e.source, t.source)) ||\n    0 != (r = e.originalLine - t.originalLine) ||\n    0 != (r = e.originalColumn - t.originalColumn)\n    ? r\n    : d(e.name, t.name);\n};\nexports.compareByGeneratedPositionsInflated = function (e, t) {\n  var n = e.generatedLine - t.generatedLine;\n  return 0 !== n ||\n    0 != (n = e.generatedColumn - t.generatedColumn) ||\n    0 !== (n = d(e.source, t.source)) ||\n    0 != (n = e.originalLine - t.originalLine) ||\n    0 != (n = e.originalColumn - t.originalColumn)\n    ? n\n    : d(e.name, t.name);\n};\nexports.parseSourceMapInput = function (e) {\n  return JSON.parse(e.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n};\nexports.computeSourceURL = function (e, t, n) {\n  t = t || \"\";\n  if (e) {\n    if (\"/\" !== e[e.length - 1] && \"/\" !== t[0]) {\n      e += \"/\";\n    }\n    t = e + t;\n  }\n  if (n) {\n    var r = urlParse(n);\n    if (!r) throw new Error(\"sourceMapURL could not be parsed\");\n    if (r.path) {\n      var c = r.path.lastIndexOf(\"/\");\n      c >= 0 && (r.path = r.path.substring(0, c + 1));\n    }\n    t = join(urlGenerate(r), t);\n  }\n  return normalize(t);\n};",
  "2783": "var r, o, i, s, a, c, l, u;\no = (r = u = require(8249)).lib;\ni = o.WordArray;\ns = o.Hasher;\na = r.algo;\nc = [];\nl = a.SHA1 = s.extend({\n  _doReset: function () {\n    this._hash = new i.init([\n      1732584193, 4023233417, 2562383102, 271733878, 3285377520,\n    ]);\n  },\n  _doProcessBlock: function (e, t) {\n    for (\n      var n = this._hash.words,\n        r = n[0],\n        o = n[1],\n        i = n[2],\n        s = n[3],\n        a = n[4],\n        l = 0;\n      l < 80;\n      l++\n    ) {\n      if (l < 16) c[l] = 0 | e[t + l];\n      else {\n        var u = c[l - 3] ^ c[l - 8] ^ c[l - 14] ^ c[l - 16];\n        c[l] = (u << 1) | (u >>> 31);\n      }\n      var d = ((r << 5) | (r >>> 27)) + a + c[l];\n      d +=\n        l < 20\n          ? 1518500249 + ((o & i) | (~o & s))\n          : l < 40\n          ? 1859775393 + (o ^ i ^ s)\n          : l < 60\n          ? ((o & i) | (o & s) | (i & s)) - 1894007588\n          : (o ^ i ^ s) - 899497514;\n      a = s;\n      s = i;\n      i = (o << 30) | (o >>> 2);\n      o = r;\n      r = d;\n    }\n    n[0] = (n[0] + r) | 0;\n    n[1] = (n[1] + o) | 0;\n    n[2] = (n[2] + i) | 0;\n    n[3] = (n[3] + s) | 0;\n    n[4] = (n[4] + a) | 0;\n  },\n  _doFinalize: function () {\n    var e = this._data,\n      t = e.words,\n      n = 8 * this._nDataBytes,\n      r = 8 * e.sigBytes;\n    t[r >>> 5] |= 128 << (24 - (r % 32));\n    t[14 + (((r + 64) >>> 9) << 4)] = Math.floor(n / 4294967296);\n    t[15 + (((r + 64) >>> 9) << 4)] = n;\n    e.sigBytes = 4 * t.length;\n    this._process();\n    return this._hash;\n  },\n  clone: function () {\n    var e = s.clone.call(this);\n    e._hash = this._hash.clone();\n    return e;\n  },\n});\nr.SHA1 = s._createHelper(l);\nr.HmacSHA1 = s._createHmacHelper(l);\nmodule.exports = u.SHA1;",
  "2807": "var r;\nr = require(8249);\nrequire(5109);\nr.pad.Iso10126 = {\n  pad: function (e, t) {\n    var n = 4 * t,\n      o = n - (e.sigBytes % n);\n    e.concat(r.lib.WordArray.random(o - 1)).concat(\n      r.lib.WordArray.create([o << 24], 1)\n    );\n  },\n  unpad: function (e) {\n    var t = 255 & e.words[(e.sigBytes - 1) >>> 2];\n    e.sigBytes -= t;\n  },\n};\nmodule.exports = r.pad.Iso10126;",
  "2818": "const r = require(\"os\"),\n  o = require(\"fs\"),\n  i = require(1595),\n  s = () => {\n    if (\"linux\" !== process.platform) return !1;\n    if (r.release().toLowerCase().includes(\"microsoft\")) return !i();\n    try {\n      return (\n        !!o\n          .readFileSync(\"/proc/version\", \"utf8\")\n          .toLowerCase()\n          .includes(\"microsoft\") && !i()\n      );\n    } catch (e) {\n      return !1;\n    }\n  };\nif (process.env.__IS_WSL_TEST__) {\n  module.exports = s;\n} else {\n  module.exports = s();\n}",
  "2826": "function n(e, t, n) {\n  var r = e[t];\n  e[t] = e[n];\n  e[n] = r;\n}\nfunction r(e, t, o, i) {\n  if (o < i) {\n    var s = o - 1;\n    n(e, ((u = o), (d = i), Math.round(u + Math.random() * (d - u))), i);\n    for (var a = e[i], c = o; c < i; c++)\n      if (t(e[c], a) <= 0) {\n        n(e, (s += 1), c);\n      }\n    n(e, s + 1, c);\n    var l = s + 1;\n    r(e, t, o, l - 1);\n    r(e, t, l + 1, i);\n  }\n  var u, d;\n}\nexports.U = function (e, t) {\n  r(e, t, 0, e.length - 1);\n};",
  "2901": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.prepareSolutionForReturn =\n  exports.processSSE =\n  exports.splitChunk =\n    undefined;\nconst r = require(9899),\n  o = require(6333),\n  i = require(937),\n  s = new r.Logger(r.LogLevel.INFO, \"streamChoices\");\nfunction splitChunk(e) {\n  const t = e.split(\"\\n\"),\n    n = t.pop();\n  return [t.filter((e) => \"\" != e), n];\n}\nexports.splitChunk = splitChunk;\nexports.processSSE = async function* (e, t, n, r, c) {\n  var l, u, d, p, h, f, m, g, _;\n  const y = await t.body();\n  y.setEncoding(\"utf8\");\n  let v = i.getRequestId(t);\n  s.debug(e, `requestId: ${v.headerRequestId}`);\n  const b = {};\n  let w = \"\";\n  for await (const x of y) {\n    if (null == c ? undefined : c.isCancellationRequested) {\n      s.info(e, \"Cancelled after awaiting body chunk\");\n      return void y.destroy();\n    }\n    s.debug(e, \"chunk\", x.toString());\n    const [E, C] = splitChunk(w + x.toString());\n    w = C;\n    for (const a of E) {\n      const w = a.slice(\"data:\".length).trim();\n      if (\"[DONE]\" == w) {\n        for (const [t, n] of Object.entries(b)) {\n          const r = Number(t);\n          if (\n            null != n &&\n            (yield {\n              solution: n,\n              finishOffset: undefined,\n              reason: \"DONE\",\n              requestId: v,\n              index: r,\n            },\n            null == c ? undefined : c.isCancellationRequested)\n          ) {\n            s.debug(e, \"Cancelled after yielding on DONE\");\n            return void y.destroy();\n          }\n        }\n        return;\n      }\n      let x;\n      try {\n        x = JSON.parse(w);\n      } catch (t) {\n        s.error(e, \"Error parsing JSON stream data\", a);\n        continue;\n      }\n      if (undefined !== x.choices || undefined === x.error) {\n        if (0 == v.created) {\n          v = i.getRequestId(t, x);\n          if (0 == v.created) {\n            s.error(\n              e,\n              `Request id invalid, should have \"completionId\" and \"created\": ${v}`,\n              v\n            );\n          }\n        }\n        for (let t = 0; t < x.choices.length; t++) {\n          const i = x.choices[t];\n          s.debug(e, \"choice\", i);\n          if (i.index in b) {\n            b[i.index] = {\n              logprobs: [],\n              top_logprobs: [],\n              text: [],\n              text_offset: [],\n              tokens: [],\n            };\n          }\n          const a = b[i.index];\n          if (null == a) continue;\n          let w;\n          a.text.push(i.text);\n          a.tokens.push(\n            null !==\n              (u =\n                null === (l = i.logprobs) || undefined === l\n                  ? undefined\n                  : l.tokens) && undefined !== u\n              ? u\n              : []\n          );\n          a.text_offset.push(\n            null !==\n              (p =\n                null === (d = i.logprobs) || undefined === d\n                  ? undefined\n                  : d.text_offset) && undefined !== p\n              ? p\n              : []\n          );\n          a.logprobs.push(\n            null !==\n              (f =\n                null === (h = i.logprobs) || undefined === h\n                  ? undefined\n                  : h.token_logprobs) && undefined !== f\n              ? f\n              : []\n          );\n          a.top_logprobs.push(\n            null !==\n              (g =\n                null === (m = i.logprobs) || undefined === m\n                  ? undefined\n                  : m.top_logprobs) && undefined !== g\n              ? g\n              : []\n          );\n          if (\n            (i.finish_reason || i.text.indexOf(\"\\n\") > -1) &&\n            ((w = await n(a.text.join(\"\"))),\n            null == c ? void 0 : c.isCancellationRequested)\n          )\n            return (\n              s.debug(e, \"Cancelled after awaiting finishedCb\"),\n              void y.destroy()\n            );\n          if (i.finish_reason || undefined !== w) {\n            const t =\n              null !== (_ = i.finish_reason) && undefined !== _\n                ? _\n                : \"client-trimmed\";\n            o.telemetry(\n              e,\n              \"completion.finishReason\",\n              r.extendedBy({\n                completionChoiceFinishReason: t,\n              })\n            );\n            yield {\n              solution: a,\n              finishOffset: w,\n              reason: JSON.stringify(i.finish_reason),\n              requestId: v,\n              index: i.index,\n            };\n            if (null == c ? void 0 : c.isCancellationRequested)\n              return (\n                s.debug(e, \"Cancelled after yielding finished choice\"),\n                void y.destroy()\n              );\n            b[i.index] = null;\n          }\n        }\n      } else s.error(e, \"Error in response:\", x.error.message);\n    }\n  }\n  for (const [t, n] of Object.entries(b)) {\n    const r = Number(t);\n    if (\n      null != n &&\n      (yield {\n        solution: n,\n        finishOffset: undefined,\n        reason: \"Iteration Done\",\n        requestId: v,\n        index: r,\n      },\n      null == c ? undefined : c.isCancellationRequested)\n    ) {\n      s.debug(e, \"Cancelled after yielding after iteration done\");\n      return void y.destroy();\n    }\n  }\n  if (w.length > 0)\n    try {\n      const t = JSON.parse(w);\n      if (undefined !== t.error) {\n        s.error(e, `Error in response: ${t.error.message}`, t.error);\n      }\n    } catch (t) {\n      s.error(e, `Error parsing extraData: ${w}`);\n    }\n};\nexports.prepareSolutionForReturn = function (e, t, n) {\n  let r = t.solution.text.join(\"\"),\n    o = !1;\n  if (undefined !== t.finishOffset) {\n    s.debug(e, `solution ${t.index}: early finish at offset ${t.finishOffset}`);\n    r = r.substring(0, t.finishOffset);\n    o = !0;\n  }\n  s.info(\n    e,\n    `solution ${t.index} returned. finish reason: [${t.reason}] finishOffset: [${t.finishOffset}] completionId: [{${t.requestId.completionId}}] created: [{${t.requestId.created}}]`\n  );\n  const a = (function (e, t) {\n    const n = {\n      text: t.text.join(\"\"),\n      tokens: t.text,\n    };\n    if (0 === t.logprobs.length) return n;\n    const r = t.logprobs.reduce((e, t) => e.concat(t), []),\n      o = t.top_logprobs.reduce((e, t) => e.concat(t), []),\n      i = t.text_offset.reduce((e, t) => e.concat(t), []),\n      s = t.tokens.reduce((e, t) => e.concat(t), []);\n    return {\n      ...n,\n      logprobs: {\n        token_logprobs: r,\n        top_logprobs: o,\n        text_offset: i,\n        tokens: s,\n      },\n    };\n  })(0, t.solution);\n  return i.convertToAPIChoice(e, r, a, t.index, t.requestId, o, n);\n};",
  "2924": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(4665),\n  o = {\n    keyword: \"prefixItems\",\n    type: \"array\",\n    schemaType: [\"array\"],\n    before: \"uniqueItems\",\n    code: (e) => r.validateTuple(e, \"items\"),\n  };\nexports.default = o;",
  "2958": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(453),\n  o = require(3487),\n  i = require(6776),\n  s = require(3510),\n  a = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: !0,\n    error: {\n      message: ({ params: { i: e, j: t } }) =>\n        o.str`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,\n      params: ({ params: { i: e, j: t } }) => o._`{i: ${e}, j: ${t}}`,\n    },\n    code(e) {\n      const {\n        gen: t,\n        data: n,\n        $data: a,\n        schema: c,\n        parentSchema: l,\n        schemaCode: u,\n        it: d,\n      } = e;\n      if (!a && !c) return;\n      const p = t.let(\"valid\"),\n        h = l.items ? r.getSchemaTypes(l.items) : [];\n      function f(i, s) {\n        const a = t.name(\"item\"),\n          c = r.checkDataTypes(h, a, d.opts.strictNumbers, r.DataType.Wrong),\n          l = t.const(\"indices\", o._`{}`);\n        t.for(o._`;${i}--;`, () => {\n          t.let(a, o._`${n}[${i}]`);\n          t.if(c, o._`continue`);\n          if (h.length > 1) {\n            t.if(o._`typeof ${a} == \"string\"`, o._`${a} += \"_\"`);\n          }\n          t.if(o._`typeof ${l}[${a}] == \"number\"`, () => {\n            t.assign(s, o._`${l}[${a}]`);\n            e.error();\n            t.assign(p, !1).break();\n          }).code(o._`${l}[${a}] = ${i}`);\n        });\n      }\n      function m(r, a) {\n        const c = i.useFunc(t, s.default),\n          l = t.name(\"outer\");\n        t.label(l).for(o._`;${r}--;`, () =>\n          t.for(o._`${a} = ${r}; ${a}--;`, () =>\n            t.if(o._`${c}(${n}[${r}], ${n}[${a}])`, () => {\n              e.error();\n              t.assign(p, !1).break(l);\n            })\n          )\n        );\n      }\n      e.block$data(\n        p,\n        function () {\n          const r = t.let(\"i\", o._`${n}.length`),\n            i = t.let(\"j\");\n          e.setParams({\n            i: r,\n            j: i,\n          });\n          t.assign(p, !0);\n          t.if(o._`${r} > 1`, () =>\n            (h.length > 0 && !h.some((e) => \"object\" === e || \"array\" === e)\n              ? f\n              : m)(r, i)\n          );\n        },\n        o._`${u} === false`\n      );\n      e.ok(p);\n    },\n  };\nexports.default = a;",
  "2981": "const { Body: r, cloneStream: o, guessContentType: i } = require(5600),\n  { Headers: s } = require(9872),\n  { isPlainObject: a } = require(4544),\n  { isFormData: c, FormDataSerializer: l } = require(9407),\n  u = Symbol(\"Response internals\");\nclass d extends r {\n  constructor(e = null, t = {}) {\n    const n = new s(t.headers);\n    let r = e;\n    if (c(r) && !n.has(\"content-type\")) {\n      const e = new l(r);\n      r = e.stream();\n      n.set(\"content-type\", e.contentType());\n      if (n.has(\"transfer-encoding\") || n.has(\"content-length\")) {\n        n.set(\"content-length\", e.length());\n      }\n    }\n    if (null !== r && !n.has(\"content-type\"))\n      if (a(r)) {\n        r = JSON.stringify(r);\n        n.set(\"content-type\", \"application/json\");\n      } else {\n        const e = i(r);\n        if (e) {\n          n.set(\"content-type\", e);\n        }\n      }\n    super(r);\n    this[u] = {\n      url: t.url,\n      status: t.status || 200,\n      statusText: t.statusText || \"\",\n      headers: n,\n      httpVersion: t.httpVersion,\n      decoded: t.decoded,\n      counter: t.counter,\n    };\n  }\n  get url() {\n    return this[u].url || \"\";\n  }\n  get status() {\n    return this[u].status;\n  }\n  get statusText() {\n    return this[u].statusText;\n  }\n  get ok() {\n    return this[u].status >= 200 && this[u].status < 300;\n  }\n  get redirected() {\n    return this[u].counter > 0;\n  }\n  get headers() {\n    return this[u].headers;\n  }\n  get httpVersion() {\n    return this[u].httpVersion;\n  }\n  get decoded() {\n    return this[u].decoded;\n  }\n  static redirect(e, t = 302) {\n    if (![301, 302, 303, 307, 308].includes(t))\n      throw new RangeError(\"Invalid status code\");\n    return new d(null, {\n      headers: {\n        location: new URL(e).toString(),\n      },\n      status: t,\n    });\n  }\n  clone() {\n    if (this.bodyUsed) throw new TypeError(\"Cannot clone: already read\");\n    return new d(o(this), {\n      ...this[u],\n    });\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\nObject.defineProperties(d.prototype, {\n  url: {\n    enumerable: !0,\n  },\n  status: {\n    enumerable: !0,\n  },\n  ok: {\n    enumerable: !0,\n  },\n  redirected: {\n    enumerable: !0,\n  },\n  statusText: {\n    enumerable: !0,\n  },\n  headers: {\n    enumerable: !0,\n  },\n  clone: {\n    enumerable: !0,\n  },\n});\nmodule.exports = {\n  Response: d,\n};",
  "2990": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.CopilotPanel = undefined;\nconst r = require(\"vscode\"),\n  o = require(1133),\n  i = require(4197),\n  s = require(256),\n  a = require(893),\n  c = require(7017),\n  l = require(3060);\nexports.CopilotPanel = class {\n  constructor(e) {\n    this._onDidChange = new r.EventEmitter();\n    this._documents = new Map();\n    this._editorDecoration = r.window.createTextEditorDecorationType({\n      textDecoration: \"underline\",\n    });\n    this._ctx = e;\n    this._subscriptions = r.workspace.onDidCloseTextDocument((e) => {\n      if (e.isClosed && e.uri.scheme == i.CopilotScheme) {\n        this._documents.delete(e.uri.toString());\n      }\n    });\n  }\n  dispose() {\n    this._subscriptions.dispose();\n    this._documents.clear();\n    this._editorDecoration.dispose();\n    this._onDidChange.dispose();\n  }\n  get onDidChange() {\n    return this._onDidChange.event;\n  }\n  async provideTextDocumentContent(e) {\n    var t;\n    let n =\n      null === (t = this._documents.get(e.toString())) || undefined === t\n        ? undefined\n        : t.model;\n    if (n) return n.value;\n    const i = new r.CancellationTokenSource(),\n      [c, l] = s.decodeLocation(this._ctx, e),\n      u = await r.workspace.openTextDocument(c);\n    n = new a.CopilotListDocument(\n      this._ctx,\n      e,\n      u,\n      l,\n      o.getConfig(this._ctx, o.ConfigKey.ListCount),\n      i.token\n    );\n    n.onDidResultUpdated((e) => this._onDidChange.fire(e));\n    this._documents.set(e.toString(), {\n      model: n,\n      cts: i,\n    });\n    n.runQuery();\n    return n.value;\n  }\n  getCodeLens(e) {\n    const t = e.model;\n    let n = t.numberHeaderLines;\n    const o = t.completionContext.insertPosition,\n      i = a.CopilotListDocument.separator.split(\"\\n\").length - 1;\n    return t.solutions().map((a, u) => {\n      const d = new r.Position(n + i, 0),\n        p = new r.Position(n + a.displayLines.length - 1, 0),\n        h = t.savedTelemetryData.extendedBy(\n          {\n            choiceIndex: a.choiceIndex.toString(),\n          },\n          {\n            compCharLen: a.completionText.length,\n            meanProb: a.meanProb,\n            rank: u,\n          }\n        );\n      h.extendWithRequestId(a.requestId);\n      h.markAsDisplayed();\n      const f = new r.CodeLens(new r.Range(d, p), {\n        title: \"Accept Solution\",\n        tooltip: \"Replace code with this solution\",\n        command: l.CMDAcceptPanelSolution,\n        arguments: [\n          t.targetUri,\n          o,\n          a.completionText,\n          t.completionContext.completionType ===\n            s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX,\n          async () => {\n            const n = (\n              await r.workspace.openTextDocument(t.targetUri)\n            ).offsetAt(o);\n            e.cts.cancel();\n            await c.postInsertionTasks(\n              this._ctx,\n              \"solution\",\n              a.completionText,\n              n,\n              t.targetUri,\n              h\n            );\n          },\n        ],\n      });\n      n += a.displayLines.length;\n      return f;\n    });\n  }\n  provideCodeLenses(e, t) {\n    const n = this._documents.get(e.uri.toString());\n    if (n) return this.getCodeLens(n);\n  }\n};",
  "3054": "var t = (function () {\n  function e() {}\n  e.prototype.getUrl = function () {\n    return this.url;\n  };\n  e.prototype.RequestParser = function () {\n    this.startTime = +new Date();\n  };\n  e.prototype._setStatus = function (e, t) {\n    var n = +new Date();\n    this.duration = n - this.startTime;\n    this.statusCode = e;\n    var r = this.properties || {};\n    if (t)\n      if (\"string\" == typeof t) r.error = t;\n      else if (t instanceof Error) r.error = t.message;\n      else if (\"object\" == typeof t)\n        for (var o in t) r[o] = t[o] && t[o].toString && t[o].toString();\n    this.properties = r;\n  };\n  e.prototype._isSuccess = function () {\n    return 0 < this.statusCode && this.statusCode < 400;\n  };\n  return e;\n})();\nmodule.exports = t;",
  "3057": "var r = require(\"assert\"),\n  o = require(9867),\n  i = \"error@context\";\nfunction s(e) {\n  this.name = e;\n  this.active = null;\n  this._set = [];\n  this.id = null;\n}\nfunction a(e) {\n  return process.namespaces[e];\n}\nfunction c(e) {\n  var t = a(e);\n  r.ok(t, \"can't delete nonexistent namespace!\");\n  r.ok(t.id, \"don't assign to process.namespaces directly!\");\n  process.removeAsyncListener(t.id);\n  process.namespaces[e] = null;\n}\nfunction l() {\n  if (process.namespaces) {\n    Object.keys(process.namespaces).forEach(function (e) {\n      c(e);\n    });\n  }\n  process.namespaces = Object.create(null);\n}\nif (process.addAsyncListener) {\n  require(7645);\n}\ns.prototype.set = function (e, t) {\n  if (!this.active)\n    throw new Error(\n      \"No context available. ns.run() or ns.bind() must be called first.\"\n    );\n  this.active[e] = t;\n  return t;\n};\ns.prototype.get = function (e) {\n  if (this.active) return this.active[e];\n};\ns.prototype.createContext = function () {\n  return Object.create(this.active);\n};\ns.prototype.run = function (e) {\n  var t = this.createContext();\n  this.enter(t);\n  try {\n    e(t);\n    return t;\n  } catch (e) {\n    throw (e && (e[i] = t), e);\n  } finally {\n    this.exit(t);\n  }\n};\ns.prototype.runAndReturn = function (e) {\n  var t;\n  this.run(function (n) {\n    t = e(n);\n  });\n  return t;\n};\ns.prototype.bind = function (e, t) {\n  if (t) {\n    t = this.active ? this.active : this.createContext();\n  }\n  var n = this;\n  return function () {\n    n.enter(t);\n    try {\n      return e.apply(this, arguments);\n    } catch (e) {\n      throw (e && (e[i] = t), e);\n    } finally {\n      n.exit(t);\n    }\n  };\n};\ns.prototype.enter = function (e) {\n  r.ok(e, \"context must be provided for entering\");\n  this._set.push(this.active);\n  this.active = e;\n};\ns.prototype.exit = function (e) {\n  r.ok(e, \"context must be provided for exiting\");\n  if (this.active === e)\n    return (\n      r.ok(this._set.length, \"can't remove top context\"),\n      void (this.active = this._set.pop())\n    );\n  var t = this._set.lastIndexOf(e);\n  r.ok(t >= 0, \"context not currently entered; can't exit\");\n  r.ok(t, \"can't remove top context\");\n  this._set.splice(t, 1);\n};\ns.prototype.bindEmitter = function (e) {\n  r.ok(e.on && e.addListener && e.emit, \"can only bind real EEs\");\n  var t = this,\n    n = \"context@\" + this.name;\n  o(\n    e,\n    function (e) {\n      if (e) {\n        if (e[\"cls@contexts\"]) {\n          e[\"cls@contexts\"] = Object.create(null);\n        }\n        e[\"cls@contexts\"][n] = {\n          namespace: t,\n          context: t.active,\n        };\n      }\n    },\n    function (e) {\n      if (!e || !e[\"cls@contexts\"]) return e;\n      var t = e,\n        n = e[\"cls@contexts\"];\n      Object.keys(n).forEach(function (e) {\n        var r = n[e];\n        t = r.namespace.bind(t, r.context);\n      });\n      return t;\n    }\n  );\n};\ns.prototype.fromException = function (e) {\n  return e[i];\n};\nif (process.namespaces) {\n  l();\n}\nmodule.exports = {\n  getNamespace: a,\n  createNamespace: function (e) {\n    r.ok(e, \"namespace must be given a name!\");\n    var t = new s(e);\n    t.id = process.addAsyncListener({\n      create: function () {\n        return t.active;\n      },\n      before: function (e, n) {\n        if (n) {\n          t.enter(n);\n        }\n      },\n      after: function (e, n) {\n        if (n) {\n          t.exit(n);\n        }\n      },\n      error: function (e) {\n        if (e) {\n          t.exit(e);\n        }\n      },\n    });\n    process.namespaces[e] = t;\n    return t;\n  },\n  destroyNamespace: c,\n  reset: l,\n};",
  "3060": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.CopilotLabelPrefix =\n  exports.CMDSendFeedback =\n  exports.CMDShowActivationErrors =\n  exports.CMDToggleCopilot =\n  exports.CMDAcceptPanelSolution =\n  exports.CMDOpenPanelForRange =\n  exports.CMDOpenPanel =\n    undefined;\nexports.CMDOpenPanel = \"github.copilot.generate\";\nexports.CMDOpenPanelForRange = \"github.copilot.openPanelForRange\";\nexports.CMDAcceptPanelSolution = \"github.copilot.acceptPanelSolution\";\nexports.CMDToggleCopilot = \"github.copilot.toggleCopilot\";\nexports.CMDShowActivationErrors = \"github.copilot.showActivationErrors\";\nexports.CMDSendFeedback = \"github.copilot.sendFeedback\";\nexports.CopilotLabelPrefix = \"$(copilot-logo) \";",
  "3076": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.LRUCache = exports.keyForPrompt = undefined;\nconst r = require(1354);\nexports.keyForPrompt = function (e) {\n  return r.SHA256(e.prefix + e.suffix).toString();\n};\nexports.LRUCache = class {\n  constructor(e = 10) {\n    this.values = new Map();\n    this.lruKeys = [];\n    this.size = e;\n  }\n  removeKeyFromLRU(e) {\n    const t = this.lruKeys.indexOf(e);\n    if (-1 !== t) {\n      this.lruKeys.splice(t, 1);\n    }\n  }\n  touchKeyInLRU(e) {\n    this.removeKeyFromLRU(e);\n    this.lruKeys.push(e);\n  }\n  clear() {\n    this.values.clear();\n    this.lruKeys = [];\n  }\n  deleteKey(e) {\n    this.removeKeyFromLRU(e);\n    if (undefined !== this.values.get(e)) {\n      this.values.delete(e);\n    }\n  }\n  get(e) {\n    if (this.values.has(e)) {\n      const t = this.values.get(e);\n      this.touchKeyInLRU(e);\n      return t;\n    }\n  }\n  put(e, t) {\n    let n = [];\n    if (this.values.has(e)) {\n      n = [e];\n    } else {\n      if (this.lruKeys.length >= this.size) {\n        n = this.lruKeys.splice(0, 1);\n      }\n    }\n    for (const e of n) this.deleteKey(e);\n    this.values.set(e, t);\n    this.touchKeyInLRU(e);\n  }\n};",
  "3092": "var r,\n  o =\n    (this && this.__extends) ||\n    ((r =\n      Object.setPrototypeOf ||\n      ({\n        __proto__: [],\n      } instanceof Array &&\n        function (e, t) {\n          e.__proto__ = t;\n        }) ||\n      function (e, t) {\n        for (var n in t)\n          if (t.hasOwnProperty(n)) {\n            e[n] = t[n];\n          }\n      }),\n    function (e, t) {\n      function n() {\n        this.constructor = e;\n      }\n      r(e, t);\n      e.prototype =\n        null === t ? Object.create(t) : ((n.prototype = t.prototype), new n());\n    }),\n  i = (function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.metrics = [];\n      t.properties = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  })(require(8934));\nmodule.exports = i;",
  "3099": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.extendSubschemaMode =\n  exports.extendSubschemaData =\n  exports.getSubschema =\n    undefined;\nconst r = require(3487),\n  o = require(6776);\nexports.getSubschema = function (\n  e,\n  {\n    keyword: t,\n    schemaProp: n,\n    schema: i,\n    schemaPath: s,\n    errSchemaPath: a,\n    topSchemaRef: c,\n  }\n) {\n  if (undefined !== t && undefined !== i)\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n  if (undefined !== t) {\n    const i = e.schema[t];\n    return undefined === n\n      ? {\n          schema: i,\n          schemaPath: r._`${e.schemaPath}${r.getProperty(t)}`,\n          errSchemaPath: `${e.errSchemaPath}/${t}`,\n        }\n      : {\n          schema: i[n],\n          schemaPath: r._`${e.schemaPath}${r.getProperty(t)}${r.getProperty(\n            n\n          )}`,\n          errSchemaPath: `${e.errSchemaPath}/${t}/${o.escapeFragment(n)}`,\n        };\n  }\n  if (undefined !== i) {\n    if (undefined === s || undefined === a || undefined === c)\n      throw new Error(\n        '\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"'\n      );\n    return {\n      schema: i,\n      schemaPath: s,\n      topSchemaRef: c,\n      errSchemaPath: a,\n    };\n  }\n  throw new Error('either \"keyword\" or \"schema\" must be passed');\n};\nexports.extendSubschemaData = function (\n  e,\n  t,\n  { dataProp: n, dataPropType: i, data: s, dataTypes: a, propertyName: c }\n) {\n  if (undefined !== s && undefined !== n)\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n  const { gen: l } = t;\n  if (undefined !== n) {\n    const { errorPath: s, dataPathArr: a, opts: c } = t;\n    u(l.let(\"data\", r._`${t.data}${r.getProperty(n)}`, !0));\n    e.errorPath = r.str`${s}${o.getErrorPath(n, i, c.jsPropertySyntax)}`;\n    e.parentDataProperty = r._`${n}`;\n    e.dataPathArr = [...a, e.parentDataProperty];\n  }\n  function u(n) {\n    e.data = n;\n    e.dataLevel = t.dataLevel + 1;\n    e.dataTypes = [];\n    t.definedProperties = new Set();\n    e.parentData = t.data;\n    e.dataNames = [...t.dataNames, n];\n  }\n  if (undefined !== s) {\n    u(s instanceof r.Name ? s : l.let(\"data\", s, !0));\n    if (undefined !== c) {\n      e.propertyName = c;\n    }\n  }\n  if (a) {\n    e.dataTypes = a;\n  }\n};\nexports.extendSubschemaMode = function (\n  e,\n  {\n    jtdDiscriminator: t,\n    jtdMetadata: n,\n    compositeRule: r,\n    createErrors: o,\n    allErrors: i,\n  }\n) {\n  if (undefined !== r) {\n    e.compositeRule = r;\n  }\n  if (undefined !== o) {\n    e.createErrors = o;\n  }\n  if (undefined !== i) {\n    e.allErrors = i;\n  }\n  e.jtdDiscriminator = t;\n  e.jtdMetadata = n;\n};",
  "3100": "const r = require(8104)(\"helix-fetch:core\"),\n  {\n    request: o,\n    setupContext: i,\n    resetContext: s,\n    RequestAbortedError: a,\n    ALPN_HTTP2: c,\n    ALPN_HTTP2C: l,\n    ALPN_HTTP1_1: u,\n    ALPN_HTTP1_0: d,\n  } = require(9575);\nclass p {\n  constructor(e) {\n    this.options = {\n      ...(e || {}),\n    };\n    i(this);\n  }\n  api() {\n    return {\n      request: async (e, t) => this.request(e, t),\n      context: (e = {}) => new p(e).api(),\n      reset: async () => this.reset(),\n      RequestAbortedError: a,\n      ALPN_HTTP2: c,\n      ALPN_HTTP2C: l,\n      ALPN_HTTP1_1: u,\n      ALPN_HTTP1_0: d,\n    };\n  }\n  async request(e, t) {\n    return o(this, e, t);\n  }\n  async reset() {\n    r(\"resetting context\");\n    return s(this);\n  }\n}\nmodule.exports = new p().api();",
  "3136": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.TextDocumentManager = exports.getRelativePath = undefined;\nconst r = require(\"path\");\nexports.getRelativePath = function (e, t) {\n  for (const n of e) {\n    const e = n.fsPath;\n    if (t.startsWith(e + r.sep)) return r.relative(e, t);\n  }\n};\nexports.TextDocumentManager = class {};",
  "3141": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getRules = exports.isJSONType = undefined;\nconst n = new Set([\n  \"string\",\n  \"number\",\n  \"integer\",\n  \"boolean\",\n  \"null\",\n  \"object\",\n  \"array\",\n]);\nexports.isJSONType = function (e) {\n  return \"string\" == typeof e && n.has(e);\n};\nexports.getRules = function () {\n  const e = {\n    number: {\n      type: \"number\",\n      rules: [],\n    },\n    string: {\n      type: \"string\",\n      rules: [],\n    },\n    array: {\n      type: \"array\",\n      rules: [],\n    },\n    object: {\n      type: \"object\",\n      rules: [],\n    },\n  };\n  return {\n    types: {\n      ...e,\n      integer: !0,\n      boolean: !0,\n      null: !0,\n    },\n    rules: [\n      {\n        rules: [],\n      },\n      e.number,\n      e.string,\n      e.array,\n      e.object,\n    ],\n    post: {\n      rules: [],\n    },\n    all: {},\n    keywords: {},\n  };\n};",
  "3197": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.registerGhostText =\n  exports.handleGhostTextPostInsert =\n  exports.handleGhostTextShown =\n  exports.provideInlineCompletions =\n  exports.ghostTextLogger =\n  exports.getInsertionTextFromCompletion =\n    undefined;\nconst r = require(\"vscode\"),\n  o = require(1133),\n  i = require(2218),\n  s = require(9334),\n  a = require(750),\n  c = require(9899),\n  l = require(7017),\n  u = require(6333),\n  d = require(4540),\n  p = \"_ghostTextPostInsert\";\nfunction getInsertionTextFromCompletion(e) {\n  return e.insertText;\n}\nlet f, m;\nexports.getInsertionTextFromCompletion = getInsertionTextFromCompletion;\nexports.ghostTextLogger = new c.Logger(c.LogLevel.INFO, \"ghostText\");\nlet g,\n  _ = [];\nasync function provideInlineCompletions(e, n, c, h, y) {\n  const v = await (async function (e, n, a, c, h) {\n    const y = u.TelemetryData.createAndMarkAsIssued();\n    if (\n      !(function (e) {\n        return o.getConfig(e, o.ConfigKey.InlineSuggestEnable);\n      })(e)\n    )\n      return {\n        type: \"abortedBeforeIssued\",\n        reason: \"ghost text is disabled\",\n      };\n    if (d.ignoreDocument(e, n))\n      return {\n        type: \"abortedBeforeIssued\",\n        reason: \"document is ignored\",\n      };\n    exports.ghostTextLogger.debug(\n      e,\n      `Ghost text called at [${a.line}, ${a.character}], with triggerKind ${c.triggerKind}`\n    );\n    if (h.isCancellationRequested)\n      return (\n        exports.ghostTextLogger.info(e, \"Cancelled before extractPrompt\"),\n        {\n          type: \"abortedBeforeIssued\",\n          reason: \"cancelled before extractPrompt\",\n        }\n      );\n    if (c.selectedCompletionInfo) {\n      exports.ghostTextLogger.debug(\n        e,\n        \"Not showing ghost text because autocomplete widget is displayed\"\n      );\n      return {\n        type: \"abortedBeforeIssued\",\n        reason: \"autocomplete widget is displayed\",\n      };\n    }\n    const v = await s.getGhostText(\n      e,\n      n,\n      a,\n      c.triggerKind === r.InlineCompletionTriggerKind.Invoke,\n      y,\n      h\n    );\n    if (\"success\" !== v.type) {\n      exports.ghostTextLogger.debug(\n        e,\n        \"Breaking, no results from getGhostText -- \" + v.type + \": \" + v.reason\n      );\n      return v;\n    }\n    const [b, w] = v.value;\n    if (\n      f &&\n      m &&\n      (!f.isEqual(a) || m !== n.uri) &&\n      w !== s.ResultType.TypingAsSuggested\n    ) {\n      const t = _.flatMap((e) =>\n        e.displayText && e.telemetry\n          ? [\n              {\n                completionText: e.displayText,\n                completionTelemetryData: e.telemetry,\n              },\n            ]\n          : []\n      );\n      if (t.length > 0) {\n        l.postRejectionTasks(e, \"ghostText\", n.offsetAt(f), m, t);\n      }\n    }\n    f = a;\n    m = n.uri;\n    _ = [];\n    if (h.isCancellationRequested)\n      return (\n        exports.ghostTextLogger.info(e, \"Cancelled after getGhostText\"),\n        {\n          type: \"canceled\",\n          reason: \"after getGhostText\",\n          telemetryData: {\n            telemetryBlob: v.telemetryBlob,\n          },\n        }\n      );\n    const x = i.completionsFromGhostTextResults(\n      e,\n      b,\n      w,\n      n,\n      a,\n      (function (e) {\n        const t = r.window.visibleTextEditors.find((t) => t.document === e);\n        return null == t ? undefined : t.options;\n      })(n),\n      g\n    );\n    exports.ghostTextLogger.debug(e, \"Completions\", x);\n    const E = x.map((e) => {\n      const { text: t, range: o } = e,\n        i = new r.Range(\n          new r.Position(o.start.line, o.start.character),\n          new r.Position(o.end.line, o.end.character)\n        ),\n        s = new r.InlineCompletionItem(t, i);\n      s.index = e.index;\n      s.telemetry = e.telemetry;\n      s.displayText = e.displayText;\n      s.resultType = e.resultType;\n      s.uri = n.uri;\n      s.insertOffset = n.offsetAt(\n        new r.Position(e.position.line, e.position.character)\n      );\n      s.command = {\n        title: \"PostInsertTask\",\n        command: p,\n        arguments: [s],\n      };\n      return s;\n    });\n    return 0 === E.length\n      ? {\n          type: \"empty\",\n          reason: \"no completions in final result\",\n          telemetryData: v.telemetryData,\n        }\n      : {\n          ...v,\n          value: E,\n        };\n  })(e, n, c, h, y);\n  return await a.handleGhostTextResultTelemetry(e, v);\n}\nexports.provideInlineCompletions = provideInlineCompletions;\nclass v {\n  constructor(e) {\n    this.ctx = e;\n  }\n  async provideInlineCompletionItems(e, t, n, r) {\n    return provideInlineCompletions(this.ctx, e, t, n, r);\n  }\n  handleDidShowCompletionItem(e) {\n    handleGhostTextShown(this.ctx, e);\n  }\n}\nfunction handleGhostTextShown(e, n) {\n  g = n.index;\n  if (!_.find((e) => e.index === n.index) && (_.push(n), n.telemetry)) {\n    const r = !(n.resultType === s.ResultType.Network);\n    exports.ghostTextLogger.debug(\n      e,\n      `[${n.telemetry.properties.headerRequestId}] shown choiceIndex: ${n.telemetry.properties.choiceIndex}, fromCache ${r}`\n    ),\n      (0, a.telemetryShown)(e, \"ghostText\", n.telemetry, r);\n  }\n}\nasync function handleGhostTextPostInsert(e, n) {\n  _ = [];\n  m = undefined;\n  f = undefined;\n  exports.ghostTextLogger.debug(e, \"Ghost text post insert\");\n  if (\n    n.telemetry &&\n    n.uri &&\n    n.displayText &&\n    undefined !== n.insertOffset &&\n    n.range\n  ) {\n    n.telemetry.measurements.compCharLen =\n      getInsertionTextFromCompletion(n).length;\n    await l.postInsertionTasks(\n      e,\n      \"ghostText\",\n      n.displayText,\n      n.insertOffset,\n      n.uri,\n      n.telemetry\n    );\n  }\n}\nexports.handleGhostTextShown = handleGhostTextShown;\nexports.handleGhostTextPostInsert = handleGhostTextPostInsert;\nexports.registerGhostText = function (e) {\n  const t = new v(e);\n  return [\n    r.languages.registerInlineCompletionItemProvider(\n      {\n        pattern: \"**\",\n      },\n      t\n    ),\n    r.commands.registerCommand(p, async (t) => handleGhostTextPostInsert(e, t)),\n  ];\n};",
  "3223": "const r = require(9822);\nif (global._asyncHook) {\n  if (global._asyncHook.version !== require(6157).i8)\n    throw new Error(\"Conflicting version of async-hook-jl found\");\n  module.exports = global._asyncHook;\n} else {\n  require(2512).filter.attach(function (e, t) {\n    return t.filter(function (e) {\n      const t = e.getFileName();\n      return !(t && t.slice(0, __dirname.length) === __dirname);\n    });\n  });\n  module.exports = global._asyncHook = new r();\n}",
  "3229": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = require(6776),\n  i = require(4499),\n  s = {\n    keyword: [\"maxLength\", \"minLength\"],\n    type: \"string\",\n    schemaType: \"number\",\n    $data: !0,\n    error: {\n      message({ keyword: e, schemaCode: t }) {\n        const n = \"maxLength\" === e ? \"more\" : \"fewer\";\n        return r.str`must NOT have ${n} than ${t} characters`;\n      },\n      params: ({ schemaCode: e }) => r._`{limit: ${e}}`,\n    },\n    code(e) {\n      const { keyword: t, data: n, schemaCode: s, it: a } = e,\n        c = \"maxLength\" === t ? r.operators.GT : r.operators.LT,\n        l =\n          !1 === a.opts.unicode\n            ? r._`${n}.length`\n            : r._`${o.useFunc(e.gen, i.default)}(${n})`;\n      e.fail$data(r._`${l} ${c} ${s}`);\n    },\n  };\nexports.default = s;",
  "3269": "function t() {}\nmodule.exports = function () {\n  const e = this._hooks,\n    n = this._state,\n    r = process.nextTick;\n  process.nextTick = function () {\n    if (!n.enabled) return r.apply(process, arguments);\n    const o = new Array(arguments.length);\n    for (let e = 0; e < arguments.length; e++) o[e] = arguments[e];\n    const i = o[0];\n    if (\"function\" != typeof i)\n      throw new TypeError(\"callback is not a function\");\n    const s = new t(),\n      a = --n.counter;\n    e.init.call(s, a, 0, null, null);\n    o[0] = function () {\n      e.pre.call(s, a);\n      let t = !0;\n      try {\n        i.apply(this, arguments);\n        t = !1;\n      } finally {\n        if (t && process.listenerCount(\"uncaughtException\") > 0) {\n          process.once(\"uncaughtException\", function () {\n            e.post.call(s, a, !0);\n            e.destroy.call(null, a);\n          });\n        }\n      }\n      e.post.call(s, a, !1);\n      e.destroy.call(null, a);\n    };\n    return r.apply(process, o);\n  };\n};",
  "3286": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.normalizeIndentCharacter = undefined;\nexports.normalizeIndentCharacter = function (e, t, n) {\n  function r(e, t, n) {\n    const r = new RegExp(`^(${t})+`, \"g\");\n    return e\n      .split(\"\\n\")\n      .map((e) => {\n        const t = e.replace(r, \"\"),\n          o = e.length - t.length;\n        return n(o) + t;\n      })\n      .join(\"\\n\");\n  }\n  let o;\n  o = undefined === e.tabSize || \"string\" == typeof e.tabSize ? 4 : e.tabSize;\n  if (!1 === e.insertSpaces) {\n    const e = (e) =>\n      r(e, \" \", (e) => \"\\t\".repeat(Math.floor(e / o)) + \" \".repeat(e % o));\n    (t.displayText = e(t.displayText)),\n      (t.completionText = e(t.completionText));\n  } else if (!0 === e.insertSpaces) {\n    const e = (e) => r(e, \"\\t\", (e) => \" \".repeat(e * o));\n    if (\n      ((t.displayText = e(t.displayText)),\n      (t.completionText = e(t.completionText)),\n      n)\n    ) {\n      const e = (e) => {\n        const t = e.length - e.trimLeft().length,\n          n = t % o;\n        return 0 !== n && t > 0\n          ? r(e, \" \".repeat(n), (e) => \" \".repeat((Math.floor(e / o) + 1) * o))\n          : e;\n      };\n      (t.displayText = e(t.displayText)),\n        (t.completionText = e(t.completionText));\n    }\n  }\n  return t;\n};",
  "3301": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(412),\n  o = require(3487),\n  i = require(6776),\n  s = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: !0,\n    error: {\n      message: ({ params: { missingProperty: e } }) =>\n        o.str`must have required property '${e}'`,\n      params: ({ params: { missingProperty: e } }) =>\n        o._`{missingProperty: ${e}}`,\n    },\n    code(e) {\n      const { gen: t, schema: n, schemaCode: s, data: a, $data: c, it: l } = e,\n        { opts: u } = l;\n      if (!c && 0 === n.length) return;\n      const d = n.length >= u.loopRequired;\n      if (l.allErrors) {\n        (function () {\n          if (d || c) e.block$data(o.nil, p);\n          else for (const t of n) r.checkReportMissingProp(e, t);\n        })();\n      } else {\n        (function () {\n          const i = t.let(\"missing\");\n          if (d || c) {\n            const n = t.let(\"valid\", !0);\n            e.block$data(n, () =>\n              (function (n, i) {\n                e.setParams({\n                  missingProperty: n,\n                });\n                t.forOf(\n                  n,\n                  s,\n                  () => {\n                    t.assign(i, r.propertyInData(t, a, n, u.ownProperties));\n                    t.if(o.not(i), () => {\n                      e.error();\n                      t.break();\n                    });\n                  },\n                  o.nil\n                );\n              })(i, n)\n            );\n            e.ok(n);\n          } else {\n            t.if(r.checkMissingProp(e, n, i));\n            r.reportMissingProp(e, i);\n            t.else();\n          }\n        })();\n      }\n      if (u.strictRequired) {\n        const t = e.parentSchema.properties,\n          { definedProperties: r } = e.it;\n        for (const e of n)\n          if (void 0 === (null == t ? void 0 : t[e]) && !r.has(e)) {\n            const t = `required property \"${e}\" is not defined at \"${\n              l.schemaEnv.baseId + l.errSchemaPath\n            }\" (strictRequired)`;\n            (0, i.checkStrictMode)(l, t, l.opts.strictRequired);\n          }\n      }\n      function p() {\n        t.forOf(\"prop\", s, (n) => {\n          e.setParams({\n            missingProperty: n,\n          });\n          t.if(r.noPropertyInData(t, a, n, u.ownProperties), () => e.error());\n        });\n      }\n    },\n  };\nexports.default = s;",
  "3327": "var r;\nr = require(8249);\nrequire(4938);\n(function (e) {\n  var t = r,\n    n = t.lib,\n    o = n.WordArray,\n    i = n.Hasher,\n    s = t.x64.Word,\n    a = t.algo,\n    c = [],\n    l = [],\n    u = [];\n  !(function () {\n    for (var e = 1, t = 0, n = 0; n < 24; n++) {\n      c[e + 5 * t] = (((n + 1) * (n + 2)) / 2) % 64;\n      var r = (2 * e + 3 * t) % 5;\n      e = t % 5;\n      t = r;\n    }\n    for (e = 0; e < 5; e++)\n      for (t = 0; t < 5; t++) l[e + 5 * t] = t + ((2 * e + 3 * t) % 5) * 5;\n    for (var o = 1, i = 0; i < 24; i++) {\n      for (var a = 0, d = 0, p = 0; p < 7; p++) {\n        if (1 & o) {\n          var h = (1 << p) - 1;\n          if (h < 32) {\n            d ^= 1 << h;\n          } else {\n            a ^= 1 << (h - 32);\n          }\n        }\n        if (128 & o) {\n          o = (o << 1) ^ 113;\n        } else {\n          o <<= 1;\n        }\n      }\n      u[i] = s.create(a, d);\n    }\n  })();\n  var d = [];\n  !(function () {\n    for (var e = 0; e < 25; e++) d[e] = s.create();\n  })();\n  var p = (a.SHA3 = i.extend({\n    cfg: i.cfg.extend({\n      outputLength: 512,\n    }),\n    _doReset: function () {\n      for (var e = (this._state = []), t = 0; t < 25; t++) e[t] = new s.init();\n      this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n    },\n    _doProcessBlock: function (e, t) {\n      for (var n = this._state, r = this.blockSize / 2, o = 0; o < r; o++) {\n        var i = e[t + 2 * o],\n          s = e[t + 2 * o + 1];\n        i =\n          (16711935 & ((i << 8) | (i >>> 24))) |\n          (4278255360 & ((i << 24) | (i >>> 8)));\n        s =\n          (16711935 & ((s << 8) | (s >>> 24))) |\n          (4278255360 & ((s << 24) | (s >>> 8)));\n        (I = n[o]).high ^= s;\n        I.low ^= i;\n      }\n      for (var a = 0; a < 24; a++) {\n        for (var p = 0; p < 5; p++) {\n          for (var h = 0, f = 0, m = 0; m < 5; m++) {\n            h ^= (I = n[p + 5 * m]).high;\n            f ^= I.low;\n          }\n          var g = d[p];\n          g.high = h;\n          g.low = f;\n        }\n        for (p = 0; p < 5; p++) {\n          var _ = d[(p + 4) % 5],\n            y = d[(p + 1) % 5],\n            v = y.high,\n            b = y.low;\n          for (\n            h = _.high ^ ((v << 1) | (b >>> 31)),\n              f = _.low ^ ((b << 1) | (v >>> 31)),\n              m = 0;\n            m < 5;\n            m++\n          ) {\n            (I = n[p + 5 * m]).high ^= h;\n            I.low ^= f;\n          }\n        }\n        for (var w = 1; w < 25; w++) {\n          var x = (I = n[w]).high,\n            E = I.low,\n            C = c[w];\n          if (C < 32) {\n            h = (x << C) | (E >>> (32 - C));\n            f = (E << C) | (x >>> (32 - C));\n          } else {\n            h = (E << (C - 32)) | (x >>> (64 - C));\n            f = (x << (C - 32)) | (E >>> (64 - C));\n          }\n          var S = d[l[w]];\n          S.high = h;\n          S.low = f;\n        }\n        var T = d[0],\n          k = n[0];\n        for (T.high = k.high, T.low = k.low, p = 0; p < 5; p++)\n          for (m = 0; m < 5; m++) {\n            var I = n[(w = p + 5 * m)],\n              P = d[w],\n              A = d[((p + 1) % 5) + 5 * m],\n              O = d[((p + 2) % 5) + 5 * m];\n            I.high = P.high ^ (~A.high & O.high);\n            I.low = P.low ^ (~A.low & O.low);\n          }\n        I = n[0];\n        var N = u[a];\n        I.high ^= N.high;\n        I.low ^= N.low;\n      }\n    },\n    _doFinalize: function () {\n      var t = this._data,\n        n = t.words,\n        r = (this._nDataBytes, 8 * t.sigBytes),\n        i = 32 * this.blockSize;\n      n[r >>> 5] |= 1 << (24 - (r % 32));\n      n[((e.ceil((r + 1) / i) * i) >>> 5) - 1] |= 128;\n      t.sigBytes = 4 * n.length;\n      this._process();\n      for (\n        var s = this._state,\n          a = this.cfg.outputLength / 8,\n          c = a / 8,\n          l = [],\n          u = 0;\n        u < c;\n        u++\n      ) {\n        var d = s[u],\n          p = d.high,\n          h = d.low;\n        p =\n          (16711935 & ((p << 8) | (p >>> 24))) |\n          (4278255360 & ((p << 24) | (p >>> 8)));\n        h =\n          (16711935 & ((h << 8) | (h >>> 24))) |\n          (4278255360 & ((h << 24) | (h >>> 8)));\n        l.push(h);\n        l.push(p);\n      }\n      return new o.init(l, a);\n    },\n    clone: function () {\n      for (\n        var e = i.clone.call(this),\n          t = (e._state = this._state.slice(0)),\n          n = 0;\n        n < 25;\n        n++\n      )\n        t[n] = t[n].clone();\n      return e;\n    },\n  }));\n  t.SHA3 = i._createHelper(p);\n  t.HmacSHA3 = i._createHmacHelper(p);\n})(Math);\nmodule.exports = r.SHA3;",
  "3458": "var r = require(9266);\nfunction o(e) {\n  if (\"string\" != typeof e) throw new Error(\"The url must be a string.\");\n  if (/^([a-z\\d-]{1,39})\\/([-\\.\\w]{1,100})$/i.test(e)) {\n    e = \"https://github.com/\" + e;\n  }\n  var t = r(e),\n    n = t.resource.split(\".\"),\n    i = null;\n  switch (\n    ((t.toString = function (e) {\n      return o.stringify(this, e);\n    }),\n    (t.source =\n      n.length > 2 ? n.slice(1 - n.length).join(\".\") : (t.source = t.resource)),\n    (t.git_suffix = /\\.git$/.test(t.pathname)),\n    (t.name = decodeURIComponent(\n      (t.pathname || t.href).replace(/(^\\/)|(\\/$)/g, \"\").replace(/\\.git$/, \"\")\n    )),\n    (t.owner = decodeURIComponent(t.user)),\n    t.source)\n  ) {\n    case \"git.cloudforge.com\":\n      t.owner = t.user;\n      t.organization = n[0];\n      t.source = \"cloudforge.com\";\n      break;\n    case \"visualstudio.com\":\n      if (\"vs-ssh.visualstudio.com\" === t.resource) {\n        if (4 === (i = t.name.split(\"/\")).length) {\n          t.organization = i[1];\n          t.owner = i[2];\n          t.name = i[3];\n          t.full_name = i[2] + \"/\" + i[3];\n        }\n        break;\n      }\n      if (2 === (i = t.name.split(\"/\")).length) {\n        t.owner = i[1];\n        t.name = i[1];\n        t.full_name = \"_git/\" + t.name;\n      } else {\n        if (3 === i.length) {\n          t.name = i[2];\n          if (\"DefaultCollection\" === i[0]) {\n            t.owner = i[2];\n            t.organization = i[0];\n            t.full_name = t.organization + \"/_git/\" + t.name;\n          } else {\n            t.owner = i[0];\n            t.full_name = t.owner + \"/_git/\" + t.name;\n          }\n        } else {\n          if (4 === i.length) {\n            t.organization = i[0];\n            t.owner = i[1];\n            t.name = i[3];\n            t.full_name = t.organization + \"/\" + t.owner + \"/_git/\" + t.name;\n          }\n        }\n      }\n      break;\n    case \"dev.azure.com\":\n    case \"azure.com\":\n      if (\"ssh.dev.azure.com\" === t.resource) {\n        if (4 === (i = t.name.split(\"/\")).length) {\n          t.organization = i[1];\n          t.owner = i[2];\n          t.name = i[3];\n        }\n        break;\n      }\n      if (5 === (i = t.name.split(\"/\")).length) {\n        t.organization = i[0];\n        t.owner = i[1];\n        t.name = i[4];\n        t.full_name = \"_git/\" + t.name;\n      } else {\n        if (3 === i.length) {\n          t.name = i[2];\n          if (\"DefaultCollection\" === i[0]) {\n            t.owner = i[2];\n            t.organization = i[0];\n            t.full_name = t.organization + \"/_git/\" + t.name;\n          } else {\n            t.owner = i[0];\n            t.full_name = t.owner + \"/_git/\" + t.name;\n          }\n        } else {\n          if (4 === i.length) {\n            t.organization = i[0];\n            t.owner = i[1];\n            t.name = i[3];\n            t.full_name = t.organization + \"/\" + t.owner + \"/_git/\" + t.name;\n          }\n        }\n      }\n      if (t.query && t.query.path) {\n        t.filepath = t.query.path.replace(/^\\/+/g, \"\");\n      }\n      if (t.query && t.query.version) {\n        t.ref = t.query.version.replace(/^GB/, \"\");\n      }\n      break;\n    default:\n      var s = (i = t.name.split(\"/\")).length - 1;\n      if (i.length >= 2) {\n        var a = i.indexOf(\"-\", 2),\n          c = i.indexOf(\"blob\", 2),\n          l = i.indexOf(\"tree\", 2),\n          u = i.indexOf(\"commit\", 2),\n          d = i.indexOf(\"src\", 2),\n          p = i.indexOf(\"raw\", 2),\n          h = i.indexOf(\"edit\", 2);\n        s =\n          a > 0\n            ? a - 1\n            : c > 0\n            ? c - 1\n            : l > 0\n            ? l - 1\n            : u > 0\n            ? u - 1\n            : d > 0\n            ? d - 1\n            : p > 0\n            ? p - 1\n            : h > 0\n            ? h - 1\n            : s;\n        t.owner = i.slice(0, s).join(\"/\");\n        t.name = i[s];\n        if (u) {\n          t.commit = i[s + 2];\n        }\n      }\n      t.ref = \"\";\n      t.filepathtype = \"\";\n      t.filepath = \"\";\n      var f = i.length > s && \"-\" === i[s + 1] ? s + 1 : s;\n      if (\n        i.length > f + 2 &&\n        [\"raw\", \"src\", \"blob\", \"tree\", \"edit\"].indexOf(i[f + 1]) >= 0\n      ) {\n        t.filepathtype = i[f + 1];\n        t.ref = i[f + 2];\n        if (i.length > f + 3) {\n          t.filepath = i.slice(f + 3).join(\"/\");\n        }\n      }\n      t.organization = t.owner;\n  }\n  if (t.full_name) {\n    t.full_name = t.owner;\n    if (t.name) {\n      if (t.full_name) {\n        t.full_name += \"/\";\n      }\n      t.full_name += t.name;\n    }\n  }\n  if (t.owner.startsWith(\"scm/\")) {\n    t.source = \"bitbucket-server\";\n    t.owner = t.owner.replace(\"scm/\", \"\");\n    t.organization = t.owner;\n    t.full_name = t.owner + \"/\" + t.name;\n  }\n  var m = /(projects|users)\\/(.*?)\\/repos\\/(.*?)((\\/.*$)|$)/.exec(t.pathname);\n  if (null != m) {\n    t.source = \"bitbucket-server\";\n    if (\"users\" === m[1]) {\n      t.owner = \"~\" + m[2];\n    } else {\n      t.owner = m[2];\n    }\n    t.organization = t.owner;\n    t.name = m[3];\n    if ((i = m[4].split(\"/\")).length > 1) {\n      if ([\"raw\", \"browse\"].indexOf(i[1]) >= 0) {\n        t.filepathtype = i[1];\n        if (i.length > 2) {\n          t.filepath = i.slice(2).join(\"/\");\n        }\n      } else {\n        if (\"commits\" === i[1] && i.length > 2) {\n          t.commit = i[2];\n        }\n      }\n    }\n    t.full_name = t.owner + \"/\" + t.name;\n    if (t.query.at) {\n      t.ref = t.query.at;\n    } else {\n      t.ref = \"\";\n    }\n  }\n  return t;\n}\no.stringify = function (e, t) {\n  t =\n    t ||\n    (e.protocols && e.protocols.length ? e.protocols.join(\"+\") : e.protocol);\n  var n = e.port ? \":\" + e.port : \"\",\n    r = e.user || \"git\",\n    o = e.git_suffix ? \".git\" : \"\";\n  switch (t) {\n    case \"ssh\":\n      return n\n        ? \"ssh://\" + r + \"@\" + e.resource + n + \"/\" + e.full_name + o\n        : r + \"@\" + e.resource + \":\" + e.full_name + o;\n    case \"git+ssh\":\n    case \"ssh+git\":\n    case \"ftp\":\n    case \"ftps\":\n      return t + \"://\" + r + \"@\" + e.resource + n + \"/\" + e.full_name + o;\n    case \"http\":\n    case \"https\":\n      return (\n        t +\n        \"://\" +\n        (e.token\n          ? (function (e) {\n              return \"bitbucket.org\" === e.source\n                ? \"x-token-auth:\" + e.token + \"@\"\n                : e.token + \"@\";\n            })(e)\n          : e.user &&\n            (e.protocols.includes(\"http\") || e.protocols.includes(\"https\"))\n          ? e.user + \"@\"\n          : \"\") +\n        e.resource +\n        n +\n        \"/\" +\n        (function (e) {\n          return \"bitbucket-server\" === e.source\n            ? \"scm/\" + e.full_name\n            : \"\" + e.full_name;\n        })(e) +\n        o\n      );\n    default:\n      return e.href;\n  }\n};\nmodule.exports = o;",
  "3487": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.or =\n  exports.and =\n  exports.not =\n  exports.CodeGen =\n  exports.operators =\n  exports.varKinds =\n  exports.ValueScopeName =\n  exports.ValueScope =\n  exports.Scope =\n  exports.Name =\n  exports.regexpCode =\n  exports.stringify =\n  exports.getProperty =\n  exports.nil =\n  exports.strConcat =\n  exports.str =\n  exports._ =\n    undefined;\nconst r = require(7023),\n  o = require(8490);\nvar i = require(7023);\nexports._ = i._;\nexports.str = i.str;\nexports.strConcat = i.strConcat;\nexports.nil = i.nil;\nexports.getProperty = i.getProperty;\nexports.stringify = i.stringify;\nexports.regexpCode = i.regexpCode;\nexports.Name = i.Name;\nvar s = require(8490);\nexports.Scope = s.Scope;\nexports.ValueScope = s.ValueScope;\nexports.ValueScopeName = s.ValueScopeName;\nexports.varKinds = s.varKinds;\nexports.operators = {\n  GT: new r._Code(\">\"),\n  GTE: new r._Code(\">=\"),\n  LT: new r._Code(\"<\"),\n  LTE: new r._Code(\"<=\"),\n  EQ: new r._Code(\"===\"),\n  NEQ: new r._Code(\"!==\"),\n  NOT: new r._Code(\"!\"),\n  OR: new r._Code(\"||\"),\n  AND: new r._Code(\"&&\"),\n  ADD: new r._Code(\"+\"),\n};\nclass a {\n  optimizeNodes() {\n    return this;\n  }\n  optimizeNames(e, t) {\n    return this;\n  }\n}\nclass c extends a {\n  constructor(e, t, n) {\n    super();\n    this.varKind = e;\n    this.name = t;\n    this.rhs = n;\n  }\n  render({ es5: e, _n: t }) {\n    const n = e ? o.varKinds.var : this.varKind,\n      r = undefined === this.rhs ? \"\" : ` = ${this.rhs}`;\n    return `${n} ${this.name}${r};` + t;\n  }\n  optimizeNames(e, t) {\n    if (e[this.name.str]) {\n      if (this.rhs) {\n        this.rhs = O(this.rhs, e, t);\n      }\n      return this;\n    }\n  }\n  get names() {\n    return this.rhs instanceof r._CodeOrName ? this.rhs.names : {};\n  }\n}\nclass l extends a {\n  constructor(e, t, n) {\n    super();\n    this.lhs = e;\n    this.rhs = t;\n    this.sideEffects = n;\n  }\n  render({ _n: e }) {\n    return `${this.lhs} = ${this.rhs};` + e;\n  }\n  optimizeNames(e, t) {\n    if (!(this.lhs instanceof r.Name) || e[this.lhs.str] || this.sideEffects) {\n      this.rhs = O(this.rhs, e, t);\n      return this;\n    }\n  }\n  get names() {\n    return A(\n      this.lhs instanceof r.Name\n        ? {}\n        : {\n            ...this.lhs.names,\n          },\n      this.rhs\n    );\n  }\n}\nclass u extends l {\n  constructor(e, t, n, r) {\n    super(e, n, r);\n    this.op = t;\n  }\n  render({ _n: e }) {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + e;\n  }\n}\nclass d extends a {\n  constructor(e) {\n    super();\n    this.label = e;\n    this.names = {};\n  }\n  render({ _n: e }) {\n    return `${this.label}:` + e;\n  }\n}\nclass p extends a {\n  constructor(e) {\n    super();\n    this.label = e;\n    this.names = {};\n  }\n  render({ _n: e }) {\n    return `break${this.label ? ` ${this.label}` : \"\"};` + e;\n  }\n}\nclass h extends a {\n  constructor(e) {\n    super();\n    this.error = e;\n  }\n  render({ _n: e }) {\n    return `throw ${this.error};` + e;\n  }\n  get names() {\n    return this.error.names;\n  }\n}\nclass f extends a {\n  constructor(e) {\n    super();\n    this.code = e;\n  }\n  render({ _n: e }) {\n    return `${this.code};` + e;\n  }\n  optimizeNodes() {\n    return `${this.code}` ? this : undefined;\n  }\n  optimizeNames(e, t) {\n    this.code = O(this.code, e, t);\n    return this;\n  }\n  get names() {\n    return this.code instanceof r._CodeOrName ? this.code.names : {};\n  }\n}\nclass m extends a {\n  constructor(e = []) {\n    super();\n    this.nodes = e;\n  }\n  render(e) {\n    return this.nodes.reduce((t, n) => t + n.render(e), \"\");\n  }\n  optimizeNodes() {\n    const { nodes: e } = this;\n    let t = e.length;\n    for (; t--; ) {\n      const n = e[t].optimizeNodes();\n      if (Array.isArray(n)) {\n        e.splice(t, 1, ...n);\n      } else {\n        if (n) {\n          e[t] = n;\n        } else {\n          e.splice(t, 1);\n        }\n      }\n    }\n    return e.length > 0 ? this : undefined;\n  }\n  optimizeNames(e, t) {\n    const { nodes: n } = this;\n    let r = n.length;\n    for (; r--; ) {\n      const o = n[r];\n      if (o.optimizeNames(e, t)) {\n        N(e, o.names);\n        n.splice(r, 1);\n      }\n    }\n    return n.length > 0 ? this : undefined;\n  }\n  get names() {\n    return this.nodes.reduce((e, t) => P(e, t.names), {});\n  }\n}\nclass g extends m {\n  render(e) {\n    return \"{\" + e._n + super.render(e) + \"}\" + e._n;\n  }\n}\nclass _ extends m {}\nclass y extends g {}\ny.kind = \"else\";\nclass v extends g {\n  constructor(e, t) {\n    super(t);\n    this.condition = e;\n  }\n  render(e) {\n    let t = `if(${this.condition})` + super.render(e);\n    if (this.else) {\n      t += \"else \" + this.else.render(e);\n    }\n    return t;\n  }\n  optimizeNodes() {\n    super.optimizeNodes();\n    const e = this.condition;\n    if (!0 === e) return this.nodes;\n    let t = this.else;\n    if (t) {\n      const e = t.optimizeNodes();\n      t = this.else = Array.isArray(e) ? new y(e) : e;\n    }\n    return t\n      ? !1 === e\n        ? t instanceof v\n          ? t\n          : t.nodes\n        : this.nodes.length\n        ? this\n        : new v(not(e), t instanceof v ? [t] : t.nodes)\n      : !1 !== e && this.nodes.length\n      ? this\n      : undefined;\n  }\n  optimizeNames(e, t) {\n    var n;\n    this.else =\n      null === (n = this.else) || undefined === n\n        ? undefined\n        : n.optimizeNames(e, t);\n    if (super.optimizeNames(e, t) || this.else)\n      return (this.condition = O(this.condition, e, t)), this;\n  }\n  get names() {\n    const e = super.names;\n    A(e, this.condition);\n    if (this.else) {\n      P(e, this.else.names);\n    }\n    return e;\n  }\n}\nv.kind = \"if\";\nclass b extends g {}\nb.kind = \"for\";\nclass w extends b {\n  constructor(e) {\n    super();\n    this.iteration = e;\n  }\n  render(e) {\n    return `for(${this.iteration})` + super.render(e);\n  }\n  optimizeNames(e, t) {\n    if (super.optimizeNames(e, t)) {\n      this.iteration = O(this.iteration, e, t);\n      return this;\n    }\n  }\n  get names() {\n    return P(super.names, this.iteration.names);\n  }\n}\nclass x extends b {\n  constructor(e, t, n, r) {\n    super();\n    this.varKind = e;\n    this.name = t;\n    this.from = n;\n    this.to = r;\n  }\n  render(e) {\n    const t = e.es5 ? o.varKinds.var : this.varKind,\n      { name: n, from: r, to: i } = this;\n    return `for(${t} ${n}=${r}; ${n}<${i}; ${n}++)` + super.render(e);\n  }\n  get names() {\n    const e = A(super.names, this.from);\n    return A(e, this.to);\n  }\n}\nclass E extends b {\n  constructor(e, t, n, r) {\n    super();\n    this.loop = e;\n    this.varKind = t;\n    this.name = n;\n    this.iterable = r;\n  }\n  render(e) {\n    return (\n      `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` +\n      super.render(e)\n    );\n  }\n  optimizeNames(e, t) {\n    if (super.optimizeNames(e, t)) {\n      this.iterable = O(this.iterable, e, t);\n      return this;\n    }\n  }\n  get names() {\n    return P(super.names, this.iterable.names);\n  }\n}\nclass C extends g {\n  constructor(e, t, n) {\n    super();\n    this.name = e;\n    this.args = t;\n    this.async = n;\n  }\n  render(e) {\n    return (\n      `${this.async ? \"async \" : \"\"}function ${this.name}(${this.args})` +\n      super.render(e)\n    );\n  }\n}\nC.kind = \"func\";\nclass S extends m {\n  render(e) {\n    return \"return \" + super.render(e);\n  }\n}\nS.kind = \"return\";\nclass T extends g {\n  render(e) {\n    let t = \"try\" + super.render(e);\n    if (this.catch) {\n      t += this.catch.render(e);\n    }\n    if (this.finally) {\n      t += this.finally.render(e);\n    }\n    return t;\n  }\n  optimizeNodes() {\n    var e, t;\n    super.optimizeNodes();\n    if (null === (e = this.catch) || undefined === e) {\n      e.optimizeNodes();\n    }\n    if (null === (t = this.finally) || undefined === t) {\n      t.optimizeNodes();\n    }\n    return this;\n  }\n  optimizeNames(e, t) {\n    var n, r;\n    super.optimizeNames(e, t);\n    if (null === (n = this.catch) || undefined === n) {\n      n.optimizeNames(e, t);\n    }\n    if (null === (r = this.finally) || undefined === r) {\n      r.optimizeNames(e, t);\n    }\n    return this;\n  }\n  get names() {\n    const e = super.names;\n    if (this.catch) {\n      P(e, this.catch.names);\n    }\n    if (this.finally) {\n      P(e, this.finally.names);\n    }\n    return e;\n  }\n}\nclass k extends g {\n  constructor(e) {\n    super();\n    this.error = e;\n  }\n  render(e) {\n    return `catch(${this.error})` + super.render(e);\n  }\n}\nk.kind = \"catch\";\nclass I extends g {\n  render(e) {\n    return \"finally\" + super.render(e);\n  }\n}\nfunction P(e, t) {\n  for (const n in t) e[n] = (e[n] || 0) + (t[n] || 0);\n  return e;\n}\nfunction A(e, t) {\n  return t instanceof r._CodeOrName ? P(e, t.names) : e;\n}\nfunction O(e, t, n) {\n  return e instanceof r.Name\n    ? i(e)\n    : (o = e) instanceof r._Code &&\n      o._items.some(\n        (e) => e instanceof r.Name && 1 === t[e.str] && undefined !== n[e.str]\n      )\n    ? new r._Code(\n        e._items.reduce(\n          (e, t) => (\n            t instanceof r.Name && (t = i(t)),\n            t instanceof r._Code ? e.push(...t._items) : e.push(t),\n            e\n          ),\n          []\n        )\n      )\n    : e;\n  var o;\n  function i(e) {\n    const r = n[e.str];\n    return undefined === r || 1 !== t[e.str] ? e : (delete t[e.str], r);\n  }\n}\nfunction N(e, t) {\n  for (const n in t) e[n] = (e[n] || 0) - (t[n] || 0);\n}\nfunction not(e) {\n  return \"boolean\" == typeof e || \"number\" == typeof e || null === e\n    ? !e\n    : r._`!${D(e)}`;\n}\nI.kind = \"finally\";\nexports.CodeGen = class {\n  constructor(e, t = {}) {\n    this._values = {};\n    this._blockStarts = [];\n    this._constants = {};\n    this.opts = {\n      ...t,\n      _n: t.lines ? \"\\n\" : \"\",\n    };\n    this._extScope = e;\n    this._scope = new o.Scope({\n      parent: e,\n    });\n    this._nodes = [new _()];\n  }\n  toString() {\n    return this._root.render(this.opts);\n  }\n  name(e) {\n    return this._scope.name(e);\n  }\n  scopeName(e) {\n    return this._extScope.name(e);\n  }\n  scopeValue(e, t) {\n    const n = this._extScope.value(e, t);\n    (this._values[n.prefix] || (this._values[n.prefix] = new Set())).add(n);\n    return n;\n  }\n  getScopeValue(e, t) {\n    return this._extScope.getValue(e, t);\n  }\n  scopeRefs(e) {\n    return this._extScope.scopeRefs(e, this._values);\n  }\n  scopeCode() {\n    return this._extScope.scopeCode(this._values);\n  }\n  _def(e, t, n, r) {\n    const o = this._scope.toName(t);\n    if (undefined !== n && r) {\n      this._constants[o.str] = n;\n    }\n    this._leafNode(new c(e, o, n));\n    return o;\n  }\n  const(e, t, n) {\n    return this._def(o.varKinds.const, e, t, n);\n  }\n  let(e, t, n) {\n    return this._def(o.varKinds.let, e, t, n);\n  }\n  var(e, t, n) {\n    return this._def(o.varKinds.var, e, t, n);\n  }\n  assign(e, t, n) {\n    return this._leafNode(new l(e, t, n));\n  }\n  add(e, n) {\n    return this._leafNode(new u(e, exports.operators.ADD, n));\n  }\n  code(e) {\n    if (\"function\" == typeof e) {\n      e();\n    } else {\n      if (e !== r.nil) {\n        this._leafNode(new f(e));\n      }\n    }\n    return this;\n  }\n  object(...e) {\n    const t = [\"{\"];\n    for (const [n, o] of e) {\n      if (t.length > 1) {\n        t.push(\",\");\n      }\n      t.push(n);\n      if (n !== o || this.opts.es5) {\n        t.push(\":\");\n        r.addCodeArg(t, o);\n      }\n    }\n    t.push(\"}\");\n    return new r._Code(t);\n  }\n  if(e, t, n) {\n    this._blockNode(new v(e));\n    if (t && n) this.code(t).else().code(n).endIf();\n    else if (t) this.code(t).endIf();\n    else if (n) throw new Error('CodeGen: \"else\" body without \"then\" body');\n    return this;\n  }\n  elseIf(e) {\n    return this._elseNode(new v(e));\n  }\n  else() {\n    return this._elseNode(new y());\n  }\n  endIf() {\n    return this._endBlockNode(v, y);\n  }\n  _for(e, t) {\n    this._blockNode(e);\n    if (t) {\n      this.code(t).endFor();\n    }\n    return this;\n  }\n  for(e, t) {\n    return this._for(new w(e), t);\n  }\n  forRange(e, t, n, r, i = this.opts.es5 ? o.varKinds.var : o.varKinds.let) {\n    const s = this._scope.toName(e);\n    return this._for(new x(i, s, t, n), () => r(s));\n  }\n  forOf(e, t, n, i = o.varKinds.const) {\n    const s = this._scope.toName(e);\n    if (this.opts.es5) {\n      const e = t instanceof r.Name ? t : this.var(\"_arr\", t);\n      return this.forRange(\"_i\", 0, r._`${e}.length`, (t) => {\n        this.var(s, r._`${e}[${t}]`);\n        n(s);\n      });\n    }\n    return this._for(new E(\"of\", i, s, t), () => n(s));\n  }\n  forIn(e, t, n, i = this.opts.es5 ? o.varKinds.var : o.varKinds.const) {\n    if (this.opts.ownProperties)\n      return this.forOf(e, r._`Object.keys(${t})`, n);\n    const s = this._scope.toName(e);\n    return this._for(new E(\"in\", i, s, t), () => n(s));\n  }\n  endFor() {\n    return this._endBlockNode(b);\n  }\n  label(e) {\n    return this._leafNode(new d(e));\n  }\n  break(e) {\n    return this._leafNode(new p(e));\n  }\n  return(e) {\n    const t = new S();\n    this._blockNode(t);\n    this.code(e);\n    if (1 !== t.nodes.length)\n      throw new Error('CodeGen: \"return\" should have one node');\n    return this._endBlockNode(S);\n  }\n  try(e, t, n) {\n    if (!t && !n)\n      throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n    const r = new T();\n    this._blockNode(r);\n    this.code(e);\n    if (t) {\n      const e = this.name(\"e\");\n      (this._currNode = r.catch = new k(e)), t(e);\n    }\n    if (n) {\n      this._currNode = r.finally = new I();\n      this.code(n);\n    }\n    return this._endBlockNode(k, I);\n  }\n  throw(e) {\n    return this._leafNode(new h(e));\n  }\n  block(e, t) {\n    this._blockStarts.push(this._nodes.length);\n    if (e) {\n      this.code(e).endBlock(t);\n    }\n    return this;\n  }\n  endBlock(e) {\n    const t = this._blockStarts.pop();\n    if (undefined === t)\n      throw new Error(\"CodeGen: not in self-balancing block\");\n    const n = this._nodes.length - t;\n    if (n < 0 || (undefined !== e && n !== e))\n      throw new Error(`CodeGen: wrong number of nodes: ${n} vs ${e} expected`);\n    this._nodes.length = t;\n    return this;\n  }\n  func(e, t = r.nil, n, o) {\n    this._blockNode(new C(e, t, n));\n    if (o) {\n      this.code(o).endFunc();\n    }\n    return this;\n  }\n  endFunc() {\n    return this._endBlockNode(C);\n  }\n  optimize(e = 1) {\n    for (; e-- > 0; ) {\n      this._root.optimizeNodes();\n      this._root.optimizeNames(this._root.names, this._constants);\n    }\n  }\n  _leafNode(e) {\n    this._currNode.nodes.push(e);\n    return this;\n  }\n  _blockNode(e) {\n    this._currNode.nodes.push(e);\n    this._nodes.push(e);\n  }\n  _endBlockNode(e, t) {\n    const n = this._currNode;\n    if (n instanceof e || (t && n instanceof t)) {\n      this._nodes.pop();\n      return this;\n    }\n    throw new Error(\n      `CodeGen: not in block \"${t ? `${e.kind}/${t.kind}` : e.kind}\"`\n    );\n  }\n  _elseNode(e) {\n    const t = this._currNode;\n    if (!(t instanceof v)) throw new Error('CodeGen: \"else\" without \"if\"');\n    this._currNode = t.else = e;\n    return this;\n  }\n  get _root() {\n    return this._nodes[0];\n  }\n  get _currNode() {\n    const e = this._nodes;\n    return e[e.length - 1];\n  }\n  set _currNode(e) {\n    const t = this._nodes;\n    t[t.length - 1] = e;\n  }\n};\nexports.not = not;\nconst M = $(exports.operators.AND);\nexports.and = function (...e) {\n  return e.reduce(M);\n};\nconst L = $(exports.operators.OR);\nfunction $(e) {\n  return (t, n) =>\n    t === r.nil ? n : n === r.nil ? t : r._`${D(t)} ${e} ${D(n)}`;\n}\nfunction D(e) {\n  return e instanceof r.Name ? e : r._`(${e})`;\n}\nexports.or = function (...e) {\n  return e.reduce(L);\n};",
  "3504": "var r = require(5282),\n  o = (function () {\n    function e(e, t, n, r) {\n      this._buffer = [];\n      this._lastSend = 0;\n      this._isDisabled = e;\n      this._getBatchSize = t;\n      this._getBatchIntervalMs = n;\n      this._sender = r;\n    }\n    e.prototype.setUseDiskRetryCaching = function (e, t, n) {\n      this._sender.setDiskRetryMode(e, t, n);\n    };\n    e.prototype.send = function (e) {\n      var t = this;\n      if (!this._isDisabled())\n        if (e) {\n          var n = this._stringify(e);\n          if (\"string\" == typeof n) {\n            this._buffer.push(n);\n            if (this._buffer.length >= this._getBatchSize()) {\n              this.triggerSend(!1);\n            } else {\n              if (!this._timeoutHandle && this._buffer.length > 0) {\n                this._timeoutHandle = setTimeout(function () {\n                  t._timeoutHandle = null;\n                  t.triggerSend(!1);\n                }, this._getBatchIntervalMs());\n              }\n            }\n          }\n        } else r.warn(\"Cannot send null/undefined telemetry\");\n    };\n    e.prototype.triggerSend = function (e, t) {\n      var n = this._buffer.length < 1;\n      if (!n) {\n        var r = this._buffer.join(\"\\n\");\n        if (e) {\n          this._sender.saveOnCrash(r);\n          if (\"function\" == typeof t) {\n            t(\"data saved on crash\");\n          }\n        } else {\n          this._sender.send(Buffer.from ? Buffer.from(r) : new Buffer(r), t);\n        }\n      }\n      this._lastSend = +new Date();\n      this._buffer.length = 0;\n      clearTimeout(this._timeoutHandle);\n      this._timeoutHandle = null;\n      if (n && \"function\" == typeof t) {\n        t(\"no data to send\");\n      }\n    };\n    e.prototype._stringify = function (e) {\n      try {\n        return JSON.stringify(e);\n      } catch (t) {\n        r.warn(\"Failed to serialize payload\", t, e);\n      }\n    };\n    return e;\n  })();\nmodule.exports = o;",
  "3507": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.extractLocalImportContext = exports.getDocComment = undefined;\nconst r = require(\"path\"),\n  o = require(464);\nfunction i(e, t) {\n  var n;\n  let o =\n    null === (n = t.namedChild(1)) || undefined === n\n      ? undefined\n      : n.text.slice(1, -1);\n  if (!o || !o.startsWith(\".\")) return null;\n  if (\"\" === r.extname(o)) o += \".ts\";\n  else if (\".ts\" !== r.extname(o)) return null;\n  return r.join(r.dirname(e), o);\n}\nfunction s(e) {\n  var t, n, r, o, i;\n  let s = [];\n  if (\n    \"import_clause\" ===\n    (null === (t = e.namedChild(0)) || undefined === t ? undefined : t.type)\n  ) {\n    let t = e.namedChild(0);\n    if (\n      \"named_imports\" ===\n      (null === (n = null == t ? undefined : t.namedChild(0)) || undefined === n\n        ? undefined\n        : n.type)\n    ) {\n      let e = t.namedChild(0);\n      for (let t of null !== (r = null == e ? undefined : e.namedChildren) &&\n      undefined !== r\n        ? r\n        : [])\n        if (\"import_specifier\" === t.type) {\n          const e =\n            null === (o = t.childForFieldName(\"name\")) || undefined === o\n              ? undefined\n              : o.text;\n          if (e) {\n            const n =\n              null === (i = t.childForFieldName(\"alias\")) || undefined === i\n                ? undefined\n                : i.text;\n            s.push({\n              name: e,\n              alias: n,\n            });\n          }\n        }\n    }\n  }\n  return s;\n}\nconst a = new Map();\nfunction c(e, t) {\n  var n, r;\n  let o =\n    null !==\n      (r =\n        null === (n = null == t ? undefined : t.childForFieldName(\"name\")) ||\n        undefined === n\n          ? undefined\n          : n.text) && undefined !== r\n      ? r\n      : \"\";\n  switch (null == t ? undefined : t.type) {\n    case \"ambient_declaration\":\n      return c(e, t.namedChild(0));\n    case \"interface_declaration\":\n    case \"enum_declaration\":\n    case \"type_alias_declaration\":\n      return {\n        name: o,\n        decl: t.text,\n      };\n    case \"function_declaration\":\n    case \"function_signature\":\n      return {\n        name: o,\n        decl: l(e, t),\n      };\n    case \"class_declaration\": {\n      let n = (function (e, t) {\n          let n = t.childForFieldName(\"body\");\n          if (n) return n.namedChildren.map((t) => d(e, t)).filter((e) => e);\n        })(e, t),\n        r = \"\";\n      if (n) {\n        let o = t.childForFieldName(\"body\");\n        r = `declare ${e.substring(t.startIndex, o.startIndex + 1)}`;\n        r += n.map((e) => \"\\n\" + e).join(\"\");\n        r += \"\\n}\";\n      }\n      return {\n        name: o,\n        decl: r,\n      };\n    }\n  }\n  return {\n    name: o,\n    decl: \"\",\n  };\n}\nfunction l(e, t) {\n  var n, r, o;\n  const i =\n    null !==\n      (r =\n        null === (n = t.childForFieldName(\"return_type\")) || undefined === n\n          ? undefined\n          : n.endIndex) && undefined !== r\n      ? r\n      : null === (o = t.childForFieldName(\"parameters\")) || undefined === o\n      ? undefined\n      : o.endIndex;\n  if (undefined !== i) {\n    let n = e.substring(t.startIndex, i) + \";\";\n    return \"function_declaration\" === t.type || \"function_signature\" === t.type\n      ? \"declare \" + n\n      : n;\n  }\n  return \"\";\n}\nfunction getDocComment(e, t) {\n  const n = o.getFirstPrecedingComment(t);\n  return n ? e.substring(n.startIndex, t.startIndex) : \"\";\n}\nfunction d(e, t) {\n  var n, r, i, s, a;\n  if (\n    \"accessibility_modifier\" ===\n      (null === (n = null == t ? undefined : t.firstChild) || undefined === n\n        ? undefined\n        : n.type) &&\n    \"private\" === t.firstChild.text\n  )\n    return \"\";\n  const c = o.getFirstPrecedingComment(t),\n    p =\n      null !==\n        (r = (function (e, t) {\n          let n = t.startIndex - 1;\n          for (; n >= 0 && (\" \" === e[n] || \"\\t\" === e[n]); ) n--;\n          if (n < 0 || \"\\n\" === e[n]) return e.substring(n + 1, t.startIndex);\n        })(e, null != c ? c : t)) && undefined !== r\n        ? r\n        : \"  \",\n    h = getDocComment(e, t);\n  switch (t.type) {\n    case \"ambient_declaration\":\n      const n = t.namedChild(0);\n      return n ? p + h + d(e, n) : \"\";\n    case \"method_definition\":\n    case \"method_signature\":\n      return p + h + l(e, t);\n    case \"public_field_definition\": {\n      let n =\n        null !==\n          (s =\n            null === (i = t.childForFieldName(\"type\")) || undefined === i\n              ? undefined\n              : i.endIndex) && undefined !== s\n          ? s\n          : null === (a = t.childForFieldName(\"name\")) || undefined === a\n          ? undefined\n          : a.endIndex;\n      if (undefined !== n) return p + h + e.substring(t.startIndex, n) + \";\";\n    }\n  }\n  return \"\";\n}\nasync function p(e, t, n) {\n  let r = new Map(),\n    i = -1;\n  try {\n    i = await n.mtime(e);\n  } catch {\n    return r;\n  }\n  let s = a.get(e);\n  if (s && s.mtime === i) return s.exports;\n  if (\"typescript\" === t) {\n    let i = null;\n    try {\n      let s = (await n.readFile(e)).toString();\n      i = await o.parseTree(t, s);\n      for (let e of o.queryExports(t, i.rootNode))\n        for (let t of e.captures) {\n          let e = t.node;\n          if (\"export_statement\" === e.type) {\n            let t = e.childForFieldName(\"declaration\");\n            if (null == t ? undefined : t.hasError()) continue;\n            let { name: n, decl: o } = c(s, t);\n            if (n) {\n              o = getDocComment(s, e) + o;\n              let t = r.get(n);\n              if (t) {\n                t = [];\n                r.set(n, t);\n              }\n              t.push(o);\n            }\n          }\n        }\n    } catch {\n    } finally {\n      if (i) {\n        i.delete();\n      }\n    }\n  }\n  if (a.size > 2e3)\n    for (let e of a.keys()) {\n      a.delete(e);\n      if (r.size <= 1e3) break;\n    }\n  a.set(e, {\n    mtime: i,\n    exports: r,\n  });\n  return r;\n}\nexports.getDocComment = getDocComment;\nconst h = /^\\s*import\\s*(type|)\\s*\\{[^}]*\\}\\s*from\\s*['\"]\\./gm;\nexports.extractLocalImportContext = async function (e, t) {\n  let { source: n, uri: r, languageId: a } = e;\n  return t && \"typescript\" === a\n    ? (async function (e, t, n) {\n        let r = \"typescript\",\n          a = [];\n        const c = (function (e) {\n          let t,\n            n = -1;\n          h.lastIndex = -1;\n          do {\n            t = h.exec(e);\n            if (t) {\n              n = h.lastIndex + t.length;\n            }\n          } while (t);\n          if (-1 === n) return -1;\n          const r = e.indexOf(\"\\n\", n);\n          return -1 !== r ? r : e.length;\n        })(e);\n        if (-1 === c) return a;\n        e = e.substring(0, c);\n        let l = await o.parseTree(r, e);\n        try {\n          for (let e of (function (e) {\n            let t = [];\n            for (let n of e.namedChildren)\n              if (\"import_statement\" === n.type) {\n                t.push(n);\n              }\n            return t;\n          })(l.rootNode)) {\n            let o = i(t, e);\n            if (!o) continue;\n            let c = s(e);\n            if (0 === c.length) continue;\n            let l = await p(o, r, n);\n            for (let e of c)\n              if (l.has(e.name)) {\n                a.push(...l.get(e.name));\n              }\n          }\n        } finally {\n          l.delete();\n        }\n        return a;\n      })(n, r, t)\n    : [];\n};",
  "3510": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(4063);\nr.code = 'require(\"ajv/dist/runtime/equal\").default';\nexports.default = r;",
  "3580": "var n, r, o;\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.DEFAULT_BREEZE_ENDPOINT = \"https://dc.services.visualstudio.com\";\nexports.DEFAULT_LIVEMETRICS_ENDPOINT = \"https://rt.services.visualstudio.com\";\nexports.DEFAULT_LIVEMETRICS_HOST = \"rt.services.visualstudio.com\";\n(function (e) {\n  e.COMMITTED_BYTES = \"\\\\Memory\\\\Committed Bytes\";\n  e.PROCESSOR_TIME = \"\\\\Processor(_Total)\\\\% Processor Time\";\n  e.REQUEST_RATE = \"\\\\ApplicationInsights\\\\Requests/Sec\";\n  e.REQUEST_FAILURE_RATE = \"\\\\ApplicationInsights\\\\Requests Failed/Sec\";\n  e.REQUEST_DURATION = \"\\\\ApplicationInsights\\\\Request Duration\";\n  e.DEPENDENCY_RATE = \"\\\\ApplicationInsights\\\\Dependency Calls/Sec\";\n  e.DEPENDENCY_FAILURE_RATE =\n    \"\\\\ApplicationInsights\\\\Dependency Calls Failed/Sec\";\n  e.DEPENDENCY_DURATION = \"\\\\ApplicationInsights\\\\Dependency Call Duration\";\n  e.EXCEPTION_RATE = \"\\\\ApplicationInsights\\\\Exceptions/Sec\";\n})((n = exports.QuickPulseCounter || (exports.QuickPulseCounter = {})));\n(function (e) {\n  e.PRIVATE_BYTES = \"\\\\Process(??APP_WIN32_PROC??)\\\\Private Bytes\";\n  e.AVAILABLE_BYTES = \"\\\\Memory\\\\Available Bytes\";\n  e.PROCESSOR_TIME = \"\\\\Processor(_Total)\\\\% Processor Time\";\n  e.PROCESS_TIME = \"\\\\Process(??APP_WIN32_PROC??)\\\\% Processor Time\";\n  e.REQUEST_RATE = \"\\\\ASP.NET Applications(??APP_W3SVC_PROC??)\\\\Requests/Sec\";\n  e.REQUEST_DURATION =\n    \"\\\\ASP.NET Applications(??APP_W3SVC_PROC??)\\\\Request Execution Time\";\n})((r = exports.PerformanceCounter || (exports.PerformanceCounter = {})));\n(o = {})[r.PROCESSOR_TIME] = n.PROCESSOR_TIME;\no[r.REQUEST_RATE] = n.REQUEST_RATE;\no[r.REQUEST_DURATION] = n.REQUEST_DURATION;\no[n.COMMITTED_BYTES] = n.COMMITTED_BYTES;\no[n.REQUEST_FAILURE_RATE] = n.REQUEST_FAILURE_RATE;\no[n.DEPENDENCY_RATE] = n.DEPENDENCY_RATE;\no[n.DEPENDENCY_FAILURE_RATE] = n.DEPENDENCY_FAILURE_RATE;\no[n.DEPENDENCY_DURATION] = n.DEPENDENCY_DURATION;\no[n.EXCEPTION_RATE] = n.EXCEPTION_RATE;\nexports.PerformanceToQuickPulseCounter = o;\nexports.QuickPulseDocumentType = {\n  Event: \"Event\",\n  Exception: \"Exception\",\n  Trace: \"Trace\",\n  Metric: \"Metric\",\n  Request: \"Request\",\n  Dependency: \"RemoteDependency\",\n  Availability: \"Availability\",\n};\nexports.QuickPulseType = {\n  Event: \"EventTelemetryDocument\",\n  Exception: \"ExceptionTelemetryDocument\",\n  Trace: \"TraceTelemetryDocument\",\n  Metric: \"MetricTelemetryDocument\",\n  Request: \"RequestTelemetryDocument\",\n  Dependency: \"DependencyTelemetryDocument\",\n  Availability: \"AvailabilityTelemetryDocument\",\n};\nexports.TelemetryTypeStringToQuickPulseType = {\n  EventData: exports.QuickPulseType.Event,\n  ExceptionData: exports.QuickPulseType.Exception,\n  MessageData: exports.QuickPulseType.Trace,\n  MetricData: exports.QuickPulseType.Metric,\n  RequestData: exports.QuickPulseType.Request,\n  RemoteDependencyData: exports.QuickPulseType.Dependency,\n  AvailabilityData: exports.QuickPulseType.Availability,\n};\nexports.TelemetryTypeStringToQuickPulseDocumentType = {\n  EventData: exports.QuickPulseDocumentType.Event,\n  ExceptionData: exports.QuickPulseDocumentType.Exception,\n  MessageData: exports.QuickPulseDocumentType.Trace,\n  MetricData: exports.QuickPulseDocumentType.Metric,\n  RequestData: exports.QuickPulseDocumentType.Request,\n  RemoteDependencyData: exports.QuickPulseDocumentType.Dependency,\n  AvailabilityData: exports.QuickPulseDocumentType.Availability,\n};",
  "3615": "var r;\nr = require(8249);\nrequire(5109);\nr.pad.AnsiX923 = {\n  pad: function (e, t) {\n    var n = e.sigBytes,\n      r = 4 * t,\n      o = r - (n % r),\n      i = n + o - 1;\n    e.clamp();\n    e.words[i >>> 2] |= o << (24 - (i % 4) * 8);\n    e.sigBytes += o;\n  },\n  unpad: function (e) {\n    var t = 255 & e.words[(e.sigBytes - 1) >>> 2];\n    e.sigBytes -= t;\n  },\n};\nmodule.exports = r.pad.Ansix923;",
  "3668": "var r = require(5282),\n  o = require(9253),\n  i = require(7148),\n  s = require(9184),\n  a = require(3580),\n  c = require(4470),\n  l = (function () {\n    function e(e, t) {\n      this._isCollectingData = !1;\n      this._lastSuccessTime = Date.now();\n      this._lastSendSucceeded = !0;\n      this._metrics = {};\n      this._documents = [];\n      this._collectors = [];\n      this.config = new o(e);\n      this.context = t || new c();\n      this._sender = new s(this.config);\n      this._isEnabled = !1;\n    }\n    e.prototype.addCollector = function (e) {\n      this._collectors.push(e);\n    };\n    e.prototype.trackMetric = function (e) {\n      this._addMetric(e);\n    };\n    e.prototype.addDocument = function (e) {\n      var t = i.telemetryEnvelopeToQuickPulseDocument(e);\n      if (t) {\n        this._documents.push(t);\n      }\n    };\n    e.prototype.enable = function (e) {\n      if (e && !this._isEnabled) {\n        this._isEnabled = !0;\n        this._goQuickPulse();\n      } else {\n        if (!e && this._isEnabled) {\n          this._isEnabled = !1;\n          clearTimeout(this._handle);\n          this._handle = undefined;\n        }\n      }\n    };\n    e.prototype.enableCollectors = function (e) {\n      this._collectors.forEach(function (t) {\n        t.enable(e);\n      });\n    };\n    e.prototype._addMetric = function (e) {\n      var t = e.value,\n        n = e.count || 1,\n        r = a.PerformanceToQuickPulseCounter[e.name];\n      if (r) {\n        if (this._metrics[r]) {\n          this._metrics[r].Value =\n            (this._metrics[r].Value * this._metrics[r].Weight + t * n) /\n            (this._metrics[r].Weight + n);\n          this._metrics[r].Weight += n;\n        } else {\n          this._metrics[r] = i.createQuickPulseMetric(e);\n          this._metrics[r].Name = r;\n          this._metrics[r].Weight = 1;\n        }\n      }\n    };\n    e.prototype._resetQuickPulseBuffer = function () {\n      delete this._metrics;\n      this._metrics = {};\n      this._documents.length = 0;\n    };\n    e.prototype._goQuickPulse = function () {\n      var t = this,\n        n = Object.keys(this._metrics).map(function (e) {\n          return t._metrics[e];\n        }),\n        r = i.createQuickPulseEnvelope(\n          n,\n          this._documents.slice(),\n          this.config,\n          this.context\n        );\n      this._resetQuickPulseBuffer();\n      if (this._isCollectingData) {\n        this._post(r);\n      } else {\n        this._ping(r);\n      }\n      var o = this._isCollectingData ? e.POST_INTERVAL : e.PING_INTERVAL;\n      if (\n        this._isCollectingData &&\n        Date.now() - this._lastSuccessTime >= e.MAX_POST_WAIT_TIME &&\n        !this._lastSendSucceeded\n      ) {\n        this._isCollectingData = !1;\n        o = e.FALLBACK_INTERVAL;\n      } else {\n        if (\n          !this._isCollectingData &&\n          Date.now() - this._lastSuccessTime >= e.MAX_PING_WAIT_TIME &&\n          !this._lastSendSucceeded\n        ) {\n          o = e.FALLBACK_INTERVAL;\n        }\n      }\n      this._lastSendSucceeded = null;\n      this._handle = setTimeout(this._goQuickPulse.bind(this), o);\n      this._handle.unref();\n    };\n    e.prototype._ping = function (e) {\n      this._sender.ping(e, this._quickPulseDone.bind(this));\n    };\n    e.prototype._post = function (e) {\n      this._sender.post(e, this._quickPulseDone.bind(this));\n    };\n    e.prototype._quickPulseDone = function (e, t) {\n      if (null != e) {\n        if (this._isCollectingData !== e) {\n          r.info(\"Live Metrics sending data\", e);\n          this.enableCollectors(e);\n        }\n        this._isCollectingData = e;\n        if (t && t.statusCode < 300 && t.statusCode >= 200) {\n          this._lastSuccessTime = Date.now();\n          this._lastSendSucceeded = !0;\n        } else {\n          this._lastSendSucceeded = !1;\n        }\n      } else {\n        this._lastSendSucceeded = !1;\n      }\n    };\n    e.MAX_POST_WAIT_TIME = 2e4;\n    e.MAX_PING_WAIT_TIME = 6e4;\n    e.FALLBACK_INTERVAL = 6e4;\n    e.PING_INTERVAL = 5e3;\n    e.POST_INTERVAL = 1e3;\n    return e;\n  })();\nmodule.exports = l;",
  "3683": "class t extends Error {\n  constructor(e, t) {\n    super(e);\n    this.type = t;\n  }\n  get name() {\n    return this.constructor.name;\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\nmodule.exports = {\n  FetchBaseError: t,\n  FetchError: class extends t {\n    constructor(e, t, n) {\n      super(e, t);\n      if (n) {\n        this.code = this.errno = n.code;\n        this.erroredSysCall = n.syscall;\n      }\n    }\n  },\n  AbortError: class extends t {\n    constructor(e, t = \"aborted\") {\n      super(e, t);\n    }\n  },\n};",
  "3708": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = require(6776),\n  i = {\n    keyword: \"propertyNames\",\n    type: \"object\",\n    schemaType: [\"object\", \"boolean\"],\n    error: {\n      message: \"property name must be valid\",\n      params: ({ params: e }) => r._`{propertyName: ${e.propertyName}}`,\n    },\n    code(e) {\n      const { gen: t, schema: n, data: i, it: s } = e;\n      if (o.alwaysValidSchema(s, n)) return;\n      const a = t.name(\"valid\");\n      t.forIn(\"key\", i, (n) => {\n        e.setParams({\n          propertyName: n,\n        });\n        e.subschema(\n          {\n            keyword: \"propertyNames\",\n            data: n,\n            dataTypes: [\"string\"],\n            propertyName: n,\n            compositeRule: !0,\n          },\n          a\n        );\n        t.if(r.not(a), () => {\n          e.error(!0);\n          if (s.allErrors) {\n            t.break();\n          }\n        });\n      });\n      e.ok(a);\n    },\n  };\nexports.default = i;",
  "3769": "const { EventEmitter: r } = require(\"events\");\nmodule.exports = () => {\n  const e = {},\n    t = new r();\n  t.setMaxListeners(0);\n  return {\n    acquire: (n) =>\n      new Promise((r) => {\n        if (!e[n]) {\n          e[n] = !0;\n          return void r();\n        }\n        const o = (i) => {\n          if (e[n]) {\n            e[n] = !0;\n            t.removeListener(n, o);\n            r(i);\n          }\n        };\n        t.on(n, o);\n      }),\n    release: (n, r) => {\n      Reflect.deleteProperty(e, n);\n      setImmediate(() => t.emit(n, r));\n    },\n  };\n};",
  "3905": "function r(e) {\n  return e && \"object\" == typeof e && \"default\" in e\n    ? e\n    : {\n        default: e,\n      };\n}\nvar o = r(require(6008));\nconst i = (e, t) => t.some((t) => (t instanceof RegExp ? t.test(e) : t === e));\nconst s = (e, t = !1) => {\n  const n =\n      /^(?:([a-z_][a-z0-9_-]{0,31})@|https?:\\/\\/)([\\w\\.\\-@]+)[\\/:]([\\~,\\.\\w,\\-,\\_,\\/]+?(?:\\.git|\\/)?)$/,\n    r = (t) => {\n      const n = new Error(t);\n      throw ((n.subject_url = e), n);\n    };\n  if (\"string\" == typeof e && e.trim()) {\n    r(\"Invalid url.\");\n  }\n  if (e.length > s.MAX_INPUT_LENGTH) {\n    r(\n      \"Input exceeds maximum length. If needed, change the value of parseUrl.MAX_INPUT_LENGTH.\"\n    );\n  }\n  if (t) {\n    if (\"object\" != typeof t) {\n      t = {\n        stripHash: !1,\n      };\n    }\n    e = (function (e, t) {\n      t = {\n        defaultProtocol: \"http:\",\n        normalizeProtocol: !0,\n        forceHttp: !1,\n        forceHttps: !1,\n        stripAuthentication: !0,\n        stripHash: !1,\n        stripTextFragment: !0,\n        stripWWW: !0,\n        removeQueryParameters: [/^utm_\\w+/i],\n        removeTrailingSlash: !0,\n        removeSingleSlash: !0,\n        removeDirectoryIndex: !1,\n        sortQueryParameters: !0,\n        ...t,\n      };\n      e = e.trim();\n      if (/^data:/i.test(e))\n        return ((e, { stripHash: t }) => {\n          const n =\n            /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(e);\n          if (!n) throw new Error(`Invalid URL: ${e}`);\n          let { type: r, data: o, hash: i } = n.groups;\n          const s = r.split(\";\");\n          i = t ? \"\" : i;\n          let a = !1;\n          \"base64\" === s[s.length - 1] && (s.pop(), (a = !0));\n          const c = (s.shift() || \"\").toLowerCase(),\n            l = [\n              ...s\n                .map((e) => {\n                  let [t, n = \"\"] = e.split(\"=\").map((e) => e.trim());\n                  return \"charset\" === t &&\n                    ((n = n.toLowerCase()), \"us-ascii\" === n)\n                    ? \"\"\n                    : `${t}${n ? `=${n}` : \"\"}`;\n                })\n                .filter(Boolean),\n            ];\n          return (\n            a && l.push(\"base64\"),\n            (l.length > 0 || (c && \"text/plain\" !== c)) && l.unshift(c),\n            `data:${l.join(\";\")},${a ? o.trim() : o}${i ? `#${i}` : \"\"}`\n          );\n        })(e, t);\n      if (/^view-source:/i.test(e))\n        throw new Error(\n          \"`view-source:` is not supported as it is a non-standard protocol\"\n        );\n      const n = e.startsWith(\"//\");\n      if (!n && /^\\.*\\//.test(e)) {\n        e = e.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, t.defaultProtocol);\n      }\n      const r = new URL(e);\n      if (t.forceHttp && t.forceHttps)\n        throw new Error(\n          \"The `forceHttp` and `forceHttps` options cannot be used together\"\n        );\n      if (t.forceHttp && \"https:\" === r.protocol) {\n        r.protocol = \"http:\";\n      }\n      if (t.forceHttps && \"http:\" === r.protocol) {\n        r.protocol = \"https:\";\n      }\n      if (t.stripAuthentication) {\n        r.username = \"\";\n        r.password = \"\";\n      }\n      if (t.stripHash) {\n        r.hash = \"\";\n      } else {\n        if (t.stripTextFragment) {\n          r.hash = r.hash.replace(/#?:~:text.*?$/i, \"\");\n        }\n      }\n      if (r.pathname) {\n        const e = /\\b[a-z][a-z\\d+\\-.]{1,50}:\\/\\//g;\n        let t = 0,\n          n = \"\";\n        for (;;) {\n          const o = e.exec(r.pathname);\n          if (!o) break;\n          const i = o[0],\n            s = o.index;\n          (n += r.pathname.slice(t, s).replace(/\\/{2,}/g, \"/\")),\n            (n += i),\n            (t = s + i.length);\n        }\n        (n += r.pathname.slice(t, r.pathname.length).replace(/\\/{2,}/g, \"/\")),\n          (r.pathname = n);\n      }\n      if (r.pathname)\n        try {\n          r.pathname = decodeURI(r.pathname);\n        } catch {}\n      if (!0 === t.removeDirectoryIndex) {\n        t.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n      }\n      if (\n        Array.isArray(t.removeDirectoryIndex) &&\n        t.removeDirectoryIndex.length > 0\n      ) {\n        let e = r.pathname.split(\"/\");\n        const n = e[e.length - 1];\n        i(n, t.removeDirectoryIndex) &&\n          ((e = e.slice(0, -1)), (r.pathname = e.slice(1).join(\"/\") + \"/\"));\n      }\n      if (r.hostname) {\n        r.hostname = r.hostname.replace(/\\.$/, \"\");\n        if (\n          t.stripWWW &&\n          /^www\\.(?!www\\.)[a-z\\-\\d]{1,63}\\.[a-z.\\-\\d]{2,63}$/.test(r.hostname)\n        ) {\n          r.hostname = r.hostname.replace(/^www\\./, \"\");\n        }\n      }\n      if (Array.isArray(t.removeQueryParameters))\n        for (const e of [...r.searchParams.keys()])\n          i(e, t.removeQueryParameters) && r.searchParams.delete(e);\n      if (!0 === t.removeQueryParameters) {\n        r.search = \"\";\n      }\n      if (t.sortQueryParameters) {\n        r.searchParams.sort();\n        try {\n          r.search = decodeURIComponent(r.search);\n        } catch {}\n      }\n      if (t.removeTrailingSlash) {\n        r.pathname = r.pathname.replace(/\\/$/, \"\");\n      }\n      const o = e;\n      e = r.toString();\n      if (\n        t.removeSingleSlash ||\n        \"/\" !== r.pathname ||\n        o.endsWith(\"/\") ||\n        \"\" !== r.hash\n      ) {\n        e = e.replace(/\\/$/, \"\");\n      }\n      if (\n        (t.removeTrailingSlash || \"/\" === r.pathname) &&\n        \"\" === r.hash &&\n        t.removeSingleSlash\n      ) {\n        e = e.replace(/\\/$/, \"\");\n      }\n      if (n && !t.normalizeProtocol) {\n        e = e.replace(/^http:\\/\\//, \"//\");\n      }\n      if (t.stripProtocol) {\n        e = e.replace(/^(?:https?:)?\\/\\//, \"\");\n      }\n      return e;\n    })(e, t);\n  }\n  const a = o.default(e);\n  if (a.parse_failed) {\n    const e = a.href.match(n);\n    if (e) {\n      a.protocols = [\"ssh\"];\n      a.protocol = \"ssh\";\n      a.resource = e[2];\n      a.host = e[2];\n      a.user = e[1];\n      a.pathname = `/${e[3]}`;\n      a.parse_failed = !1;\n    } else {\n      r(\"URL parsing failed.\");\n    }\n  }\n  return a;\n};\ns.MAX_INPUT_LENGTH = 2048;\nmodule.exports = s;",
  "3924": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(5684),\n  o = require(2649),\n  i = require(8200),\n  s = require(9502),\n  a = require(6167),\n  c = [\n    r.default,\n    o.default,\n    i.default(),\n    s.default,\n    a.metadataVocabulary,\n    a.contentVocabulary,\n  ];\nexports.default = c;",
  "3964": "const r = require(\"util\"),\n  o = require(\"assert\"),\n  i = require(9867),\n  s = require(\"async_hooks\"),\n  a = \"error@context\",\n  c = process.env.DEBUG_CLS_HOOKED;\nlet l = -1;\nfunction u(e) {\n  this.name = e;\n  this.active = null;\n  this._set = [];\n  this.id = null;\n  this._contexts = new Map();\n  this._indent = 0;\n}\nfunction d(e) {\n  return process.namespaces[e];\n}\nfunction p(e) {\n  let t = d(e);\n  o.ok(t, \"can't delete nonexistent namespace! \\\"\" + e + '\"');\n  o.ok(t.id, \"don't assign to process.namespaces directly! \" + r.inspect(t));\n  process.namespaces[e] = null;\n}\nfunction h(...e) {\n  if (c) {\n    process._rawDebug(`${r.format(...e)}`);\n  }\n}\nmodule.exports = {\n  getNamespace: d,\n  createNamespace: function (e) {\n    o.ok(e, \"namespace must be given a name.\");\n    if (c) {\n      h(`NS-CREATING NAMESPACE (${e})`);\n    }\n    let t = new u(e);\n    t.id = l;\n    s.createHook({\n      init(n, o, i, a) {\n        l = s.executionAsyncId();\n        if (t.active) {\n          if ((t._contexts.set(n, t.active), c)) {\n            h(\n              `${\" \".repeat(\n                t._indent < 0 ? 0 : t._indent\n              )}INIT [${o}] (${e}) asyncId:${n} currentUid:${l} triggerId:${i} active:${r.inspect(\n                t.active,\n                {\n                  showHidden: !0,\n                  depth: 2,\n                  colors: !0,\n                }\n              )} resource:${a}`\n            );\n          }\n        } else if (0 === l) {\n          const i = s.triggerAsyncId(),\n            u = t._contexts.get(i);\n          if (u) {\n            if ((t._contexts.set(n, u), c)) {\n              h(\n                `${\" \".repeat(\n                  t._indent < 0 ? 0 : t._indent\n                )}INIT USING CONTEXT FROM TRIGGERID [${o}] (${e}) asyncId:${n} currentUid:${l} triggerId:${i} active:${r.inspect(\n                  t.active,\n                  {\n                    showHidden: !0,\n                    depth: 2,\n                    colors: !0,\n                  }\n                )} resource:${a}`\n              );\n            }\n          } else if (c) {\n            h(\n              `${\" \".repeat(\n                t._indent < 0 ? 0 : t._indent\n              )}INIT MISSING CONTEXT [${o}] (${e}) asyncId:${n} currentUid:${l} triggerId:${i} active:${r.inspect(\n                t.active,\n                {\n                  showHidden: !0,\n                  depth: 2,\n                  colors: !0,\n                }\n              )} resource:${a}`\n            );\n          }\n        }\n        if (c && \"PROMISE\" === o) {\n          h(\n            r.inspect(a, {\n              showHidden: !0,\n            })\n          );\n          const s = a.parentId;\n          h(\n            `${\" \".repeat(\n              t._indent < 0 ? 0 : t._indent\n            )}INIT RESOURCE-PROMISE [${o}] (${e}) parentId:${s} asyncId:${n} currentUid:${l} triggerId:${i} active:${r.inspect(\n              t.active,\n              {\n                showHidden: !0,\n                depth: 2,\n                colors: !0,\n              }\n            )} resource:${a}`\n          );\n        }\n      },\n      before(n) {\n        let o;\n        l = s.executionAsyncId();\n        o = t._contexts.get(n) || t._contexts.get(l);\n        if (o) {\n          if (c) {\n            const i = s.triggerAsyncId();\n            h(\n              `${\" \".repeat(\n                t._indent < 0 ? 0 : t._indent\n              )}BEFORE (${e}) asyncId:${n} currentUid:${l} triggerId:${i} active:${r.inspect(\n                t.active,\n                {\n                  showHidden: !0,\n                  depth: 2,\n                  colors: !0,\n                }\n              )} context:${r.inspect(o)}`\n            ),\n              (t._indent += 2);\n          }\n          t.enter(o);\n        } else if (c) {\n          const o = s.triggerAsyncId();\n          h(\n            `${\" \".repeat(\n              t._indent < 0 ? 0 : t._indent\n            )}BEFORE MISSING CONTEXT (${e}) asyncId:${n} currentUid:${l} triggerId:${o} active:${r.inspect(\n              t.active,\n              {\n                showHidden: !0,\n                depth: 2,\n                colors: !0,\n              }\n            )} namespace._contexts:${r.inspect(t._contexts, {\n              showHidden: !0,\n              depth: 2,\n              colors: !0,\n            })}`\n          ),\n            (t._indent += 2);\n        }\n      },\n      after(n) {\n        let o;\n        l = s.executionAsyncId();\n        o = t._contexts.get(n) || t._contexts.get(l);\n        if (o) {\n          if (c) {\n            const i = s.triggerAsyncId();\n            t._indent -= 2;\n            h(\n              `${\" \".repeat(\n                t._indent < 0 ? 0 : t._indent\n              )}AFTER (${e}) asyncId:${n} currentUid:${l} triggerId:${i} active:${r.inspect(\n                t.active,\n                {\n                  showHidden: !0,\n                  depth: 2,\n                  colors: !0,\n                }\n              )} context:${r.inspect(o)}`\n            );\n          }\n          t.exit(o);\n        } else if (c) {\n          const i = s.triggerAsyncId();\n          t._indent -= 2;\n          h(\n            `${\" \".repeat(\n              t._indent < 0 ? 0 : t._indent\n            )}AFTER MISSING CONTEXT (${e}) asyncId:${n} currentUid:${l} triggerId:${i} active:${r.inspect(\n              t.active,\n              {\n                showHidden: !0,\n                depth: 2,\n                colors: !0,\n              }\n            )} context:${r.inspect(o)}`\n          );\n        }\n      },\n      destroy(n) {\n        l = s.executionAsyncId();\n        if (c) {\n          const o = s.triggerAsyncId();\n          h(\n            `${\" \".repeat(\n              t._indent < 0 ? 0 : t._indent\n            )}DESTROY (${e}) currentUid:${l} asyncId:${n} triggerId:${o} active:${r.inspect(\n              t.active,\n              {\n                showHidden: !0,\n                depth: 2,\n                colors: !0,\n              }\n            )} context:${r.inspect(t._contexts.get(l))}`\n          );\n        }\n        t._contexts.delete(n);\n      },\n    }).enable();\n    process.namespaces[e] = t;\n    return t;\n  },\n  destroyNamespace: p,\n  reset: function () {\n    if (process.namespaces) {\n      Object.keys(process.namespaces).forEach(function (e) {\n        p(e);\n      });\n    }\n    process.namespaces = Object.create(null);\n  },\n  ERROR_SYMBOL: a,\n};\nu.prototype.set = function (e, t) {\n  if (!this.active)\n    throw new Error(\n      \"No context available. ns.run() or ns.bind() must be called first.\"\n    );\n  this.active[e] = t;\n  if (c) {\n    h(\n      \" \".repeat(this._indent < 0 ? 0 : this._indent) +\n        \"CONTEXT-SET KEY:\" +\n        e +\n        \"=\" +\n        t +\n        \" in ns:\" +\n        this.name +\n        \" currentUid:\" +\n        l +\n        \" active:\" +\n        r.inspect(this.active, {\n          showHidden: !0,\n          depth: 2,\n          colors: !0,\n        })\n    );\n  }\n  return t;\n};\nu.prototype.get = function (e) {\n  if (this.active) {\n    if (c) {\n      const t = s.executionAsyncId(),\n        n = s.triggerAsyncId(),\n        o = \" \".repeat(this._indent < 0 ? 0 : this._indent);\n      h(\n        o +\n          \"CONTEXT-GETTING KEY:\" +\n          e +\n          \"=\" +\n          this.active[e] +\n          \" (\" +\n          this.name +\n          \") currentUid:\" +\n          l +\n          \" active:\" +\n          r.inspect(this.active, {\n            showHidden: !0,\n            depth: 2,\n            colors: !0,\n          })\n      );\n      h(\n        `${o}CONTEXT-GETTING KEY: (${this.name}) ${e}=${\n          this.active[e]\n        } currentUid:${l} asyncHooksCurrentId:${t} triggerId:${n} len:${\n          this._set.length\n        } active:${r.inspect(this.active)}`\n      );\n    }\n    return this.active[e];\n  }\n  if (c) {\n    const t = s.currentId(),\n      n = s.triggerAsyncId();\n    h(\n      `${\" \".repeat(\n        this._indent < 0 ? 0 : this._indent\n      )}CONTEXT-GETTING KEY NO ACTIVE NS: (${\n        this.name\n      }) ${e}=undefined currentUid:${l} asyncHooksCurrentId:${t} triggerId:${n} len:${\n        this._set.length\n      }`\n    );\n  }\n};\nu.prototype.createContext = function () {\n  let e = Object.create(this.active ? this.active : Object.prototype);\n  e._ns_name = this.name;\n  e.id = l;\n  if (c) {\n    const t = s.executionAsyncId(),\n      n = s.triggerAsyncId();\n    h(\n      `${\" \".repeat(\n        this._indent < 0 ? 0 : this._indent\n      )}CONTEXT-CREATED Context: (${\n        this.name\n      }) currentUid:${l} asyncHooksCurrentId:${t} triggerId:${n} len:${\n        this._set.length\n      } context:${r.inspect(e, {\n        showHidden: !0,\n        depth: 2,\n        colors: !0,\n      })}`\n    );\n  }\n  return e;\n};\nu.prototype.run = function (e) {\n  let t = this.createContext();\n  this.enter(t);\n  try {\n    if (c) {\n      const e = s.triggerAsyncId(),\n        n = s.executionAsyncId();\n      h(\n        `${\" \".repeat(\n          this._indent < 0 ? 0 : this._indent\n        )}CONTEXT-RUN BEGIN: (${\n          this.name\n        }) currentUid:${l} triggerId:${e} asyncHooksCurrentId:${n} len:${\n          this._set.length\n        } context:${r.inspect(t)}`\n      );\n    }\n    e(t);\n    return t;\n  } catch (e) {\n    throw (e && (e[a] = t), e);\n  } finally {\n    if (c) {\n      const e = s.triggerAsyncId(),\n        n = s.executionAsyncId();\n      h(\n        `${\" \".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-RUN END: (${\n          this.name\n        }) currentUid:${l} triggerId:${e} asyncHooksCurrentId:${n} len:${\n          this._set.length\n        } ${r.inspect(t)}`\n      );\n    }\n    this.exit(t);\n  }\n};\nu.prototype.runAndReturn = function (e) {\n  let t;\n  this.run(function (n) {\n    t = e(n);\n  });\n  return t;\n};\nu.prototype.runPromise = function (e) {\n  let t = this.createContext();\n  this.enter(t);\n  let n = e(t);\n  if (!n || !n.then || !n.catch) throw new Error(\"fn must return a promise.\");\n  if (c) {\n    h(\n      \"CONTEXT-runPromise BEFORE: (\" +\n        this.name +\n        \") currentUid:\" +\n        l +\n        \" len:\" +\n        this._set.length +\n        \" \" +\n        r.inspect(t)\n    );\n  }\n  return n\n    .then(\n      (e) => (\n        c &&\n          h(\n            \"CONTEXT-runPromise AFTER then: (\" +\n              this.name +\n              \") currentUid:\" +\n              l +\n              \" len:\" +\n              this._set.length +\n              \" \" +\n              r.inspect(t)\n          ),\n        this.exit(t),\n        e\n      )\n    )\n    .catch((e) => {\n      throw (\n        ((e[a] = t),\n        c &&\n          h(\n            \"CONTEXT-runPromise AFTER catch: (\" +\n              this.name +\n              \") currentUid:\" +\n              l +\n              \" len:\" +\n              this._set.length +\n              \" \" +\n              r.inspect(t)\n          ),\n        this.exit(t),\n        e)\n      );\n    });\n};\nu.prototype.bind = function (e, t) {\n  if (t) {\n    t = this.active ? this.active : this.createContext();\n  }\n  let n = this;\n  return function () {\n    n.enter(t);\n    try {\n      return e.apply(this, arguments);\n    } catch (e) {\n      throw (e && (e[a] = t), e);\n    } finally {\n      n.exit(t);\n    }\n  };\n};\nu.prototype.enter = function (e) {\n  o.ok(e, \"context must be provided for entering\");\n  if (c) {\n    const t = s.executionAsyncId(),\n      n = s.triggerAsyncId();\n    h(\n      `${\" \".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-ENTER: (${\n        this.name\n      }) currentUid:${l} triggerId:${n} asyncHooksCurrentId:${t} len:${\n        this._set.length\n      } ${r.inspect(e)}`\n    );\n  }\n  this._set.push(this.active);\n  this.active = e;\n};\nu.prototype.exit = function (e) {\n  o.ok(e, \"context must be provided for exiting\");\n  if (c) {\n    const t = s.executionAsyncId(),\n      n = s.triggerAsyncId();\n    h(\n      `${\" \".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-EXIT: (${\n        this.name\n      }) currentUid:${l} triggerId:${n} asyncHooksCurrentId:${t} len:${\n        this._set.length\n      } ${r.inspect(e)}`\n    );\n  }\n  if (this.active === e) {\n    o.ok(this._set.length, \"can't remove top context\");\n    return void (this.active = this._set.pop());\n  }\n  let t = this._set.lastIndexOf(e);\n  if (t < 0) {\n    if (c) {\n      h(\n        \"??ERROR?? context exiting but not entered - ignoring: \" + r.inspect(e)\n      );\n    }\n    o.ok(\n      t >= 0,\n      \"context not currently entered; can't exit. \\n\" +\n        r.inspect(this) +\n        \"\\n\" +\n        r.inspect(e)\n    );\n  } else {\n    o.ok(t, \"can't remove top context\");\n    this._set.splice(t, 1);\n  }\n};\nu.prototype.bindEmitter = function (e) {\n  o.ok(e.on && e.addListener && e.emit, \"can only bind real EEs\");\n  let t = this,\n    n = \"context@\" + this.name;\n  i(\n    e,\n    function (e) {\n      if (e) {\n        if (e[\"cls@contexts\"]) {\n          e[\"cls@contexts\"] = Object.create(null);\n        }\n        e[\"cls@contexts\"][n] = {\n          namespace: t,\n          context: t.active,\n        };\n      }\n    },\n    function (e) {\n      if (!e || !e[\"cls@contexts\"]) return e;\n      let t = e,\n        n = e[\"cls@contexts\"];\n      Object.keys(n).forEach(function (e) {\n        let r = n[e];\n        t = r.namespace.bind(t, r.context);\n      });\n      return t;\n    }\n  );\n};\nu.prototype.fromException = function (e) {\n  return e[a];\n};\nprocess.namespaces = {};",
  "3974": "var r;\nr = require(8249);\nrequire(8269);\nrequire(8214);\nrequire(888);\nrequire(5109);\n(function () {\n  var e = r,\n    t = e.lib.StreamCipher,\n    n = e.algo,\n    o = [],\n    i = [],\n    s = [],\n    a = (n.RabbitLegacy = t.extend({\n      _doReset: function () {\n        var e = this._key.words,\n          t = this.cfg.iv,\n          n = (this._X = [\n            e[0],\n            (e[3] << 16) | (e[2] >>> 16),\n            e[1],\n            (e[0] << 16) | (e[3] >>> 16),\n            e[2],\n            (e[1] << 16) | (e[0] >>> 16),\n            e[3],\n            (e[2] << 16) | (e[1] >>> 16),\n          ]),\n          r = (this._C = [\n            (e[2] << 16) | (e[2] >>> 16),\n            (4294901760 & e[0]) | (65535 & e[1]),\n            (e[3] << 16) | (e[3] >>> 16),\n            (4294901760 & e[1]) | (65535 & e[2]),\n            (e[0] << 16) | (e[0] >>> 16),\n            (4294901760 & e[2]) | (65535 & e[3]),\n            (e[1] << 16) | (e[1] >>> 16),\n            (4294901760 & e[3]) | (65535 & e[0]),\n          ]);\n        this._b = 0;\n        for (var o = 0; o < 4; o++) c.call(this);\n        for (o = 0; o < 8; o++) r[o] ^= n[(o + 4) & 7];\n        if (t) {\n          var i = t.words,\n            s = i[0],\n            a = i[1],\n            l =\n              (16711935 & ((s << 8) | (s >>> 24))) |\n              (4278255360 & ((s << 24) | (s >>> 8))),\n            u =\n              (16711935 & ((a << 8) | (a >>> 24))) |\n              (4278255360 & ((a << 24) | (a >>> 8))),\n            d = (l >>> 16) | (4294901760 & u),\n            p = (u << 16) | (65535 & l);\n          for (\n            r[0] ^= l,\n              r[1] ^= d,\n              r[2] ^= u,\n              r[3] ^= p,\n              r[4] ^= l,\n              r[5] ^= d,\n              r[6] ^= u,\n              r[7] ^= p,\n              o = 0;\n            o < 4;\n            o++\n          )\n            c.call(this);\n        }\n      },\n      _doProcessBlock: function (e, t) {\n        var n = this._X;\n        c.call(this);\n        o[0] = n[0] ^ (n[5] >>> 16) ^ (n[3] << 16);\n        o[1] = n[2] ^ (n[7] >>> 16) ^ (n[5] << 16);\n        o[2] = n[4] ^ (n[1] >>> 16) ^ (n[7] << 16);\n        o[3] = n[6] ^ (n[3] >>> 16) ^ (n[1] << 16);\n        for (var r = 0; r < 4; r++) {\n          o[r] =\n            (16711935 & ((o[r] << 8) | (o[r] >>> 24))) |\n            (4278255360 & ((o[r] << 24) | (o[r] >>> 8)));\n          e[t + r] ^= o[r];\n        }\n      },\n      blockSize: 4,\n      ivSize: 2,\n    }));\n  function c() {\n    for (var e = this._X, t = this._C, n = 0; n < 8; n++) i[n] = t[n];\n    for (\n      t[0] = (t[0] + 1295307597 + this._b) | 0,\n        t[1] = (t[1] + 3545052371 + (t[0] >>> 0 < i[0] >>> 0 ? 1 : 0)) | 0,\n        t[2] = (t[2] + 886263092 + (t[1] >>> 0 < i[1] >>> 0 ? 1 : 0)) | 0,\n        t[3] = (t[3] + 1295307597 + (t[2] >>> 0 < i[2] >>> 0 ? 1 : 0)) | 0,\n        t[4] = (t[4] + 3545052371 + (t[3] >>> 0 < i[3] >>> 0 ? 1 : 0)) | 0,\n        t[5] = (t[5] + 886263092 + (t[4] >>> 0 < i[4] >>> 0 ? 1 : 0)) | 0,\n        t[6] = (t[6] + 1295307597 + (t[5] >>> 0 < i[5] >>> 0 ? 1 : 0)) | 0,\n        t[7] = (t[7] + 3545052371 + (t[6] >>> 0 < i[6] >>> 0 ? 1 : 0)) | 0,\n        this._b = t[7] >>> 0 < i[7] >>> 0 ? 1 : 0,\n        n = 0;\n      n < 8;\n      n++\n    ) {\n      var r = e[n] + t[n],\n        o = 65535 & r,\n        a = r >>> 16,\n        c = ((((o * o) >>> 17) + o * a) >>> 15) + a * a,\n        l = (((4294901760 & r) * r) | 0) + (((65535 & r) * r) | 0);\n      s[n] = c ^ l;\n    }\n    e[0] =\n      (s[0] + ((s[7] << 16) | (s[7] >>> 16)) + ((s[6] << 16) | (s[6] >>> 16))) |\n      0;\n    e[1] = (s[1] + ((s[0] << 8) | (s[0] >>> 24)) + s[7]) | 0;\n    e[2] =\n      (s[2] + ((s[1] << 16) | (s[1] >>> 16)) + ((s[0] << 16) | (s[0] >>> 16))) |\n      0;\n    e[3] = (s[3] + ((s[2] << 8) | (s[2] >>> 24)) + s[1]) | 0;\n    e[4] =\n      (s[4] + ((s[3] << 16) | (s[3] >>> 16)) + ((s[2] << 16) | (s[2] >>> 16))) |\n      0;\n    e[5] = (s[5] + ((s[4] << 8) | (s[4] >>> 24)) + s[3]) | 0;\n    e[6] =\n      (s[6] + ((s[5] << 16) | (s[5] >>> 16)) + ((s[4] << 16) | (s[4] >>> 16))) |\n      0;\n    e[7] = (s[7] + ((s[6] << 8) | (s[6] >>> 24)) + s[5]) | 0;\n  }\n  e.RabbitLegacy = t._createHelper(a);\n})();\nmodule.exports = r.RabbitLegacy;",
  "3983": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = r.operators,\n  i = {\n    maximum: {\n      okStr: \"<=\",\n      ok: o.LTE,\n      fail: o.GT,\n    },\n    minimum: {\n      okStr: \">=\",\n      ok: o.GTE,\n      fail: o.LT,\n    },\n    exclusiveMaximum: {\n      okStr: \"<\",\n      ok: o.LT,\n      fail: o.GTE,\n    },\n    exclusiveMinimum: {\n      okStr: \">\",\n      ok: o.GT,\n      fail: o.LTE,\n    },\n  },\n  s = {\n    message: ({ keyword: e, schemaCode: t }) =>\n      r.str`must be ${i[e].okStr} ${t}`,\n    params: ({ keyword: e, schemaCode: t }) =>\n      r._`{comparison: ${i[e].okStr}, limit: ${t}}`,\n  },\n  a = {\n    keyword: Object.keys(i),\n    type: \"number\",\n    schemaType: \"number\",\n    $data: !0,\n    error: s,\n    code(e) {\n      const { keyword: t, data: n, schemaCode: o } = e;\n      e.fail$data(r._`${n} ${i[t].fail} ${o} || isNaN(${n})`);\n    },\n  };\nexports.default = a;",
  "4014": "var n;\nexports = module.exports = SemVer;\nn =\n  \"object\" == typeof process &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n    ? function () {\n        var e = Array.prototype.slice.call(arguments, 0);\n        e.unshift(\"SEMVER\");\n        console.log.apply(console, e);\n      }\n    : function () {};\nexports.SEMVER_SPEC_VERSION = \"2.0.0\";\nvar r = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  o = (exports.re = []),\n  i = (exports.src = []),\n  s = 0,\n  a = s++;\ni[a] = \"0|[1-9]\\\\d*\";\nvar c = s++;\ni[c] = \"[0-9]+\";\nvar l = s++;\ni[l] = \"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\";\nvar u = s++;\ni[u] = \"(\" + i[a] + \")\\\\.(\" + i[a] + \")\\\\.(\" + i[a] + \")\";\nvar d = s++;\ni[d] = \"(\" + i[c] + \")\\\\.(\" + i[c] + \")\\\\.(\" + i[c] + \")\";\nvar p = s++;\ni[p] = \"(?:\" + i[a] + \"|\" + i[l] + \")\";\nvar h = s++;\ni[h] = \"(?:\" + i[c] + \"|\" + i[l] + \")\";\nvar f = s++;\ni[f] = \"(?:-(\" + i[p] + \"(?:\\\\.\" + i[p] + \")*))\";\nvar m = s++;\ni[m] = \"(?:-?(\" + i[h] + \"(?:\\\\.\" + i[h] + \")*))\";\nvar g = s++;\ni[g] = \"[0-9A-Za-z-]+\";\nvar _ = s++;\ni[_] = \"(?:\\\\+(\" + i[g] + \"(?:\\\\.\" + i[g] + \")*))\";\nvar y = s++,\n  v = \"v?\" + i[u] + i[f] + \"?\" + i[_] + \"?\";\ni[y] = \"^\" + v + \"$\";\nvar b = \"[v=\\\\s]*\" + i[d] + i[m] + \"?\" + i[_] + \"?\",\n  w = s++;\ni[w] = \"^\" + b + \"$\";\nvar x = s++;\ni[x] = \"((?:<|>)?=?)\";\nvar E = s++;\ni[E] = i[c] + \"|x|X|\\\\*\";\nvar C = s++;\ni[C] = i[a] + \"|x|X|\\\\*\";\nvar S = s++;\ni[S] =\n  \"[v=\\\\s]*(\" +\n  i[C] +\n  \")(?:\\\\.(\" +\n  i[C] +\n  \")(?:\\\\.(\" +\n  i[C] +\n  \")(?:\" +\n  i[f] +\n  \")?\" +\n  i[_] +\n  \"?)?)?\";\nvar T = s++;\ni[T] =\n  \"[v=\\\\s]*(\" +\n  i[E] +\n  \")(?:\\\\.(\" +\n  i[E] +\n  \")(?:\\\\.(\" +\n  i[E] +\n  \")(?:\" +\n  i[m] +\n  \")?\" +\n  i[_] +\n  \"?)?)?\";\nvar k = s++;\ni[k] = \"^\" + i[x] + \"\\\\s*\" + i[S] + \"$\";\nvar I = s++;\ni[I] = \"^\" + i[x] + \"\\\\s*\" + i[T] + \"$\";\nvar P = s++;\ni[P] =\n  \"(?:^|[^\\\\d])(\\\\d{1,16})(?:\\\\.(\\\\d{1,16}))?(?:\\\\.(\\\\d{1,16}))?(?:$|[^\\\\d])\";\nvar A = s++;\ni[A] = \"(?:~>?)\";\nvar O = s++;\ni[O] = \"(\\\\s*)\" + i[A] + \"\\\\s+\";\no[O] = new RegExp(i[O], \"g\");\nvar N = s++;\ni[N] = \"^\" + i[A] + i[S] + \"$\";\nvar R = s++;\ni[R] = \"^\" + i[A] + i[T] + \"$\";\nvar M = s++;\ni[M] = \"(?:\\\\^)\";\nvar L = s++;\ni[L] = \"(\\\\s*)\" + i[M] + \"\\\\s+\";\no[L] = new RegExp(i[L], \"g\");\nvar $ = s++;\ni[$] = \"^\" + i[M] + i[S] + \"$\";\nvar D = s++;\ni[D] = \"^\" + i[M] + i[T] + \"$\";\nvar F = s++;\ni[F] = \"^\" + i[x] + \"\\\\s*(\" + b + \")$|^$\";\nvar j = s++;\ni[j] = \"^\" + i[x] + \"\\\\s*(\" + v + \")$|^$\";\nvar q = s++;\ni[q] = \"(\\\\s*)\" + i[x] + \"\\\\s*(\" + b + \"|\" + i[S] + \")\";\no[q] = new RegExp(i[q], \"g\");\nvar B = s++;\ni[B] = \"^\\\\s*(\" + i[S] + \")\\\\s+-\\\\s+(\" + i[S] + \")\\\\s*$\";\nvar U = s++;\ni[U] = \"^\\\\s*(\" + i[T] + \")\\\\s+-\\\\s+(\" + i[T] + \")\\\\s*$\";\nvar H = s++;\ni[H] = \"(<|>)?=?\\\\s*\\\\*\";\nfor (var z = 0; z < 35; z++) {\n  n(z, i[z]);\n  if (o[z]) {\n    o[z] = new RegExp(i[z]);\n  }\n}\nfunction parse(e, t) {\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (e instanceof SemVer) return e;\n  if (\"string\" != typeof e) return null;\n  if (e.length > 256) return null;\n  if (!(t.loose ? o[w] : o[y]).test(e)) return null;\n  try {\n    return new SemVer(e, t);\n  } catch (e) {\n    return null;\n  }\n}\nfunction SemVer(e, t) {\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (e instanceof SemVer) {\n    if (e.loose === t.loose) return e;\n    e = e.version;\n  } else if (\"string\" != typeof e) throw new TypeError(\"Invalid Version: \" + e);\n  if (e.length > 256)\n    throw new TypeError(\"version is longer than 256 characters\");\n  if (!(this instanceof SemVer)) return new SemVer(e, t);\n  n(\"SemVer\", e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  var i = e.trim().match(t.loose ? o[w] : o[y]);\n  if (!i) throw new TypeError(\"Invalid Version: \" + e);\n  this.raw = e;\n  this.major = +i[1];\n  this.minor = +i[2];\n  this.patch = +i[3];\n  if (this.major > r || this.major < 0)\n    throw new TypeError(\"Invalid major version\");\n  if (this.minor > r || this.minor < 0)\n    throw new TypeError(\"Invalid minor version\");\n  if (this.patch > r || this.patch < 0)\n    throw new TypeError(\"Invalid patch version\");\n  if (i[4]) {\n    this.prerelease = i[4].split(\".\").map(function (e) {\n      if (/^[0-9]+$/.test(e)) {\n        var t = +e;\n        if (t >= 0 && t < r) return t;\n      }\n      return e;\n    });\n  } else {\n    this.prerelease = [];\n  }\n  this.build = i[5] ? i[5].split(\".\") : [];\n  this.format();\n}\nexports.parse = parse;\nexports.valid = function (e, t) {\n  var n = parse(e, t);\n  return n ? n.version : null;\n};\nexports.clean = function (e, t) {\n  var n = parse(e.trim().replace(/^[=v]+/, \"\"), t);\n  return n ? n.version : null;\n};\nexports.SemVer = SemVer;\nSemVer.prototype.format = function () {\n  this.version = this.major + \".\" + this.minor + \".\" + this.patch;\n  if (this.prerelease.length) {\n    this.version += \"-\" + this.prerelease.join(\".\");\n  }\n  return this.version;\n};\nSemVer.prototype.toString = function () {\n  return this.version;\n};\nSemVer.prototype.compare = function (e) {\n  n(\"SemVer.compare\", this.version, this.options, e);\n  if (e instanceof SemVer) {\n    e = new SemVer(e, this.options);\n  }\n  return this.compareMain(e) || this.comparePre(e);\n};\nSemVer.prototype.compareMain = function (e) {\n  if (e instanceof SemVer) {\n    e = new SemVer(e, this.options);\n  }\n  return (\n    compareIdentifiers(this.major, e.major) ||\n    compareIdentifiers(this.minor, e.minor) ||\n    compareIdentifiers(this.patch, e.patch)\n  );\n};\nSemVer.prototype.comparePre = function (e) {\n  if (e instanceof SemVer) {\n    e = new SemVer(e, this.options);\n  }\n  if (this.prerelease.length && !e.prerelease.length) return -1;\n  if (!this.prerelease.length && e.prerelease.length) return 1;\n  if (!this.prerelease.length && !e.prerelease.length) return 0;\n  var t = 0;\n  do {\n    var r = this.prerelease[t],\n      o = e.prerelease[t];\n    n(\"prerelease compare\", t, r, o);\n    if (void 0 === r && void 0 === o) return 0;\n    if (undefined === o) return 1;\n    if (undefined === r) return -1;\n    if (r !== o) return compareIdentifiers(r, o);\n  } while (++t);\n};\nSemVer.prototype.inc = function (e, t) {\n  switch (e) {\n    case \"premajor\":\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc(\"pre\", t);\n      break;\n    case \"preminor\":\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc(\"pre\", t);\n      break;\n    case \"prepatch\":\n      this.prerelease.length = 0;\n      this.inc(\"patch\", t);\n      this.inc(\"pre\", t);\n      break;\n    case \"prerelease\":\n      if (0 === this.prerelease.length) {\n        this.inc(\"patch\", t);\n      }\n      this.inc(\"pre\", t);\n      break;\n    case \"major\":\n      if (\n        0 === this.minor &&\n        0 === this.patch &&\n        0 !== this.prerelease.length\n      ) {\n        this.major++;\n      }\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case \"minor\":\n      if (0 === this.patch && 0 !== this.prerelease.length) {\n        this.minor++;\n      }\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case \"patch\":\n      if (0 === this.prerelease.length) {\n        this.patch++;\n      }\n      this.prerelease = [];\n      break;\n    case \"pre\":\n      if (0 === this.prerelease.length) this.prerelease = [0];\n      else {\n        for (var n = this.prerelease.length; --n >= 0; )\n          if (\"number\" == typeof this.prerelease[n]) {\n            this.prerelease[n]++;\n            n = -2;\n          }\n        if (-1 === n) {\n          this.prerelease.push(0);\n        }\n      }\n      if (t) {\n        if (this.prerelease[0] === t) {\n          if (isNaN(this.prerelease[1])) {\n            this.prerelease = [t, 0];\n          }\n        } else {\n          this.prerelease = [t, 0];\n        }\n      }\n      break;\n    default:\n      throw new Error(\"invalid increment argument: \" + e);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\nexports.inc = function (e, t, n, r) {\n  if (\"string\" == typeof n) {\n    r = n;\n    n = undefined;\n  }\n  try {\n    return new SemVer(e, n).inc(t, r).version;\n  } catch (e) {\n    return null;\n  }\n};\nexports.diff = function (e, t) {\n  if (eq(e, t)) return null;\n  var n = parse(e),\n    r = parse(t),\n    o = \"\";\n  if (n.prerelease.length || r.prerelease.length) {\n    o = \"pre\";\n    var i = \"prerelease\";\n  }\n  for (var s in n)\n    if ((\"major\" === s || \"minor\" === s || \"patch\" === s) && n[s] !== r[s])\n      return o + s;\n  return i;\n};\nexports.compareIdentifiers = compareIdentifiers;\nvar W = /^[0-9]+$/;\nfunction compareIdentifiers(e, t) {\n  var n = W.test(e),\n    r = W.test(t);\n  if (n && r) {\n    e = +e;\n    t = +t;\n  }\n  return e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1;\n}\nfunction compare(e, t, n) {\n  return new SemVer(e, n).compare(new SemVer(t, n));\n}\nfunction gt(e, t, n) {\n  return compare(e, t, n) > 0;\n}\nfunction lt(e, t, n) {\n  return compare(e, t, n) < 0;\n}\nfunction eq(e, t, n) {\n  return 0 === compare(e, t, n);\n}\nfunction neq(e, t, n) {\n  return 0 !== compare(e, t, n);\n}\nfunction ee(e, t, n) {\n  return compare(e, t, n) >= 0;\n}\nfunction te(e, t, n) {\n  return compare(e, t, n) <= 0;\n}\nfunction ne(e, t, n, r) {\n  switch (t) {\n    case \"===\":\n      if (\"object\" == typeof e) {\n        e = e.version;\n      }\n      if (\"object\" == typeof n) {\n        n = n.version;\n      }\n      return e === n;\n    case \"!==\":\n      if (\"object\" == typeof e) {\n        e = e.version;\n      }\n      if (\"object\" == typeof n) {\n        n = n.version;\n      }\n      return e !== n;\n    case \"\":\n    case \"=\":\n    case \"==\":\n      return eq(e, n, r);\n    case \"!=\":\n      return neq(e, n, r);\n    case \">\":\n      return gt(e, n, r);\n    case \">=\":\n      return ee(e, n, r);\n    case \"<\":\n      return lt(e, n, r);\n    case \"<=\":\n      return te(e, n, r);\n    default:\n      throw new TypeError(\"Invalid operator: \" + t);\n  }\n}\nfunction re(e, t) {\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (e instanceof re) {\n    if (e.loose === !!t.loose) return e;\n    e = e.value;\n  }\n  if (!(this instanceof re)) return new re(e, t);\n  n(\"comparator\", e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  this.parse(e);\n  if (this.semver === oe) {\n    this.value = \"\";\n  } else {\n    this.value = this.operator + this.semver.version;\n  }\n  n(\"comp\", this);\n}\nexports.rcompareIdentifiers = function (e, t) {\n  return compareIdentifiers(t, e);\n};\nexports.major = function (e, t) {\n  return new SemVer(e, t).major;\n};\nexports.minor = function (e, t) {\n  return new SemVer(e, t).minor;\n};\nexports.patch = function (e, t) {\n  return new SemVer(e, t).patch;\n};\nexports.compare = compare;\nexports.compareLoose = function (e, t) {\n  return compare(e, t, !0);\n};\nexports.rcompare = function (e, t, n) {\n  return compare(t, e, n);\n};\nexports.sort = function (e, n) {\n  return e.sort(function (e, r) {\n    return exports.compare(e, r, n);\n  });\n};\nexports.rsort = function (e, n) {\n  return e.sort(function (e, r) {\n    return exports.rcompare(e, r, n);\n  });\n};\nexports.gt = gt;\nexports.lt = lt;\nexports.eq = eq;\nexports.neq = neq;\nexports.gte = ee;\nexports.lte = te;\nexports.cmp = ne;\nexports.Comparator = re;\nvar oe = {};\nfunction ie(e, t) {\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (e instanceof ie)\n    return e.loose === !!t.loose &&\n      e.includePrerelease === !!t.includePrerelease\n      ? e\n      : new ie(e.raw, t);\n  if (e instanceof re) return new ie(e.value, t);\n  if (!(this instanceof ie)) return new ie(e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  this.includePrerelease = !!t.includePrerelease;\n  this.raw = e;\n  this.set = e\n    .split(/\\s*\\|\\|\\s*/)\n    .map(function (e) {\n      return this.parseRange(e.trim());\n    }, this)\n    .filter(function (e) {\n      return e.length;\n    });\n  if (!this.set.length) throw new TypeError(\"Invalid SemVer Range: \" + e);\n  this.format();\n}\nfunction se(e) {\n  return !e || \"x\" === e.toLowerCase() || \"*\" === e;\n}\nfunction ae(e, t, n, r, o, i, s, a, c, l, u, d, p) {\n  return (\n    (t = se(n)\n      ? \"\"\n      : se(r)\n      ? \">=\" + n + \".0.0\"\n      : se(o)\n      ? \">=\" + n + \".\" + r + \".0\"\n      : \">=\" + t) +\n    \" \" +\n    (a = se(c)\n      ? \"\"\n      : se(l)\n      ? \"<\" + (+c + 1) + \".0.0\"\n      : se(u)\n      ? \"<\" + c + \".\" + (+l + 1) + \".0\"\n      : d\n      ? \"<=\" + c + \".\" + l + \".\" + u + \"-\" + d\n      : \"<=\" + a)\n  ).trim();\n}\nfunction ce(e, t, r) {\n  for (var o = 0; o < e.length; o++) if (!e[o].test(t)) return !1;\n  if (t.prerelease.length && !r.includePrerelease) {\n    for (o = 0; o < e.length; o++) {\n      n(e[o].semver);\n      if (e[o].semver !== oe && e[o].semver.prerelease.length > 0) {\n        var i = e[o].semver;\n        if (i.major === t.major && i.minor === t.minor && i.patch === t.patch)\n          return !0;\n      }\n    }\n    return !1;\n  }\n  return !0;\n}\nfunction le(e, t, n) {\n  try {\n    t = new ie(t, n);\n  } catch (e) {\n    return !1;\n  }\n  return t.test(e);\n}\nfunction ue(e, t, n, r) {\n  var o, i, s, a, c;\n  switch (((e = new SemVer(e, r)), (t = new ie(t, r)), n)) {\n    case \">\":\n      o = gt;\n      i = te;\n      s = lt;\n      a = \">\";\n      c = \">=\";\n      break;\n    case \"<\":\n      o = lt;\n      i = ee;\n      s = gt;\n      a = \"<\";\n      c = \"<=\";\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n  if (le(e, t, r)) return !1;\n  for (var l = 0; l < t.set.length; ++l) {\n    var u = t.set[l],\n      d = null,\n      p = null;\n    u.forEach(function (e) {\n      if (e.semver === oe) {\n        e = new re(\">=0.0.0\");\n      }\n      d = d || e;\n      p = p || e;\n      if (o(e.semver, d.semver, r)) {\n        d = e;\n      } else {\n        if (s(e.semver, p.semver, r)) {\n          p = e;\n        }\n      }\n    });\n    if (d.operator === a || d.operator === c) return !1;\n    if ((!p.operator || p.operator === a) && i(e, p.semver)) return !1;\n    if (p.operator === c && s(e, p.semver)) return !1;\n  }\n  return !0;\n}\nre.prototype.parse = function (e) {\n  var t = this.options.loose ? o[F] : o[j],\n    n = e.match(t);\n  if (!n) throw new TypeError(\"Invalid comparator: \" + e);\n  this.operator = n[1];\n  if (\"=\" === this.operator) {\n    this.operator = \"\";\n  }\n  if (n[2]) {\n    this.semver = new SemVer(n[2], this.options.loose);\n  } else {\n    this.semver = oe;\n  }\n};\nre.prototype.toString = function () {\n  return this.value;\n};\nre.prototype.test = function (e) {\n  n(\"Comparator.test\", e, this.options.loose);\n  return (\n    this.semver === oe ||\n    (\"string\" == typeof e && (e = new SemVer(e, this.options)),\n    ne(e, this.operator, this.semver, this.options))\n  );\n};\nre.prototype.intersects = function (e, t) {\n  if (!(e instanceof re)) throw new TypeError(\"a Comparator is required\");\n  var n;\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (\"\" === this.operator)\n    return (n = new ie(e.value, t)), le(this.value, n, t);\n  if (\"\" === e.operator) {\n    n = new ie(this.value, t);\n    return le(e.semver, n, t);\n  }\n  var r = !(\n      (\">=\" !== this.operator && \">\" !== this.operator) ||\n      (\">=\" !== e.operator && \">\" !== e.operator)\n    ),\n    o = !(\n      (\"<=\" !== this.operator && \"<\" !== this.operator) ||\n      (\"<=\" !== e.operator && \"<\" !== e.operator)\n    ),\n    i = this.semver.version === e.semver.version,\n    s = !(\n      (\">=\" !== this.operator && \"<=\" !== this.operator) ||\n      (\">=\" !== e.operator && \"<=\" !== e.operator)\n    ),\n    a =\n      ne(this.semver, \"<\", e.semver, t) &&\n      (\">=\" === this.operator || \">\" === this.operator) &&\n      (\"<=\" === e.operator || \"<\" === e.operator),\n    c =\n      ne(this.semver, \">\", e.semver, t) &&\n      (\"<=\" === this.operator || \"<\" === this.operator) &&\n      (\">=\" === e.operator || \">\" === e.operator);\n  return r || o || (i && s) || a || c;\n};\nexports.Range = ie;\nie.prototype.format = function () {\n  this.range = this.set\n    .map(function (e) {\n      return e.join(\" \").trim();\n    })\n    .join(\"||\")\n    .trim();\n  return this.range;\n};\nie.prototype.toString = function () {\n  return this.range;\n};\nie.prototype.parseRange = function (e) {\n  var t = this.options.loose;\n  e = e.trim();\n  var r = t ? o[U] : o[B];\n  e = e.replace(r, ae);\n  n(\"hyphen replace\", e);\n  e = e.replace(o[q], \"$1$2$3\");\n  n(\"comparator trim\", e, o[q]);\n  e = (e = (e = e.replace(o[O], \"$1~\")).replace(o[L], \"$1^\"))\n    .split(/\\s+/)\n    .join(\" \");\n  var i = t ? o[F] : o[j],\n    s = e\n      .split(\" \")\n      .map(function (e) {\n        return (function (e, t) {\n          n(\"comp\", e, t);\n          e = (function (e, t) {\n            return e\n              .trim()\n              .split(/\\s+/)\n              .map(function (e) {\n                return (function (e, t) {\n                  n(\"caret\", e, t);\n                  var r = t.loose ? o[D] : o[$];\n                  return e.replace(r, function (t, r, o, i, s) {\n                    var a;\n                    n(\"caret\", e, t, r, o, i, s);\n                    if (se(r)) {\n                      a = \"\";\n                    } else {\n                      if (se(o)) {\n                        a = \">=\" + r + \".0.0 <\" + (+r + 1) + \".0.0\";\n                      } else {\n                        if (se(i)) {\n                          a =\n                            \"0\" === r\n                              ? \">=\" +\n                                r +\n                                \".\" +\n                                o +\n                                \".0 <\" +\n                                r +\n                                \".\" +\n                                (+o + 1) +\n                                \".0\"\n                              : \">=\" + r + \".\" + o + \".0 <\" + (+r + 1) + \".0.0\";\n                        } else {\n                          if (s) {\n                            n(\"replaceCaret pr\", s);\n                            a =\n                              \"0\" === r\n                                ? \"0\" === o\n                                  ? \">=\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    i +\n                                    \"-\" +\n                                    s +\n                                    \" <\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    (+i + 1)\n                                  : \">=\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    i +\n                                    \"-\" +\n                                    s +\n                                    \" <\" +\n                                    r +\n                                    \".\" +\n                                    (+o + 1) +\n                                    \".0\"\n                                : \">=\" +\n                                  r +\n                                  \".\" +\n                                  o +\n                                  \".\" +\n                                  i +\n                                  \"-\" +\n                                  s +\n                                  \" <\" +\n                                  (+r + 1) +\n                                  \".0.0\";\n                          } else {\n                            n(\"no pr\");\n                            a =\n                              \"0\" === r\n                                ? \"0\" === o\n                                  ? \">=\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    i +\n                                    \" <\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    (+i + 1)\n                                  : \">=\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    i +\n                                    \" <\" +\n                                    r +\n                                    \".\" +\n                                    (+o + 1) +\n                                    \".0\"\n                                : \">=\" +\n                                  r +\n                                  \".\" +\n                                  o +\n                                  \".\" +\n                                  i +\n                                  \" <\" +\n                                  (+r + 1) +\n                                  \".0.0\";\n                          }\n                        }\n                      }\n                    }\n                    n(\"caret return\", a);\n                    return a;\n                  });\n                })(e, t);\n              })\n              .join(\" \");\n          })(e, t);\n          n(\"caret\", e);\n          e = (function (e, t) {\n            return e\n              .trim()\n              .split(/\\s+/)\n              .map(function (e) {\n                return (function (e, t) {\n                  var r = t.loose ? o[R] : o[N];\n                  return e.replace(r, function (t, r, o, i, s) {\n                    var a;\n                    n(\"tilde\", e, t, r, o, i, s);\n                    if (se(r)) {\n                      a = \"\";\n                    } else {\n                      if (se(o)) {\n                        a = \">=\" + r + \".0.0 <\" + (+r + 1) + \".0.0\";\n                      } else {\n                        if (se(i)) {\n                          a =\n                            \">=\" +\n                            r +\n                            \".\" +\n                            o +\n                            \".0 <\" +\n                            r +\n                            \".\" +\n                            (+o + 1) +\n                            \".0\";\n                        } else {\n                          if (s) {\n                            n(\"replaceTilde pr\", s);\n                            a =\n                              \">=\" +\n                              r +\n                              \".\" +\n                              o +\n                              \".\" +\n                              i +\n                              \"-\" +\n                              s +\n                              \" <\" +\n                              r +\n                              \".\" +\n                              (+o + 1) +\n                              \".0\";\n                          } else {\n                            a =\n                              \">=\" +\n                              r +\n                              \".\" +\n                              o +\n                              \".\" +\n                              i +\n                              \" <\" +\n                              r +\n                              \".\" +\n                              (+o + 1) +\n                              \".0\";\n                          }\n                        }\n                      }\n                    }\n                    n(\"tilde return\", a);\n                    return a;\n                  });\n                })(e, t);\n              })\n              .join(\" \");\n          })(e, t);\n          n(\"tildes\", e);\n          e = (function (e, t) {\n            n(\"replaceXRanges\", e, t);\n            return e\n              .split(/\\s+/)\n              .map(function (e) {\n                return (function (e, t) {\n                  e = e.trim();\n                  var r = t.loose ? o[I] : o[k];\n                  return e.replace(r, function (t, r, o, i, s, a) {\n                    n(\"xRange\", e, t, r, o, i, s, a);\n                    var c = se(o),\n                      l = c || se(i),\n                      u = l || se(s);\n                    if (\"=\" === r && u) {\n                      r = \"\";\n                    }\n                    if (c) {\n                      t = \">\" === r || \"<\" === r ? \"<0.0.0\" : \"*\";\n                    } else {\n                      if (r && u) {\n                        if (l) {\n                          i = 0;\n                        }\n                        s = 0;\n                        if (\">\" === r) {\n                          r = \">=\";\n                          if (l) {\n                            o = +o + 1;\n                            i = 0;\n                            s = 0;\n                          } else {\n                            i = +i + 1;\n                            s = 0;\n                          }\n                        } else {\n                          if (\"<=\" === r) {\n                            r = \"<\";\n                            if (l) {\n                              o = +o + 1;\n                            } else {\n                              i = +i + 1;\n                            }\n                          }\n                        }\n                        t = r + o + \".\" + i + \".\" + s;\n                      } else {\n                        if (l) {\n                          t = \">=\" + o + \".0.0 <\" + (+o + 1) + \".0.0\";\n                        } else {\n                          if (u) {\n                            t =\n                              \">=\" +\n                              o +\n                              \".\" +\n                              i +\n                              \".0 <\" +\n                              o +\n                              \".\" +\n                              (+i + 1) +\n                              \".0\";\n                          }\n                        }\n                      }\n                    }\n                    n(\"xRange return\", t);\n                    return t;\n                  });\n                })(e, t);\n              })\n              .join(\" \");\n          })(e, t);\n          n(\"xrange\", e);\n          e = (function (e, t) {\n            n(\"replaceStars\", e, t);\n            return e.trim().replace(o[H], \"\");\n          })(e, t);\n          n(\"stars\", e);\n          return e;\n        })(e, this.options);\n      }, this)\n      .join(\" \")\n      .split(/\\s+/);\n  if (this.options.loose) {\n    s = s.filter(function (e) {\n      return !!e.match(i);\n    });\n  }\n  return s.map(function (e) {\n    return new re(e, this.options);\n  }, this);\n};\nie.prototype.intersects = function (e, t) {\n  if (!(e instanceof ie)) throw new TypeError(\"a Range is required\");\n  return this.set.some(function (n) {\n    return n.every(function (n) {\n      return e.set.some(function (e) {\n        return e.every(function (e) {\n          return n.intersects(e, t);\n        });\n      });\n    });\n  });\n};\nexports.toComparators = function (e, t) {\n  return new ie(e, t).set.map(function (e) {\n    return e\n      .map(function (e) {\n        return e.value;\n      })\n      .join(\" \")\n      .trim()\n      .split(\" \");\n  });\n};\nie.prototype.test = function (e) {\n  if (!e) return !1;\n  if (\"string\" == typeof e) {\n    e = new SemVer(e, this.options);\n  }\n  for (var t = 0; t < this.set.length; t++)\n    if (ce(this.set[t], e, this.options)) return !0;\n  return !1;\n};\nexports.satisfies = le;\nexports.maxSatisfying = function (e, t, n) {\n  var r = null,\n    o = null;\n  try {\n    var i = new ie(t, n);\n  } catch (e) {\n    return null;\n  }\n  e.forEach(function (e) {\n    if (i.test(e)) {\n      if (r && -1 !== o.compare(e)) {\n        o = new SemVer((r = e), n);\n      }\n    }\n  });\n  return r;\n};\nexports.minSatisfying = function (e, t, n) {\n  var r = null,\n    o = null;\n  try {\n    var i = new ie(t, n);\n  } catch (e) {\n    return null;\n  }\n  e.forEach(function (e) {\n    if (i.test(e)) {\n      if (r && 1 !== o.compare(e)) {\n        o = new SemVer((r = e), n);\n      }\n    }\n  });\n  return r;\n};\nexports.minVersion = function (e, t) {\n  e = new ie(e, t);\n  var n = new SemVer(\"0.0.0\");\n  if (e.test(n)) return n;\n  n = new SemVer(\"0.0.0-0\");\n  if (e.test(n)) return n;\n  n = null;\n  for (var r = 0; r < e.set.length; ++r)\n    e.set[r].forEach(function (e) {\n      var t = new SemVer(e.semver.version);\n      switch (e.operator) {\n        case \">\":\n          if (0 === t.prerelease.length) {\n            t.patch++;\n          } else {\n            t.prerelease.push(0);\n          }\n          t.raw = t.format();\n        case \"\":\n        case \">=\":\n          if (n && !gt(n, t)) {\n            n = t;\n          }\n          break;\n        case \"<\":\n        case \"<=\":\n          break;\n        default:\n          throw new Error(\"Unexpected operation: \" + e.operator);\n      }\n    });\n  return n && e.test(n) ? n : null;\n};\nexports.validRange = function (e, t) {\n  try {\n    return new ie(e, t).range || \"*\";\n  } catch (e) {\n    return null;\n  }\n};\nexports.ltr = function (e, t, n) {\n  return ue(e, t, \"<\", n);\n};\nexports.gtr = function (e, t, n) {\n  return ue(e, t, \">\", n);\n};\nexports.outside = ue;\nexports.prerelease = function (e, t) {\n  var n = parse(e, t);\n  return n && n.prerelease.length ? n.prerelease : null;\n};\nexports.intersects = function (e, t, n) {\n  e = new ie(e, n);\n  t = new ie(t, n);\n  return e.intersects(t);\n};\nexports.coerce = function (e) {\n  if (e instanceof SemVer) return e;\n  if (\"string\" != typeof e) return null;\n  var t = e.match(o[P]);\n  return null == t\n    ? null\n    : parse(t[1] + \".\" + (t[2] || \"0\") + \".\" + (t[3] || \"0\"));\n};",
  "4046": "const r = require(\"util\"),\n  o = require(\"assert\"),\n  i = require(9867),\n  s = require(3223),\n  a = \"error@context\",\n  c = [];\nfor (let e in s.providers) c[s.providers[e]] = e;\nconst l = process.env.DEBUG_CLS_HOOKED;\nlet u = -1;\nfunction d(e) {\n  this.name = e;\n  this.active = null;\n  this._set = [];\n  this.id = null;\n  this._contexts = new Map();\n}\nfunction p(e) {\n  return process.namespaces[e];\n}\nfunction h(e) {\n  let t = p(e);\n  o.ok(t, \"can't delete nonexistent namespace! \\\"\" + e + '\"');\n  o.ok(t.id, \"don't assign to process.namespaces directly! \" + r.inspect(t));\n  process.namespaces[e] = null;\n}\nfunction f(e) {\n  if (process.env.DEBUG) {\n    process._rawDebug(e);\n  }\n}\nfunction m(e) {\n  return e\n    ? \"function\" == typeof e\n      ? e.name\n        ? e.name\n        : (e\n            .toString()\n            .trim()\n            .match(/^function\\s*([^\\s(]+)/) || [])[1]\n      : e.constructor && e.constructor.name\n      ? e.constructor.name\n      : undefined\n    : e;\n}\nmodule.exports = {\n  getNamespace: p,\n  createNamespace: function (e) {\n    o.ok(e, \"namespace must be given a name.\");\n    if (l) {\n      f(\"CREATING NAMESPACE \" + e);\n    }\n    let t = new d(e);\n    t.id = u;\n    s.addHooks({\n      init(n, o, i, s, a) {\n        u = n;\n        if (s) {\n          t._contexts.set(n, t._contexts.get(s));\n          if (l) {\n            f(\n              \"PARENTID: \" + e + \" uid:\" + n + \" parent:\" + s + \" provider:\" + i\n            );\n          }\n        } else {\n          t._contexts.set(u, t.active);\n        }\n        if (l) {\n          f(\n            \"INIT \" +\n              e +\n              \" uid:\" +\n              n +\n              \" parent:\" +\n              s +\n              \" provider:\" +\n              c[i] +\n              \" active:\" +\n              r.inspect(t.active, !0)\n          );\n        }\n      },\n      pre(n, o) {\n        u = n;\n        let i = t._contexts.get(n);\n        if (i) {\n          if (l) {\n            f(\n              \" PRE \" +\n                e +\n                \" uid:\" +\n                n +\n                \" handle:\" +\n                m(o) +\n                \" context:\" +\n                r.inspect(i)\n            );\n          }\n          t.enter(i);\n        } else {\n          if (l) {\n            f(\" PRE MISSING CONTEXT \" + e + \" uid:\" + n + \" handle:\" + m(o));\n          }\n        }\n      },\n      post(n, o) {\n        u = n;\n        let i = t._contexts.get(n);\n        if (i) {\n          if (l) {\n            f(\n              \" POST \" +\n                e +\n                \" uid:\" +\n                n +\n                \" handle:\" +\n                m(o) +\n                \" context:\" +\n                r.inspect(i)\n            );\n          }\n          t.exit(i);\n        } else {\n          if (l) {\n            f(\" POST MISSING CONTEXT \" + e + \" uid:\" + n + \" handle:\" + m(o));\n          }\n        }\n      },\n      destroy(n) {\n        u = n;\n        if (l) {\n          f(\n            \"DESTROY \" +\n              e +\n              \" uid:\" +\n              n +\n              \" context:\" +\n              r.inspect(t._contexts.get(u)) +\n              \" active:\" +\n              r.inspect(t.active, !0)\n          );\n        }\n        t._contexts.delete(n);\n      },\n    });\n    process.namespaces[e] = t;\n    return t;\n  },\n  destroyNamespace: h,\n  reset: function () {\n    if (process.namespaces) {\n      Object.keys(process.namespaces).forEach(function (e) {\n        h(e);\n      });\n    }\n    process.namespaces = Object.create(null);\n  },\n  ERROR_SYMBOL: a,\n};\nd.prototype.set = function (e, t) {\n  if (!this.active)\n    throw new Error(\n      \"No context available. ns.run() or ns.bind() must be called first.\"\n    );\n  if (l) {\n    f(\n      \"    SETTING KEY:\" +\n        e +\n        \"=\" +\n        t +\n        \" in ns:\" +\n        this.name +\n        \" uid:\" +\n        u +\n        \" active:\" +\n        r.inspect(this.active, !0)\n    );\n  }\n  this.active[e] = t;\n  return t;\n};\nd.prototype.get = function (e) {\n  if (this.active) {\n    if (l) {\n      f(\n        \"    GETTING KEY:\" +\n          e +\n          \"=\" +\n          this.active[e] +\n          \" \" +\n          this.name +\n          \" uid:\" +\n          u +\n          \" active:\" +\n          r.inspect(this.active, !0)\n      );\n    }\n    return this.active[e];\n  }\n  if (l) {\n    f(\n      \"    GETTING KEY:\" +\n        e +\n        \"=undefined \" +\n        this.name +\n        \" uid:\" +\n        u +\n        \" active:\" +\n        r.inspect(this.active, !0)\n    );\n  }\n};\nd.prototype.createContext = function () {\n  if (l) {\n    f(\n      \"   CREATING Context: \" +\n        this.name +\n        \" uid:\" +\n        u +\n        \" len:\" +\n        this._set.length +\n        \"  active:\" +\n        r.inspect(this.active, !0, 2, !0)\n    );\n  }\n  let e = Object.create(this.active ? this.active : Object.prototype);\n  e._ns_name = this.name;\n  e.id = u;\n  if (l) {\n    f(\n      \"   CREATED Context: \" +\n        this.name +\n        \" uid:\" +\n        u +\n        \" len:\" +\n        this._set.length +\n        \"  context:\" +\n        r.inspect(e, !0, 2, !0)\n    );\n  }\n  return e;\n};\nd.prototype.run = function (e) {\n  let t = this.createContext();\n  this.enter(t);\n  try {\n    if (l) {\n      f(\n        \" BEFORE RUN: \" +\n          this.name +\n          \" uid:\" +\n          u +\n          \" len:\" +\n          this._set.length +\n          \" \" +\n          r.inspect(t)\n      );\n    }\n    e(t);\n    return t;\n  } catch (e) {\n    throw (e && (e[a] = t), e);\n  } finally {\n    if (l) {\n      f(\n        \" AFTER RUN: \" +\n          this.name +\n          \" uid:\" +\n          u +\n          \" len:\" +\n          this._set.length +\n          \" \" +\n          r.inspect(t)\n      );\n    }\n    this.exit(t);\n  }\n};\nd.prototype.runAndReturn = function (e) {\n  var t;\n  this.run(function (n) {\n    t = e(n);\n  });\n  return t;\n};\nd.prototype.runPromise = function (e) {\n  let t = this.createContext();\n  this.enter(t);\n  let n = e(t);\n  if (!n || !n.then || !n.catch) throw new Error(\"fn must return a promise.\");\n  if (l) {\n    f(\n      \" BEFORE runPromise: \" +\n        this.name +\n        \" uid:\" +\n        u +\n        \" len:\" +\n        this._set.length +\n        \" \" +\n        r.inspect(t)\n    );\n  }\n  return n\n    .then(\n      (e) => (\n        l &&\n          f(\n            \" AFTER runPromise: \" +\n              this.name +\n              \" uid:\" +\n              u +\n              \" len:\" +\n              this._set.length +\n              \" \" +\n              r.inspect(t)\n          ),\n        this.exit(t),\n        e\n      )\n    )\n    .catch((e) => {\n      throw (\n        ((e[a] = t),\n        l &&\n          f(\n            \" AFTER runPromise: \" +\n              this.name +\n              \" uid:\" +\n              u +\n              \" len:\" +\n              this._set.length +\n              \" \" +\n              r.inspect(t)\n          ),\n        this.exit(t),\n        e)\n      );\n    });\n};\nd.prototype.bind = function (e, t) {\n  if (t) {\n    t = this.active ? this.active : this.createContext();\n  }\n  let n = this;\n  return function () {\n    n.enter(t);\n    try {\n      return e.apply(this, arguments);\n    } catch (e) {\n      throw (e && (e[a] = t), e);\n    } finally {\n      n.exit(t);\n    }\n  };\n};\nd.prototype.enter = function (e) {\n  o.ok(e, \"context must be provided for entering\");\n  if (l) {\n    f(\n      \"  ENTER \" +\n        this.name +\n        \" uid:\" +\n        u +\n        \" len:\" +\n        this._set.length +\n        \" context: \" +\n        r.inspect(e)\n    );\n  }\n  this._set.push(this.active);\n  this.active = e;\n};\nd.prototype.exit = function (e) {\n  o.ok(e, \"context must be provided for exiting\");\n  if (l) {\n    f(\n      \"  EXIT \" +\n        this.name +\n        \" uid:\" +\n        u +\n        \" len:\" +\n        this._set.length +\n        \" context: \" +\n        r.inspect(e)\n    );\n  }\n  if (this.active === e)\n    return (\n      o.ok(this._set.length, \"can't remove top context\"),\n      void (this.active = this._set.pop())\n    );\n  let t = this._set.lastIndexOf(e);\n  if (t < 0) {\n    if (l) {\n      f(\n        \"??ERROR?? context exiting but not entered - ignoring: \" + r.inspect(e)\n      );\n    }\n    o.ok(\n      t >= 0,\n      \"context not currently entered; can't exit. \\n\" +\n        r.inspect(this) +\n        \"\\n\" +\n        r.inspect(e)\n    );\n  } else {\n    o.ok(t, \"can't remove top context\");\n    this._set.splice(t, 1);\n  }\n};\nd.prototype.bindEmitter = function (e) {\n  o.ok(e.on && e.addListener && e.emit, \"can only bind real EEs\");\n  let t = this,\n    n = \"context@\" + this.name;\n  i(\n    e,\n    function (e) {\n      if (e) {\n        if (e[\"cls@contexts\"]) {\n          e[\"cls@contexts\"] = Object.create(null);\n        }\n        e[\"cls@contexts\"][n] = {\n          namespace: t,\n          context: t.active,\n        };\n      }\n    },\n    function (e) {\n      if (!e || !e[\"cls@contexts\"]) return e;\n      let t = e,\n        n = e[\"cls@contexts\"];\n      Object.keys(n).forEach(function (e) {\n        let r = n[e];\n        t = r.namespace.bind(t, r.context);\n      });\n      return t;\n    }\n  );\n};\nd.prototype.fromException = function (e) {\n  return e[a];\n};\nprocess.namespaces = {};\nif (s._state && !s._state.enabled) {\n  s.enable();\n}\nif (l) {\n  var g = require(2512);\n  for (var _ in g.filter._modifiers) g.filter.deattach(_);\n}",
  "4063": "module.exports = function e(t, n) {\n  if (t === n) return !0;\n  if (t && n && \"object\" == typeof t && \"object\" == typeof n) {\n    if (t.constructor !== n.constructor) return !1;\n    var r, o, i;\n    if (Array.isArray(t)) {\n      if ((r = t.length) != n.length) return !1;\n      for (o = r; 0 != o--; ) if (!e(t[o], n[o])) return !1;\n      return !0;\n    }\n    if (t.constructor === RegExp)\n      return t.source === n.source && t.flags === n.flags;\n    if (t.valueOf !== Object.prototype.valueOf)\n      return t.valueOf() === n.valueOf();\n    if (t.toString !== Object.prototype.toString)\n      return t.toString() === n.toString();\n    if ((r = (i = Object.keys(t)).length) !== Object.keys(n).length) return !1;\n    for (o = r; 0 != o--; )\n      if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;\n    for (o = r; 0 != o--; ) {\n      var s = i[o];\n      if (!e(t[s], n[s])) return !1;\n    }\n    return !0;\n  }\n  return t != t && n != n;\n};",
  "4087": "var r,\n  o = undefined !== o ? o : {};\nif (\n  undefined ===\n  (r = function () {\n    var t,\n      r = {};\n    for (t in o)\n      if (o.hasOwnProperty(t)) {\n        r[t] = o[t];\n      }\n    var i,\n      s,\n      a = [],\n      c = \"./this.program\",\n      l = function (e, t) {\n        throw t;\n      },\n      u = !1,\n      d = !1;\n    u = \"object\" == typeof window;\n    d = \"function\" == typeof importScripts;\n    i =\n      \"object\" == typeof process &&\n      \"object\" == typeof process.versions &&\n      \"string\" == typeof process.versions.node;\n    s = !u && !i && !d;\n    var p,\n      h,\n      f,\n      m,\n      g,\n      _ = \"\";\n    if (i) {\n      _ = d ? require(\"path\").dirname(_) + \"/\" : __dirname + \"/\";\n      p = function (e, t) {\n        if (m) {\n          m = require(\"fs\");\n        }\n        if (g) {\n          g = require(\"path\");\n        }\n        e = g.normalize(e);\n        return m.readFileSync(e, t ? null : \"utf8\");\n      };\n      f = function (e) {\n        var t = p(e, !0);\n        if (t.buffer) {\n          t = new Uint8Array(t);\n        }\n        O(t.buffer);\n        return t;\n      };\n      if (process.argv.length > 1) {\n        c = process.argv[1].replace(/\\\\/g, \"/\");\n      }\n      a = process.argv.slice(2);\n      module.exports = o;\n      l = function (e) {\n        process.exit(e);\n      };\n      o.inspect = function () {\n        return \"[Emscripten Module object]\";\n      };\n    } else {\n      if (s) {\n        if (\"undefined\" != typeof read) {\n          p = function (e) {\n            return read(e);\n          };\n        }\n        f = function (e) {\n          var t;\n          return \"function\" == typeof readbuffer\n            ? new Uint8Array(readbuffer(e))\n            : (O(\"object\" == typeof (t = read(e, \"binary\"))), t);\n        };\n        if (\"undefined\" != typeof scriptArgs) {\n          a = scriptArgs;\n        } else {\n          if (undefined !== arguments) {\n            a = arguments;\n          }\n        }\n        if (\"function\" == typeof quit) {\n          l = function (e) {\n            quit(e);\n          };\n        }\n        if (\"undefined\" != typeof print) {\n          if (\"undefined\" == typeof console) {\n            console = {};\n          }\n          console.log = print;\n          console.warn = console.error =\n            \"undefined\" != typeof printErr ? printErr : print;\n        }\n      } else {\n        if (u || d) {\n          if (d) {\n            _ = self.location.href;\n          } else {\n            if (\"undefined\" != typeof document && document.currentScript) {\n              _ = document.currentScript.src;\n            }\n          }\n          _ =\n            0 !== _.indexOf(\"blob:\") ? _.substr(0, _.lastIndexOf(\"/\") + 1) : \"\";\n          p = function (e) {\n            var t = new XMLHttpRequest();\n            t.open(\"GET\", e, !1);\n            t.send(null);\n            return t.responseText;\n          };\n          if (d) {\n            f = function (e) {\n              var t = new XMLHttpRequest();\n              t.open(\"GET\", e, !1);\n              t.responseType = \"arraybuffer\";\n              t.send(null);\n              return new Uint8Array(t.response);\n            };\n          }\n          h = function (e, t, n) {\n            var r = new XMLHttpRequest();\n            r.open(\"GET\", e, !0);\n            r.responseType = \"arraybuffer\";\n            r.onload = function () {\n              if (200 == r.status || (0 == r.status && r.response)) {\n                t(r.response);\n              } else {\n                n();\n              }\n            };\n            r.onerror = n;\n            r.send(null);\n          };\n        }\n      }\n    }\n    if (o.print) {\n      console.log.bind(console);\n    }\n    var y = o.printErr || console.warn.bind(console);\n    for (t in r)\n      if (r.hasOwnProperty(t)) {\n        o[t] = r[t];\n      }\n    r = null;\n    if (o.arguments) {\n      a = o.arguments;\n    }\n    if (o.thisProgram) {\n      c = o.thisProgram;\n    }\n    if (o.quit) {\n      l = o.quit;\n    }\n    var v,\n      b = 16,\n      w = [];\n    function x(e, t) {\n      if (!v) {\n        v = new WeakMap();\n        for (var n = 0; n < J.length; n++) {\n          var r = J.get(n);\n          if (r) {\n            v.set(r, n);\n          }\n        }\n      }\n      if (v.has(e)) return v.get(e);\n      var o = (function () {\n        if (w.length) return w.pop();\n        try {\n          J.grow(1);\n        } catch (e) {\n          if (!(e instanceof RangeError)) throw e;\n          throw \"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.\";\n        }\n        return J.length - 1;\n      })();\n      try {\n        J.set(o, e);\n      } catch (n) {\n        if (!(n instanceof TypeError)) throw n;\n        var i = (function (e, t) {\n          if (\"function\" == typeof WebAssembly.Function) {\n            for (\n              var n = {\n                  i: \"i32\",\n                  j: \"i64\",\n                  f: \"f32\",\n                  d: \"f64\",\n                },\n                r = {\n                  parameters: [],\n                  results: \"v\" == t[0] ? [] : [n[t[0]]],\n                },\n                o = 1;\n              o < t.length;\n              ++o\n            )\n              r.parameters.push(n[t[o]]);\n            return new WebAssembly.Function(r, e);\n          }\n          var i = [1, 0, 1, 96],\n            s = t.slice(0, 1),\n            a = t.slice(1),\n            c = {\n              i: 127,\n              j: 126,\n              f: 125,\n              d: 124,\n            };\n          for (i.push(a.length), o = 0; o < a.length; ++o) i.push(c[a[o]]);\n          if (\"v\" == s) {\n            i.push(0);\n          } else {\n            i = i.concat([1, c[s]]);\n          }\n          i[1] = i.length - 2;\n          var l = new Uint8Array(\n              [0, 97, 115, 109, 1, 0, 0, 0].concat(\n                i,\n                [2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0]\n              )\n            ),\n            u = new WebAssembly.Module(l);\n          return new WebAssembly.Instance(u, {\n            e: {\n              f: e,\n            },\n          }).exports.f;\n        })(e, t);\n        J.set(o, i);\n      }\n      v.set(e, o);\n      return o;\n    }\n    var E,\n      C = function (e) {},\n      S = o.dynamicLibraries || [];\n    if (o.wasmBinary) {\n      E = o.wasmBinary;\n    }\n    var T,\n      k = o.noExitRuntime || !0;\n    function I(e, t, n, r) {\n      switch (\n        (\"*\" === (n = n || \"i8\").charAt(n.length - 1) && (n = \"i32\"), n)\n      ) {\n        case \"i1\":\n        case \"i8\":\n          R[e >> 0] = t;\n          break;\n        case \"i16\":\n          L[e >> 1] = t;\n          break;\n        case \"i32\":\n          $[e >> 2] = t;\n          break;\n        case \"i64\":\n          pe = [\n            t >>> 0,\n            ((de = t),\n            +Math.abs(de) >= 1\n              ? de > 0\n                ? (0 | Math.min(+Math.floor(de / 4294967296), 4294967295)) >>> 0\n                : ~~+Math.ceil((de - +(~~de >>> 0)) / 4294967296) >>> 0\n              : 0),\n          ];\n          $[e >> 2] = pe[0];\n          $[(e + 4) >> 2] = pe[1];\n          break;\n        case \"float\":\n          D[e >> 2] = t;\n          break;\n        case \"double\":\n          F[e >> 3] = t;\n          break;\n        default:\n          se(\"invalid type for setValue: \" + n);\n      }\n    }\n    function P(e, t, n) {\n      switch (\n        (\"*\" === (t = t || \"i8\").charAt(t.length - 1) && (t = \"i32\"), t)\n      ) {\n        case \"i1\":\n        case \"i8\":\n          return R[e >> 0];\n        case \"i16\":\n          return L[e >> 1];\n        case \"i32\":\n        case \"i64\":\n          return $[e >> 2];\n        case \"float\":\n          return D[e >> 2];\n        case \"double\":\n          return F[e >> 3];\n        default:\n          se(\"invalid type for getValue: \" + t);\n      }\n      return null;\n    }\n    if (\"object\" != typeof WebAssembly) {\n      se(\"no native wasm support detected\");\n    }\n    var A = !1;\n    function O(e, t) {\n      if (e) {\n        se(\"Assertion failed: \" + t);\n      }\n    }\n    var N,\n      R,\n      M,\n      L,\n      $,\n      D,\n      F,\n      j = 1,\n      q =\n        \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : undefined;\n    function B(e, t, n) {\n      for (var r = t + n, o = t; e[o] && !(o >= r); ) ++o;\n      if (o - t > 16 && e.subarray && q) return q.decode(e.subarray(t, o));\n      for (var i = \"\"; t < o; ) {\n        var s = e[t++];\n        if (128 & s) {\n          var a = 63 & e[t++];\n          if (192 != (224 & s)) {\n            var c = 63 & e[t++];\n            if (\n              (s =\n                224 == (240 & s)\n                  ? ((15 & s) << 12) | (a << 6) | c\n                  : ((7 & s) << 18) | (a << 12) | (c << 6) | (63 & e[t++])) <\n              65536\n            )\n              i += String.fromCharCode(s);\n            else {\n              var l = s - 65536;\n              i += String.fromCharCode(55296 | (l >> 10), 56320 | (1023 & l));\n            }\n          } else i += String.fromCharCode(((31 & s) << 6) | a);\n        } else i += String.fromCharCode(s);\n      }\n      return i;\n    }\n    function U(e, t) {\n      return e ? B(M, e, t) : \"\";\n    }\n    function H(e, t, n, r) {\n      if (!(r > 0)) return 0;\n      for (var o = n, i = n + r - 1, s = 0; s < e.length; ++s) {\n        var a = e.charCodeAt(s);\n        if (a >= 55296 && a <= 57343) {\n          a = (65536 + ((1023 & a) << 10)) | (1023 & e.charCodeAt(++s));\n        }\n        if (a <= 127) {\n          if (n >= i) break;\n          t[n++] = a;\n        } else if (a <= 2047) {\n          if (n + 1 >= i) break;\n          (t[n++] = 192 | (a >> 6)), (t[n++] = 128 | (63 & a));\n        } else if (a <= 65535) {\n          if (n + 2 >= i) break;\n          (t[n++] = 224 | (a >> 12)),\n            (t[n++] = 128 | ((a >> 6) & 63)),\n            (t[n++] = 128 | (63 & a));\n        } else {\n          if (n + 3 >= i) break;\n          (t[n++] = 240 | (a >> 18)),\n            (t[n++] = 128 | ((a >> 12) & 63)),\n            (t[n++] = 128 | ((a >> 6) & 63)),\n            (t[n++] = 128 | (63 & a));\n        }\n      }\n      t[n] = 0;\n      return n - o;\n    }\n    function z(e, t, n) {\n      return H(e, M, t, n);\n    }\n    function G(e) {\n      for (var t = 0, n = 0; n < e.length; ++n) {\n        var r = e.charCodeAt(n);\n        if (r >= 55296 && r <= 57343) {\n          r = (65536 + ((1023 & r) << 10)) | (1023 & e.charCodeAt(++n));\n        }\n        if (r <= 127) {\n          ++t;\n        } else {\n          t += r <= 2047 ? 2 : r <= 65535 ? 3 : 4;\n        }\n      }\n      return t;\n    }\n    function V(e) {\n      var t = G(e) + 1,\n        n = Ve(t);\n      H(e, R, n, t);\n      return n;\n    }\n    function W(e) {\n      N = e;\n      o.HEAP8 = R = new Int8Array(e);\n      o.HEAP16 = L = new Int16Array(e);\n      o.HEAP32 = $ = new Int32Array(e);\n      o.HEAPU8 = M = new Uint8Array(e);\n      o.HEAPU16 = new Uint16Array(e);\n      o.HEAPU32 = new Uint32Array(e);\n      o.HEAPF32 = D = new Float32Array(e);\n      o.HEAPF64 = F = new Float64Array(e);\n    }\n    var K = o.INITIAL_MEMORY || 33554432;\n    if (\n      (T = o.wasmMemory\n        ? o.wasmMemory\n        : new WebAssembly.Memory({\n            initial: K / 65536,\n            maximum: 32768,\n          }))\n    ) {\n      N = T.buffer;\n    }\n    K = N.byteLength;\n    W(N);\n    var J = new WebAssembly.Table({\n        initial: 13,\n        element: \"anyfunc\",\n      }),\n      X = [],\n      Q = [],\n      Y = [],\n      Z = [],\n      ee = !1,\n      te = 0,\n      ne = null,\n      re = null;\n    function oe(e) {\n      te++;\n      if (o.monitorRunDependencies) {\n        o.monitorRunDependencies(te);\n      }\n    }\n    function ie(e) {\n      te--;\n      if (o.monitorRunDependencies) {\n        o.monitorRunDependencies(te);\n      }\n      if (0 == te && (null !== ne && (clearInterval(ne), (ne = null)), re)) {\n        var t = re;\n        (re = null), t();\n      }\n    }\n    function se(e) {\n      throw (\n        (o.onAbort && o.onAbort(e),\n        y((e += \"\")),\n        (A = !0),\n        (e = \"abort(\" + e + \"). Build with -s ASSERTIONS=1 for more info.\"),\n        new WebAssembly.RuntimeError(e))\n      );\n    }\n    o.preloadedImages = {};\n    o.preloadedAudios = {};\n    o.preloadedWasm = {};\n    var ae = \"data:application/octet-stream;base64,\";\n    function ce(e) {\n      return e.startsWith(ae);\n    }\n    function le(e) {\n      return e.startsWith(\"file://\");\n    }\n    var ue,\n      de,\n      pe,\n      he = \"tree-sitter.wasm\";\n    function fe(e) {\n      try {\n        if (e == he && E) return new Uint8Array(E);\n        if (f) return f(e);\n        throw \"both async and sync fetching of the wasm failed\";\n      } catch (e) {\n        se(e);\n      }\n    }\n    if (ce(he)) {\n      ue = he;\n      he = o.locateFile ? o.locateFile(ue, _) : _ + ue;\n    }\n    var me = {},\n      ge = {\n        get: function (e, t) {\n          if (me[t]) {\n            me[t] = new WebAssembly.Global({\n              value: \"i32\",\n              mutable: !0,\n            });\n          }\n          return me[t];\n        },\n      };\n    function _e(e) {\n      for (; e.length > 0; ) {\n        var t = e.shift();\n        if (\"function\" != typeof t) {\n          var n = t.func;\n          if (\"number\" == typeof n) {\n            if (undefined === t.arg) {\n              J.get(n)();\n            } else {\n              J.get(n)(t.arg);\n            }\n          } else {\n            n(undefined === t.arg ? null : t.arg);\n          }\n        } else t(o);\n      }\n    }\n    function ye(e) {\n      var t = 0;\n      function n() {\n        for (var n = 0, r = 1; ; ) {\n          var o = e[t++];\n          n += (127 & o) * r;\n          r *= 128;\n          if (!(128 & o)) break;\n        }\n        return n;\n      }\n      if (e instanceof WebAssembly.Module) {\n        var r = WebAssembly.Module.customSections(e, \"dylink\");\n        O(0 != r.length, \"need dylink section\");\n        e = new Int8Array(r[0]);\n      } else {\n        O(\n          1836278016 ==\n            new Uint32Array(new Uint8Array(e.subarray(0, 24)).buffer)[0],\n          \"need to see wasm magic number\"\n        );\n        O(0 === e[8], \"need the dylink section to be first\");\n        t = 9;\n        n();\n        O(6 === e[t]);\n        O(e[++t] === \"d\".charCodeAt(0));\n        O(e[++t] === \"y\".charCodeAt(0));\n        O(e[++t] === \"l\".charCodeAt(0));\n        O(e[++t] === \"i\".charCodeAt(0));\n        O(e[++t] === \"n\".charCodeAt(0));\n        O(e[++t] === \"k\".charCodeAt(0));\n        t++;\n      }\n      var o = {};\n      o.memorySize = n();\n      o.memoryAlign = n();\n      o.tableSize = n();\n      o.tableAlign = n();\n      var i = n();\n      o.neededDynlibs = [];\n      for (var s = 0; s < i; ++s) {\n        var a = n(),\n          c = e.subarray(t, t + a);\n        t += a;\n        var l = B(c, 0);\n        o.neededDynlibs.push(l);\n      }\n      return o;\n    }\n    var ve = 0;\n    function be() {\n      return k || ve > 0;\n    }\n    function we(e) {\n      return 0 == e.indexOf(\"dynCall_\") ||\n        [\"stackAlloc\", \"stackSave\", \"stackRestore\"].includes(e)\n        ? e\n        : \"_\" + e;\n    }\n    function xe(e, t) {\n      for (var n in e)\n        if (e.hasOwnProperty(n)) {\n          if (Be.hasOwnProperty(n)) {\n            Be[n] = e[n];\n          }\n          var r = we(n);\n          if (o.hasOwnProperty(r)) {\n            o[r] = e[n];\n          }\n        }\n    }\n    var Ee = {\n      nextHandle: 1,\n      loadedLibs: {},\n      loadedLibNames: {},\n    };\n    function Ce(e, t, n) {\n      return e.includes(\"j\")\n        ? (function (e, t, n) {\n            var r = o[\"dynCall_\" + e];\n            return n && n.length\n              ? r.apply(null, [t].concat(n))\n              : r.call(null, t);\n          })(e, t, n)\n        : J.get(t).apply(null, n);\n    }\n    var Se = 5250816;\n    function Te(e) {\n      return [\n        \"__cpp_exception\",\n        \"__wasm_apply_data_relocs\",\n        \"__dso_handle\",\n        \"__set_stack_limits\",\n      ].includes(e);\n    }\n    function ke(e, t) {\n      var n = {};\n      for (var r in e) {\n        var o = e[r];\n        if (\"object\" == typeof o) {\n          o = o.value;\n        }\n        if (\"number\" == typeof o) {\n          o += t;\n        }\n        n[r] = o;\n      }\n      (function (e) {\n        for (var t in e)\n          if (!Te(t)) {\n            var n = !1,\n              r = e[t];\n            if (t.startsWith(\"orig$\")) {\n              t = t.split(\"$\")[1];\n              n = !0;\n            }\n            if (me[t]) {\n              me[t] = new WebAssembly.Global({\n                value: \"i32\",\n                mutable: !0,\n              });\n            }\n            if (n || 0 == me[t].value) {\n              if (\"function\" == typeof r) {\n                me[t].value = x(r);\n              } else {\n                if (\"number\" == typeof r) {\n                  me[t].value = r;\n                } else {\n                  y(\"unhandled export type for `\" + t + \"`: \" + typeof r);\n                }\n              }\n            }\n          }\n      })(n);\n      return n;\n    }\n    function Ie(e, t) {\n      var n, r;\n      if (t) {\n        n = Be[\"orig$\" + e];\n      }\n      if (n) {\n        n = Be[e];\n      }\n      if (n) {\n        n = o[we(e)];\n      }\n      if (!n && e.startsWith(\"invoke_\")) {\n        r = e.split(\"_\")[1];\n        n = function () {\n          var e = ze();\n          try {\n            return Ce(\n              r,\n              arguments[0],\n              Array.prototype.slice.call(arguments, 1)\n            );\n          } catch (t) {\n            Ge(e);\n            if (t !== t + 0 && \"longjmp\" !== t) throw t;\n            We(1, 0);\n          }\n        };\n      }\n      return n;\n    }\n    function Pe(e, t) {\n      var n = ye(e);\n      function r() {\n        var r = Math.pow(2, n.memoryAlign);\n        r = Math.max(r, b);\n        var o,\n          i,\n          s,\n          a =\n            ((o = (function (e) {\n              if (ee) return Ue(e);\n              var t = Se,\n                n = (t + e + 15) & -16;\n              Se = n;\n              me.__heap_base.value = n;\n              return t;\n            })(n.memorySize + r)),\n            (i = r) || (i = b),\n            Math.ceil(o / i) * i),\n          c = J.length;\n        J.grow(n.tableSize);\n        for (var l = a; l < a + n.memorySize; l++) R[l] = 0;\n        for (l = c; l < c + n.tableSize; l++) J.set(l, null);\n        var u = new Proxy(\n            {},\n            {\n              get: function (e, t) {\n                switch (t) {\n                  case \"__memory_base\":\n                    return a;\n                  case \"__table_base\":\n                    return c;\n                }\n                return t in Be\n                  ? Be[t]\n                  : (t in e ||\n                      (e[t] = function () {\n                        if (n) {\n                          n = (function (e) {\n                            var t = Ie(e, !1);\n                            if (t) {\n                              t = s[e];\n                            }\n                            return t;\n                          })(t);\n                        }\n                        return n.apply(null, arguments);\n                      }),\n                    e[t]);\n                var n;\n              },\n            }\n          ),\n          d = {\n            \"GOT.mem\": new Proxy({}, ge),\n            \"GOT.func\": new Proxy({}, ge),\n            env: u,\n            wasi_snapshot_preview1: u,\n          };\n        function p(e) {\n          for (var r = 0; r < n.tableSize; r++) {\n            var o = J.get(c + r);\n            if (o) {\n              v.set(o, c + r);\n            }\n          }\n          s = ke(e.exports, a);\n          if (t.allowUndefined) {\n            Oe();\n          }\n          var i = s.__wasm_call_ctors;\n          if (i) {\n            i = s.__post_instantiate;\n          }\n          if (i) {\n            if (ee) {\n              i();\n            } else {\n              Q.push(i);\n            }\n          }\n          return s;\n        }\n        if (t.loadAsync) {\n          if (e instanceof WebAssembly.Module) {\n            var h = new WebAssembly.Instance(e, d);\n            return Promise.resolve(p(h));\n          }\n          return WebAssembly.instantiate(e, d).then(function (e) {\n            return p(e.instance);\n          });\n        }\n        var f = e instanceof WebAssembly.Module ? e : new WebAssembly.Module(e);\n        return p((h = new WebAssembly.Instance(f, d)));\n      }\n      return t.loadAsync\n        ? n.neededDynlibs\n            .reduce(function (e, n) {\n              return e.then(function () {\n                return Ae(n, t);\n              });\n            }, Promise.resolve())\n            .then(function () {\n              return r();\n            })\n        : (n.neededDynlibs.forEach(function (e) {\n            Ae(e, t);\n          }),\n          r());\n    }\n    function Ae(e, t) {\n      if (\"__main__\" != e || Ee.loadedLibNames[e]) {\n        Ee.loadedLibs[-1] = {\n          refcount: 1 / 0,\n          name: \"__main__\",\n          module: o.asm,\n          global: !0,\n        };\n        Ee.loadedLibNames.__main__ = -1;\n      }\n      t = t || {\n        global: !0,\n        nodelete: !0,\n      };\n      var n,\n        r = Ee.loadedLibNames[e];\n      if (r) {\n        n = Ee.loadedLibs[r];\n        if (t.global && !n.global) {\n          n.global = !0;\n          if (\"loading\" !== n.module) {\n            xe(n.module);\n          }\n        }\n        if (t.nodelete && n.refcount !== 1 / 0) {\n          n.refcount = 1 / 0;\n        }\n        n.refcount++;\n        return t.loadAsync ? Promise.resolve(r) : r;\n      }\n      function i(e) {\n        if (t.fs) {\n          var n = t.fs.readFile(e, {\n            encoding: \"binary\",\n          });\n          if (n instanceof Uint8Array) {\n            n = new Uint8Array(n);\n          }\n          return t.loadAsync ? Promise.resolve(n) : n;\n        }\n        return t.loadAsync\n          ? ((r = e),\n            fetch(r, {\n              credentials: \"same-origin\",\n            })\n              .then(function (e) {\n                if (!e.ok) throw \"failed to load binary file at '\" + r + \"'\";\n                return e.arrayBuffer();\n              })\n              .then(function (e) {\n                return new Uint8Array(e);\n              }))\n          : f(e);\n        var r;\n      }\n      function s() {\n        if (undefined !== o.preloadedWasm && undefined !== o.preloadedWasm[e]) {\n          var n = o.preloadedWasm[e];\n          return t.loadAsync ? Promise.resolve(n) : n;\n        }\n        return t.loadAsync\n          ? i(e).then(function (e) {\n              return Pe(e, t);\n            })\n          : Pe(i(e), t);\n      }\n      function a(e) {\n        if (n.global) {\n          xe(e);\n        }\n        n.module = e;\n      }\n      r = Ee.nextHandle++;\n      n = {\n        refcount: t.nodelete ? 1 / 0 : 1,\n        name: e,\n        module: \"loading\",\n        global: t.global,\n      };\n      Ee.loadedLibNames[e] = r;\n      Ee.loadedLibs[r] = n;\n      return t.loadAsync\n        ? s().then(function (e) {\n            a(e);\n            return r;\n          })\n        : (a(s()), r);\n    }\n    function Oe() {\n      for (var e in me)\n        if (0 == me[e].value) {\n          var t = Ie(e, !0);\n          if (\"function\" == typeof t) {\n            me[e].value = x(t, t.sig);\n          } else {\n            if (\"number\" == typeof t) {\n              me[e].value = t;\n            } else {\n              O(!1, \"bad export type for `\" + e + \"`: \" + typeof t);\n            }\n          }\n        }\n    }\n    o.___heap_base = Se;\n    var Ne,\n      Re = new WebAssembly.Global(\n        {\n          value: \"i32\",\n          mutable: !0,\n        },\n        5250816\n      );\n    function Me() {\n      se();\n    }\n    o._abort = Me;\n    Me.sig = \"v\";\n    Ne = i\n      ? function () {\n          var e = process.hrtime();\n          return 1e3 * e[0] + e[1] / 1e6;\n        }\n      : \"undefined\" != typeof dateNow\n      ? dateNow\n      : function () {\n          return performance.now();\n        };\n    var Le = !0;\n    function $e(e, t) {\n      var n;\n      if (0 === e) n = Date.now();\n      else {\n        if ((1 !== e && 4 !== e) || !Le) {\n          28;\n          $[He() >> 2] = 28;\n          return -1;\n        }\n        n = Ne();\n      }\n      $[t >> 2] = (n / 1e3) | 0;\n      $[(t + 4) >> 2] = ((n % 1e3) * 1e3 * 1e3) | 0;\n      return 0;\n    }\n    function De(e) {\n      try {\n        T.grow((e - N.byteLength + 65535) >>> 16);\n        W(T.buffer);\n        return 1;\n      } catch (e) {}\n    }\n    function Fe(e) {\n      Qe(e);\n    }\n    function je(e) {\n      C(e);\n    }\n    $e.sig = \"iii\";\n    Fe.sig = \"vi\";\n    je.sig = \"vi\";\n    var qe,\n      Be = {\n        __heap_base: Se,\n        __indirect_function_table: J,\n        __memory_base: 1024,\n        __stack_pointer: Re,\n        __table_base: 1,\n        abort: Me,\n        clock_gettime: $e,\n        emscripten_memcpy_big: function (e, t, n) {\n          M.copyWithin(e, t, t + n);\n        },\n        emscripten_resize_heap: function (e) {\n          var t,\n            n = M.length;\n          if ((e >>>= 0) > 2147483648) return !1;\n          for (var r = 1; r <= 4; r *= 2) {\n            var o = n * (1 + 0.2 / r);\n            o = Math.min(o, e + 100663296);\n            if (\n              De(\n                Math.min(\n                  2147483648,\n                  ((t = Math.max(e, o)) % 65536 > 0 &&\n                    (t += 65536 - (t % 65536)),\n                  t)\n                )\n              )\n            )\n              return !0;\n          }\n          return !1;\n        },\n        exit: Fe,\n        memory: T,\n        setTempRet0: je,\n        tree_sitter_log_callback: function (e, t) {\n          if (ft) {\n            const n = U(t);\n            ft(n, 0 !== e);\n          }\n        },\n        tree_sitter_parse_callback: function (e, t, n, r, o) {\n          var i = ht(t, {\n            row: n,\n            column: r,\n          });\n          if (\"string\" == typeof i) {\n            I(o, i.length, \"i32\");\n            (function (e, t, n) {\n              if (undefined === n) {\n                n = 2147483647;\n              }\n              if (n < 2) return 0;\n              for (\n                var r = (n -= 2) < 2 * e.length ? n / 2 : e.length, o = 0;\n                o < r;\n                ++o\n              ) {\n                var i = e.charCodeAt(o);\n                L[t >> 1] = i;\n                t += 2;\n              }\n              L[t >> 1] = 0;\n            })(i, e, 10240);\n          } else {\n            I(o, 0, \"i32\");\n          }\n        },\n      },\n      Ue =\n        ((function () {\n          var e = {\n            env: Be,\n            wasi_snapshot_preview1: Be,\n            \"GOT.mem\": new Proxy(Be, ge),\n            \"GOT.func\": new Proxy(Be, ge),\n          };\n          function t(e, t) {\n            var n = e.exports;\n            n = ke(n, 1024);\n            o.asm = n;\n            var r,\n              i = ye(t);\n            if (i.neededDynlibs) {\n              S = i.neededDynlibs.concat(S);\n            }\n            xe(n);\n            r = o.asm.__wasm_call_ctors;\n            Q.unshift(r);\n            ie();\n          }\n          function n(e) {\n            t(e.instance, e.module);\n          }\n          function r(t) {\n            return (function () {\n              if (!E && (u || d)) {\n                if (\"function\" == typeof fetch && !le(he))\n                  return fetch(he, {\n                    credentials: \"same-origin\",\n                  })\n                    .then(function (e) {\n                      if (!e.ok)\n                        throw \"failed to load wasm binary file at '\" + he + \"'\";\n                      return e.arrayBuffer();\n                    })\n                    .catch(function () {\n                      return fe(he);\n                    });\n                if (h)\n                  return new Promise(function (e, t) {\n                    h(\n                      he,\n                      function (t) {\n                        e(new Uint8Array(t));\n                      },\n                      t\n                    );\n                  });\n              }\n              return Promise.resolve().then(function () {\n                return fe(he);\n              });\n            })()\n              .then(function (t) {\n                return WebAssembly.instantiate(t, e);\n              })\n              .then(t, function (e) {\n                y(\"failed to asynchronously prepare wasm: \" + e);\n                se(e);\n              });\n          }\n          oe();\n          if (o.instantiateWasm)\n            try {\n              return o.instantiateWasm(e, t);\n            } catch (e) {\n              return (\n                y(\"Module.instantiateWasm callback failed with error: \" + e), !1\n              );\n            }\n          if (\n            E ||\n            \"function\" != typeof WebAssembly.instantiateStreaming ||\n            ce(he) ||\n            le(he) ||\n            \"function\" != typeof fetch\n          ) {\n            r(n);\n          } else {\n            fetch(he, {\n              credentials: \"same-origin\",\n            }).then(function (t) {\n              return WebAssembly.instantiateStreaming(t, e).then(\n                n,\n                function (e) {\n                  y(\"wasm streaming compile failed: \" + e);\n                  y(\"falling back to ArrayBuffer instantiation\");\n                  return r(n);\n                }\n              );\n            });\n          }\n        })(),\n        (o.___wasm_call_ctors = function () {\n          return (o.___wasm_call_ctors = o.asm.__wasm_call_ctors).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._malloc = function () {\n          return (Ue = o._malloc = o.asm.malloc).apply(null, arguments);\n        })),\n      He =\n        ((o._ts_language_symbol_count = function () {\n          return (o._ts_language_symbol_count =\n            o.asm.ts_language_symbol_count).apply(null, arguments);\n        }),\n        (o._ts_language_version = function () {\n          return (o._ts_language_version = o.asm.ts_language_version).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_language_field_count = function () {\n          return (o._ts_language_field_count =\n            o.asm.ts_language_field_count).apply(null, arguments);\n        }),\n        (o._ts_language_symbol_name = function () {\n          return (o._ts_language_symbol_name =\n            o.asm.ts_language_symbol_name).apply(null, arguments);\n        }),\n        (o._ts_language_symbol_for_name = function () {\n          return (o._ts_language_symbol_for_name =\n            o.asm.ts_language_symbol_for_name).apply(null, arguments);\n        }),\n        (o._ts_language_symbol_type = function () {\n          return (o._ts_language_symbol_type =\n            o.asm.ts_language_symbol_type).apply(null, arguments);\n        }),\n        (o._ts_language_field_name_for_id = function () {\n          return (o._ts_language_field_name_for_id =\n            o.asm.ts_language_field_name_for_id).apply(null, arguments);\n        }),\n        (o._memcpy = function () {\n          return (o._memcpy = o.asm.memcpy).apply(null, arguments);\n        }),\n        (o._free = function () {\n          return (o._free = o.asm.free).apply(null, arguments);\n        }),\n        (o._calloc = function () {\n          return (o._calloc = o.asm.calloc).apply(null, arguments);\n        }),\n        (o._ts_parser_delete = function () {\n          return (o._ts_parser_delete = o.asm.ts_parser_delete).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_parser_reset = function () {\n          return (o._ts_parser_reset = o.asm.ts_parser_reset).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_parser_set_language = function () {\n          return (o._ts_parser_set_language =\n            o.asm.ts_parser_set_language).apply(null, arguments);\n        }),\n        (o._ts_parser_timeout_micros = function () {\n          return (o._ts_parser_timeout_micros =\n            o.asm.ts_parser_timeout_micros).apply(null, arguments);\n        }),\n        (o._ts_parser_set_timeout_micros = function () {\n          return (o._ts_parser_set_timeout_micros =\n            o.asm.ts_parser_set_timeout_micros).apply(null, arguments);\n        }),\n        (o._memcmp = function () {\n          return (o._memcmp = o.asm.memcmp).apply(null, arguments);\n        }),\n        (o._ts_query_new = function () {\n          return (o._ts_query_new = o.asm.ts_query_new).apply(null, arguments);\n        }),\n        (o._ts_query_delete = function () {\n          return (o._ts_query_delete = o.asm.ts_query_delete).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._iswspace = function () {\n          return (o._iswspace = o.asm.iswspace).apply(null, arguments);\n        }),\n        (o._iswalnum = function () {\n          return (o._iswalnum = o.asm.iswalnum).apply(null, arguments);\n        }),\n        (o._ts_query_pattern_count = function () {\n          return (o._ts_query_pattern_count =\n            o.asm.ts_query_pattern_count).apply(null, arguments);\n        }),\n        (o._ts_query_capture_count = function () {\n          return (o._ts_query_capture_count =\n            o.asm.ts_query_capture_count).apply(null, arguments);\n        }),\n        (o._ts_query_string_count = function () {\n          return (o._ts_query_string_count = o.asm.ts_query_string_count).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_query_capture_name_for_id = function () {\n          return (o._ts_query_capture_name_for_id =\n            o.asm.ts_query_capture_name_for_id).apply(null, arguments);\n        }),\n        (o._ts_query_string_value_for_id = function () {\n          return (o._ts_query_string_value_for_id =\n            o.asm.ts_query_string_value_for_id).apply(null, arguments);\n        }),\n        (o._ts_query_predicates_for_pattern = function () {\n          return (o._ts_query_predicates_for_pattern =\n            o.asm.ts_query_predicates_for_pattern).apply(null, arguments);\n        }),\n        (o._ts_tree_copy = function () {\n          return (o._ts_tree_copy = o.asm.ts_tree_copy).apply(null, arguments);\n        }),\n        (o._ts_tree_delete = function () {\n          return (o._ts_tree_delete = o.asm.ts_tree_delete).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_init = function () {\n          return (o._ts_init = o.asm.ts_init).apply(null, arguments);\n        }),\n        (o._ts_parser_new_wasm = function () {\n          return (o._ts_parser_new_wasm = o.asm.ts_parser_new_wasm).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_parser_enable_logger_wasm = function () {\n          return (o._ts_parser_enable_logger_wasm =\n            o.asm.ts_parser_enable_logger_wasm).apply(null, arguments);\n        }),\n        (o._ts_parser_parse_wasm = function () {\n          return (o._ts_parser_parse_wasm = o.asm.ts_parser_parse_wasm).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_language_type_is_named_wasm = function () {\n          return (o._ts_language_type_is_named_wasm =\n            o.asm.ts_language_type_is_named_wasm).apply(null, arguments);\n        }),\n        (o._ts_language_type_is_visible_wasm = function () {\n          return (o._ts_language_type_is_visible_wasm =\n            o.asm.ts_language_type_is_visible_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_root_node_wasm = function () {\n          return (o._ts_tree_root_node_wasm =\n            o.asm.ts_tree_root_node_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_edit_wasm = function () {\n          return (o._ts_tree_edit_wasm = o.asm.ts_tree_edit_wasm).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_tree_get_changed_ranges_wasm = function () {\n          return (o._ts_tree_get_changed_ranges_wasm =\n            o.asm.ts_tree_get_changed_ranges_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_cursor_new_wasm = function () {\n          return (o._ts_tree_cursor_new_wasm =\n            o.asm.ts_tree_cursor_new_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_cursor_delete_wasm = function () {\n          return (o._ts_tree_cursor_delete_wasm =\n            o.asm.ts_tree_cursor_delete_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_cursor_reset_wasm = function () {\n          return (o._ts_tree_cursor_reset_wasm =\n            o.asm.ts_tree_cursor_reset_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_cursor_goto_first_child_wasm = function () {\n          return (o._ts_tree_cursor_goto_first_child_wasm =\n            o.asm.ts_tree_cursor_goto_first_child_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_cursor_goto_next_sibling_wasm = function () {\n          return (o._ts_tree_cursor_goto_next_sibling_wasm =\n            o.asm.ts_tree_cursor_goto_next_sibling_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_cursor_goto_parent_wasm = function () {\n          return (o._ts_tree_cursor_goto_parent_wasm =\n            o.asm.ts_tree_cursor_goto_parent_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_cursor_current_node_type_id_wasm = function () {\n          return (o._ts_tree_cursor_current_node_type_id_wasm =\n            o.asm.ts_tree_cursor_current_node_type_id_wasm).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_tree_cursor_current_node_is_named_wasm = function () {\n          return (o._ts_tree_cursor_current_node_is_named_wasm =\n            o.asm.ts_tree_cursor_current_node_is_named_wasm).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_tree_cursor_current_node_is_missing_wasm = function () {\n          return (o._ts_tree_cursor_current_node_is_missing_wasm =\n            o.asm.ts_tree_cursor_current_node_is_missing_wasm).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_tree_cursor_current_node_id_wasm = function () {\n          return (o._ts_tree_cursor_current_node_id_wasm =\n            o.asm.ts_tree_cursor_current_node_id_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_cursor_start_position_wasm = function () {\n          return (o._ts_tree_cursor_start_position_wasm =\n            o.asm.ts_tree_cursor_start_position_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_cursor_end_position_wasm = function () {\n          return (o._ts_tree_cursor_end_position_wasm =\n            o.asm.ts_tree_cursor_end_position_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_cursor_start_index_wasm = function () {\n          return (o._ts_tree_cursor_start_index_wasm =\n            o.asm.ts_tree_cursor_start_index_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_cursor_end_index_wasm = function () {\n          return (o._ts_tree_cursor_end_index_wasm =\n            o.asm.ts_tree_cursor_end_index_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_cursor_current_field_id_wasm = function () {\n          return (o._ts_tree_cursor_current_field_id_wasm =\n            o.asm.ts_tree_cursor_current_field_id_wasm).apply(null, arguments);\n        }),\n        (o._ts_tree_cursor_current_node_wasm = function () {\n          return (o._ts_tree_cursor_current_node_wasm =\n            o.asm.ts_tree_cursor_current_node_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_symbol_wasm = function () {\n          return (o._ts_node_symbol_wasm = o.asm.ts_node_symbol_wasm).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_node_child_count_wasm = function () {\n          return (o._ts_node_child_count_wasm =\n            o.asm.ts_node_child_count_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_named_child_count_wasm = function () {\n          return (o._ts_node_named_child_count_wasm =\n            o.asm.ts_node_named_child_count_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_child_wasm = function () {\n          return (o._ts_node_child_wasm = o.asm.ts_node_child_wasm).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_node_named_child_wasm = function () {\n          return (o._ts_node_named_child_wasm =\n            o.asm.ts_node_named_child_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_child_by_field_id_wasm = function () {\n          return (o._ts_node_child_by_field_id_wasm =\n            o.asm.ts_node_child_by_field_id_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_next_sibling_wasm = function () {\n          return (o._ts_node_next_sibling_wasm =\n            o.asm.ts_node_next_sibling_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_prev_sibling_wasm = function () {\n          return (o._ts_node_prev_sibling_wasm =\n            o.asm.ts_node_prev_sibling_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_next_named_sibling_wasm = function () {\n          return (o._ts_node_next_named_sibling_wasm =\n            o.asm.ts_node_next_named_sibling_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_prev_named_sibling_wasm = function () {\n          return (o._ts_node_prev_named_sibling_wasm =\n            o.asm.ts_node_prev_named_sibling_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_parent_wasm = function () {\n          return (o._ts_node_parent_wasm = o.asm.ts_node_parent_wasm).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_node_descendant_for_index_wasm = function () {\n          return (o._ts_node_descendant_for_index_wasm =\n            o.asm.ts_node_descendant_for_index_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_named_descendant_for_index_wasm = function () {\n          return (o._ts_node_named_descendant_for_index_wasm =\n            o.asm.ts_node_named_descendant_for_index_wasm).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_node_descendant_for_position_wasm = function () {\n          return (o._ts_node_descendant_for_position_wasm =\n            o.asm.ts_node_descendant_for_position_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_named_descendant_for_position_wasm = function () {\n          return (o._ts_node_named_descendant_for_position_wasm =\n            o.asm.ts_node_named_descendant_for_position_wasm).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_node_start_point_wasm = function () {\n          return (o._ts_node_start_point_wasm =\n            o.asm.ts_node_start_point_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_end_point_wasm = function () {\n          return (o._ts_node_end_point_wasm =\n            o.asm.ts_node_end_point_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_start_index_wasm = function () {\n          return (o._ts_node_start_index_wasm =\n            o.asm.ts_node_start_index_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_end_index_wasm = function () {\n          return (o._ts_node_end_index_wasm =\n            o.asm.ts_node_end_index_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_to_string_wasm = function () {\n          return (o._ts_node_to_string_wasm =\n            o.asm.ts_node_to_string_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_children_wasm = function () {\n          return (o._ts_node_children_wasm = o.asm.ts_node_children_wasm).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_node_named_children_wasm = function () {\n          return (o._ts_node_named_children_wasm =\n            o.asm.ts_node_named_children_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_descendants_of_type_wasm = function () {\n          return (o._ts_node_descendants_of_type_wasm =\n            o.asm.ts_node_descendants_of_type_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_is_named_wasm = function () {\n          return (o._ts_node_is_named_wasm = o.asm.ts_node_is_named_wasm).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_node_has_changes_wasm = function () {\n          return (o._ts_node_has_changes_wasm =\n            o.asm.ts_node_has_changes_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_has_error_wasm = function () {\n          return (o._ts_node_has_error_wasm =\n            o.asm.ts_node_has_error_wasm).apply(null, arguments);\n        }),\n        (o._ts_node_is_missing_wasm = function () {\n          return (o._ts_node_is_missing_wasm =\n            o.asm.ts_node_is_missing_wasm).apply(null, arguments);\n        }),\n        (o._ts_query_matches_wasm = function () {\n          return (o._ts_query_matches_wasm = o.asm.ts_query_matches_wasm).apply(\n            null,\n            arguments\n          );\n        }),\n        (o._ts_query_captures_wasm = function () {\n          return (o._ts_query_captures_wasm =\n            o.asm.ts_query_captures_wasm).apply(null, arguments);\n        }),\n        (o._iswdigit = function () {\n          return (o._iswdigit = o.asm.iswdigit).apply(null, arguments);\n        }),\n        (o._iswalpha = function () {\n          return (o._iswalpha = o.asm.iswalpha).apply(null, arguments);\n        }),\n        (o._iswlower = function () {\n          return (o._iswlower = o.asm.iswlower).apply(null, arguments);\n        }),\n        (o._towupper = function () {\n          return (o._towupper = o.asm.towupper).apply(null, arguments);\n        }),\n        (o.___errno_location = function () {\n          return (He = o.___errno_location = o.asm.__errno_location).apply(\n            null,\n            arguments\n          );\n        })),\n      ze =\n        ((o._memchr = function () {\n          return (o._memchr = o.asm.memchr).apply(null, arguments);\n        }),\n        (o._strlen = function () {\n          return (o._strlen = o.asm.strlen).apply(null, arguments);\n        }),\n        (o.stackSave = function () {\n          return (ze = o.stackSave = o.asm.stackSave).apply(null, arguments);\n        })),\n      Ge = (o.stackRestore = function () {\n        return (Ge = o.stackRestore = o.asm.stackRestore).apply(\n          null,\n          arguments\n        );\n      }),\n      Ve = (o.stackAlloc = function () {\n        return (Ve = o.stackAlloc = o.asm.stackAlloc).apply(null, arguments);\n      }),\n      We = (o._setThrew = function () {\n        return (We = o._setThrew = o.asm.setThrew).apply(null, arguments);\n      });\n    function Ke(e) {\n      this.name = \"ExitStatus\";\n      this.message = \"Program terminated with exit(\" + e + \")\";\n      this.status = e;\n    }\n    o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm =\n      function () {\n        return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm =\n          o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm).apply(\n          null,\n          arguments\n        );\n      };\n    o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev =\n      function () {\n        return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev =\n          o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev).apply(\n          null,\n          arguments\n        );\n      };\n    o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm =\n      function () {\n        return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm =\n          o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm).apply(\n          null,\n          arguments\n        );\n      };\n    o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm =\n      function () {\n        return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm =\n          o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm).apply(\n          null,\n          arguments\n        );\n      };\n    o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc =\n      function () {\n        return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc =\n          o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc).apply(\n          null,\n          arguments\n        );\n      };\n    o.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm =\n      function () {\n        return (o.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm =\n          o.asm._ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm).apply(\n          null,\n          arguments\n        );\n      };\n    o.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev =\n      function () {\n        return (o.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev =\n          o.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev).apply(\n          null,\n          arguments\n        );\n      };\n    o.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw =\n      function () {\n        return (o.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw =\n          o.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw).apply(\n          null,\n          arguments\n        );\n      };\n    o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_ =\n      function () {\n        return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_ =\n          o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_).apply(\n          null,\n          arguments\n        );\n      };\n    o.__Znwm = function () {\n      return (o.__Znwm = o.asm._Znwm).apply(null, arguments);\n    };\n    o.__ZdlPv = function () {\n      return (o.__ZdlPv = o.asm._ZdlPv).apply(null, arguments);\n    };\n    o.__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv =\n      function () {\n        return (o.__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv =\n          o.asm._ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv).apply(\n          null,\n          arguments\n        );\n      };\n    o._orig$ts_parser_timeout_micros = function () {\n      return (o._orig$ts_parser_timeout_micros =\n        o.asm.orig$ts_parser_timeout_micros).apply(null, arguments);\n    };\n    o._orig$ts_parser_set_timeout_micros = function () {\n      return (o._orig$ts_parser_set_timeout_micros =\n        o.asm.orig$ts_parser_set_timeout_micros).apply(null, arguments);\n    };\n    o.allocate = function (e, t) {\n      var n;\n      n = t == j ? Ve(e.length) : Ue(e.length);\n      if (e.subarray || e.slice) {\n        M.set(e, n);\n      } else {\n        M.set(new Uint8Array(e), n);\n      }\n      return n;\n    };\n    re = function e() {\n      if (qe) {\n        Xe();\n      }\n      if (qe) {\n        re = e;\n      }\n    };\n    var Je = !1;\n    function Xe(e) {\n      function t() {\n        if (qe) {\n          qe = !0;\n          o.calledRun = !0;\n          if (A) {\n            ee = !0;\n            _e(Q);\n            _e(Y);\n            if (o.onRuntimeInitialized) {\n              o.onRuntimeInitialized();\n            }\n            if (Ye) {\n              (function (e) {\n                var t = o._main;\n                if (t) {\n                  var n = (e = e || []).length + 1,\n                    r = Ve(4 * (n + 1));\n                  $[r >> 2] = V(c);\n                  for (var i = 1; i < n; i++) $[(r >> 2) + i] = V(e[i - 1]);\n                  $[(r >> 2) + n] = 0;\n                  try {\n                    Qe(t(n, r), !0);\n                  } catch (e) {\n                    if (e instanceof Ke) return;\n                    if (\"unwind\" == e) return;\n                    var s = e;\n                    if (e && \"object\" == typeof e && e.stack) {\n                      s = [e, e.stack];\n                    }\n                    y(\"exception thrown: \" + s);\n                    l(1, e);\n                  }\n                }\n              })(e);\n            }\n            (function () {\n              if (o.postRun)\n                for (\n                  \"function\" == typeof o.postRun && (o.postRun = [o.postRun]);\n                  o.postRun.length;\n\n                ) {\n                  e = o.postRun.shift();\n                  Z.unshift(e);\n                }\n              var e;\n              _e(Z);\n            })();\n          }\n        }\n      }\n      e = e || a;\n      if (\n        te > 0 ||\n        (!Je &&\n          ((function () {\n            if (S.length) {\n              if (!f) {\n                oe();\n                return void S.reduce(function (e, t) {\n                  return e.then(function () {\n                    return Ae(t, {\n                      loadAsync: !0,\n                      global: !0,\n                      nodelete: !0,\n                      allowUndefined: !0,\n                    });\n                  });\n                }, Promise.resolve()).then(function () {\n                  ie();\n                  Oe();\n                });\n              }\n              S.forEach(function (e) {\n                Ae(e, {\n                  global: !0,\n                  nodelete: !0,\n                  allowUndefined: !0,\n                });\n              });\n              Oe();\n            } else Oe();\n          })(),\n          (Je = !0),\n          te > 0))\n      ) {\n        (function () {\n          if (o.preRun)\n            for (\n              \"function\" == typeof o.preRun && (o.preRun = [o.preRun]);\n              o.preRun.length;\n\n            ) {\n              e = o.preRun.shift();\n              X.unshift(e);\n            }\n          var e;\n          _e(X);\n        })();\n        if (te > 0) {\n          if (o.setStatus) {\n            o.setStatus(\"Running...\");\n            setTimeout(function () {\n              setTimeout(function () {\n                o.setStatus(\"\");\n              }, 1);\n              t();\n            }, 1);\n          } else {\n            t();\n          }\n        }\n      }\n    }\n    function Qe(e, t) {\n      if (t && be() && 0 === e) {\n        if (be()) {\n          if (o.onExit) {\n            o.onExit(e);\n          }\n          A = !0;\n        }\n        l(e, new Ke(e));\n      }\n    }\n    o.run = Xe;\n    if (o.preInit)\n      for (\n        \"function\" == typeof o.preInit && (o.preInit = [o.preInit]);\n        o.preInit.length > 0;\n\n      )\n        o.preInit.pop()();\n    var Ye = !0;\n    if (o.noInitialRun) {\n      Ye = !1;\n    }\n    Xe();\n    const Ze = o,\n      et = {},\n      tt = 4,\n      nt = 5 * tt,\n      rt = 2 * tt,\n      ot = 2 * tt + 2 * rt,\n      it = {\n        row: 0,\n        column: 0,\n      },\n      st = /[\\w-.]*/g,\n      at = 1,\n      ct = 2,\n      lt = /^_?tree_sitter_\\w+/;\n    var ut,\n      dt,\n      pt,\n      ht,\n      ft,\n      mt = new Promise((e) => {\n        o.onRuntimeInitialized = e;\n      }).then(() => {\n        pt = Ze._ts_init();\n        ut = P(pt, \"i32\");\n        dt = P(pt + tt, \"i32\");\n      });\n    class gt {\n      static init() {\n        return mt;\n      }\n      constructor() {\n        if (null == pt)\n          throw new Error(\n            \"You must first call Parser.init() and wait for it to resolve.\"\n          );\n        Ze._ts_parser_new_wasm();\n        this[0] = P(pt, \"i32\");\n        this[1] = P(pt + tt, \"i32\");\n      }\n      delete() {\n        Ze._ts_parser_delete(this[0]);\n        Ze._free(this[1]);\n        this[0] = 0;\n        this[1] = 0;\n      }\n      setLanguage(e) {\n        let t;\n        if (e) {\n          if (e.constructor !== bt)\n            throw new Error(\"Argument must be a Language\");\n          {\n            t = e[0];\n            const n = Ze._ts_language_version(t);\n            if (n < dt || ut < n)\n              throw new Error(\n                `Incompatible language version ${n}. Compatibility range ${dt} through ${ut}.`\n              );\n          }\n        } else {\n          t = 0;\n          e = null;\n        }\n        this.language = e;\n        Ze._ts_parser_set_language(this[0], t);\n        return this;\n      }\n      getLanguage() {\n        return this.language;\n      }\n      parse(e, t, n) {\n        if (\"string\" == typeof e) ht = (t, n, r) => e.slice(t, r);\n        else {\n          if (\"function\" != typeof e)\n            throw new Error(\"Argument must be a string or a function\");\n          ht = e;\n        }\n        if (this.logCallback) {\n          ft = this.logCallback;\n          Ze._ts_parser_enable_logger_wasm(this[0], 1);\n        } else {\n          ft = null;\n          Ze._ts_parser_enable_logger_wasm(this[0], 0);\n        }\n        let r = 0,\n          o = 0;\n        if (n && n.includedRanges) {\n          r = n.includedRanges.length;\n          let e = (o = Ze._calloc(r, ot));\n          for (let t = 0; t < r; t++) {\n            Nt(e, n.includedRanges[t]);\n            e += ot;\n          }\n        }\n        const i = Ze._ts_parser_parse_wasm(\n          this[0],\n          this[1],\n          t ? t[0] : 0,\n          o,\n          r\n        );\n        if (!i) throw ((ht = null), (ft = null), new Error(\"Parsing failed\"));\n        const s = new _t(et, i, this.language, ht);\n        ht = null;\n        ft = null;\n        return s;\n      }\n      reset() {\n        Ze._ts_parser_reset(this[0]);\n      }\n      setTimeoutMicros(e) {\n        Ze._ts_parser_set_timeout_micros(this[0], e);\n      }\n      getTimeoutMicros() {\n        return Ze._ts_parser_timeout_micros(this[0]);\n      }\n      setLogger(e) {\n        if (e) {\n          if (\"function\" != typeof e)\n            throw new Error(\"Logger callback must be a function\");\n        } else e = null;\n        this.logCallback = e;\n        return this;\n      }\n      getLogger() {\n        return this.logCallback;\n      }\n    }\n    class _t {\n      constructor(e, t, n, r) {\n        Ct(e);\n        this[0] = t;\n        this.language = n;\n        this.textCallback = r;\n      }\n      copy() {\n        const e = Ze._ts_tree_copy(this[0]);\n        return new _t(et, e, this.language, this.textCallback);\n      }\n      delete() {\n        Ze._ts_tree_delete(this[0]);\n        this[0] = 0;\n      }\n      edit(e) {\n        !(function (e) {\n          let t = pt;\n          At(t, e.startPosition);\n          At((t += rt), e.oldEndPosition);\n          At((t += rt), e.newEndPosition);\n          I((t += rt), e.startIndex, \"i32\");\n          I((t += tt), e.oldEndIndex, \"i32\");\n          I((t += tt), e.newEndIndex, \"i32\");\n          t += tt;\n        })(e);\n        Ze._ts_tree_edit_wasm(this[0]);\n      }\n      get rootNode() {\n        Ze._ts_tree_root_node_wasm(this[0]);\n        return kt(this);\n      }\n      getLanguage() {\n        return this.language;\n      }\n      walk() {\n        return this.rootNode.walk();\n      }\n      getChangedRanges(e) {\n        if (e.constructor !== _t)\n          throw new TypeError(\"Argument must be a Tree\");\n        Ze._ts_tree_get_changed_ranges_wasm(this[0], e[0]);\n        const t = P(pt, \"i32\"),\n          n = P(pt + tt, \"i32\"),\n          r = new Array(t);\n        if (t > 0) {\n          let e = n;\n          for (let n = 0; n < t; n++) {\n            r[n] = Rt(e);\n            e += ot;\n          }\n          Ze._free(n);\n        }\n        return r;\n      }\n    }\n    class yt {\n      constructor(e, t) {\n        Ct(e);\n        this.tree = t;\n      }\n      get typeId() {\n        Tt(this);\n        return Ze._ts_node_symbol_wasm(this.tree[0]);\n      }\n      get type() {\n        return this.tree.language.types[this.typeId] || \"ERROR\";\n      }\n      get endPosition() {\n        Tt(this);\n        Ze._ts_node_end_point_wasm(this.tree[0]);\n        return Ot(pt);\n      }\n      get endIndex() {\n        Tt(this);\n        return Ze._ts_node_end_index_wasm(this.tree[0]);\n      }\n      get text() {\n        return xt(this.tree, this.startIndex, this.endIndex);\n      }\n      isNamed() {\n        Tt(this);\n        return 1 === Ze._ts_node_is_named_wasm(this.tree[0]);\n      }\n      hasError() {\n        Tt(this);\n        return 1 === Ze._ts_node_has_error_wasm(this.tree[0]);\n      }\n      hasChanges() {\n        Tt(this);\n        return 1 === Ze._ts_node_has_changes_wasm(this.tree[0]);\n      }\n      isMissing() {\n        Tt(this);\n        return 1 === Ze._ts_node_is_missing_wasm(this.tree[0]);\n      }\n      equals(e) {\n        return this.id === e.id;\n      }\n      child(e) {\n        Tt(this);\n        Ze._ts_node_child_wasm(this.tree[0], e);\n        return kt(this.tree);\n      }\n      namedChild(e) {\n        Tt(this);\n        Ze._ts_node_named_child_wasm(this.tree[0], e);\n        return kt(this.tree);\n      }\n      childForFieldId(e) {\n        Tt(this);\n        Ze._ts_node_child_by_field_id_wasm(this.tree[0], e);\n        return kt(this.tree);\n      }\n      childForFieldName(e) {\n        const t = this.tree.language.fields.indexOf(e);\n        if (-1 !== t) return this.childForFieldId(t);\n      }\n      get childCount() {\n        Tt(this);\n        return Ze._ts_node_child_count_wasm(this.tree[0]);\n      }\n      get namedChildCount() {\n        Tt(this);\n        return Ze._ts_node_named_child_count_wasm(this.tree[0]);\n      }\n      get firstChild() {\n        return this.child(0);\n      }\n      get firstNamedChild() {\n        return this.namedChild(0);\n      }\n      get lastChild() {\n        return this.child(this.childCount - 1);\n      }\n      get lastNamedChild() {\n        return this.namedChild(this.namedChildCount - 1);\n      }\n      get children() {\n        if (!this._children) {\n          Tt(this);\n          Ze._ts_node_children_wasm(this.tree[0]);\n          const e = P(pt, \"i32\"),\n            t = P(pt + tt, \"i32\");\n          this._children = new Array(e);\n          if (e > 0) {\n            let n = t;\n            for (let t = 0; t < e; t++)\n              (this._children[t] = kt(this.tree, n)), (n += nt);\n            Ze._free(t);\n          }\n        }\n        return this._children;\n      }\n      get namedChildren() {\n        if (!this._namedChildren) {\n          Tt(this);\n          Ze._ts_node_named_children_wasm(this.tree[0]);\n          const e = P(pt, \"i32\"),\n            t = P(pt + tt, \"i32\");\n          this._namedChildren = new Array(e);\n          if (e > 0) {\n            let n = t;\n            for (let t = 0; t < e; t++)\n              (this._namedChildren[t] = kt(this.tree, n)), (n += nt);\n            Ze._free(t);\n          }\n        }\n        return this._namedChildren;\n      }\n      descendantsOfType(e, t, n) {\n        if (Array.isArray(e)) {\n          e = [e];\n        }\n        if (t) {\n          t = it;\n        }\n        if (n) {\n          n = it;\n        }\n        const r = [],\n          o = this.tree.language.types;\n        for (let t = 0, n = o.length; t < n; t++)\n          if (e.includes(o[t])) {\n            r.push(t);\n          }\n        const i = Ze._malloc(tt * r.length);\n        for (let e = 0, t = r.length; e < t; e++) I(i + e * tt, r[e], \"i32\");\n        Tt(this);\n        Ze._ts_node_descendants_of_type_wasm(\n          this.tree[0],\n          i,\n          r.length,\n          t.row,\n          t.column,\n          n.row,\n          n.column\n        );\n        const s = P(pt, \"i32\"),\n          a = P(pt + tt, \"i32\"),\n          c = new Array(s);\n        if (s > 0) {\n          let e = a;\n          for (let t = 0; t < s; t++) {\n            c[t] = kt(this.tree, e);\n            e += nt;\n          }\n        }\n        Ze._free(a);\n        Ze._free(i);\n        return c;\n      }\n      get nextSibling() {\n        Tt(this);\n        Ze._ts_node_next_sibling_wasm(this.tree[0]);\n        return kt(this.tree);\n      }\n      get previousSibling() {\n        Tt(this);\n        Ze._ts_node_prev_sibling_wasm(this.tree[0]);\n        return kt(this.tree);\n      }\n      get nextNamedSibling() {\n        Tt(this);\n        Ze._ts_node_next_named_sibling_wasm(this.tree[0]);\n        return kt(this.tree);\n      }\n      get previousNamedSibling() {\n        Tt(this);\n        Ze._ts_node_prev_named_sibling_wasm(this.tree[0]);\n        return kt(this.tree);\n      }\n      get parent() {\n        Tt(this);\n        Ze._ts_node_parent_wasm(this.tree[0]);\n        return kt(this.tree);\n      }\n      descendantForIndex(e, t = e) {\n        if (\"number\" != typeof e || \"number\" != typeof t)\n          throw new Error(\"Arguments must be numbers\");\n        Tt(this);\n        let n = pt + nt;\n        I(n, e, \"i32\");\n        I(n + tt, t, \"i32\");\n        Ze._ts_node_descendant_for_index_wasm(this.tree[0]);\n        return kt(this.tree);\n      }\n      namedDescendantForIndex(e, t = e) {\n        if (\"number\" != typeof e || \"number\" != typeof t)\n          throw new Error(\"Arguments must be numbers\");\n        Tt(this);\n        let n = pt + nt;\n        I(n, e, \"i32\");\n        I(n + tt, t, \"i32\");\n        Ze._ts_node_named_descendant_for_index_wasm(this.tree[0]);\n        return kt(this.tree);\n      }\n      descendantForPosition(e, t = e) {\n        if (!St(e) || !St(t))\n          throw new Error(\"Arguments must be {row, column} objects\");\n        Tt(this);\n        let n = pt + nt;\n        At(n, e);\n        At(n + rt, t);\n        Ze._ts_node_descendant_for_position_wasm(this.tree[0]);\n        return kt(this.tree);\n      }\n      namedDescendantForPosition(e, t = e) {\n        if (!St(e) || !St(t))\n          throw new Error(\"Arguments must be {row, column} objects\");\n        Tt(this);\n        let n = pt + nt;\n        At(n, e);\n        At(n + rt, t);\n        Ze._ts_node_named_descendant_for_position_wasm(this.tree[0]);\n        return kt(this.tree);\n      }\n      walk() {\n        Tt(this);\n        Ze._ts_tree_cursor_new_wasm(this.tree[0]);\n        return new vt(et, this.tree);\n      }\n      toString() {\n        Tt(this);\n        const e = Ze._ts_node_to_string_wasm(this.tree[0]),\n          t = (function (e) {\n            for (var t = \"\"; ; ) {\n              var n = M[e++ >> 0];\n              if (!n) return t;\n              t += String.fromCharCode(n);\n            }\n          })(e);\n        Ze._free(e);\n        return t;\n      }\n    }\n    class vt {\n      constructor(e, t) {\n        Ct(e);\n        this.tree = t;\n        Pt(this);\n      }\n      delete() {\n        It(this);\n        Ze._ts_tree_cursor_delete_wasm(this.tree[0]);\n        this[0] = this[1] = this[2] = 0;\n      }\n      reset(e) {\n        Tt(e);\n        It(this, pt + nt);\n        Ze._ts_tree_cursor_reset_wasm(this.tree[0]);\n        Pt(this);\n      }\n      get nodeType() {\n        return this.tree.language.types[this.nodeTypeId] || \"ERROR\";\n      }\n      get nodeTypeId() {\n        It(this);\n        return Ze._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);\n      }\n      get nodeId() {\n        It(this);\n        return Ze._ts_tree_cursor_current_node_id_wasm(this.tree[0]);\n      }\n      get nodeIsNamed() {\n        It(this);\n        return (\n          1 === Ze._ts_tree_cursor_current_node_is_named_wasm(this.tree[0])\n        );\n      }\n      get nodeIsMissing() {\n        It(this);\n        return (\n          1 === Ze._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0])\n        );\n      }\n      get nodeText() {\n        It(this);\n        const e = Ze._ts_tree_cursor_start_index_wasm(this.tree[0]),\n          t = Ze._ts_tree_cursor_end_index_wasm(this.tree[0]);\n        return xt(this.tree, e, t);\n      }\n      get startPosition() {\n        It(this);\n        Ze._ts_tree_cursor_start_position_wasm(this.tree[0]);\n        return Ot(pt);\n      }\n      get endPosition() {\n        It(this);\n        Ze._ts_tree_cursor_end_position_wasm(this.tree[0]);\n        return Ot(pt);\n      }\n      get startIndex() {\n        It(this);\n        return Ze._ts_tree_cursor_start_index_wasm(this.tree[0]);\n      }\n      get endIndex() {\n        It(this);\n        return Ze._ts_tree_cursor_end_index_wasm(this.tree[0]);\n      }\n      currentNode() {\n        It(this);\n        Ze._ts_tree_cursor_current_node_wasm(this.tree[0]);\n        return kt(this.tree);\n      }\n      currentFieldId() {\n        It(this);\n        return Ze._ts_tree_cursor_current_field_id_wasm(this.tree[0]);\n      }\n      currentFieldName() {\n        return this.tree.language.fields[this.currentFieldId()];\n      }\n      gotoFirstChild() {\n        It(this);\n        const e = Ze._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);\n        Pt(this);\n        return 1 === e;\n      }\n      gotoNextSibling() {\n        It(this);\n        const e = Ze._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);\n        Pt(this);\n        return 1 === e;\n      }\n      gotoParent() {\n        It(this);\n        const e = Ze._ts_tree_cursor_goto_parent_wasm(this.tree[0]);\n        Pt(this);\n        return 1 === e;\n      }\n    }\n    class bt {\n      constructor(e, t) {\n        Ct(e);\n        this[0] = t;\n        this.types = new Array(Ze._ts_language_symbol_count(this[0]));\n        for (let e = 0, t = this.types.length; e < t; e++)\n          if (Ze._ts_language_symbol_type(this[0], e) < 2) {\n            this.types[e] = U(Ze._ts_language_symbol_name(this[0], e));\n          }\n        this.fields = new Array(Ze._ts_language_field_count(this[0]) + 1);\n        for (let e = 0, t = this.fields.length; e < t; e++) {\n          const t = Ze._ts_language_field_name_for_id(this[0], e);\n          this.fields[e] = 0 !== t ? U(t) : null;\n        }\n      }\n      get version() {\n        return Ze._ts_language_version(this[0]);\n      }\n      get fieldCount() {\n        return this.fields.length - 1;\n      }\n      fieldIdForName(e) {\n        const t = this.fields.indexOf(e);\n        return -1 !== t ? t : null;\n      }\n      fieldNameForId(e) {\n        return this.fields[e] || null;\n      }\n      idForNodeType(e, t) {\n        const n = G(e),\n          r = Ze._malloc(n + 1);\n        z(e, r, n + 1);\n        const o = Ze._ts_language_symbol_for_name(this[0], r, n, t);\n        Ze._free(r);\n        return o || null;\n      }\n      get nodeTypeCount() {\n        return Ze._ts_language_symbol_count(this[0]);\n      }\n      nodeTypeForId(e) {\n        const t = Ze._ts_language_symbol_name(this[0], e);\n        return t ? U(t) : null;\n      }\n      nodeTypeIsNamed(e) {\n        return !!Ze._ts_language_type_is_named_wasm(this[0], e);\n      }\n      nodeTypeIsVisible(e) {\n        return !!Ze._ts_language_type_is_visible_wasm(this[0], e);\n      }\n      query(e) {\n        const t = G(e),\n          n = Ze._malloc(t + 1);\n        z(e, n, t + 1);\n        const r = Ze._ts_query_new(this[0], n, t, pt, pt + tt);\n        if (!r) {\n          const t = P(pt + tt, \"i32\"),\n            r = U(n, P(pt, \"i32\")).length,\n            o = e.substr(r, 100).split(\"\\n\")[0];\n          let i,\n            s = o.match(st)[0];\n          switch (t) {\n            case 2:\n              i = new RangeError(`Bad node name '${s}'`);\n              break;\n            case 3:\n              i = new RangeError(`Bad field name '${s}'`);\n              break;\n            case 4:\n              i = new RangeError(`Bad capture name @${s}`);\n              break;\n            case 5:\n              i = new TypeError(\n                `Bad pattern structure at offset ${r}: '${o}'...`\n              );\n              s = \"\";\n              break;\n            default:\n              i = new SyntaxError(`Bad syntax at offset ${r}: '${o}'...`);\n              s = \"\";\n          }\n          throw ((i.index = r), (i.length = s.length), Ze._free(n), i);\n        }\n        const o = Ze._ts_query_string_count(r),\n          i = Ze._ts_query_capture_count(r),\n          s = Ze._ts_query_pattern_count(r),\n          a = new Array(i),\n          c = new Array(o);\n        for (let e = 0; e < i; e++) {\n          const t = Ze._ts_query_capture_name_for_id(r, e, pt),\n            n = P(pt, \"i32\");\n          a[e] = U(t, n);\n        }\n        for (let e = 0; e < o; e++) {\n          const t = Ze._ts_query_string_value_for_id(r, e, pt),\n            n = P(pt, \"i32\");\n          c[e] = U(t, n);\n        }\n        const l = new Array(s),\n          u = new Array(s),\n          d = new Array(s),\n          p = new Array(s),\n          h = new Array(s);\n        for (let e = 0; e < s; e++) {\n          const t = Ze._ts_query_predicates_for_pattern(r, e, pt),\n            n = P(pt, \"i32\");\n          p[e] = [];\n          h[e] = [];\n          const o = [];\n          let i = t;\n          for (let t = 0; t < n; t++) {\n            const t = P(i, \"i32\"),\n              n = P((i += tt), \"i32\");\n            i += tt;\n            if (t === at)\n              o.push({\n                type: \"capture\",\n                name: a[n],\n              });\n            else if (t === ct)\n              o.push({\n                type: \"string\",\n                value: c[n],\n              });\n            else if (o.length > 0) {\n              if (\"string\" !== o[0].type)\n                throw new Error(\"Predicates must begin with a literal value\");\n              const t = o[0].value;\n              let n = !0;\n              switch (t) {\n                case \"not-eq?\":\n                  n = !1;\n                case \"eq?\":\n                  if (3 !== o.length)\n                    throw new Error(\n                      \"Wrong number of arguments to `#eq?` predicate. Expected 2, got \" +\n                        (o.length - 1)\n                    );\n                  if (\"capture\" !== o[1].type)\n                    throw new Error(\n                      `First argument of \\`#eq?\\` predicate must be a capture. Got \"${o[1].value}\"`\n                    );\n                  if (\"capture\" === o[2].type) {\n                    const t = o[1].name,\n                      r = o[2].name;\n                    h[e].push(function (e) {\n                      let o, i;\n                      for (const n of e)\n                        n.name === t && (o = n.node),\n                          n.name === r && (i = n.node);\n                      return (o.text === i.text) === n;\n                    });\n                  } else {\n                    const t = o[1].name,\n                      r = o[2].value;\n                    h[e].push(function (e) {\n                      for (const o of e)\n                        if (o.name === t) return (o.node.text === r) === n;\n                      return !1;\n                    });\n                  }\n                  break;\n                case \"not-match?\":\n                  n = !1;\n                case \"match?\":\n                  if (3 !== o.length)\n                    throw new Error(\n                      `Wrong number of arguments to \\`#match?\\` predicate. Expected 2, got ${\n                        o.length - 1\n                      }.`\n                    );\n                  if (\"capture\" !== o[1].type)\n                    throw new Error(\n                      `First argument of \\`#match?\\` predicate must be a capture. Got \"${o[1].value}\".`\n                    );\n                  if (\"string\" !== o[2].type)\n                    throw new Error(\n                      `Second argument of \\`#match?\\` predicate must be a string. Got @${o[2].value}.`\n                    );\n                  const r = o[1].name,\n                    i = new RegExp(o[2].value);\n                  h[e].push(function (e) {\n                    for (const t of e)\n                      if (t.name === r) return i.test(t.node.text) === n;\n                    return !1;\n                  });\n                  break;\n                case \"set!\":\n                  if (o.length < 2 || o.length > 3)\n                    throw new Error(\n                      `Wrong number of arguments to \\`#set!\\` predicate. Expected 1 or 2. Got ${\n                        o.length - 1\n                      }.`\n                    );\n                  if (o.some((e) => \"string\" !== e.type))\n                    throw new Error(\n                      'Arguments to `#set!` predicate must be a strings.\".'\n                    );\n                  l[e] || (l[e] = {}),\n                    (l[e][o[1].value] = o[2] ? o[2].value : null);\n                  break;\n                case \"is?\":\n                case \"is-not?\":\n                  if (o.length < 2 || o.length > 3)\n                    throw new Error(\n                      `Wrong number of arguments to \\`#${t}\\` predicate. Expected 1 or 2. Got ${\n                        o.length - 1\n                      }.`\n                    );\n                  if (o.some((e) => \"string\" !== e.type))\n                    throw new Error(\n                      `Arguments to \\`#${t}\\` predicate must be a strings.\".`\n                    );\n                  const s = \"is?\" === t ? u : d;\n                  s[e] || (s[e] = {}),\n                    (s[e][o[1].value] = o[2] ? o[2].value : null);\n                  break;\n                default:\n                  p[e].push({\n                    operator: t,\n                    operands: o.slice(1),\n                  });\n              }\n              o.length = 0;\n            }\n          }\n          Object.freeze(l[e]);\n          Object.freeze(u[e]);\n          Object.freeze(d[e]);\n        }\n        Ze._free(n);\n        return new wt(\n          et,\n          r,\n          a,\n          h,\n          p,\n          Object.freeze(l),\n          Object.freeze(u),\n          Object.freeze(d)\n        );\n      }\n      static load(e) {\n        let t;\n        if (e instanceof Uint8Array) t = Promise.resolve(e);\n        else {\n          const r = e;\n          if (\n            \"undefined\" != typeof process &&\n            process.versions &&\n            process.versions.node\n          ) {\n            const e = require(\"fs\");\n            t = Promise.resolve(e.readFileSync(r));\n          } else\n            t = fetch(r).then((e) =>\n              e.arrayBuffer().then((t) => {\n                if (e.ok) return new Uint8Array(t);\n                {\n                  const n = new TextDecoder(\"utf-8\").decode(t);\n                  throw new Error(\n                    `Language.load failed with status ${e.status}.\\n\\n${n}`\n                  );\n                }\n              })\n            );\n        }\n        const r = \"function\" == typeof loadSideModule ? loadSideModule : Pe;\n        return t\n          .then((e) =>\n            r(e, {\n              loadAsync: !0,\n            })\n          )\n          .then((e) => {\n            const t = Object.keys(e),\n              n = t.find((e) => lt.test(e) && !e.includes(\"external_scanner_\"));\n            if (n) {\n              console.log(\n                `Couldn't find language function in WASM file. Symbols:\\n${JSON.stringify(\n                  t,\n                  null,\n                  2\n                )}`\n              );\n            }\n            const r = e[n]();\n            return new bt(et, r);\n          });\n      }\n    }\n    class wt {\n      constructor(e, t, n, r, o, i, s, a) {\n        Ct(e);\n        this[0] = t;\n        this.captureNames = n;\n        this.textPredicates = r;\n        this.predicates = o;\n        this.setProperties = i;\n        this.assertedProperties = s;\n        this.refutedProperties = a;\n        this.exceededMatchLimit = !1;\n      }\n      delete() {\n        Ze._ts_query_delete(this[0]);\n        this[0] = 0;\n      }\n      matches(e, t, n) {\n        if (t) {\n          t = it;\n        }\n        if (n) {\n          n = it;\n        }\n        Tt(e);\n        Ze._ts_query_matches_wasm(\n          this[0],\n          e.tree[0],\n          t.row,\n          t.column,\n          n.row,\n          n.column\n        );\n        const r = P(pt, \"i32\"),\n          o = P(pt + tt, \"i32\"),\n          i = P(pt + 2 * tt, \"i32\"),\n          s = new Array(r);\n        this.exceededMatchLimit = !!i;\n        let a = 0,\n          c = o;\n        for (let t = 0; t < r; t++) {\n          const n = P(c, \"i32\"),\n            r = P((c += tt), \"i32\");\n          c += tt;\n          const o = new Array(r);\n          c = Et(this, e.tree, c, o);\n          if (this.textPredicates[n].every((e) => e(o))) {\n            s[a++] = {\n              pattern: n,\n              captures: o,\n            };\n            const e = this.setProperties[n];\n            e && (s[t].setProperties = e);\n            const r = this.assertedProperties[n];\n            r && (s[t].assertedProperties = r);\n            const i = this.refutedProperties[n];\n            i && (s[t].refutedProperties = i);\n          }\n        }\n        s.length = a;\n        Ze._free(o);\n        return s;\n      }\n      captures(e, t, n) {\n        if (t) {\n          t = it;\n        }\n        if (n) {\n          n = it;\n        }\n        Tt(e);\n        Ze._ts_query_captures_wasm(\n          this[0],\n          e.tree[0],\n          t.row,\n          t.column,\n          n.row,\n          n.column\n        );\n        const r = P(pt, \"i32\"),\n          o = P(pt + tt, \"i32\"),\n          i = P(pt + 2 * tt, \"i32\"),\n          s = [];\n        this.exceededMatchLimit = !!i;\n        const a = [];\n        let c = o;\n        for (let t = 0; t < r; t++) {\n          const t = P(c, \"i32\"),\n            n = P((c += tt), \"i32\"),\n            r = P((c += tt), \"i32\");\n          c += tt;\n          a.length = n;\n          c = Et(this, e.tree, c, a);\n          if (this.textPredicates[t].every((e) => e(a))) {\n            const e = a[r],\n              n = this.setProperties[t];\n            n && (e.setProperties = n);\n            const o = this.assertedProperties[t];\n            o && (e.assertedProperties = o);\n            const i = this.refutedProperties[t];\n            i && (e.refutedProperties = i), s.push(e);\n          }\n        }\n        Ze._free(o);\n        return s;\n      }\n      predicatesForPattern(e) {\n        return this.predicates[e];\n      }\n      didExceedMatchLimit() {\n        return this.exceededMatchLimit;\n      }\n    }\n    function xt(e, t, n) {\n      const r = n - t;\n      let o = e.textCallback(t, null, n);\n      for (t += o.length; t < n; ) {\n        const r = e.textCallback(t, null, n);\n        if (!(r && r.length > 0)) break;\n        t += r.length;\n        o += r;\n      }\n      if (t > n) {\n        o = o.slice(0, r);\n      }\n      return o;\n    }\n    function Et(e, t, n, r) {\n      for (let o = 0, i = r.length; o < i; o++) {\n        const i = P(n, \"i32\"),\n          s = kt(t, (n += tt));\n        n += nt;\n        r[o] = {\n          name: e.captureNames[i],\n          node: s,\n        };\n      }\n      return n;\n    }\n    function Ct(e) {\n      if (e !== et) throw new Error(\"Illegal constructor\");\n    }\n    function St(e) {\n      return e && \"number\" == typeof e.row && \"number\" == typeof e.column;\n    }\n    function Tt(e) {\n      let t = pt;\n      I(t, e.id, \"i32\");\n      I((t += tt), e.startIndex, \"i32\");\n      I((t += tt), e.startPosition.row, \"i32\");\n      I((t += tt), e.startPosition.column, \"i32\");\n      I((t += tt), e[0], \"i32\");\n    }\n    function kt(e, t = pt) {\n      const n = P(t, \"i32\");\n      if (0 === n) return null;\n      const r = P((t += tt), \"i32\"),\n        o = P((t += tt), \"i32\"),\n        i = P((t += tt), \"i32\"),\n        s = P((t += tt), \"i32\"),\n        a = new yt(et, e);\n      a.id = n;\n      a.startIndex = r;\n      a.startPosition = {\n        row: o,\n        column: i,\n      };\n      a[0] = s;\n      return a;\n    }\n    function It(e, t = pt) {\n      I(t + 0 * tt, e[0], \"i32\");\n      I(t + 1 * tt, e[1], \"i32\");\n      I(t + 2 * tt, e[2], \"i32\");\n    }\n    function Pt(e) {\n      e[0] = P(pt + 0 * tt, \"i32\");\n      e[1] = P(pt + 1 * tt, \"i32\");\n      e[2] = P(pt + 2 * tt, \"i32\");\n    }\n    function At(e, t) {\n      I(e, t.row, \"i32\");\n      I(e + tt, t.column, \"i32\");\n    }\n    function Ot(e) {\n      return {\n        row: P(e, \"i32\"),\n        column: P(e + tt, \"i32\"),\n      };\n    }\n    function Nt(e, t) {\n      At(e, t.startPosition);\n      At((e += rt), t.endPosition);\n      I((e += rt), t.startIndex, \"i32\");\n      I((e += tt), t.endIndex, \"i32\");\n      e += tt;\n    }\n    function Rt(e) {\n      const t = {};\n      t.startPosition = Ot(e);\n      e += rt;\n      t.endPosition = Ot(e);\n      e += rt;\n      t.startIndex = P(e, \"i32\");\n      e += tt;\n      t.endIndex = P(e, \"i32\");\n      return t;\n    }\n    gt.Language = bt;\n    gt.Parser = gt;\n    return gt;\n  }.apply(exports, []))\n) {\n  module.exports = r;\n}",
  "4106": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar azuresdk = require(8604);\nexports.azuresdk = azuresdk;\nvar bunyan = require(8859);\nexports.bunyan = bunyan;\nvar console = require(2495);\nexports.console = console;\nvar mongodbCore = require(2028);\nexports.mongodbCore = mongodbCore;\nvar mongodb = require(8436);\nexports.mongodb = mongodb;\nvar mysql = require(8002);\nexports.mysql = mysql;\nvar pgPool = require(9024);\nexports.pgPool = pgPool;\nvar pg = require(8060);\nexports.pg = pg;\nvar redis = require(4487);\nexports.redis = redis;\nvar tedious = require(6661);\nexports.tedious = tedious;\nvar winston = require(4650);\nexports.winston = winston;\nexports.enable = function () {\n  bunyan.enable();\n  console.enable();\n  mongodbCore.enable();\n  mongodb.enable();\n  mysql.enable();\n  pg.enable();\n  pgPool.enable();\n  redis.enable();\n  winston.enable();\n  azuresdk.enable();\n  tedious.enable();\n};",
  "4127": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r = require(4350),\n  o = require(5290);\nexports.performanceMetricsTelemetryProcessor = function (e, t) {\n  switch ((t && t.addDocument(e), e.data.baseType)) {\n    case o.TelemetryTypeString.Exception:\n      r.countException();\n      break;\n    case o.TelemetryTypeString.Request:\n      var n = e.data.baseData;\n      r.countRequest(n.duration, n.success);\n      break;\n    case o.TelemetryTypeString.Dependency:\n      var i = e.data.baseData;\n      r.countDependency(i.duration, i.success);\n  }\n  return !0;\n};",
  "4147": "module.exports = JSON.parse(\n  '{\"name\":\"copilot\",\"displayName\":\"GitHub Copilot\",\"description\":\"Your AI pair programmer\",\"version\":\"1.57.7193\",\"build\":\"7193\",\"buildType\":\"prod\",\"publisher\":\"GitHub\",\"preview\":false,\"homepage\":\"https://github.com/features/copilot\",\"bugs\":{\"url\":\"https://github.com/community/community/discussions/categories/copilot\"},\"qna\":\"https://github.com/github-community/community/discussions/categories/copilot\",\"icon\":\"assets/Copilot-App-Icon.png\",\"engines\":{\"vscode\":\"^1.68.0\",\"npm\":\">=7.0.0\"},\"categories\":[\"Other\"],\"badges\":[{\"url\":\"https://img.shields.io/badge/GitHub%20Copilot-Subscription%20Required-orange\",\"href\":\"https://github.com/github-copilot/signup\",\"description\":\"Sign up for GitHub Copilot\"}],\"activationEvents\":[\"onStartupFinished\"],\"main\":\"./dist/extension\",\"enabledApiProposals\":[\"inlineCompletionsAdditions\"],\"contributes\":{\"commands\":[{\"command\":\"github.copilot.generate\",\"title\":\"Open GitHub Copilot\"},{\"command\":\"github.copilot.toggleCopilot\",\"title\":\"GitHub Copilot: Configure Enabled/Disabled\"},{\"command\":\"github.copilot.sendFeedback\",\"title\":\"GitHub Copilot: Send Feedback\"}],\"keybindings\":[{\"command\":\"github.copilot.generate\",\"key\":\"ctrl+enter\",\"mac\":\"ctrl+enter\",\"when\":\"editorTextFocus && github.copilot.activated\"},{\"command\":\"editor.action.inlineSuggest.trigger\",\"key\":\"alt+\\\\\\\\\",\"when\":\"editorTextFocus && !editorHasSelection && config.github.copilot.inlineSuggest.enable && !inlineSuggestionsVisible\"}],\"menus\":{\"editor/inlineCompletions/actions\":[{\"command\":\"github.copilot.generate\",\"when\":\"github.copilot.activated\"}],\"commandPalette\":[{\"command\":\"github.copilot.generate\",\"when\":\"github.copilot.activated\"},{\"command\":\"github.copilot.toggleCopilot\",\"when\":\"github.copilot.activated\"},{\"command\":\"github.copilot.sendFeedback\",\"when\":\"github.copilot.activated\"}]},\"configuration\":[{\"title\":\"Copilot\",\"properties\":{\"github.copilot.advanced\":{\"type\":\"object\",\"title\":\"Advanced Settings\",\"properties\":{\"secret_key\":{\"type\":\"string\",\"default\":\"\",\"description\":\"Secret API key\"},\"length\":{\"type\":\"integer\",\"default\":500,\"description\":\"Length of code to generate in tokens\"},\"temperature\":{\"type\":\"string\",\"default\":\"\",\"description\":\"Override sampling temperature (range 0.0 - 1.0)\"},\"top_p\":{\"type\":\"number\",\"default\":1,\"description\":\"Top probability mass to consider\"},\"stops\":{\"type\":\"object\",\"default\":{\"*\":[\"\\\\n\\\\n\\\\n\"],\"python\":[\"\\\\ndef \",\"\\\\nclass \",\"\\\\nif \",\"\\\\n\\\\n#\"]},\"description\":\"Configure per-language stop sequences\"},\"indentationMode\":{\"type\":\"object\",\"default\":{\"python\":false,\"javascript\":false,\"javascriptreact\":false,\"jsx\":false,\"typescript\":false,\"typescriptreact\":false,\"go\":false,\"ruby\":false,\"*\":true},\"markdownDescription\":\"Enable or disable indentation block termination for specified [languages](https://code.visualstudio.com/docs/languages/identifiers). Set to \\'clientandserver\\' to run both parser-based and indent-based termination.\"},\"inlineSuggestCount\":{\"type\":\"integer\",\"default\":3,\"description\":\"Number of inline suggestions to fetch\"},\"listCount\":{\"type\":\"integer\",\"default\":10,\"description\":\"Number of solutions to list in Open GitHub Copilot\"},\"debug.showScores\":{\"type\":\"boolean\",\"default\":false,\"description\":\"Show scores in sorted solutions\"},\"debug.overrideEngine\":{\"type\":\"string\",\"default\":\"\",\"description\":\"Override engine name\"},\"debug.overrideProxyUrl\":{\"type\":\"string\",\"default\":\"\",\"description\":\"Override GitHub authentication proxy full URL\"},\"debug.testOverrideProxyUrl\":{\"type\":\"string\",\"default\":\"\",\"description\":\"Override GitHub authentication proxy URL when running tests\"},\"debug.filterLogCategories\":{\"type\":\"array\",\"default\":[],\"description\":\"Show only log categories listed in this setting. If an array is empty, show all loggers\"}}},\"github.copilot.enable\":{\"type\":\"object\",\"default\":{\"*\":true,\"yaml\":false,\"plaintext\":false,\"markdown\":false},\"markdownDescription\":\"Enable or disable Copilot for specified [languages](https://code.visualstudio.com/docs/languages/identifiers)\"},\"github.copilot.inlineSuggest.enable\":{\"type\":\"boolean\",\"default\":true,\"description\":\"Show inline suggestions\"}}}],\"icons\":{\"copilot-logo\":{\"description\":\"GitHub Copilot icon\",\"default\":{\"fontPath\":\"assets/copilot.woff\",\"fontCharacter\":\"\\\\\\\\0041\"}},\"copilot-warning\":{\"description\":\"GitHub Copilot icon\",\"default\":{\"fontPath\":\"assets/copilot.woff\",\"fontCharacter\":\"\\\\\\\\0042\"}},\"copilot-notconnected\":{\"description\":\"GitHub Copilot icon\",\"default\":{\"fontPath\":\"assets/copilot.woff\",\"fontCharacter\":\"\\\\\\\\0043\"}}},\"iconFonts\":[{\"id\":\"copilot-font\",\"src\":[{\"path\":\"assets/copilot.woff\",\"format\":\"woff\"}]}]},\"scripts\":{\"postinstall\":\"npx vscode-dts dev && mv vscode.proposed.*.ts extension/src\",\"vscode:prepublish\":\"npm-run-all build:extension\",\"build\":\"npm-run-all build:*\",\"build:agent\":\"cd agent && npm run build\",\"build:agent-no-pkg\":\"cd agent && npm run build-no-pkg\",\"build:extension\":\"webpack --mode production\",\"build:lib\":\"cd lib && npm run build\",\"compile\":\"npm-run-all compile:*\",\"compile:agent\":\"cd agent && npm run compile\",\"compile:extension\":\"webpack --mode development\",\"compile:lib\":\"cd lib && npm run compile\",\"watch\":\"npm-run-all -p watch:*\",\"watch:agent\":\"cd agent && npm run watch\",\"watch:extension\":\"webpack --mode development --watch\",\"watch:lib\":\"cd lib && npm run watch\",\"lint\":\"eslint lib extension agent --ext ts\",\"check_deps\":\"depcruise -c .dependency-cruiser.js .\",\"test\":\"npm-run-all test:*\",\"test:agent\":\"cd agent && npm run test\",\"test:extension\":\"cd extension && ts-node ./test/runTest.ts\",\"test:prompt\":\"cd prompt && npm install && npm run test\",\"test:lib\":\"cd lib && npm run test\",\"test:lsp-client\":\"cd lsp-client && npm run smokeTest\",\"build_test\":\"tsc extension/test/run.ts\",\"get_token\":\"ts-node script/getToken.ts\"},\"devDependencies\":{\"@github/prettier-config\":\"0.0.4\",\"@types/crypto-js\":\"^4.0.1\",\"@types/mocha\":\"^5.2.6\",\"@types/node\":\"^13.11.0\",\"@types/tunnel\":\"^0.0.3\",\"@types/uuid\":\"^8.3.1\",\"@types/vscode\":\"^1.68.0\",\"@typescript-eslint/eslint-plugin\":\"^4.27.0\",\"@typescript-eslint/parser\":\"^4.27.0\",\"dependency-cruiser\":\"^9.26.1\",\"eslint\":\"^7.29.0\",\"eslint-plugin-no-only-tests\":\"^2.6.0\",\"fantasticon\":\"^1.2.2\",\"get-port\":\"^5.1.1\",\"mocha\":\"^6.1.4\",\"npm-run-all\":\"^4.1.5\",\"prettier\":\"2.5.1\",\"prettier-plugin-organize-imports\":\"^2.3.4\",\"ts-dedent\":\"^2.2.0\",\"ts-loader\":\"^8.0.11\",\"ts-node\":\"^9.0.0\",\"typescript\":\"^4.4.3\",\"vsce\":\"1.91.0\",\"vscode-dts\":\"^0.3.2\",\"vscode-test\":\"^1.3.0\",\"webpack\":\"^5.54.0\",\"webpack-cli\":\"^4.2.0\",\"zlib\":\"^1.0.5\"},\"dependencies\":{\"@adobe/helix-fetch\":\"github:bmuskalla/helix-fetch#4e33e47bf6e64b637d5d713558fde504bf71c947\",\"@github/copilot-promptlib\":\"file:prompt\",\"@sinclair/typebox\":\"^0.23.4\",\"@types/git-url-parse\":\"^9.0.1\",\"ajv\":\"^8.6.3\",\"ajv-errors\":\"^3.0.0\",\"crypto-js\":\"^4.0.0\",\"git-url-parse\":\"^13.1.0\",\"open\":\"^8.4.0\",\"source-map-support\":\"^0.5.19\",\"tunnel\":\"^0.0.6\",\"uuid\":\"^8.3.2\",\"vscode-extension-telemetry\":\"^0.1.6\",\"vscode-uri\":\"^3.0.2\"}}'\n);",
  "4181": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.extendErrors =\n  exports.resetErrorsCount =\n  exports.reportExtraError =\n  exports.reportError =\n  exports.keyword$DataError =\n  exports.keywordError =\n    undefined;\nconst r = require(3487),\n  o = require(6776),\n  i = require(2141);\nfunction s(e, t) {\n  const n = e.const(\"err\", t);\n  e.if(\n    r._`${i.default.vErrors} === null`,\n    () => e.assign(i.default.vErrors, r._`[${n}]`),\n    r._`${i.default.vErrors}.push(${n})`\n  );\n  e.code(r._`${i.default.errors}++`);\n}\nfunction a(e, t) {\n  const { gen: n, validateName: o, schemaEnv: i } = e;\n  if (i.$async) {\n    n.throw(r._`new ${e.ValidationError}(${t})`);\n  } else {\n    n.assign(r._`${o}.errors`, t);\n    n.return(!1);\n  }\n}\nexports.keywordError = {\n  message: ({ keyword: e }) => r.str`must pass \"${e}\" keyword validation`,\n};\nexports.keyword$DataError = {\n  message: ({ keyword: e, schemaType: t }) =>\n    t\n      ? r.str`\"${e}\" keyword must be ${t} ($data)`\n      : r.str`\"${e}\" keyword is invalid ($data)`,\n};\nexports.reportError = function (e, n = exports.keywordError, o, i) {\n  const { it: c } = e,\n    { gen: u, compositeRule: d, allErrors: p } = c,\n    h = l(e, n, o);\n  if (null != i ? i : d || p) {\n    s(u, h);\n  } else {\n    a(c, r._`[${h}]`);\n  }\n};\nexports.reportExtraError = function (e, n = exports.keywordError, r) {\n  const { it: o } = e,\n    { gen: c, compositeRule: u, allErrors: d } = o;\n  s(c, l(e, n, r));\n  if (u || d) {\n    a(o, i.default.vErrors);\n  }\n};\nexports.resetErrorsCount = function (e, t) {\n  e.assign(i.default.errors, t);\n  e.if(r._`${i.default.vErrors} !== null`, () =>\n    e.if(\n      t,\n      () => e.assign(r._`${i.default.vErrors}.length`, t),\n      () => e.assign(i.default.vErrors, null)\n    )\n  );\n};\nexports.extendErrors = function ({\n  gen: e,\n  keyword: t,\n  schemaValue: n,\n  data: o,\n  errsCount: s,\n  it: a,\n}) {\n  if (undefined === s) throw new Error(\"ajv implementation error\");\n  const c = e.name(\"err\");\n  e.forRange(\"i\", s, i.default.errors, (s) => {\n    e.const(c, r._`${i.default.vErrors}[${s}]`);\n    e.if(r._`${c}.instancePath === undefined`, () =>\n      e.assign(\n        r._`${c}.instancePath`,\n        r.strConcat(i.default.instancePath, a.errorPath)\n      )\n    );\n    e.assign(r._`${c}.schemaPath`, r.str`${a.errSchemaPath}/${t}`);\n    if (a.opts.verbose) {\n      e.assign(r._`${c}.schema`, n);\n      e.assign(r._`${c}.data`, o);\n    }\n  });\n};\nconst c = {\n  keyword: new r.Name(\"keyword\"),\n  schemaPath: new r.Name(\"schemaPath\"),\n  params: new r.Name(\"params\"),\n  propertyName: new r.Name(\"propertyName\"),\n  message: new r.Name(\"message\"),\n  schema: new r.Name(\"schema\"),\n  parentSchema: new r.Name(\"parentSchema\"),\n};\nfunction l(e, t, n) {\n  const { createErrors: o } = e.it;\n  return !1 === o\n    ? r._`{}`\n    : (function (e, t, n = {}) {\n        const { gen: o, it: s } = e,\n          a = [u(s, n), d(e, n)];\n        (function (e, { params: t, message: n }, o) {\n          const { keyword: s, data: a, schemaValue: l, it: u } = e,\n            { opts: d, propertyName: p, topSchemaRef: h, schemaPath: f } = u;\n          o.push(\n            [c.keyword, s],\n            [c.params, \"function\" == typeof t ? t(e) : t || r._`{}`]\n          );\n          if (d.messages) {\n            o.push([c.message, \"function\" == typeof n ? n(e) : n]);\n          }\n          if (d.verbose) {\n            o.push(\n              [c.schema, l],\n              [c.parentSchema, r._`${h}${f}`],\n              [i.default.data, a]\n            );\n          }\n          if (p) {\n            o.push([c.propertyName, p]);\n          }\n        })(e, t, a);\n        return o.object(...a);\n      })(e, t, n);\n}\nfunction u({ errorPath: e }, { instancePath: t }) {\n  const n = t ? r.str`${e}${o.getErrorPath(t, o.Type.Str)}` : e;\n  return [i.default.instancePath, r.strConcat(i.default.instancePath, n)];\n}\nfunction d(\n  { keyword: e, it: { errSchemaPath: t } },\n  { schemaPath: n, parentSchema: i }\n) {\n  let s = i ? t : r.str`${t}/${e}`;\n  if (n) {\n    s = r.str`${s}${o.getErrorPath(n, o.Type.Str)}`;\n  }\n  return [c.schemaPath, s];\n}",
  "4193": "const r = require(6214),\n  { Headers: o } = require(9872),\n  i = (e) => ({\n    url: e.url,\n    method: e.method,\n    headers: e.headers.plain(),\n  }),\n  s = (e) => ({\n    status: e.status,\n    headers: e.headers.plain(),\n  });\nmodule.exports = class {\n  constructor(e, t, n) {\n    this.policy = new r(i(e), s(t), n);\n  }\n  storable() {\n    return this.policy.storable();\n  }\n  satisfiesWithoutRevalidation(e) {\n    return this.policy.satisfiesWithoutRevalidation(i(e));\n  }\n  responseHeaders(e) {\n    return new o(this.policy.responseHeaders(s(e)));\n  }\n  timeToLive() {\n    return this.policy.timeToLive();\n  }\n};",
  "4197": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.CopilotScheme = exports.CopilotConfigPrefix = undefined;\nexports.CopilotConfigPrefix = \"github.copilot\";\nexports.CopilotScheme = \"copilot\";",
  "4200": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = require(6776),\n  i = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: !0,\n    error: {\n      message: \"must match exactly one schema in oneOf\",\n      params: ({ params: e }) => r._`{passingSchemas: ${e.passing}}`,\n    },\n    code(e) {\n      const { gen: t, schema: n, parentSchema: i, it: s } = e;\n      if (!Array.isArray(n)) throw new Error(\"ajv implementation error\");\n      if (s.opts.discriminator && i.discriminator) return;\n      const a = n,\n        c = t.let(\"valid\", !1),\n        l = t.let(\"passing\", null),\n        u = t.name(\"_valid\");\n      e.setParams({\n        passing: l,\n      });\n      t.block(function () {\n        a.forEach((n, i) => {\n          let a;\n          if (o.alwaysValidSchema(s, n)) {\n            t.var(u, !0);\n          } else {\n            a = e.subschema(\n              {\n                keyword: \"oneOf\",\n                schemaProp: i,\n                compositeRule: !0,\n              },\n              u\n            );\n          }\n          if (i > 0) {\n            t.if(r._`${u} && ${c}`)\n              .assign(c, !1)\n              .assign(l, r._`[${l}, ${i}]`)\n              .else();\n          }\n          t.if(u, () => {\n            t.assign(c, !0);\n            t.assign(l, i);\n            if (a) {\n              e.mergeEvaluated(a, r.Name);\n            }\n          });\n        });\n      });\n      e.result(\n        c,\n        () => e.reset(),\n        () => e.error(!0)\n      );\n    },\n  };\nexports.default = i;",
  "4242": "var r, o, i;\ni = require(8249);\nrequire(5109);\no = (r = i.lib.BlockCipherMode.extend()).Encryptor = r.extend({\n  processBlock: function (e, t) {\n    var n = this._cipher,\n      r = n.blockSize,\n      o = this._iv,\n      i = this._counter;\n    if (o) {\n      i = this._counter = o.slice(0);\n      this._iv = undefined;\n    }\n    var s = i.slice(0);\n    n.encryptBlock(s, 0);\n    i[r - 1] = (i[r - 1] + 1) | 0;\n    for (var a = 0; a < r; a++) e[t + a] ^= s[a];\n  },\n});\nr.Decryptor = o;\ni.mode.CTR = r;\nmodule.exports = i.mode.CTR;",
  "4253": "var r;\nr = require(8249);\nrequire(8269);\nrequire(8214);\nrequire(888);\nrequire(5109);\n(function () {\n  var e = r,\n    t = e.lib,\n    n = t.WordArray,\n    o = t.BlockCipher,\n    i = e.algo,\n    s = [\n      57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43,\n      35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54,\n      46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4,\n    ],\n    a = [\n      14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7,\n      27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39,\n      56, 34, 53, 46, 42, 50, 36, 29, 32,\n    ],\n    c = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],\n    l = [\n      {\n        0: 8421888,\n        268435456: 32768,\n        536870912: 8421378,\n        805306368: 2,\n        1073741824: 512,\n        1342177280: 8421890,\n        1610612736: 8389122,\n        1879048192: 8388608,\n        2147483648: 514,\n        2415919104: 8389120,\n        2684354560: 33280,\n        2952790016: 8421376,\n        3221225472: 32770,\n        3489660928: 8388610,\n        3758096384: 0,\n        4026531840: 33282,\n        134217728: 0,\n        402653184: 8421890,\n        671088640: 33282,\n        939524096: 32768,\n        1207959552: 8421888,\n        1476395008: 512,\n        1744830464: 8421378,\n        2013265920: 2,\n        2281701376: 8389120,\n        2550136832: 33280,\n        2818572288: 8421376,\n        3087007744: 8389122,\n        3355443200: 8388610,\n        3623878656: 32770,\n        3892314112: 514,\n        4160749568: 8388608,\n        1: 32768,\n        268435457: 2,\n        536870913: 8421888,\n        805306369: 8388608,\n        1073741825: 8421378,\n        1342177281: 33280,\n        1610612737: 512,\n        1879048193: 8389122,\n        2147483649: 8421890,\n        2415919105: 8421376,\n        2684354561: 8388610,\n        2952790017: 33282,\n        3221225473: 514,\n        3489660929: 8389120,\n        3758096385: 32770,\n        4026531841: 0,\n        134217729: 8421890,\n        402653185: 8421376,\n        671088641: 8388608,\n        939524097: 512,\n        1207959553: 32768,\n        1476395009: 8388610,\n        1744830465: 2,\n        2013265921: 33282,\n        2281701377: 32770,\n        2550136833: 8389122,\n        2818572289: 514,\n        3087007745: 8421888,\n        3355443201: 8389120,\n        3623878657: 0,\n        3892314113: 33280,\n        4160749569: 8421378,\n      },\n      {\n        0: 1074282512,\n        16777216: 16384,\n        33554432: 524288,\n        50331648: 1074266128,\n        67108864: 1073741840,\n        83886080: 1074282496,\n        100663296: 1073758208,\n        117440512: 16,\n        134217728: 540672,\n        150994944: 1073758224,\n        167772160: 1073741824,\n        184549376: 540688,\n        201326592: 524304,\n        218103808: 0,\n        234881024: 16400,\n        251658240: 1074266112,\n        8388608: 1073758208,\n        25165824: 540688,\n        41943040: 16,\n        58720256: 1073758224,\n        75497472: 1074282512,\n        92274688: 1073741824,\n        109051904: 524288,\n        125829120: 1074266128,\n        142606336: 524304,\n        159383552: 0,\n        176160768: 16384,\n        192937984: 1074266112,\n        209715200: 1073741840,\n        226492416: 540672,\n        243269632: 1074282496,\n        260046848: 16400,\n        268435456: 0,\n        285212672: 1074266128,\n        301989888: 1073758224,\n        318767104: 1074282496,\n        335544320: 1074266112,\n        352321536: 16,\n        369098752: 540688,\n        385875968: 16384,\n        402653184: 16400,\n        419430400: 524288,\n        436207616: 524304,\n        452984832: 1073741840,\n        469762048: 540672,\n        486539264: 1073758208,\n        503316480: 1073741824,\n        520093696: 1074282512,\n        276824064: 540688,\n        293601280: 524288,\n        310378496: 1074266112,\n        327155712: 16384,\n        343932928: 1073758208,\n        360710144: 1074282512,\n        377487360: 16,\n        394264576: 1073741824,\n        411041792: 1074282496,\n        427819008: 1073741840,\n        444596224: 1073758224,\n        461373440: 524304,\n        478150656: 0,\n        494927872: 16400,\n        511705088: 1074266128,\n        528482304: 540672,\n      },\n      {\n        0: 260,\n        1048576: 0,\n        2097152: 67109120,\n        3145728: 65796,\n        4194304: 65540,\n        5242880: 67108868,\n        6291456: 67174660,\n        7340032: 67174400,\n        8388608: 67108864,\n        9437184: 67174656,\n        10485760: 65792,\n        11534336: 67174404,\n        12582912: 67109124,\n        13631488: 65536,\n        14680064: 4,\n        15728640: 256,\n        524288: 67174656,\n        1572864: 67174404,\n        2621440: 0,\n        3670016: 67109120,\n        4718592: 67108868,\n        5767168: 65536,\n        6815744: 65540,\n        7864320: 260,\n        8912896: 4,\n        9961472: 256,\n        11010048: 67174400,\n        12058624: 65796,\n        13107200: 65792,\n        14155776: 67109124,\n        15204352: 67174660,\n        16252928: 67108864,\n        16777216: 67174656,\n        17825792: 65540,\n        18874368: 65536,\n        19922944: 67109120,\n        20971520: 256,\n        22020096: 67174660,\n        23068672: 67108868,\n        24117248: 0,\n        25165824: 67109124,\n        26214400: 67108864,\n        27262976: 4,\n        28311552: 65792,\n        29360128: 67174400,\n        30408704: 260,\n        31457280: 65796,\n        32505856: 67174404,\n        17301504: 67108864,\n        18350080: 260,\n        19398656: 67174656,\n        20447232: 0,\n        21495808: 65540,\n        22544384: 67109120,\n        23592960: 256,\n        24641536: 67174404,\n        25690112: 65536,\n        26738688: 67174660,\n        27787264: 65796,\n        28835840: 67108868,\n        29884416: 67109124,\n        30932992: 67174400,\n        31981568: 4,\n        33030144: 65792,\n      },\n      {\n        0: 2151682048,\n        65536: 2147487808,\n        131072: 4198464,\n        196608: 2151677952,\n        262144: 0,\n        327680: 4198400,\n        393216: 2147483712,\n        458752: 4194368,\n        524288: 2147483648,\n        589824: 4194304,\n        655360: 64,\n        720896: 2147487744,\n        786432: 2151678016,\n        851968: 4160,\n        917504: 4096,\n        983040: 2151682112,\n        32768: 2147487808,\n        98304: 64,\n        163840: 2151678016,\n        229376: 2147487744,\n        294912: 4198400,\n        360448: 2151682112,\n        425984: 0,\n        491520: 2151677952,\n        557056: 4096,\n        622592: 2151682048,\n        688128: 4194304,\n        753664: 4160,\n        819200: 2147483648,\n        884736: 4194368,\n        950272: 4198464,\n        1015808: 2147483712,\n        1048576: 4194368,\n        1114112: 4198400,\n        1179648: 2147483712,\n        1245184: 0,\n        1310720: 4160,\n        1376256: 2151678016,\n        1441792: 2151682048,\n        1507328: 2147487808,\n        1572864: 2151682112,\n        1638400: 2147483648,\n        1703936: 2151677952,\n        1769472: 4198464,\n        1835008: 2147487744,\n        1900544: 4194304,\n        1966080: 64,\n        2031616: 4096,\n        1081344: 2151677952,\n        1146880: 2151682112,\n        1212416: 0,\n        1277952: 4198400,\n        1343488: 4194368,\n        1409024: 2147483648,\n        1474560: 2147487808,\n        1540096: 64,\n        1605632: 2147483712,\n        1671168: 4096,\n        1736704: 2147487744,\n        1802240: 2151678016,\n        1867776: 4160,\n        1933312: 2151682048,\n        1998848: 4194304,\n        2064384: 4198464,\n      },\n      {\n        0: 128,\n        4096: 17039360,\n        8192: 262144,\n        12288: 536870912,\n        16384: 537133184,\n        20480: 16777344,\n        24576: 553648256,\n        28672: 262272,\n        32768: 16777216,\n        36864: 537133056,\n        40960: 536871040,\n        45056: 553910400,\n        49152: 553910272,\n        53248: 0,\n        57344: 17039488,\n        61440: 553648128,\n        2048: 17039488,\n        6144: 553648256,\n        10240: 128,\n        14336: 17039360,\n        18432: 262144,\n        22528: 537133184,\n        26624: 553910272,\n        30720: 536870912,\n        34816: 537133056,\n        38912: 0,\n        43008: 553910400,\n        47104: 16777344,\n        51200: 536871040,\n        55296: 553648128,\n        59392: 16777216,\n        63488: 262272,\n        65536: 262144,\n        69632: 128,\n        73728: 536870912,\n        77824: 553648256,\n        81920: 16777344,\n        86016: 553910272,\n        90112: 537133184,\n        94208: 16777216,\n        98304: 553910400,\n        102400: 553648128,\n        106496: 17039360,\n        110592: 537133056,\n        114688: 262272,\n        118784: 536871040,\n        122880: 0,\n        126976: 17039488,\n        67584: 553648256,\n        71680: 16777216,\n        75776: 17039360,\n        79872: 537133184,\n        83968: 536870912,\n        88064: 17039488,\n        92160: 128,\n        96256: 553910272,\n        100352: 262272,\n        104448: 553910400,\n        108544: 0,\n        112640: 553648128,\n        116736: 16777344,\n        120832: 262144,\n        124928: 537133056,\n        129024: 536871040,\n      },\n      {\n        0: 268435464,\n        256: 8192,\n        512: 270532608,\n        768: 270540808,\n        1024: 268443648,\n        1280: 2097152,\n        1536: 2097160,\n        1792: 268435456,\n        2048: 0,\n        2304: 268443656,\n        2560: 2105344,\n        2816: 8,\n        3072: 270532616,\n        3328: 2105352,\n        3584: 8200,\n        3840: 270540800,\n        128: 270532608,\n        384: 270540808,\n        640: 8,\n        896: 2097152,\n        1152: 2105352,\n        1408: 268435464,\n        1664: 268443648,\n        1920: 8200,\n        2176: 2097160,\n        2432: 8192,\n        2688: 268443656,\n        2944: 270532616,\n        3200: 0,\n        3456: 270540800,\n        3712: 2105344,\n        3968: 268435456,\n        4096: 268443648,\n        4352: 270532616,\n        4608: 270540808,\n        4864: 8200,\n        5120: 2097152,\n        5376: 268435456,\n        5632: 268435464,\n        5888: 2105344,\n        6144: 2105352,\n        6400: 0,\n        6656: 8,\n        6912: 270532608,\n        7168: 8192,\n        7424: 268443656,\n        7680: 270540800,\n        7936: 2097160,\n        4224: 8,\n        4480: 2105344,\n        4736: 2097152,\n        4992: 268435464,\n        5248: 268443648,\n        5504: 8200,\n        5760: 270540808,\n        6016: 270532608,\n        6272: 270540800,\n        6528: 270532616,\n        6784: 8192,\n        7040: 2105352,\n        7296: 2097160,\n        7552: 0,\n        7808: 268435456,\n        8064: 268443656,\n      },\n      {\n        0: 1048576,\n        16: 33555457,\n        32: 1024,\n        48: 1049601,\n        64: 34604033,\n        80: 0,\n        96: 1,\n        112: 34603009,\n        128: 33555456,\n        144: 1048577,\n        160: 33554433,\n        176: 34604032,\n        192: 34603008,\n        208: 1025,\n        224: 1049600,\n        240: 33554432,\n        8: 34603009,\n        24: 0,\n        40: 33555457,\n        56: 34604032,\n        72: 1048576,\n        88: 33554433,\n        104: 33554432,\n        120: 1025,\n        136: 1049601,\n        152: 33555456,\n        168: 34603008,\n        184: 1048577,\n        200: 1024,\n        216: 34604033,\n        232: 1,\n        248: 1049600,\n        256: 33554432,\n        272: 1048576,\n        288: 33555457,\n        304: 34603009,\n        320: 1048577,\n        336: 33555456,\n        352: 34604032,\n        368: 1049601,\n        384: 1025,\n        400: 34604033,\n        416: 1049600,\n        432: 1,\n        448: 0,\n        464: 34603008,\n        480: 33554433,\n        496: 1024,\n        264: 1049600,\n        280: 33555457,\n        296: 34603009,\n        312: 1,\n        328: 33554432,\n        344: 1048576,\n        360: 1025,\n        376: 34604032,\n        392: 33554433,\n        408: 34603008,\n        424: 0,\n        440: 34604033,\n        456: 1049601,\n        472: 1024,\n        488: 33555456,\n        504: 1048577,\n      },\n      {\n        0: 134219808,\n        1: 131072,\n        2: 134217728,\n        3: 32,\n        4: 131104,\n        5: 134350880,\n        6: 134350848,\n        7: 2048,\n        8: 134348800,\n        9: 134219776,\n        10: 133120,\n        11: 134348832,\n        12: 2080,\n        13: 0,\n        14: 134217760,\n        15: 133152,\n        2147483648: 2048,\n        2147483649: 134350880,\n        2147483650: 134219808,\n        2147483651: 134217728,\n        2147483652: 134348800,\n        2147483653: 133120,\n        2147483654: 133152,\n        2147483655: 32,\n        2147483656: 134217760,\n        2147483657: 2080,\n        2147483658: 131104,\n        2147483659: 134350848,\n        2147483660: 0,\n        2147483661: 134348832,\n        2147483662: 134219776,\n        2147483663: 131072,\n        16: 133152,\n        17: 134350848,\n        18: 32,\n        19: 2048,\n        20: 134219776,\n        21: 134217760,\n        22: 134348832,\n        23: 131072,\n        24: 0,\n        25: 131104,\n        26: 134348800,\n        27: 134219808,\n        28: 134350880,\n        29: 133120,\n        30: 2080,\n        31: 134217728,\n        2147483664: 131072,\n        2147483665: 2048,\n        2147483666: 134348832,\n        2147483667: 133152,\n        2147483668: 32,\n        2147483669: 134348800,\n        2147483670: 134217728,\n        2147483671: 134219808,\n        2147483672: 134350880,\n        2147483673: 134217760,\n        2147483674: 134219776,\n        2147483675: 0,\n        2147483676: 133120,\n        2147483677: 2080,\n        2147483678: 131104,\n        2147483679: 134350848,\n      },\n    ],\n    u = [\n      4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679,\n    ],\n    d = (i.DES = o.extend({\n      _doReset: function () {\n        for (var e = this._key.words, t = [], n = 0; n < 56; n++) {\n          var r = s[n] - 1;\n          t[n] = (e[r >>> 5] >>> (31 - (r % 32))) & 1;\n        }\n        for (var o = (this._subKeys = []), i = 0; i < 16; i++) {\n          var l = (o[i] = []),\n            u = c[i];\n          for (n = 0; n < 24; n++) {\n            l[(n / 6) | 0] |= t[(a[n] - 1 + u) % 28] << (31 - (n % 6));\n            l[4 + ((n / 6) | 0)] |=\n              t[28 + ((a[n + 24] - 1 + u) % 28)] << (31 - (n % 6));\n          }\n          for (l[0] = (l[0] << 1) | (l[0] >>> 31), n = 1; n < 7; n++)\n            l[n] = l[n] >>> (4 * (n - 1) + 3);\n          l[7] = (l[7] << 5) | (l[7] >>> 27);\n        }\n        var d = (this._invSubKeys = []);\n        for (n = 0; n < 16; n++) d[n] = o[15 - n];\n      },\n      encryptBlock: function (e, t) {\n        this._doCryptBlock(e, t, this._subKeys);\n      },\n      decryptBlock: function (e, t) {\n        this._doCryptBlock(e, t, this._invSubKeys);\n      },\n      _doCryptBlock: function (e, t, n) {\n        this._lBlock = e[t];\n        this._rBlock = e[t + 1];\n        p.call(this, 4, 252645135);\n        p.call(this, 16, 65535);\n        h.call(this, 2, 858993459);\n        h.call(this, 8, 16711935);\n        p.call(this, 1, 1431655765);\n        for (var r = 0; r < 16; r++) {\n          for (\n            var o = n[r], i = this._lBlock, s = this._rBlock, a = 0, c = 0;\n            c < 8;\n            c++\n          )\n            a |= l[c][((s ^ o[c]) & u[c]) >>> 0];\n          this._lBlock = s;\n          this._rBlock = i ^ a;\n        }\n        var d = this._lBlock;\n        this._lBlock = this._rBlock;\n        this._rBlock = d;\n        p.call(this, 1, 1431655765);\n        h.call(this, 8, 16711935);\n        h.call(this, 2, 858993459);\n        p.call(this, 16, 65535);\n        p.call(this, 4, 252645135);\n        e[t] = this._lBlock;\n        e[t + 1] = this._rBlock;\n      },\n      keySize: 2,\n      ivSize: 2,\n      blockSize: 2,\n    }));\n  function p(e, t) {\n    var n = ((this._lBlock >>> e) ^ this._rBlock) & t;\n    this._rBlock ^= n;\n    this._lBlock ^= n << e;\n  }\n  function h(e, t) {\n    var n = ((this._rBlock >>> e) ^ this._lBlock) & t;\n    this._lBlock ^= n;\n    this._rBlock ^= n << e;\n  }\n  e.DES = o._createHelper(d);\n  var f = (i.TripleDES = o.extend({\n    _doReset: function () {\n      var e = this._key.words;\n      if (2 !== e.length && 4 !== e.length && e.length < 6)\n        throw new Error(\n          \"Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.\"\n        );\n      var t = e.slice(0, 2),\n        r = e.length < 4 ? e.slice(0, 2) : e.slice(2, 4),\n        o = e.length < 6 ? e.slice(0, 2) : e.slice(4, 6);\n      this._des1 = d.createEncryptor(n.create(t));\n      this._des2 = d.createEncryptor(n.create(r));\n      this._des3 = d.createEncryptor(n.create(o));\n    },\n    encryptBlock: function (e, t) {\n      this._des1.encryptBlock(e, t);\n      this._des2.decryptBlock(e, t);\n      this._des3.encryptBlock(e, t);\n    },\n    decryptBlock: function (e, t) {\n      this._des3.decryptBlock(e, t);\n      this._des2.encryptBlock(e, t);\n      this._des1.decryptBlock(e, t);\n    },\n    keySize: 6,\n    ivSize: 2,\n    blockSize: 2,\n  }));\n  e.TripleDES = o._createHelper(f);\n})();\nmodule.exports = r.TripleDES;",
  "4309": "var r = require(5290),\n  o = require(4953),\n  i = [],\n  s = function (e) {\n    var t = e.data.message;\n    i.forEach(function (n) {\n      if (t instanceof Error) {\n        n.trackException({\n          exception: t,\n        });\n      } else {\n        if (t.lastIndexOf(\"\\n\") == t.length - 1) {\n          t = t.substring(0, t.length - 1);\n        }\n        n.trackTrace({\n          message: t,\n          severity: e.data.stderr\n            ? r.SeverityLevel.Warning\n            : r.SeverityLevel.Information,\n        });\n      }\n    });\n  };\nexports.wp = function (e, t) {\n  if (e) {\n    if (0 === i.length) {\n      o.channel.subscribe(\"console\", s);\n    }\n    i.push(t);\n  } else {\n    if (\n      0 ===\n      (i = i.filter(function (e) {\n        return e != t;\n      })).length\n    ) {\n      o.channel.unsubscribe(\"console\", s);\n    }\n  }\n};",
  "4336": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(412),\n  o = require(3487),\n  i = {\n    keyword: \"pattern\",\n    type: \"string\",\n    schemaType: \"string\",\n    $data: !0,\n    error: {\n      message: ({ schemaCode: e }) => o.str`must match pattern \"${e}\"`,\n      params: ({ schemaCode: e }) => o._`{pattern: ${e}}`,\n    },\n    code(e) {\n      const { data: t, $data: n, schema: i, schemaCode: s, it: a } = e,\n        c = a.opts.unicodeRegExp ? \"u\" : \"\",\n        l = n ? o._`(new RegExp(${s}, ${c}))` : r.usePattern(e, i);\n      e.fail$data(o._`!${l}.test(${t})`);\n    },\n  };\nexports.default = i;",
  "4350": "var r = require(\"os\"),\n  o = require(3580),\n  i = (function () {\n    function e(t, n, r) {\n      if (undefined === n) {\n        n = 6e4;\n      }\n      if (undefined === r) {\n        r = !1;\n      }\n      this._lastIntervalRequestExecutionTime = 0;\n      this._lastIntervalDependencyExecutionTime = 0;\n      if (e.INSTANCE) {\n        e.INSTANCE = this;\n      }\n      this._isInitialized = !1;\n      this._client = t;\n      this._collectionInterval = n;\n      this._enableLiveMetricsCounters = r;\n    }\n    e.prototype.enable = function (t, n) {\n      var o = this;\n      this._isEnabled = t;\n      if (this._isEnabled && !this._isInitialized) {\n        this._isInitialized = !0;\n      }\n      if (t) {\n        if (this._handle) {\n          this._lastCpus = r.cpus();\n          this._lastRequests = {\n            totalRequestCount: e._totalRequestCount,\n            totalFailedRequestCount: e._totalFailedRequestCount,\n            time: +new Date(),\n          };\n          this._lastDependencies = {\n            totalDependencyCount: e._totalDependencyCount,\n            totalFailedDependencyCount: e._totalFailedDependencyCount,\n            time: +new Date(),\n          };\n          this._lastExceptions = {\n            totalExceptionCount: e._totalExceptionCount,\n            time: +new Date(),\n          };\n          if (\"function\" == typeof process.cpuUsage) {\n            this._lastAppCpuUsage = process.cpuUsage();\n          }\n          this._lastHrtime = process.hrtime();\n          this._collectionInterval = n || this._collectionInterval;\n          this._handle = setInterval(function () {\n            return o.trackPerformance();\n          }, this._collectionInterval);\n          this._handle.unref();\n        }\n      } else {\n        if (this._handle) {\n          clearInterval(this._handle);\n          this._handle = undefined;\n        }\n      }\n    };\n    e.countRequest = function (t, n) {\n      var r;\n      if (e.isEnabled()) {\n        if (\"string\" == typeof t) r = +new Date(\"1970-01-01T\" + t + \"Z\");\n        else {\n          if (\"number\" != typeof t) return;\n          r = t;\n        }\n        e._intervalRequestExecutionTime += r;\n        if (!1 === n) {\n          e._totalFailedRequestCount++;\n        }\n        e._totalRequestCount++;\n      }\n    };\n    e.countException = function () {\n      e._totalExceptionCount++;\n    };\n    e.countDependency = function (t, n) {\n      var r;\n      if (e.isEnabled()) {\n        if (\"string\" == typeof t) r = +new Date(\"1970-01-01T\" + t + \"Z\");\n        else {\n          if (\"number\" != typeof t) return;\n          r = t;\n        }\n        e._intervalDependencyExecutionTime += r;\n        if (!1 === n) {\n          e._totalFailedDependencyCount++;\n        }\n        e._totalDependencyCount++;\n      }\n    };\n    e.prototype.isInitialized = function () {\n      return this._isInitialized;\n    };\n    e.isEnabled = function () {\n      return e.INSTANCE && e.INSTANCE._isEnabled;\n    };\n    e.prototype.trackPerformance = function () {\n      this._trackCpu();\n      this._trackMemory();\n      this._trackNetwork();\n      this._trackDependencyRate();\n      this._trackExceptionRate();\n    };\n    e.prototype._trackCpu = function () {\n      var e = r.cpus();\n      if (\n        e &&\n        e.length &&\n        this._lastCpus &&\n        e.length === this._lastCpus.length\n      ) {\n        for (\n          var t = 0, n = 0, i = 0, s = 0, a = 0, c = 0;\n          e && c < e.length;\n          c++\n        ) {\n          var l = e[c],\n            u = this._lastCpus[c],\n            d = (l.model, l.speed, l.times),\n            p = u.times;\n          t += d.user - p.user || 0;\n          n += d.sys - p.sys || 0;\n          i += d.nice - p.nice || 0;\n          s += d.idle - p.idle || 0;\n          a += d.irq - p.irq || 0;\n        }\n        var h = undefined;\n        if (\"function\" == typeof process.cpuUsage) {\n          var f = process.cpuUsage(),\n            m = process.hrtime(),\n            g =\n              f.user -\n                this._lastAppCpuUsage.user +\n                (f.system - this._lastAppCpuUsage.system) || 0;\n          if (undefined !== this._lastHrtime && 2 === this._lastHrtime.length) {\n            h =\n              (100 * g) /\n              ((1e6 * (m[0] - this._lastHrtime[0]) +\n                (m[1] - this._lastHrtime[1]) / 1e3 || 0) *\n                e.length);\n          }\n          this._lastAppCpuUsage = f;\n          this._lastHrtime = m;\n        }\n        var _ = t + n + i + s + a || 1;\n        this._client.trackMetric({\n          name: o.PerformanceCounter.PROCESSOR_TIME,\n          value: ((_ - s) / _) * 100,\n        });\n        this._client.trackMetric({\n          name: o.PerformanceCounter.PROCESS_TIME,\n          value: h || (t / _) * 100,\n        });\n      }\n      this._lastCpus = e;\n    };\n    e.prototype._trackMemory = function () {\n      var e = r.freemem(),\n        t = process.memoryUsage().rss,\n        n = r.totalmem() - e;\n      this._client.trackMetric({\n        name: o.PerformanceCounter.PRIVATE_BYTES,\n        value: t,\n      });\n      this._client.trackMetric({\n        name: o.PerformanceCounter.AVAILABLE_BYTES,\n        value: e,\n      });\n      if (this._enableLiveMetricsCounters) {\n        this._client.trackMetric({\n          name: o.QuickPulseCounter.COMMITTED_BYTES,\n          value: n,\n        });\n      }\n    };\n    e.prototype._trackNetwork = function () {\n      var t = this._lastRequests,\n        n = {\n          totalRequestCount: e._totalRequestCount,\n          totalFailedRequestCount: e._totalFailedRequestCount,\n          time: +new Date(),\n        },\n        r = n.totalRequestCount - t.totalRequestCount || 0,\n        i = n.totalFailedRequestCount - t.totalFailedRequestCount || 0,\n        s = n.time - t.time,\n        a = s / 1e3,\n        c =\n          (e._intervalRequestExecutionTime -\n            this._lastIntervalRequestExecutionTime) /\n            r || 0;\n      this._lastIntervalRequestExecutionTime = e._intervalRequestExecutionTime;\n      if (s > 0) {\n        var l = r / a,\n          u = i / a;\n        this._client.trackMetric({\n          name: o.PerformanceCounter.REQUEST_RATE,\n          value: l,\n        }),\n          (!this._enableLiveMetricsCounters || r > 0) &&\n            this._client.trackMetric({\n              name: o.PerformanceCounter.REQUEST_DURATION,\n              value: c,\n            }),\n          this._enableLiveMetricsCounters &&\n            this._client.trackMetric({\n              name: o.QuickPulseCounter.REQUEST_FAILURE_RATE,\n              value: u,\n            });\n      }\n      this._lastRequests = n;\n    };\n    e.prototype._trackDependencyRate = function () {\n      if (this._enableLiveMetricsCounters) {\n        var t = this._lastDependencies,\n          n = {\n            totalDependencyCount: e._totalDependencyCount,\n            totalFailedDependencyCount: e._totalFailedDependencyCount,\n            time: +new Date(),\n          },\n          r = n.totalDependencyCount - t.totalDependencyCount || 0,\n          i = n.totalFailedDependencyCount - t.totalFailedDependencyCount || 0,\n          s = n.time - t.time,\n          a = s / 1e3,\n          c =\n            (e._intervalDependencyExecutionTime -\n              this._lastIntervalDependencyExecutionTime) /\n              r || 0;\n        this._lastIntervalDependencyExecutionTime =\n          e._intervalDependencyExecutionTime;\n        if (s > 0) {\n          var l = r / a,\n            u = i / a;\n          this._client.trackMetric({\n            name: o.QuickPulseCounter.DEPENDENCY_RATE,\n            value: l,\n          }),\n            this._client.trackMetric({\n              name: o.QuickPulseCounter.DEPENDENCY_FAILURE_RATE,\n              value: u,\n            }),\n            (!this._enableLiveMetricsCounters || r > 0) &&\n              this._client.trackMetric({\n                name: o.QuickPulseCounter.DEPENDENCY_DURATION,\n                value: c,\n              });\n        }\n        this._lastDependencies = n;\n      }\n    };\n    e.prototype._trackExceptionRate = function () {\n      if (this._enableLiveMetricsCounters) {\n        var t = this._lastExceptions,\n          n = {\n            totalExceptionCount: e._totalExceptionCount,\n            time: +new Date(),\n          },\n          r = n.totalExceptionCount - t.totalExceptionCount || 0,\n          i = n.time - t.time;\n        if (i > 0) {\n          var s = r / (i / 1e3);\n          this._client.trackMetric({\n            name: o.QuickPulseCounter.EXCEPTION_RATE,\n            value: s,\n          });\n        }\n        this._lastExceptions = n;\n      }\n    };\n    e.prototype.dispose = function () {\n      e.INSTANCE = null;\n      this.enable(!1);\n      this._isInitialized = !1;\n    };\n    e._totalRequestCount = 0;\n    e._totalFailedRequestCount = 0;\n    e._lastRequestExecutionTime = 0;\n    e._totalDependencyCount = 0;\n    e._totalFailedDependencyCount = 0;\n    e._lastDependencyExecutionTime = 0;\n    e._totalExceptionCount = 0;\n    e._intervalDependencyExecutionTime = 0;\n    e._intervalRequestExecutionTime = 0;\n    return e;\n  })();\nmodule.exports = i;",
  "4398": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nprocess.env.APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL = !0;\nvar r = require(\"fs\"),\n  o = require(\"os\"),\n  i = require(\"path\"),\n  s = require(\"vscode\"),\n  a = require(9574),\n  c = (function () {\n    function e(e, t, n, o) {\n      var a = this;\n      this.extensionId = e;\n      this.extensionVersion = t;\n      this.firstParty = !1;\n      this.userOptIn = !1;\n      this.firstParty = !!o;\n      var c = process.env.VSCODE_LOGS || \"\";\n      if (c && e && \"trace\" === process.env.VSCODE_LOG_LEVEL) {\n        c = i.join(c, e + \".txt\");\n        this.logStream = r.createWriteStream(c, {\n          flags: \"a\",\n          encoding: \"utf8\",\n          autoClose: !0,\n        });\n      }\n      this.updateUserOptIn(n);\n      if (undefined !== s.env.onDidChangeTelemetryEnabled) {\n        this.optOutListener = s.env.onDidChangeTelemetryEnabled(function () {\n          return a.updateUserOptIn(n);\n        });\n      } else {\n        this.optOutListener = s.workspace.onDidChangeConfiguration(function () {\n          return a.updateUserOptIn(n);\n        });\n      }\n    }\n    e.prototype.updateUserOptIn = function (t) {\n      var n = s.workspace.getConfiguration(e.TELEMETRY_CONFIG_ID),\n        r =\n          undefined === s.env.isTelemetryEnabled\n            ? n.get(e.TELEMETRY_CONFIG_ENABLED_ID, !0)\n            : s.env.isTelemetryEnabled;\n      if (this.userOptIn !== r) {\n        this.userOptIn = r;\n        if (this.userOptIn) {\n          this.createAppInsightsClient(t);\n        } else {\n          this.dispose();\n        }\n      }\n    };\n    e.prototype.createAppInsightsClient = function (e) {\n      if (a.defaultClient) {\n        this.appInsightsClient = new a.TelemetryClient(e);\n        this.appInsightsClient.channel.setUseDiskRetryCaching(!0);\n      } else {\n        a.setup(e)\n          .setAutoCollectRequests(!1)\n          .setAutoCollectPerformance(!1)\n          .setAutoCollectExceptions(!1)\n          .setAutoCollectDependencies(!1)\n          .setAutoDependencyCorrelation(!1)\n          .setAutoCollectConsole(!1)\n          .setUseDiskRetryCaching(!0)\n          .start();\n        this.appInsightsClient = a.defaultClient;\n      }\n      this.appInsightsClient.commonProperties = this.getCommonProperties();\n      if (s && s.env) {\n        this.appInsightsClient.context.tags[\n          this.appInsightsClient.context.keys.userId\n        ] = s.env.machineId;\n        this.appInsightsClient.context.tags[\n          this.appInsightsClient.context.keys.sessionId\n        ] = s.env.sessionId;\n      }\n      if (e && 0 === e.indexOf(\"AIF-\")) {\n        this.appInsightsClient.config.endpointUrl =\n          \"https://vortex.data.microsoft.com/collect/v1\";\n        this.firstParty = !0;\n      }\n    };\n    e.prototype.getCommonProperties = function () {\n      var e = Object.create(null);\n      e[\"common.os\"] = o.platform();\n      e[\"common.platformversion\"] = (o.release() || \"\").replace(\n        /^(\\d+)(\\.\\d+)?(\\.\\d+)?(.*)/,\n        \"$1$2$3\"\n      );\n      e[\"common.extname\"] = this.extensionId;\n      e[\"common.extversion\"] = this.extensionVersion;\n      if (s && s.env) {\n        switch (\n          ((e[\"common.vscodemachineid\"] = s.env.machineId),\n          (e[\"common.vscodesessionid\"] = s.env.sessionId),\n          (e[\"common.vscodeversion\"] = s.version),\n          (e[\"common.isnewappinstall\"] = s.env.isNewAppInstall),\n          s.env.uiKind)\n        ) {\n          case s.UIKind.Web:\n            e[\"common.uikind\"] = \"web\";\n            break;\n          case s.UIKind.Desktop:\n            e[\"common.uikind\"] = \"desktop\";\n            break;\n          default:\n            e[\"common.uikind\"] = \"unknown\";\n        }\n        e[\"common.remotename\"] = this.cleanRemoteName(s.env.remoteName);\n      }\n      return e;\n    };\n    e.prototype.cleanRemoteName = function (e) {\n      if (!e) return \"none\";\n      var t = \"other\";\n      [\"ssh-remote\", \"dev-container\", \"attached-container\", \"wsl\"].forEach(\n        function (n) {\n          if (0 === e.indexOf(n + \"+\")) {\n            t = n;\n          }\n        }\n      );\n      return t;\n    };\n    e.prototype.shouldSendErrorTelemetry = function () {\n      return (\n        !this.firstParty ||\n        \"other\" !== this.cleanRemoteName(s.env.remoteName) ||\n        (undefined !== this.extension &&\n          this.extension.extensionKind !== s.ExtensionKind.Workspace &&\n          s.env.uiKind !== s.UIKind.Web)\n      );\n    };\n    Object.defineProperty(e.prototype, \"extension\", {\n      get: function () {\n        if (undefined === this._extension) {\n          this._extension = s.extensions.getExtension(this.extensionId);\n        }\n        return this._extension;\n      },\n      enumerable: !1,\n      configurable: !0,\n    });\n    e.prototype.cloneAndChange = function (e, t) {\n      if (null === e || \"object\" != typeof e) return e;\n      if (\"function\" != typeof t) return e;\n      var n = {};\n      for (var r in e) n[r] = t(r, e[r]);\n      return n;\n    };\n    e.prototype.anonymizeFilePaths = function (e, t) {\n      if (null == e) return \"\";\n      var n = [\n        new RegExp(s.env.appRoot.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), \"gi\"),\n      ];\n      if (this.extension) {\n        n.push(\n          new RegExp(\n            this.extension.extensionPath.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"),\n            \"gi\"\n          )\n        );\n      }\n      var r = e;\n      if (t) {\n        for (var o = [], i = 0, a = n; i < a.length; i++)\n          for (var c = a[i]; ; ) {\n            var l = c.exec(e);\n            if (!l) break;\n            o.push([l.index, c.lastIndex]);\n          }\n        var u = /^[\\\\\\/]?(node_modules|node_modules\\.asar)[\\\\\\/]/,\n          d =\n            /(file:\\/\\/)?([a-zA-Z]:(\\\\\\\\|\\\\|\\/)|(\\\\\\\\|\\\\|\\/))?([\\w-\\._]+(\\\\\\\\|\\\\|\\/))+[\\w-\\._]*/g,\n          p = 0;\n        r = \"\";\n        for (\n          var h = function () {\n            var t = d.exec(e);\n            if (!t) return \"break\";\n            if (\n              !u.test(t[0]) &&\n              o.every(function (e) {\n                var n = e[0],\n                  r = e[1];\n                return t.index < n || t.index >= r;\n              })\n            ) {\n              r += e.substring(p, t.index) + \"<REDACTED: user-file-path>\";\n              p = d.lastIndex;\n            }\n          };\n          \"break\" !== h();\n\n        );\n        if (p < e.length) {\n          r += e.substr(p);\n        }\n      }\n      for (var f = 0, m = n; f < m.length; f++) {\n        c = m[f];\n        r = r.replace(c, \"\");\n      }\n      return r;\n    };\n    e.prototype.sendTelemetryEvent = function (e, t, n) {\n      var r = this;\n      if (this.userOptIn && e && this.appInsightsClient) {\n        var o = this.cloneAndChange(t, function (e, t) {\n          return r.anonymizeFilePaths(t, r.firstParty);\n        });\n        this.appInsightsClient.trackEvent({\n          name: this.extensionId + \"/\" + e,\n          properties: o,\n          measurements: n,\n        });\n        if (this.logStream) {\n          this.logStream.write(\n            \"telemetry/\" +\n              e +\n              \" \" +\n              JSON.stringify({\n                properties: t,\n                measurements: n,\n              }) +\n              \"\\n\"\n          );\n        }\n      }\n    };\n    e.prototype.sendTelemetryErrorEvent = function (e, t, n, r) {\n      var o = this;\n      if (this.userOptIn && e && this.appInsightsClient) {\n        var i = this.cloneAndChange(t, function (e, t) {\n          return o.shouldSendErrorTelemetry()\n            ? o.anonymizeFilePaths(t, o.firstParty)\n            : undefined === r || -1 !== r.indexOf(e)\n            ? \"REDACTED\"\n            : o.anonymizeFilePaths(t, o.firstParty);\n        });\n        this.appInsightsClient.trackEvent({\n          name: this.extensionId + \"/\" + e,\n          properties: i,\n          measurements: n,\n        });\n        if (this.logStream) {\n          this.logStream.write(\n            \"telemetry/\" +\n              e +\n              \" \" +\n              JSON.stringify({\n                properties: t,\n                measurements: n,\n              }) +\n              \"\\n\"\n          );\n        }\n      }\n    };\n    e.prototype.sendTelemetryException = function (e, t, n) {\n      var r = this;\n      if (\n        this.shouldSendErrorTelemetry() &&\n        this.userOptIn &&\n        e &&\n        this.appInsightsClient\n      ) {\n        var o = this.cloneAndChange(t, function (e, t) {\n          return r.anonymizeFilePaths(t, r.firstParty);\n        });\n        this.appInsightsClient.trackException({\n          exception: e,\n          properties: o,\n          measurements: n,\n        });\n        if (this.logStream) {\n          this.logStream.write(\n            \"telemetry/\" +\n              e.name +\n              \" \" +\n              e.message +\n              \" \" +\n              JSON.stringify({\n                properties: t,\n                measurements: n,\n              }) +\n              \"\\n\"\n          );\n        }\n      }\n    };\n    e.prototype.dispose = function () {\n      var e = this;\n      this.optOutListener.dispose();\n      var t = new Promise(function (t) {\n          if (!e.logStream) return t(undefined);\n          e.logStream.on(\"finish\", t);\n          e.logStream.end();\n        }),\n        n = new Promise(function (t) {\n          if (e.appInsightsClient) {\n            e.appInsightsClient.flush({\n              callback: function () {\n                e.appInsightsClient = undefined;\n                t(undefined);\n              },\n            });\n          } else {\n            t(undefined);\n          }\n        });\n      return Promise.all([n, t]);\n    };\n    e.TELEMETRY_CONFIG_ID = \"telemetry\";\n    e.TELEMETRY_CONFIG_ENABLED_ID = \"enableTelemetry\";\n    return e;\n  })();\nexports.default = c;",
  "4419": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.LiveOpenAIFetcher =\n  exports.postProcessChoices =\n  exports.OpenAIFetcher =\n  exports.extractEngineName =\n  exports.getProcessingTime =\n  exports.getRequestId =\n  exports.CopilotUiKind =\n    undefined;\nconst r = require(\"util\"),\n  o = require(362),\n  i = require(6932),\n  s = require(1133),\n  a = require(9189),\n  c = require(5413),\n  l = require(9899),\n  u = require(2279),\n  d = require(6722),\n  p = require(766),\n  h = require(9657),\n  f = require(6333),\n  m = require(937),\n  g = require(2901),\n  _ = new l.Logger(l.LogLevel.INFO, \"fetch\");\nvar y;\nfunction getRequestId(e, t) {\n  return {\n    headerRequestId: e.headers.get(\"x-request-id\") || \"\",\n    completionId: t && t.id ? t.id : \"\",\n    created: t && t.created ? t.created : 0,\n    serverExperiments: e.headers.get(\"X-Copilot-Experiment\") || \"\",\n    deploymentId: e.headers.get(\"azureml-model-deployment\") || \"\",\n  };\n}\nfunction getProcessingTime(e) {\n  const t = e.headers.get(\"openai-processing-ms\");\n  return t ? parseInt(t, 10) : 0;\n}\nfunction extractEngineName(e, t) {\n  return t.split(\"/\").pop() || (_.error(e, \"Malformed engine URL: \" + t), t);\n}\n!(function (e) {\n  e.GhostText = \"ghostText\";\n  e.Panel = \"synthesize\";\n})((y = exports.CopilotUiKind || (exports.CopilotUiKind = {})));\nexports.getRequestId = getRequestId;\nexports.getProcessingTime = getProcessingTime;\nexports.extractEngineName = extractEngineName;\nclass OpenAIFetcher {}\nfunction postProcessChoices(e, t) {\n  return null != t && t\n    ? e\n    : i.asyncIterableFilter(e, async (e) => e.completionText.trim().length > 0);\n}\nexports.OpenAIFetcher = OpenAIFetcher;\nexports.postProcessChoices = postProcessChoices;\nexports.LiveOpenAIFetcher = class extends OpenAIFetcher {\n  async fetchAndStreamCompletions(e, t, n, r, o) {\n    const s = e.get(d.StatusReporter),\n      a = \"completions\",\n      c = await this.fetchWithParameters(e, a, t, o);\n    if (\"not-sent\" === c)\n      return {\n        type: \"canceled\",\n        reason: \"before fetch request\",\n      };\n    if (null == o ? undefined : o.isCancellationRequested) {\n      const t = await c.body();\n      try {\n        t.destroy();\n      } catch (t) {\n        l.logger.error(e, `Error destroying stream: ${t}`);\n      }\n      return {\n        type: \"canceled\",\n        reason: \"after fetch request\",\n      };\n    }\n    if (undefined === c) {\n      const n = this.createTelemetryData(a, e, t);\n      s.setWarning();\n      n.properties.error = \"Response was undefined\";\n      f.telemetry(e, \"request.shownWarning\", n);\n      return {\n        type: \"failed\",\n        reason: \"fetch response was undefined\",\n      };\n    }\n    if (200 !== c.status) {\n      const n = this.createTelemetryData(a, e, t);\n      return this.handleError(e, s, n, c);\n    }\n    return {\n      type: \"success\",\n      choices: postProcessChoices(\n        i.asyncIterableMap(g.processSSE(e, c, r, n, o), async (t) =>\n          g.prepareSolutionForReturn(e, t, n)\n        ),\n        t.allowEmptyChoices\n      ),\n      getProcessingTime: () => getProcessingTime(c),\n    };\n  }\n  createTelemetryData(e, t, n) {\n    return f.TelemetryData.createAndMarkAsIssued({\n      endpoint: e,\n      engineName: extractEngineName(t, n.engineUrl),\n      uiKind: n.uiKind,\n      headerRequestId: n.ourRequestId,\n    });\n  }\n  async fetchWithParameters(e, t, n, i) {\n    var g;\n    const _ = s.getLanguageConfig(e, s.ConfigKey.Stops),\n      b = await e.get(a.Features).disableLogProb(),\n      x = {\n        prompt: n.prompt.prefix,\n        suffix: n.prompt.suffix,\n        max_tokens: s.getConfig(e, s.ConfigKey.SolutionLength),\n        temperature: m.getTemperatureForSamples(e, n.count),\n        top_p: s.getConfig(e, s.ConfigKey.TopP),\n        n: n.count,\n        stop: _,\n      };\n    if (!n.requestLogProbs && b) {\n      x.logprobs = 2;\n    }\n    const E = p.tryGetGitHubNWO(n.repoInfo);\n    if (undefined !== E) {\n      x.nwo = E;\n    }\n    if (\n      [h.RepetitionFilterMode.PROXY, h.RepetitionFilterMode.BOTH].includes(\n        await e.get(a.Features).repetitionFilterMode()\n      )\n    ) {\n      x.feature_flags = [\n        ...(null !== (g = x.feature_flags) && undefined !== g ? g : []),\n        \"filter-repetitions\",\n      ];\n    }\n    if (n.postOptions) {\n      Object.assign(x, n.postOptions);\n    }\n    return (null == i ? undefined : i.isCancellationRequested)\n      ? \"not-sent\"\n      : (l.logger.info(e, `[fetchCompletions] engine ${n.engineUrl}`),\n        await (function (e, t, n, o, i, s, a, p, h) {\n          var m;\n          const g = e.get(d.StatusReporter),\n            _ = r.format(\"%s/%s\", n, o);\n          if (!a)\n            return void l.logger.error(\n              e,\n              `Failed to send request to ${_} due to missing key`\n            );\n          const b = f.TelemetryData.createAndMarkAsIssued(\n            {\n              endpoint: o,\n              engineName: extractEngineName(e, n),\n              uiKind: p,\n            },\n            f.telemetrizePromptLength(t)\n          );\n          for (const [e, t] of Object.entries(s))\n            if (\"prompt\" != e && \"suffix\" != e) {\n              b.properties[`request.option.${e}`] =\n                null !== (m = JSON.stringify(t)) && undefined !== m\n                  ? m\n                  : \"undefined\";\n            }\n          b.properties.headerRequestId = i;\n          f.telemetry(e, \"request.sent\", b);\n          const x = f.now(),\n            E = (function (e) {\n              switch (e) {\n                case y.GhostText:\n                  return \"copilot-ghost\";\n                case y.Panel:\n                  return \"copilot-panel\";\n              }\n            })(p);\n          return u\n            .postRequest(e, _, a, E, i, s, h)\n            .then((n) => {\n              const r = getRequestId(n, undefined);\n              b.extendWithRequestId(r);\n              const o = f.now() - x;\n              b.measurements.totalTimeMs = o;\n              l.logger.info(e, `request.response: [${_}] took ${o} ms`);\n              l.logger.debug(e, \"request.response properties\", b.properties);\n              l.logger.debug(\n                e,\n                \"request.response measurements\",\n                b.measurements\n              );\n              l.logger.debug(e, `prompt: ${JSON.stringify(t)}`);\n              f.telemetry(e, \"request.response\", b);\n              const i = n.headers.get(\"x-copilot-delay\"),\n                s = i ? parseInt(i, 10) : 0;\n              e.get(c.GhostTextDebounceManager).extraDebounceMs = s;\n              return n;\n            })\n            .catch((t) => {\n              var n, r, o, i;\n              if (u.isAbortError(t)) throw t;\n              g.setWarning();\n              const s = b.extendedBy({\n                error: \"Network exception\",\n              });\n              f.telemetry(e, \"request.shownWarning\", s);\n              b.properties.code = String(\n                null !== (n = t.code) && undefined !== n ? n : \"\"\n              );\n              b.properties.errno = String(\n                null !== (r = t.errno) && undefined !== r ? r : \"\"\n              );\n              b.properties.message = String(\n                null !== (o = t.message) && undefined !== o ? o : \"\"\n              );\n              b.properties.type = String(\n                null !== (i = t.type) && undefined !== i ? i : \"\"\n              );\n              const a = f.now() - x;\n              throw (\n                ((b.measurements.totalTimeMs = a),\n                l.logger.debug(e, `request.response: [${_}] took ${a} ms`),\n                l.logger.debug(e, \"request.error properties\", b.properties),\n                l.logger.debug(e, \"request.error measurements\", b.measurements),\n                l.logger.error(e, `Request Error: ${t.message}`),\n                f.telemetry(e, \"request.error\", b),\n                t)\n              );\n            })\n            .finally(() => {\n              f.logEnginePrompt(e, t, b);\n            });\n        })(\n          e,\n          n.prompt,\n          n.engineUrl,\n          t,\n          n.ourRequestId,\n          x,\n          (\n            await e.get(o.CopilotTokenManager).getCopilotToken(e)\n          ).token,\n          n.uiKind,\n          i\n        ));\n  }\n  async handleError(e, t, n, r) {\n    t.setWarning();\n    n.properties.error = `Response status was ${r.status}`;\n    n.properties.status = String(r.status);\n    f.telemetry(e, \"request.shownWarning\", n);\n    if (401 === r.status || 403 === r.status)\n      return (\n        e.get(o.CopilotTokenManager).resetCopilotToken(e, r.status),\n        {\n          type: \"failed\",\n          reason: `token expired or invalid: ${r.status}`,\n        }\n      );\n    if (499 === r.status) {\n      _.info(e, \"Cancelled by server\");\n      return {\n        type: \"failed\",\n        reason: \"canceled by server\",\n      };\n    }\n    const i = await r.text();\n    return 466 === r.status\n      ? (t.setError(i),\n        _.info(e, i),\n        {\n          type: \"failed\",\n          reason: `client not supported: ${i}`,\n        })\n      : (_.error(e, \"Unhandled status from server:\", r.status, i),\n        {\n          type: \"failed\",\n          reason: `unhandled status from server: ${r.status} ${i}`,\n        });\n  }\n};",
  "4428": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.activate = undefined;\nconst r = require(4398),\n  o = require(1133),\n  i = require(6333),\n  s = require(9380);\nfunction a(e, t, n, o, a) {\n  const c = new r.default(t, n, o);\n  s.setupExperimentationService(e);\n  i.configureReporter(e, c);\n  return c;\n}\nexports.activate = function (e, t) {\n  const n = t.extension.packageJSON.name,\n    r = o.getVersion(e),\n    s = a(e, n, r, i.APP_INSIGHTS_KEY, t.globalState),\n    c = a(e, n, r, i.APP_INSIGHTS_KEY_SECURE, t.globalState);\n  t.subscriptions.push(s);\n  t.subscriptions.push(c);\n  return new i.TelemetryReporters(s, c);\n};",
  "4431": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.findEditDistanceScore = undefined;\nconst r = require(9852);\nexports.findEditDistanceScore = function (e, t) {\n  if (\"string\" == typeof e) {\n    e = r.tokenize(e);\n  }\n  if (\"string\" == typeof t) {\n    t = r.tokenize(t);\n  }\n  if (0 === e.length || 0 === t.length)\n    return {\n      score: e.length + t.length,\n    };\n  const n = Array.from({\n    length: e.length,\n  }).map(() =>\n    Array.from({\n      length: t.length,\n    }).map(() => 0)\n  );\n  for (let t = 0; t < e.length; t++) n[t][0] = t;\n  for (let e = 0; e < t.length; e++) n[0][e] = e;\n  for (let r = 0; r < t.length; r++)\n    for (let o = 0; o < e.length; o++)\n      n[o][r] = Math.min(\n        (0 == o ? r : n[o - 1][r]) + 1,\n        (0 == r ? o : n[o][r - 1]) + 1,\n        (0 == o || 0 == r ? Math.max(o, r) : n[o - 1][r - 1]) +\n          (e[o] == t[r] ? 0 : 1)\n      );\n  return {\n    score: n[e.length - 1][t.length - 1],\n  };\n};",
  "4433": "var r = require(6400),\n  o = require(2728),\n  i = require(8213).I,\n  s = require(1188).H;\nfunction h(e) {\n  if (e) {\n    e = {};\n  }\n  this._file = o.getArg(e, \"file\", null);\n  this._sourceRoot = o.getArg(e, \"sourceRoot\", null);\n  this._skipValidation = o.getArg(e, \"skipValidation\", !1);\n  this._sources = new i();\n  this._names = new i();\n  this._mappings = new s();\n  this._sourcesContents = null;\n}\nh.prototype._version = 3;\nh.fromSourceMap = function (e) {\n  var t = e.sourceRoot,\n    n = new h({\n      file: e.file,\n      sourceRoot: t,\n    });\n  e.eachMapping(function (e) {\n    var r = {\n      generated: {\n        line: e.generatedLine,\n        column: e.generatedColumn,\n      },\n    };\n    if (null != e.source) {\n      r.source = e.source;\n      if (null != t) {\n        r.source = o.relative(t, r.source);\n      }\n      r.original = {\n        line: e.originalLine,\n        column: e.originalColumn,\n      };\n      if (null != e.name) {\n        r.name = e.name;\n      }\n    }\n    n.addMapping(r);\n  });\n  e.sources.forEach(function (r) {\n    var i = r;\n    if (null !== t) {\n      i = o.relative(t, r);\n    }\n    if (n._sources.has(i)) {\n      n._sources.add(i);\n    }\n    var s = e.sourceContentFor(r);\n    if (null != s) {\n      n.setSourceContent(r, s);\n    }\n  });\n  return n;\n};\nh.prototype.addMapping = function (e) {\n  var t = o.getArg(e, \"generated\"),\n    n = o.getArg(e, \"original\", null),\n    r = o.getArg(e, \"source\", null),\n    i = o.getArg(e, \"name\", null);\n  if (this._skipValidation) {\n    this._validateMapping(t, n, r, i);\n  }\n  if (null != r) {\n    r = String(r);\n    if (this._sources.has(r)) {\n      this._sources.add(r);\n    }\n  }\n  if (null != i) {\n    i = String(i);\n    if (this._names.has(i)) {\n      this._names.add(i);\n    }\n  }\n  this._mappings.add({\n    generatedLine: t.line,\n    generatedColumn: t.column,\n    originalLine: null != n && n.line,\n    originalColumn: null != n && n.column,\n    source: r,\n    name: i,\n  });\n};\nh.prototype.setSourceContent = function (e, t) {\n  var n = e;\n  if (null != this._sourceRoot) {\n    n = o.relative(this._sourceRoot, n);\n  }\n  if (null != t) {\n    if (this._sourcesContents) {\n      this._sourcesContents = Object.create(null);\n    }\n    this._sourcesContents[o.toSetString(n)] = t;\n  } else {\n    if (this._sourcesContents) {\n      delete this._sourcesContents[o.toSetString(n)];\n      if (0 === Object.keys(this._sourcesContents).length) {\n        this._sourcesContents = null;\n      }\n    }\n  }\n};\nh.prototype.applySourceMap = function (e, t, n) {\n  var r = t;\n  if (null == t) {\n    if (null == e.file)\n      throw new Error(\n        'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\\'s \"file\" property. Both were omitted.'\n      );\n    r = e.file;\n  }\n  var s = this._sourceRoot;\n  if (null != s) {\n    r = o.relative(s, r);\n  }\n  var a = new i(),\n    c = new i();\n  this._mappings.unsortedForEach(function (t) {\n    if (t.source === r && null != t.originalLine) {\n      var i = e.originalPositionFor({\n        line: t.originalLine,\n        column: t.originalColumn,\n      });\n      if (null != i.source) {\n        t.source = i.source;\n        if (null != n) {\n          t.source = o.join(n, t.source);\n        }\n        if (null != s) {\n          t.source = o.relative(s, t.source);\n        }\n        t.originalLine = i.line;\n        t.originalColumn = i.column;\n        if (null != i.name) {\n          t.name = i.name;\n        }\n      }\n    }\n    var l = t.source;\n    if (null == l || a.has(l)) {\n      a.add(l);\n    }\n    var u = t.name;\n    if (null == u || c.has(u)) {\n      c.add(u);\n    }\n  }, this);\n  this._sources = a;\n  this._names = c;\n  e.sources.forEach(function (t) {\n    var r = e.sourceContentFor(t);\n    if (null != r) {\n      if (null != n) {\n        t = o.join(n, t);\n      }\n      if (null != s) {\n        t = o.relative(s, t);\n      }\n      this.setSourceContent(t, r);\n    }\n  }, this);\n};\nh.prototype._validateMapping = function (e, t, n, r) {\n  if (t && \"number\" != typeof t.line && \"number\" != typeof t.column)\n    throw new Error(\n      \"original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.\"\n    );\n  if (\n    (!(e && \"line\" in e && \"column\" in e && e.line > 0 && e.column >= 0) ||\n      t ||\n      n ||\n      r) &&\n    !(\n      e &&\n      \"line\" in e &&\n      \"column\" in e &&\n      t &&\n      \"line\" in t &&\n      \"column\" in t &&\n      e.line > 0 &&\n      e.column >= 0 &&\n      t.line > 0 &&\n      t.column >= 0 &&\n      n\n    )\n  )\n    throw new Error(\n      \"Invalid mapping: \" +\n        JSON.stringify({\n          generated: e,\n          source: n,\n          original: t,\n          name: r,\n        })\n    );\n};\nh.prototype._serializeMappings = function () {\n  for (\n    var e,\n      t,\n      n,\n      i,\n      s = 0,\n      a = 1,\n      c = 0,\n      l = 0,\n      u = 0,\n      d = 0,\n      p = \"\",\n      h = this._mappings.toArray(),\n      f = 0,\n      m = h.length;\n    f < m;\n    f++\n  ) {\n    e = \"\";\n    if ((t = h[f]).generatedLine !== a)\n      for (s = 0; t.generatedLine !== a; ) (e += \";\"), a++;\n    else if (f > 0) {\n      if (!o.compareByGeneratedPositionsInflated(t, h[f - 1])) continue;\n      e += \",\";\n    }\n    e += r.encode(t.generatedColumn - s);\n    s = t.generatedColumn;\n    if (null != t.source) {\n      i = this._sources.indexOf(t.source);\n      e += r.encode(i - d);\n      d = i;\n      e += r.encode(t.originalLine - 1 - l);\n      l = t.originalLine - 1;\n      e += r.encode(t.originalColumn - c);\n      c = t.originalColumn;\n      if (null != t.name) {\n        n = this._names.indexOf(t.name);\n        e += r.encode(n - u);\n        u = n;\n      }\n    }\n    p += e;\n  }\n  return p;\n};\nh.prototype._generateSourcesContent = function (e, t) {\n  return e.map(function (e) {\n    if (!this._sourcesContents) return null;\n    if (null != t) {\n      e = o.relative(t, e);\n    }\n    var n = o.toSetString(e);\n    return Object.prototype.hasOwnProperty.call(this._sourcesContents, n)\n      ? this._sourcesContents[n]\n      : null;\n  }, this);\n};\nh.prototype.toJSON = function () {\n  var e = {\n    version: this._version,\n    sources: this._sources.toArray(),\n    names: this._names.toArray(),\n    mappings: this._serializeMappings(),\n  };\n  if (null != this._file) {\n    e.file = this._file;\n  }\n  if (null != this._sourceRoot) {\n    e.sourceRoot = this._sourceRoot;\n  }\n  if (this._sourcesContents) {\n    e.sourcesContent = this._generateSourcesContent(e.sources, e.sourceRoot);\n  }\n  return e;\n};\nh.prototype.toString = function () {\n  return JSON.stringify(this.toJSON());\n};\nexports.h = h;",
  "4454": "var r;\nr = require(8249);\nrequire(8269);\nrequire(8214);\nrequire(888);\nrequire(5109);\n(function () {\n  var e = r,\n    t = e.lib.StreamCipher,\n    n = e.algo,\n    o = [],\n    i = [],\n    s = [],\n    a = (n.Rabbit = t.extend({\n      _doReset: function () {\n        for (var e = this._key.words, t = this.cfg.iv, n = 0; n < 4; n++)\n          e[n] =\n            (16711935 & ((e[n] << 8) | (e[n] >>> 24))) |\n            (4278255360 & ((e[n] << 24) | (e[n] >>> 8)));\n        var r = (this._X = [\n            e[0],\n            (e[3] << 16) | (e[2] >>> 16),\n            e[1],\n            (e[0] << 16) | (e[3] >>> 16),\n            e[2],\n            (e[1] << 16) | (e[0] >>> 16),\n            e[3],\n            (e[2] << 16) | (e[1] >>> 16),\n          ]),\n          o = (this._C = [\n            (e[2] << 16) | (e[2] >>> 16),\n            (4294901760 & e[0]) | (65535 & e[1]),\n            (e[3] << 16) | (e[3] >>> 16),\n            (4294901760 & e[1]) | (65535 & e[2]),\n            (e[0] << 16) | (e[0] >>> 16),\n            (4294901760 & e[2]) | (65535 & e[3]),\n            (e[1] << 16) | (e[1] >>> 16),\n            (4294901760 & e[3]) | (65535 & e[0]),\n          ]);\n        for (this._b = 0, n = 0; n < 4; n++) c.call(this);\n        for (n = 0; n < 8; n++) o[n] ^= r[(n + 4) & 7];\n        if (t) {\n          var i = t.words,\n            s = i[0],\n            a = i[1],\n            l =\n              (16711935 & ((s << 8) | (s >>> 24))) |\n              (4278255360 & ((s << 24) | (s >>> 8))),\n            u =\n              (16711935 & ((a << 8) | (a >>> 24))) |\n              (4278255360 & ((a << 24) | (a >>> 8))),\n            d = (l >>> 16) | (4294901760 & u),\n            p = (u << 16) | (65535 & l);\n          for (\n            o[0] ^= l,\n              o[1] ^= d,\n              o[2] ^= u,\n              o[3] ^= p,\n              o[4] ^= l,\n              o[5] ^= d,\n              o[6] ^= u,\n              o[7] ^= p,\n              n = 0;\n            n < 4;\n            n++\n          )\n            c.call(this);\n        }\n      },\n      _doProcessBlock: function (e, t) {\n        var n = this._X;\n        c.call(this);\n        o[0] = n[0] ^ (n[5] >>> 16) ^ (n[3] << 16);\n        o[1] = n[2] ^ (n[7] >>> 16) ^ (n[5] << 16);\n        o[2] = n[4] ^ (n[1] >>> 16) ^ (n[7] << 16);\n        o[3] = n[6] ^ (n[3] >>> 16) ^ (n[1] << 16);\n        for (var r = 0; r < 4; r++) {\n          o[r] =\n            (16711935 & ((o[r] << 8) | (o[r] >>> 24))) |\n            (4278255360 & ((o[r] << 24) | (o[r] >>> 8)));\n          e[t + r] ^= o[r];\n        }\n      },\n      blockSize: 4,\n      ivSize: 2,\n    }));\n  function c() {\n    for (var e = this._X, t = this._C, n = 0; n < 8; n++) i[n] = t[n];\n    for (\n      t[0] = (t[0] + 1295307597 + this._b) | 0,\n        t[1] = (t[1] + 3545052371 + (t[0] >>> 0 < i[0] >>> 0 ? 1 : 0)) | 0,\n        t[2] = (t[2] + 886263092 + (t[1] >>> 0 < i[1] >>> 0 ? 1 : 0)) | 0,\n        t[3] = (t[3] + 1295307597 + (t[2] >>> 0 < i[2] >>> 0 ? 1 : 0)) | 0,\n        t[4] = (t[4] + 3545052371 + (t[3] >>> 0 < i[3] >>> 0 ? 1 : 0)) | 0,\n        t[5] = (t[5] + 886263092 + (t[4] >>> 0 < i[4] >>> 0 ? 1 : 0)) | 0,\n        t[6] = (t[6] + 1295307597 + (t[5] >>> 0 < i[5] >>> 0 ? 1 : 0)) | 0,\n        t[7] = (t[7] + 3545052371 + (t[6] >>> 0 < i[6] >>> 0 ? 1 : 0)) | 0,\n        this._b = t[7] >>> 0 < i[7] >>> 0 ? 1 : 0,\n        n = 0;\n      n < 8;\n      n++\n    ) {\n      var r = e[n] + t[n],\n        o = 65535 & r,\n        a = r >>> 16,\n        c = ((((o * o) >>> 17) + o * a) >>> 15) + a * a,\n        l = (((4294901760 & r) * r) | 0) + (((65535 & r) * r) | 0);\n      s[n] = c ^ l;\n    }\n    e[0] =\n      (s[0] + ((s[7] << 16) | (s[7] >>> 16)) + ((s[6] << 16) | (s[6] >>> 16))) |\n      0;\n    e[1] = (s[1] + ((s[0] << 8) | (s[0] >>> 24)) + s[7]) | 0;\n    e[2] =\n      (s[2] + ((s[1] << 16) | (s[1] >>> 16)) + ((s[0] << 16) | (s[0] >>> 16))) |\n      0;\n    e[3] = (s[3] + ((s[2] << 8) | (s[2] >>> 24)) + s[1]) | 0;\n    e[4] =\n      (s[4] + ((s[3] << 16) | (s[3] >>> 16)) + ((s[2] << 16) | (s[2] >>> 16))) |\n      0;\n    e[5] = (s[5] + ((s[4] << 8) | (s[4] >>> 24)) + s[3]) | 0;\n    e[6] =\n      (s[6] + ((s[5] << 16) | (s[5] >>> 16)) + ((s[4] << 16) | (s[4] >>> 16))) |\n      0;\n    e[7] = (s[7] + ((s[6] << 8) | (s[6] >>> 24)) + s[5]) | 0;\n  }\n  e.Rabbit = t._createHelper(a);\n})();\nmodule.exports = r.Rabbit;",
  "4470": "var r = require(\"os\"),\n  o = require(\"fs\"),\n  i = require(\"path\"),\n  s = require(5290),\n  a = require(5282),\n  c = (function () {\n    function e(e) {\n      this.keys = new s.ContextTagKeys();\n      this.tags = {};\n      this._loadApplicationContext();\n      this._loadDeviceContext();\n      this._loadInternalContext();\n    }\n    e.prototype._loadApplicationContext = function (t) {\n      t = t || i.resolve(__dirname, \"../../../../package.json\");\n      if (!e.appVersion[t]) {\n        e.appVersion[t] = \"unknown\";\n        try {\n          var n = JSON.parse(o.readFileSync(t, \"utf8\"));\n          n && \"string\" == typeof n.version && (e.appVersion[t] = n.version);\n        } catch (e) {\n          a.info(\"unable to read app version: \", e);\n        }\n      }\n      this.tags[this.keys.applicationVersion] = e.appVersion[t];\n    };\n    e.prototype._loadDeviceContext = function () {\n      this.tags[this.keys.deviceId] = \"\";\n      this.tags[this.keys.cloudRoleInstance] = r && r.hostname();\n      this.tags[this.keys.deviceOSVersion] = r && r.type() + \" \" + r.release();\n      this.tags[this.keys.cloudRole] = e.DefaultRoleName;\n      this.tags[\"ai.device.osArchitecture\"] = r && r.arch();\n      this.tags[\"ai.device.osPlatform\"] = r && r.platform();\n    };\n    e.prototype._loadInternalContext = function () {\n      var t = i.resolve(__dirname, \"../../package.json\");\n      if (!e.sdkVersion) {\n        e.sdkVersion = \"unknown\";\n        try {\n          var n = JSON.parse(o.readFileSync(t, \"utf8\"));\n          if (n && \"string\" == typeof n.version) {\n            e.sdkVersion = n.version;\n          }\n        } catch (e) {\n          a.info(\"unable to read app version: \", e);\n        }\n      }\n      this.tags[this.keys.internalSdkVersion] = \"node:\" + e.sdkVersion;\n    };\n    e.DefaultRoleName = \"Web\";\n    e.appVersion = {};\n    e.sdkVersion = null;\n    return e;\n  })();\nmodule.exports = c;",
  "4487": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r = require(4953);\nexports.redis = {\n  versionSpecifier: \">= 2.0.0 < 4.0.0\",\n  patch: function (e) {\n    var t = e.RedisClient.prototype.internal_send_command;\n    e.RedisClient.prototype.internal_send_command = function (e) {\n      if (e) {\n        var n = e.callback;\n        if (!n || !n.pubsubBound) {\n          var o = this.address,\n            i = process.hrtime(),\n            s = new Date();\n          e.callback = r.channel.bindToContext(function (t, a) {\n            var c = process.hrtime(i),\n              l = (1e3 * c[0] + c[1] / 1e6) | 0;\n            r.channel.publish(\"redis\", {\n              duration: l,\n              address: o,\n              commandObj: e,\n              err: t,\n              result: a,\n              time: s,\n            });\n            if (\"function\" == typeof n) {\n              n.apply(this, arguments);\n            }\n          });\n          e.callback.pubsubBound = !0;\n        }\n      }\n      return t.call(this, e);\n    };\n    return e;\n  },\n};\nexports.enable = function () {\n  r.channel.registerMonkeyPatch(\"redis\", exports.redis);\n};",
  "4499": "function n(e) {\n  const t = e.length;\n  let n,\n    r = 0,\n    o = 0;\n  for (; o < t; ) {\n    r++;\n    n = e.charCodeAt(o++);\n    if (n >= 55296 && n <= 56319 && o < t) {\n      n = e.charCodeAt(o);\n      if (56320 == (64512 & n)) {\n        o++;\n      }\n    }\n  }\n  return r;\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.default = n;\nn.code = 'require(\"ajv/dist/runtime/ucs2length\").default';",
  "4526": "var r,\n  o =\n    (this && this.__extends) ||\n    ((r =\n      Object.setPrototypeOf ||\n      ({\n        __proto__: [],\n      } instanceof Array &&\n        function (e, t) {\n          e.__proto__ = t;\n        }) ||\n      function (e, t) {\n        for (var n in t)\n          if (t.hasOwnProperty(n)) {\n            e[n] = t[n];\n          }\n      }),\n    function (e, t) {\n      function n() {\n        this.constructor = e;\n      }\n      r(e, t);\n      e.prototype =\n        null === t ? Object.create(t) : ((n.prototype = t.prototype), new n());\n    }),\n  i = (function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.properties = {};\n      t.measurements = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  })(require(8934));\nmodule.exports = i;",
  "4540": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.ignoreDocument = undefined;\nconst r = require(1133),\n  o = require(4197);\nexports.ignoreDocument = function (e, t) {\n  const n = t.languageId;\n  return (\n    !r.getEnabledConfig(e, n) ||\n    !![o.CopilotScheme, \"output\", \"search-editor\"].includes(t.uri.scheme)\n  );\n};",
  "4544": "const {\n    constants: { MAX_LENGTH: r },\n  } = require(\"buffer\"),\n  { pipeline: o, PassThrough: i } = require(\"stream\"),\n  { promisify: s } = require(\"util\"),\n  {\n    createGunzip: a,\n    createInflate: c,\n    createBrotliDecompress: l,\n    constants: { Z_SYNC_FLUSH: u },\n  } = require(\"zlib\"),\n  d = require(8104)(\"helix-fetch:utils\"),\n  p = s(o),\n  h = (e, t) => {\n    if (Buffer.isBuffer(e)) return e.length;\n    switch (typeof e) {\n      case \"string\":\n        return 2 * e.length;\n      case \"boolean\":\n        return 4;\n      case \"number\":\n        return 8;\n      case \"symbol\":\n        return Symbol.keyFor(e)\n          ? 2 * Symbol.keyFor(e).length\n          : 2 * (e.toString().length - 8);\n      case \"object\":\n        return Array.isArray(e) ? f(e, t) : m(e, t);\n      default:\n        return 0;\n    }\n  },\n  f = (e, t) => (\n    t.add(e), e.map((e) => (t.has(e) ? 0 : h(e, t))).reduce((e, t) => e + t, 0)\n  ),\n  m = (e, t) => {\n    if (null == e) return 0;\n    t.add(e);\n    let n = 0;\n    const r = [];\n    for (const t in e) r.push(t);\n    r.push(...Object.getOwnPropertySymbols(e));\n    r.forEach((r) => {\n      n += h(r, t);\n      if (\"object\" == typeof e[r] && null !== e[r]) {\n        if (t.has(e[r])) return;\n        t.add(e[r]);\n      }\n      n += h(e[r], t);\n    });\n    return n;\n  };\nmodule.exports = {\n  decodeStream: (e, t, n, r) => {\n    if (\n      !((e, t) =>\n        204 !== e &&\n        304 !== e &&\n        0 != +t[\"content-length\"] &&\n        /^\\s*(?:(x-)?deflate|(x-)?gzip|br)\\s*$/.test(t[\"content-encoding\"]))(\n        e,\n        t\n      )\n    )\n      return n;\n    const i = (e) => {\n      if (e) {\n        d(`encountered error while decoding stream: ${e}`);\n        r(e);\n      }\n    };\n    switch (t[\"content-encoding\"].trim()) {\n      case \"gzip\":\n      case \"x-gzip\":\n        return o(\n          n,\n          a({\n            flush: u,\n            finishFlush: u,\n          }),\n          i\n        );\n      case \"deflate\":\n      case \"x-deflate\":\n        return o(n, c(), i);\n      case \"br\":\n        return o(n, l(), i);\n      default:\n        return n;\n    }\n  },\n  isPlainObject: (e) => {\n    if (!e || \"object\" != typeof e) return !1;\n    if (\"[object Object]\" !== Object.prototype.toString.call(e)) return !1;\n    if (null === Object.getPrototypeOf(e)) return !0;\n    let t = e;\n    for (; null !== Object.getPrototypeOf(t); ) t = Object.getPrototypeOf(t);\n    return Object.getPrototypeOf(e) === t;\n  },\n  sizeof: (e) => h(e, new WeakSet()),\n  streamToBuffer: async (e) => {\n    const t = new i();\n    let n = 0;\n    const o = [];\n    t.on(\"data\", (e) => {\n      if (n + e.length > r)\n        throw new Error(\"Buffer.constants.MAX_SIZE exceeded\");\n      o.push(e);\n      n += e.length;\n    });\n    await p(e, t);\n    return Buffer.concat(o, n);\n  },\n};",
  "4650": "var r,\n  o =\n    (this && this.__extends) ||\n    ((r =\n      Object.setPrototypeOf ||\n      ({\n        __proto__: [],\n      } instanceof Array &&\n        function (e, t) {\n          e.__proto__ = t;\n        }) ||\n      function (e, t) {\n        for (var n in t)\n          if (t.hasOwnProperty(n)) {\n            e[n] = t[n];\n          }\n      }),\n    function (e, t) {\n      function n() {\n        this.constructor = e;\n      }\n      r(e, t);\n      e.prototype =\n        null === t ? Object.create(t) : ((n.prototype = t.prototype), new n());\n    }),\n  i =\n    (this && this.__rest) ||\n    function (e, t) {\n      var n = {};\n      for (var r in e)\n        if (Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0) {\n          n[r] = e[r];\n        }\n      if (null != e && \"function\" == typeof Object.getOwnPropertySymbols) {\n        var o = 0;\n        for (r = Object.getOwnPropertySymbols(e); o < r.length; o++)\n          if (t.indexOf(r[o]) < 0) {\n            n[r[o]] = e[r[o]];\n          }\n      }\n      return n;\n    };\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar s = require(4953);\nexports.winston3 = {\n  versionSpecifier: \"3.x\",\n  patch: function (e) {\n    var t = (function (e) {\n      function t(t, n) {\n        var r = e.call(this, n) || this;\n        r.winston = t;\n        return r;\n      }\n      o(t, e);\n      t.prototype.log = function (e, t) {\n        var n = e.message,\n          r = e.level,\n          o = e.meta,\n          a = i(e, [\"message\", \"level\", \"meta\"]);\n        r = \"function\" == typeof Symbol.for ? e[Symbol.for(\"level\")] : r;\n        n = e instanceof Error ? e : n;\n        var c = (function (e, t) {\n          return null != e.config.npm.levels[t]\n            ? \"npm\"\n            : null != e.config.syslog.levels[t]\n            ? \"syslog\"\n            : \"unknown\";\n        })(this.winston, r);\n        for (var l in ((o = o || {}), a))\n          if (a.hasOwnProperty(l)) {\n            o[l] = a[l];\n          }\n        s.channel.publish(\"winston\", {\n          message: n,\n          level: r,\n          levelKind: c,\n          meta: o,\n        });\n        t();\n      };\n      return t;\n    })(e.Transport);\n    function n() {\n      var n,\n        r = arguments[0].levels || e.config.npm.levels;\n      for (var o in r)\n        if (r.hasOwnProperty(o)) {\n          n = undefined === n || r[o] > r[n] ? o : n;\n        }\n      this.add(\n        new t(e, {\n          level: n,\n        })\n      );\n    }\n    var r = e.createLogger;\n    e.createLogger = function () {\n      var o,\n        i = arguments[0].levels || e.config.npm.levels;\n      for (var s in i)\n        if (i.hasOwnProperty(s)) {\n          o = undefined === o || i[s] > i[o] ? s : o;\n        }\n      var a = r.apply(this, arguments);\n      a.add(\n        new t(e, {\n          level: o,\n        })\n      );\n      var c = a.configure;\n      a.configure = function () {\n        c.apply(this, arguments);\n        n.apply(this, arguments);\n      };\n      return a;\n    };\n    var a = e.createLogger;\n    e.configure = function () {\n      a.apply(this, arguments);\n      n.apply(this, arguments);\n    };\n    e.add(new t(e));\n    return e;\n  },\n};\nexports.winston2 = {\n  versionSpecifier: \"2.x\",\n  patch: function (e) {\n    var t,\n      n = e.Logger.prototype.log,\n      r = function (n, r, o) {\n        var i;\n        i =\n          t === e.config.npm.levels\n            ? \"npm\"\n            : t === e.config.syslog.levels\n            ? \"syslog\"\n            : \"unknown\";\n        s.channel.publish(\"winston\", {\n          level: n,\n          message: r,\n          meta: o,\n          levelKind: i,\n        });\n        return r;\n      };\n    e.Logger.prototype.log = function () {\n      t = this.levels;\n      if (this.filters && 0 !== this.filters.length) {\n        if (this.filters[this.filters.length - 1] !== r) {\n          this.filters = this.filters.filter(function (e) {\n            return e !== r;\n          });\n          this.filters.push(r);\n        }\n      } else {\n        this.filters = [r];\n      }\n      return n.apply(this, arguments);\n    };\n    return e;\n  },\n};\nexports.enable = function () {\n  s.channel.registerMonkeyPatch(\"winston\", exports.winston2);\n  s.channel.registerMonkeyPatch(\"winston\", exports.winston3);\n};",
  "4665": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.validateTuple = undefined;\nconst r = require(3487),\n  o = require(6776),\n  i = require(412),\n  s = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(e) {\n      const { schema: t, it: n } = e;\n      if (Array.isArray(t)) return validateTuple(e, \"additionalItems\", t);\n      n.items = !0;\n      if (o.alwaysValidSchema(n, t)) {\n        e.ok(i.validateArray(e));\n      }\n    },\n  };\nfunction validateTuple(e, t, n = e.schema) {\n  const { gen: i, parentSchema: s, data: a, keyword: c, it: l } = e;\n  !(function (e) {\n    const { opts: r, errSchemaPath: i } = l,\n      s = n.length,\n      a = s === e.minItems && (s === e.maxItems || !1 === e[t]);\n    if (r.strictTuples && !a) {\n      const e = `\"${c}\" is ${s}-tuple, but minItems or maxItems/${t} are not specified or different at path \"${i}\"`;\n      o.checkStrictMode(l, e, r.strictTuples);\n    }\n  })(s);\n  if (l.opts.unevaluated && n.length && !0 !== l.items) {\n    l.items = o.mergeEvaluated.items(i, n.length, l.items);\n  }\n  const u = i.name(\"valid\"),\n    d = i.const(\"len\", r._`${a}.length`);\n  n.forEach((t, n) => {\n    if (o.alwaysValidSchema(l, t)) {\n      i.if(r._`${d} > ${n}`, () =>\n        e.subschema(\n          {\n            keyword: c,\n            schemaProp: n,\n            dataProp: n,\n          },\n          u\n        )\n      );\n      e.ok(u);\n    }\n  });\n}\nexports.validateTuple = validateTuple;\nexports.default = s;",
  "4693": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = require(6776),\n  i = require(3510),\n  s = {\n    keyword: \"const\",\n    $data: !0,\n    error: {\n      message: \"must be equal to constant\",\n      params: ({ schemaCode: e }) => r._`{allowedValue: ${e}}`,\n    },\n    code(e) {\n      const { gen: t, data: n, $data: s, schemaCode: a, schema: c } = e;\n      if (s || (c && \"object\" == typeof c)) {\n        e.fail$data(r._`!${o.useFunc(t, i.default)}(${n}, ${a})`);\n      } else {\n        e.fail(r._`${c} !== ${n}`);\n      }\n    },\n  };\nexports.default = s;",
  "4694": "function t(e) {\n  var t = new Error(\"Cannot find module '\" + e + \"'\");\n  throw ((t.code = \"MODULE_NOT_FOUND\"), t);\n}\nt.keys = () => [];\nt.resolve = t;\nt.id = 4694;\nmodule.exports = t;",
  "4723": "var r =\n    (this && this.__createBinding) ||\n    (Object.create\n      ? function (e, t, n, r) {\n          if (undefined === r) {\n            r = n;\n          }\n          Object.defineProperty(e, r, {\n            enumerable: !0,\n            get: function () {\n              return t[n];\n            },\n          });\n        }\n      : function (e, t, n, r) {\n          if (undefined === r) {\n            r = n;\n          }\n          e[r] = t[n];\n        }),\n  o =\n    (this && this.__exportStar) ||\n    function (e, t) {\n      for (var n in e)\n        if (\"default\" === n || Object.prototype.hasOwnProperty.call(t, n)) {\n          r(t, e, n);\n        }\n    };\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.createWorker =\n  exports.FileSystem =\n  exports.comment =\n  exports.languageCommentMarkers =\n    undefined;\nconst i = require(\"path\"),\n  s = require(\"worker_threads\");\no(require(464), exports);\no(require(9940), exports);\no(require(1747), exports);\no(require(9852), exports);\nvar a = require(1788);\nexports.languageCommentMarkers = a.languageCommentMarkers;\nexports.comment = a.comment;\nvar c = require(5012);\nexports.FileSystem = c.FileSystem;\nexports.createWorker = function () {\n  return new s.Worker(i.resolve(__dirname, \"..\", \"dist\", \"worker.js\"));\n};",
  "4775": "module.exports = JSON.parse(\n  '{\"$id\":\"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\"description\":\"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\"type\":\"object\",\"required\":[\"$data\"],\"properties\":{\"$data\":{\"type\":\"string\",\"anyOf\":[{\"format\":\"relative-json-pointer\"},{\"format\":\"json-pointer\"}]}},\"additionalProperties\":false}'\n);",
  "4777": "var r = require(4953),\n  o = [];\nexports.qP = function (e) {\n  o.forEach(function (t) {\n    var n = e.data.query || {},\n      r = n.sql || \"Unknown query\",\n      o = !e.data.err,\n      i = (n._connection || {}).config || {},\n      s = i.socketPath ? i.socketPath : (i.host || \"localhost\") + \":\" + i.port;\n    t.trackDependency({\n      target: s,\n      data: r,\n      name: r,\n      duration: e.data.duration,\n      success: o,\n      resultCode: o ? \"0\" : \"1\",\n      dependencyTypeName: \"mysql\",\n    });\n  });\n};\nexports.wp = function (e, n) {\n  if (e) {\n    if (0 === o.length) {\n      r.channel.subscribe(\"mysql\", exports.qP);\n    }\n    o.push(n);\n  } else {\n    if (\n      0 ===\n      (o = o.filter(function (e) {\n        return e != n;\n      })).length\n    ) {\n      r.channel.unsubscribe(\"mysql\", exports.qP);\n    }\n  }\n};",
  "4783": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.validateAdditionalItems = undefined;\nconst r = require(3487),\n  o = require(6776),\n  i = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    before: \"uniqueItems\",\n    error: {\n      message: ({ params: { len: e } }) =>\n        r.str`must NOT have more than ${e} items`,\n      params: ({ params: { len: e } }) => r._`{limit: ${e}}`,\n    },\n    code(e) {\n      const { parentSchema: t, it: n } = e,\n        { items: r } = t;\n      if (Array.isArray(r)) {\n        validateAdditionalItems(e, r);\n      } else {\n        o.checkStrictMode(\n          n,\n          '\"additionalItems\" is ignored when \"items\" is not an array of schemas'\n        );\n      }\n    },\n  };\nfunction validateAdditionalItems(e, t) {\n  const { gen: n, schema: i, data: s, keyword: a, it: c } = e;\n  c.items = !0;\n  const l = n.const(\"len\", r._`${s}.length`);\n  if (!1 === i) {\n    e.setParams({\n      len: t.length,\n    });\n    e.pass(r._`${l} <= ${t.length}`);\n  } else if (\"object\" == typeof i && !o.alwaysValidSchema(c, i)) {\n    const i = n.var(\"valid\", r._`${l} <= ${t.length}`);\n    n.if(r.not(i), () =>\n      (function (i) {\n        n.forRange(\"i\", t.length, l, (t) => {\n          e.subschema(\n            {\n              keyword: a,\n              dataProp: t,\n              dataPropType: o.Type.Num,\n            },\n            i\n          );\n          if (c.allErrors) {\n            n.if(r.not(i), () => n.break());\n          }\n        });\n      })(i)\n    );\n    e.ok(i);\n  }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports.default = i;",
  "4815": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = undefined;\nconst r = require(5667),\n  o = require(453),\n  i = require(8876),\n  s = require(453),\n  a = require(313),\n  c = require(5005),\n  l = require(3099),\n  u = require(3487),\n  d = require(2141),\n  p = require(2531),\n  h = require(6776),\n  f = require(4181);\nfunction m({ gen: e, validateName: t, schema: n, schemaEnv: r, opts: o }, i) {\n  if (o.code.es5) {\n    e.func(t, u._`${d.default.data}, ${d.default.valCxt}`, r.$async, () => {\n      e.code(u._`\"use strict\"; ${g(n, o)}`);\n      (function (e, t) {\n        e.if(\n          d.default.valCxt,\n          () => {\n            e.var(\n              d.default.instancePath,\n              u._`${d.default.valCxt}.${d.default.instancePath}`\n            );\n            e.var(\n              d.default.parentData,\n              u._`${d.default.valCxt}.${d.default.parentData}`\n            );\n            e.var(\n              d.default.parentDataProperty,\n              u._`${d.default.valCxt}.${d.default.parentDataProperty}`\n            );\n            e.var(\n              d.default.rootData,\n              u._`${d.default.valCxt}.${d.default.rootData}`\n            );\n            if (t.dynamicRef) {\n              e.var(\n                d.default.dynamicAnchors,\n                u._`${d.default.valCxt}.${d.default.dynamicAnchors}`\n              );\n            }\n          },\n          () => {\n            e.var(d.default.instancePath, u._`\"\"`);\n            e.var(d.default.parentData, u._`undefined`);\n            e.var(d.default.parentDataProperty, u._`undefined`);\n            e.var(d.default.rootData, d.default.data);\n            if (t.dynamicRef) {\n              e.var(d.default.dynamicAnchors, u._`{}`);\n            }\n          }\n        );\n      })(e, o);\n      e.code(i);\n    });\n  } else {\n    e.func(\n      t,\n      u._`${d.default.data}, ${(function (e) {\n        return u._`{${d.default.instancePath}=\"\", ${d.default.parentData}, ${\n          d.default.parentDataProperty\n        }, ${d.default.rootData}=${d.default.data}${\n          e.dynamicRef ? u._`, ${d.default.dynamicAnchors}={}` : u.nil\n        }}={}`;\n      })(o)}`,\n      r.$async,\n      () => e.code(g(n, o)).code(i)\n    );\n  }\n}\nfunction g(e, t) {\n  const n = \"object\" == typeof e && e[t.schemaId];\n  return n && (t.code.source || t.code.process)\n    ? u._`/*# sourceURL=${n} */`\n    : u.nil;\n}\nfunction _({ schema: e, self: t }) {\n  if (\"boolean\" == typeof e) return !e;\n  for (const n in e) if (t.RULES.all[n]) return !0;\n  return !1;\n}\nfunction y(e) {\n  return \"boolean\" != typeof e.schema;\n}\nfunction v(e) {\n  h.checkUnknownRules(e);\n  (function (e) {\n    const { schema: t, errSchemaPath: n, opts: r, self: o } = e;\n    if (\n      t.$ref &&\n      r.ignoreKeywordsWithRef &&\n      h.schemaHasRulesButRef(t, o.RULES)\n    ) {\n      o.logger.warn(`$ref: keywords ignored in schema at path \"${n}\"`);\n    }\n  })(e);\n}\nfunction b(e, t) {\n  if (e.opts.jtd) return x(e, [], !1, t);\n  const n = o.getSchemaTypes(e.schema);\n  x(e, n, !o.coerceAndCheckDataType(e, n), t);\n}\nfunction w({ gen: e, schemaEnv: t, schema: n, errSchemaPath: r, opts: o }) {\n  const i = n.$comment;\n  if (!0 === o.$comment) e.code(u._`${d.default.self}.logger.log(${i})`);\n  else if (\"function\" == typeof o.$comment) {\n    const n = u.str`${r}/$comment`,\n      o = e.scopeValue(\"root\", {\n        ref: t.root,\n      });\n    e.code(u._`${d.default.self}.opts.$comment(${i}, ${n}, ${o}.schema)`);\n  }\n}\nfunction x(e, t, n, r) {\n  const { gen: o, schema: a, data: c, allErrors: l, opts: p, self: f } = e,\n    { RULES: m } = f;\n  function g(h) {\n    if (i.shouldUseGroup(a, h)) {\n      if (h.type) {\n        o.if(s.checkDataType(h.type, c, p.strictNumbers));\n        E(e, h);\n        if (1 === t.length && t[0] === h.type && n) {\n          o.else();\n          s.reportTypeError(e);\n        }\n        o.endIf();\n      } else {\n        E(e, h);\n      }\n      if (l) {\n        o.if(u._`${d.default.errors} === ${r || 0}`);\n      }\n    }\n  }\n  if (!a.$ref || (!p.ignoreKeywordsWithRef && h.schemaHasRulesButRef(a, m))) {\n    if (p.jtd) {\n      (function (e, t) {\n        if (!e.schemaEnv.meta && e.opts.strictTypes) {\n          (function (e, t) {\n            if (t.length) {\n              if (e.dataTypes.length) {\n                t.forEach((t) => {\n                  if (C(e.dataTypes, t)) {\n                    S(\n                      e,\n                      `type \"${t}\" not allowed by context \"${e.dataTypes.join(\n                        \",\"\n                      )}\"`\n                    );\n                  }\n                });\n                e.dataTypes = e.dataTypes.filter((e) => C(t, e));\n              } else {\n                e.dataTypes = t;\n              }\n            }\n          })(e, t);\n          if (e.opts.allowUnionTypes) {\n            (function (e, t) {\n              if (t.length > 1 && (2 !== t.length || !t.includes(\"null\"))) {\n                S(e, \"use allowUnionTypes to allow union type keyword\");\n              }\n            })(e, t);\n          }\n          (function (e, t) {\n            const n = e.self.RULES.all;\n            for (const r in n) {\n              const o = n[r];\n              if (\"object\" == typeof o && i.shouldUseRule(e.schema, o)) {\n                const { type: n } = o.definition;\n                if (\n                  n.length &&\n                  !n.some((e) => {\n                    r = e;\n                    return (\n                      (n = t).includes(r) ||\n                      (\"number\" === r && n.includes(\"integer\"))\n                    );\n                    var n, r;\n                  })\n                ) {\n                  S(e, `missing type \"${n.join(\",\")}\" for keyword \"${r}\"`);\n                }\n              }\n            }\n          })(e, e.dataTypes);\n        }\n      })(e, t);\n    }\n    o.block(() => {\n      for (const e of m.rules) g(e);\n      g(m.post);\n    });\n  } else {\n    o.block(() => k(e, \"$ref\", m.all.$ref.definition));\n  }\n}\nfunction E(e, t) {\n  const {\n    gen: n,\n    schema: r,\n    opts: { useDefaults: o },\n  } = e;\n  if (o) {\n    a.assignDefaults(e, t.type);\n  }\n  n.block(() => {\n    for (const n of t.rules)\n      if (i.shouldUseRule(r, n)) {\n        k(e, n.keyword, n.definition, t.type);\n      }\n  });\n}\nfunction C(e, t) {\n  return e.includes(t) || (\"integer\" === t && e.includes(\"number\"));\n}\nfunction S(e, t) {\n  t += ` at \"${e.schemaEnv.baseId + e.errSchemaPath}\" (strictTypes)`;\n  h.checkStrictMode(e, t, e.opts.strictTypes);\n}\nexports.validateFunctionCode = function (e) {\n  if (y(e) && (v(e), _(e))) {\n    (function (e) {\n      const { schema: t, opts: n, gen: r } = e;\n      m(e, () => {\n        if (n.$comment && t.$comment) {\n          w(e);\n        }\n        (function (e) {\n          const { schema: t, opts: n } = e;\n          if (undefined !== t.default && n.useDefaults && n.strictSchema) {\n            h.checkStrictMode(e, \"default is ignored in the schema root\");\n          }\n        })(e);\n        r.let(d.default.vErrors, null);\n        r.let(d.default.errors, 0);\n        if (n.unevaluated) {\n          (function (e) {\n            const { gen: t, validateName: n } = e;\n            e.evaluated = t.const(\"evaluated\", u._`${n}.evaluated`);\n            t.if(u._`${e.evaluated}.dynamicProps`, () =>\n              t.assign(u._`${e.evaluated}.props`, u._`undefined`)\n            );\n            t.if(u._`${e.evaluated}.dynamicItems`, () =>\n              t.assign(u._`${e.evaluated}.items`, u._`undefined`)\n            );\n          })(e);\n        }\n        b(e);\n        (function (e) {\n          const {\n            gen: t,\n            schemaEnv: n,\n            validateName: r,\n            ValidationError: o,\n            opts: i,\n          } = e;\n          if (n.$async) {\n            t.if(\n              u._`${d.default.errors} === 0`,\n              () => t.return(d.default.data),\n              () => t.throw(u._`new ${o}(${d.default.vErrors})`)\n            );\n          } else {\n            t.assign(u._`${r}.errors`, d.default.vErrors);\n            if (i.unevaluated) {\n              (function ({ gen: e, evaluated: t, props: n, items: r }) {\n                if (n instanceof u.Name) {\n                  e.assign(u._`${t}.props`, n);\n                }\n                if (r instanceof u.Name) {\n                  e.assign(u._`${t}.items`, r);\n                }\n              })(e);\n            }\n            t.return(u._`${d.default.errors} === 0`);\n          }\n        })(e);\n      });\n    })(e);\n  } else {\n    m(e, () => r.topBoolOrEmptySchema(e));\n  }\n};\nclass KeywordCxt {\n  constructor(e, t, n) {\n    c.validateKeywordUsage(e, t, n);\n    this.gen = e.gen;\n    this.allErrors = e.allErrors;\n    this.keyword = n;\n    this.data = e.data;\n    this.schema = e.schema[n];\n    this.$data = t.$data && e.opts.$data && this.schema && this.schema.$data;\n    this.schemaValue = h.schemaRefOrVal(e, this.schema, n, this.$data);\n    this.schemaType = t.schemaType;\n    this.parentSchema = e.schema;\n    this.params = {};\n    this.it = e;\n    this.def = t;\n    if (this.$data)\n      this.schemaCode = e.gen.const(\"vSchema\", getData(this.$data, e));\n    else if (\n      ((this.schemaCode = this.schemaValue),\n      !(0, c.validSchemaType)(this.schema, t.schemaType, t.allowUndefined))\n    )\n      throw new Error(`${n} value must be ${JSON.stringify(t.schemaType)}`);\n    if (\"code\" in t ? t.trackErrors : !1 !== t.errors) {\n      this.errsCount = e.gen.const(\"_errs\", d.default.errors);\n    }\n  }\n  result(e, t, n) {\n    this.failResult(u.not(e), t, n);\n  }\n  failResult(e, t, n) {\n    this.gen.if(e);\n    if (n) {\n      n();\n    } else {\n      this.error();\n    }\n    if (t) {\n      this.gen.else();\n      t();\n      if (this.allErrors) {\n        this.gen.endIf();\n      }\n    } else {\n      if (this.allErrors) {\n        this.gen.endIf();\n      } else {\n        this.gen.else();\n      }\n    }\n  }\n  pass(e, t) {\n    this.failResult(u.not(e), undefined, t);\n  }\n  fail(e) {\n    if (undefined === e) {\n      this.error();\n      return void (this.allErrors || this.gen.if(!1));\n    }\n    this.gen.if(e);\n    this.error();\n    if (this.allErrors) {\n      this.gen.endIf();\n    } else {\n      this.gen.else();\n    }\n  }\n  fail$data(e) {\n    if (!this.$data) return this.fail(e);\n    const { schemaCode: t } = this;\n    this.fail(u._`${t} !== undefined && (${u.or(this.invalid$data(), e)})`);\n  }\n  error(e, t, n) {\n    if (t) {\n      this.setParams(t);\n      this._error(e, n);\n      return void this.setParams({});\n    }\n    this._error(e, n);\n  }\n  _error(e, t) {\n    (e ? f.reportExtraError : f.reportError)(this, this.def.error, t);\n  }\n  $dataError() {\n    f.reportError(this, this.def.$dataError || f.keyword$DataError);\n  }\n  reset() {\n    if (undefined === this.errsCount)\n      throw new Error('add \"trackErrors\" to keyword definition');\n    f.resetErrorsCount(this.gen, this.errsCount);\n  }\n  ok(e) {\n    if (this.allErrors) {\n      this.gen.if(e);\n    }\n  }\n  setParams(e, t) {\n    if (t) {\n      Object.assign(this.params, e);\n    } else {\n      this.params = e;\n    }\n  }\n  block$data(e, t, n = u.nil) {\n    this.gen.block(() => {\n      this.check$data(e, n);\n      t();\n    });\n  }\n  check$data(e = u.nil, t = u.nil) {\n    if (!this.$data) return;\n    const { gen: n, schemaCode: r, schemaType: o, def: i } = this;\n    n.if(u.or(u._`${r} === undefined`, t));\n    if (e !== u.nil) {\n      n.assign(e, !0);\n    }\n    if (o.length || i.validateSchema) {\n      n.elseIf(this.invalid$data());\n      this.$dataError();\n      if (e !== u.nil) {\n        n.assign(e, !1);\n      }\n    }\n    n.else();\n  }\n  invalid$data() {\n    const { gen: e, schemaCode: t, schemaType: n, def: r, it: o } = this;\n    return u.or(\n      (function () {\n        if (n.length) {\n          if (!(t instanceof u.Name))\n            throw new Error(\"ajv implementation error\");\n          const e = Array.isArray(n) ? n : [n];\n          return u._`${s.checkDataTypes(\n            e,\n            t,\n            o.opts.strictNumbers,\n            s.DataType.Wrong\n          )}`;\n        }\n        return u.nil;\n      })(),\n      (function () {\n        if (r.validateSchema) {\n          const n = e.scopeValue(\"validate$data\", {\n            ref: r.validateSchema,\n          });\n          return u._`!${n}(${t})`;\n        }\n        return u.nil;\n      })()\n    );\n  }\n  subschema(e, t) {\n    const n = l.getSubschema(this.it, e);\n    l.extendSubschemaData(n, this.it, e);\n    l.extendSubschemaMode(n, e);\n    const o = {\n      ...this.it,\n      ...n,\n      items: undefined,\n      props: undefined,\n    };\n    (function (e, t) {\n      if (y(e) && (v(e), _(e))) {\n        (function (e, t) {\n          const { schema: n, gen: r, opts: o } = e;\n          if (o.$comment && n.$comment) {\n            w(e);\n          }\n          (function (e) {\n            const t = e.schema[e.opts.schemaId];\n            if (t) {\n              e.baseId = p.resolveUrl(e.baseId, t);\n            }\n          })(e);\n          (function (e) {\n            if (e.schema.$async && !e.schemaEnv.$async)\n              throw new Error(\"async schema in sync schema\");\n          })(e);\n          const i = r.const(\"_errs\", d.default.errors);\n          b(e, i);\n          r.var(t, u._`${i} === ${d.default.errors}`);\n        })(e, t);\n      } else {\n        r.boolOrEmptySchema(e, t);\n      }\n    })(o, t);\n    return o;\n  }\n  mergeEvaluated(e, t) {\n    const { it: n, gen: r } = this;\n    if (n.opts.unevaluated) {\n      if (!0 !== n.props && undefined !== e.props) {\n        n.props = h.mergeEvaluated.props(r, e.props, n.props, t);\n      }\n      if (!0 !== n.items && undefined !== e.items) {\n        n.items = h.mergeEvaluated.items(r, e.items, n.items, t);\n      }\n    }\n  }\n  mergeValidEvaluated(e, t) {\n    const { it: n, gen: r } = this;\n    if (n.opts.unevaluated && (!0 !== n.props || !0 !== n.items)) {\n      r.if(t, () => this.mergeEvaluated(e, u.Name));\n      return !0;\n    }\n  }\n}\nfunction k(e, t, n, r) {\n  const o = new KeywordCxt(e, n, t);\n  if (\"code\" in n) {\n    n.code(o, r);\n  } else {\n    if (o.$data && n.validate) {\n      c.funcKeywordCode(o, n);\n    } else {\n      if (\"macro\" in n) {\n        c.macroKeywordCode(o, n);\n      } else {\n        if (n.compile || n.validate) {\n          c.funcKeywordCode(o, n);\n        }\n      }\n    }\n  }\n}\nexports.KeywordCxt = KeywordCxt;\nconst I = /^\\/(?:[^~]|~0|~1)*$/,\n  P = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData(e, { dataLevel: t, dataNames: n, dataPathArr: r }) {\n  let o, i;\n  if (\"\" === e) return d.default.rootData;\n  if (\"/\" === e[0]) {\n    if (!I.test(e)) throw new Error(`Invalid JSON-pointer: ${e}`);\n    o = e;\n    i = d.default.rootData;\n  } else {\n    const s = P.exec(e);\n    if (!s) throw new Error(`Invalid JSON-pointer: ${e}`);\n    const a = +s[1];\n    o = s[2];\n    if (\"#\" === o) {\n      if (a >= t) throw new Error(c(\"property/index\", a));\n      return r[t - a];\n    }\n    if (a > t) throw new Error(c(\"data\", a));\n    i = n[t - a];\n    if (!o) return i;\n  }\n  let s = i;\n  const a = o.split(\"/\");\n  for (const e of a)\n    if (e) {\n      i = u._`${i}${u.getProperty(h.unescapeJsonPointer(e))}`;\n      s = u._`${s} && ${i}`;\n    }\n  return s;\n  function c(e, n) {\n    return `Cannot access ${e} ${n} levels up, current level is ${t}`;\n  }\n}\nexports.getData = getData;",
  "4855": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getWindowsDelineations = undefined;\nconst r = require(5288),\n  o = require(9829);\nexports.getWindowsDelineations = function (e, t, n, i) {\n  if (e.length < n || 0 == i) return [];\n  const s = [],\n    a = o.clearLabels(r.parseTree(e.join(\"\\n\"), t));\n  o.visitTree(\n    a,\n    (e) => {\n      if (\"blank\" === e.type)\n        return void (e.label = {\n          totalLength: 1,\n          firstLineAfter: e.lineNumber + 1,\n        });\n      let t = \"line\" === e.type ? 1 : 0,\n        r = \"line\" === e.type ? e.lineNumber + 1 : NaN;\n      function o(n) {\n        return -1 == n\n          ? r - t\n          : e.subs[n].label.firstLineAfter - e.subs[n].label.totalLength;\n      }\n      function a(t, n) {\n        return 0 == t ? n + 1 : e.subs[t - 1].label.firstLineAfter;\n      }\n      let c = \"line\" === e.type ? -1 : 0,\n        l = \"line\" === e.type ? 1 : 0,\n        u = 0;\n      for (let d = 0; d < e.subs.length; d++) {\n        for (; c >= 0 && c < e.subs.length && \"blank\" === e.subs[c].type; ) {\n          l -= e.subs[c].label.totalLength;\n          c++;\n        }\n        if (\"blank\" !== e.subs[d].type) {\n          u = d;\n        }\n        r = e.subs[d].label.firstLineAfter;\n        t += e.subs[d].label.totalLength;\n        l += e.subs[d].label.totalLength;\n        if (l > i) {\n          const t = o(c),\n            r = a(d, t),\n            p = u == d ? r : a(u, t);\n          for (n <= r - t && s.push([t, p]); l > i; )\n            (l -=\n              -1 == c\n                ? \"line\" == e.type\n                  ? 1\n                  : 0\n                : e.subs[c].label.totalLength),\n              c++;\n        }\n      }\n      if (c < e.subs.length) {\n        const t = o(c),\n          i = r,\n          a = -1 == c ? i : e.subs[u].label.firstLineAfter;\n        if (n <= i - t) {\n          s.push([t, a]);\n        }\n      }\n      e.label = {\n        totalLength: t,\n        firstLineAfter: r,\n      };\n    },\n    \"bottomUp\"\n  );\n  return s\n    .sort((e, t) => e[0] - t[0] || e[1] - t[1])\n    .filter((e, t, n) => 0 == t || e[0] != n[t - 1][0] || e[1] != n[t - 1][1]);\n};",
  "4938": "var r, o, i, s, a, c;\nr = require(8249);\ni = (o = r).lib;\ns = i.Base;\na = i.WordArray;\n(c = o.x64 = {}).Word = s.extend({\n  init: function (e, t) {\n    this.high = e;\n    this.low = t;\n  },\n});\nc.WordArray = s.extend({\n  init: function (e, t) {\n    e = this.words = e || [];\n    this.sigBytes = null != t ? t : 8 * e.length;\n  },\n  toX32: function () {\n    for (var e = this.words, t = e.length, n = [], r = 0; r < t; r++) {\n      var o = e[r];\n      n.push(o.high);\n      n.push(o.low);\n    }\n    return a.create(n, this.sigBytes);\n  },\n  clone: function () {\n    for (\n      var e = s.clone.call(this),\n        t = (e.words = this.words.slice(0)),\n        n = t.length,\n        r = 0;\n      r < n;\n      r++\n    )\n      t[r] = t[r].clone();\n    return e;\n  },\n});\nmodule.exports = r;",
  "4953": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r = require(7424),\n  o = require(7424);\nexports.makePatchingRequire = o.makePatchingRequire;\nvar i = function (e) {\n    return !0;\n  },\n  s = (function () {\n    function e() {\n      this.version = require(130).i8;\n      this.subscribers = {};\n      this.contextPreservationFunction = function (e) {\n        return e;\n      };\n      this.knownPatches = {};\n      this.currentlyPublishing = !1;\n    }\n    e.prototype.shouldPublish = function (e) {\n      var t = this.subscribers[e];\n      return (\n        !!t &&\n        t.some(function (e) {\n          var t = e.filter;\n          return !t || t(!1);\n        })\n      );\n    };\n    e.prototype.publish = function (e, t) {\n      if (!this.currentlyPublishing) {\n        var n = this.subscribers[e];\n        if (n) {\n          var r = {\n            timestamp: Date.now(),\n            data: t,\n          };\n          this.currentlyPublishing = !0;\n          n.forEach(function (e) {\n            var t = e.listener,\n              n = e.filter;\n            try {\n              if (n && n(!0)) {\n                t(r);\n              }\n            } catch (e) {}\n          });\n          this.currentlyPublishing = !1;\n        }\n      }\n    };\n    e.prototype.subscribe = function (e, t, n) {\n      if (undefined === n) {\n        n = i;\n      }\n      if (this.subscribers[e]) {\n        this.subscribers[e] = [];\n      }\n      this.subscribers[e].push({\n        listener: t,\n        filter: n,\n      });\n    };\n    e.prototype.unsubscribe = function (e, t, n) {\n      if (undefined === n) {\n        n = i;\n      }\n      var r = this.subscribers[e];\n      if (r)\n        for (var o = 0; o < r.length; ++o)\n          if (r[o].listener === t && r[o].filter === n) {\n            r.splice(o, 1);\n            return !0;\n          }\n      return !1;\n    };\n    e.prototype.reset = function () {\n      var e = this;\n      this.subscribers = {};\n      this.contextPreservationFunction = function (e) {\n        return e;\n      };\n      Object.getOwnPropertyNames(this.knownPatches).forEach(function (t) {\n        return delete e.knownPatches[t];\n      });\n    };\n    e.prototype.bindToContext = function (e) {\n      return this.contextPreservationFunction(e);\n    };\n    e.prototype.addContextPreservation = function (e) {\n      var t = this.contextPreservationFunction;\n      this.contextPreservationFunction = function (n) {\n        return e(t(n));\n      };\n    };\n    e.prototype.registerMonkeyPatch = function (e, t) {\n      if (this.knownPatches[e]) {\n        this.knownPatches[e] = [];\n      }\n      this.knownPatches[e].push(t);\n    };\n    e.prototype.getPatchesObject = function () {\n      return this.knownPatches;\n    };\n    return e;\n  })();\nif (global.diagnosticsSource) {\n  global.diagnosticsSource = new s();\n  require(\"module\").prototype.require = r.makePatchingRequire(\n    global.diagnosticsSource.getPatchesObject()\n  );\n}\nexports.channel = global.diagnosticsSource;",
  "4969": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.extractPrompt =\n  exports.trimLastLine =\n  exports._contextTooShort =\n  exports.MIN_PROMPT_CHARS =\n    undefined;\nconst r = require(3055563),\n  o = require(1133),\n  i = require(1839),\n  s = require(9189),\n  a = require(3136),\n  c = require(2533),\n  l = require(766);\nfunction trimLastLine(e) {\n  const t = e.split(\"\\n\"),\n    n = t[t.length - 1],\n    r = n.length - n.trimRight().length,\n    o = e.slice(0, e.length - r),\n    i = e.substr(o.length);\n  return [n.length == r ? o : e, i];\n}\nasync function d(e, n, d, p, h, f) {\n  var m;\n  const g =\n      null !==\n        (m = l.tryGetGitHubNWO(l.extractRepoInfoInBackground(e, h.fsPath))) &&\n      undefined !== m\n        ? m\n        : \"\",\n    _ = await o.suffixPercent(e, g, f),\n    y = await o.fimSuffixLengthThreshold(e, g, f);\n  if ((_ > 0 ? n.length : d) < exports.MIN_PROMPT_CHARS)\n    return exports._contextTooShort;\n  const v = Date.now(),\n    {\n      prefix: b,\n      suffix: w,\n      promptChoices: x,\n      promptBackground: E,\n      promptElementRanges: C,\n    } = await (async function (e, t, n, u, d, p) {\n      var h;\n      let f = [];\n      f = await (async function (e, t, n) {\n        const r = [],\n          o = i.sortByAccessTimes(e.get(a.TextDocumentManager).textDocuments);\n        let s = 0;\n        for (const i of o) {\n          if (r.length + 1 > 20 || s + i.getText().length > 2e5) break;\n          if (\n            \"file\" == i.uri.scheme &&\n            i.fileName !== t &&\n            i.languageId === n\n          ) {\n            r.push({\n              uri: i.uri.toString(),\n              relativePath: await e\n                .get(a.TextDocumentManager)\n                .getRelativePath(i),\n              languageId: i.languageId,\n              source: i.getText(),\n            });\n            s += i.getText().length;\n          }\n        }\n        return r;\n      })(e, d.fsPath, p);\n      const m = {\n          uri: d.toString(),\n          source: t,\n          offset: n,\n          relativePath: u,\n          languageId: p,\n        },\n        g =\n          null !==\n            (h = l.tryGetGitHubNWO(\n              l.extractRepoInfoInBackground(e, d.fsPath)\n            )) && undefined !== h\n            ? h\n            : \"\";\n      let _ = {\n        maxPromptLength: 2048 - o.getConfig(e, o.ConfigKey.SolutionLength),\n        neighboringTabs: await e.get(s.Features).neighboringTabsOption(g, p),\n        suffixStartMode: await e.get(s.Features).suffixStartMode(g, p),\n      };\n      const y = await o.suffixPercent(e, g, p),\n        v = await o.suffixMatchThreshold(e, g, p),\n        b = await o.fimSuffixLengthThreshold(e, g, p);\n      if (y > 0) {\n        _ = {\n          ..._,\n          includeSiblingFunctions: r.SiblingOption.NoSiblings,\n          suffixPercent: y,\n          suffixMatchThreshold: v,\n          fimSuffixLengthThreshold: b,\n        };\n      }\n      const w = e.get(r.FileSystem);\n      return await c.getPrompt(w, m, _, f);\n    })(e, n, d, p, h, f),\n    [S, T] = trimLastLine(b),\n    k = Date.now();\n  return {\n    type: \"prompt\",\n    prompt: {\n      prefix: S,\n      suffix: w,\n      isFimEnabled: _ > 0 && w.length > y,\n      promptElementRanges: C.ranges,\n    },\n    trailingWs: T,\n    promptChoices: x,\n    computeTimeMs: k - v,\n    promptBackground: E,\n  };\n}\nasync function p(e, t, n) {\n  const r = await e.get(a.TextDocumentManager).getRelativePath(t);\n  return d(e, t.getText(), t.offsetAt(n), r, t.uri, t.languageId);\n}\nexports.MIN_PROMPT_CHARS = 10;\nexports._contextTooShort = {\n  type: \"contextTooShort\",\n};\nexports.trimLastLine = trimLastLine;\nexports.extractPrompt = function (e, t, n) {\n  const r = e.get(a.TextDocumentManager).findNotebook(t);\n  return undefined === r\n    ? p(e, t, n)\n    : (async function (e, t, n, r) {\n        const o = n.getCells().find((e) => e.document.uri === t.uri);\n        if (o) {\n          const i = n\n              .getCells()\n              .filter(\n                (e) =>\n                  e.index < o.index &&\n                  e.document.languageId === o.document.languageId\n              ),\n            s =\n              i.length > 0\n                ? i.map((e) => e.document.getText()).join(\"\\n\\n\") + \"\\n\\n\"\n                : \"\",\n            c = s + t.getText(),\n            l = s.length + t.offsetAt(r),\n            u = await e.get(a.TextDocumentManager).getRelativePath(t);\n          return d(e, c, l, u, t.uri, o.document.languageId);\n        }\n        return p(e, t, r);\n      })(e, t, r, n);\n};",
  "5005": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.validateKeywordUsage =\n  exports.validSchemaType =\n  exports.funcKeywordCode =\n  exports.macroKeywordCode =\n    undefined;\nconst r = require(3487),\n  o = require(2141),\n  i = require(412),\n  s = require(4181);\nfunction a(e) {\n  const { gen: t, data: n, it: o } = e;\n  t.if(o.parentData, () =>\n    t.assign(n, r._`${o.parentData}[${o.parentDataProperty}]`)\n  );\n}\nfunction c(e, t, n) {\n  if (undefined === n) throw new Error(`keyword \"${t}\" failed to compile`);\n  return e.scopeValue(\n    \"keyword\",\n    \"function\" == typeof n\n      ? {\n          ref: n,\n        }\n      : {\n          ref: n,\n          code: r.stringify(n),\n        }\n  );\n}\nexports.macroKeywordCode = function (e, t) {\n  const { gen: n, keyword: o, schema: i, parentSchema: s, it: a } = e,\n    l = t.macro.call(a.self, i, s, a),\n    u = c(n, o, l);\n  if (!1 !== a.opts.validateSchema) {\n    a.self.validateSchema(l, !0);\n  }\n  const d = n.name(\"valid\");\n  e.subschema(\n    {\n      schema: l,\n      schemaPath: r.nil,\n      errSchemaPath: `${a.errSchemaPath}/${o}`,\n      topSchemaRef: u,\n      compositeRule: !0,\n    },\n    d\n  );\n  e.pass(d, () => e.error(!0));\n};\nexports.funcKeywordCode = function (e, t) {\n  var n;\n  const { gen: l, keyword: u, schema: d, parentSchema: p, $data: h, it: f } = e;\n  !(function ({ schemaEnv: e }, t) {\n    if (t.async && !e.$async) throw new Error(\"async keyword in sync schema\");\n  })(f, t);\n  const m = !h && t.compile ? t.compile.call(f.self, d, p, f) : t.validate,\n    g = c(l, u, m),\n    _ = l.let(\"valid\");\n  function y(n = t.async ? r._`await ` : r.nil) {\n    const s = f.opts.passContext ? o.default.this : o.default.self,\n      a = !((\"compile\" in t && !h) || !1 === t.schema);\n    l.assign(_, r._`${n}${i.callValidateCode(e, g, s, a)}`, t.modifying);\n  }\n  function v(e) {\n    var n;\n    l.if(r.not(null !== (n = t.valid) && undefined !== n ? n : _), e);\n  }\n  e.block$data(_, function () {\n    if (!1 === t.errors) {\n      y();\n      if (t.modifying) {\n        a(e);\n      }\n      v(() => e.error());\n    } else {\n      const n = t.async\n        ? (function () {\n            const e = l.let(\"ruleErrs\", null);\n            l.try(\n              () => y(r._`await `),\n              (t) =>\n                l.assign(_, !1).if(\n                  r._`${t} instanceof ${f.ValidationError}`,\n                  () => l.assign(e, r._`${t}.errors`),\n                  () => l.throw(t)\n                )\n            );\n            return e;\n          })()\n        : (function () {\n            const e = r._`${g}.errors`;\n            l.assign(e, null);\n            y(r.nil);\n            return e;\n          })();\n      if (t.modifying) {\n        a(e);\n      }\n      v(() =>\n        (function (e, t) {\n          const { gen: n } = e;\n          n.if(\n            r._`Array.isArray(${t})`,\n            () => {\n              n.assign(\n                o.default.vErrors,\n                r._`${o.default.vErrors} === null ? ${t} : ${o.default.vErrors}.concat(${t})`\n              ).assign(o.default.errors, r._`${o.default.vErrors}.length`);\n              s.extendErrors(e);\n            },\n            () => e.error()\n          );\n        })(e, n)\n      );\n    }\n  });\n  e.ok(null !== (n = t.valid) && undefined !== n ? n : _);\n};\nexports.validSchemaType = function (e, t, n = !1) {\n  return (\n    !t.length ||\n    t.some((t) =>\n      \"array\" === t\n        ? Array.isArray(e)\n        : \"object\" === t\n        ? e && \"object\" == typeof e && !Array.isArray(e)\n        : typeof e == t || (n && undefined === e)\n    )\n  );\n};\nexports.validateKeywordUsage = function (\n  { schema: e, opts: t, self: n, errSchemaPath: r },\n  o,\n  i\n) {\n  if (Array.isArray(o.keyword) ? !o.keyword.includes(i) : o.keyword !== i)\n    throw new Error(\"ajv implementation error\");\n  const s = o.dependencies;\n  if (\n    null == s\n      ? undefined\n      : s.some((t) => !Object.prototype.hasOwnProperty.call(e, t))\n  )\n    throw new Error(\n      `parent schema must have dependencies of ${i}: ${s.join(\",\")}`\n    );\n  if (o.validateSchema && !o.validateSchema(e[i])) {\n    const e =\n      `keyword \"${i}\" value is invalid at path \"${r}\": ` +\n      n.errorsText(o.validateSchema.errors);\n    if (\"log\" !== t.validateSchema) throw new Error(e);\n    n.logger.error(e);\n  }\n};",
  "5012": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.defaultFileSystem = exports.FileSystem = undefined;\nconst r = require(\"fs\");\nexports.FileSystem = class {};\nexports.defaultFileSystem = {\n  readFile: (e) => r.promises.readFile(e),\n  mtime: async (e) => (await r.promises.stat(e)).mtimeMs,\n  async stat(e) {\n    const t = await r.promises.stat(e);\n    return {\n      ctime: t.ctimeMs,\n      mtime: t.mtimeMs,\n      size: t.size,\n    };\n  },\n};",
  "5071": "var r = require(4953),\n  o = [];\nexports.qP = function (e) {\n  o.forEach(function (t) {\n    if (\"info\" !== e.data.commandObj.command) {\n      t.trackDependency({\n        target: e.data.address,\n        name: e.data.commandObj.command,\n        data: e.data.commandObj.command,\n        duration: e.data.duration,\n        success: !e.data.err,\n        resultCode: e.data.err ? \"1\" : \"0\",\n        dependencyTypeName: \"redis\",\n      });\n    }\n  });\n};\nexports.wp = function (e, n) {\n  if (e) {\n    if (0 === o.length) {\n      r.channel.subscribe(\"redis\", exports.qP);\n    }\n    o.push(n);\n  } else {\n    if (\n      0 ===\n      (o = o.filter(function (e) {\n        return e != n;\n      })).length\n    ) {\n      r.channel.unsubscribe(\"redis\", exports.qP);\n    }\n  }\n};",
  "5109": "var r, o, i, s, a, c, l, u, d, p, h, f, m, g, _, y, v, b, w;\nr = require(8249);\nrequire(888);\nmodule.exports = void (\n  r.lib.Cipher ||\n  ((o = r),\n  (i = o.lib),\n  (s = i.Base),\n  (a = i.WordArray),\n  (c = i.BufferedBlockAlgorithm),\n  (l = o.enc),\n  l.Utf8,\n  (u = l.Base64),\n  (d = o.algo.EvpKDF),\n  (p = i.Cipher =\n    c.extend({\n      cfg: s.extend(),\n      createEncryptor: function (e, t) {\n        return this.create(this._ENC_XFORM_MODE, e, t);\n      },\n      createDecryptor: function (e, t) {\n        return this.create(this._DEC_XFORM_MODE, e, t);\n      },\n      init: function (e, t, n) {\n        (this.cfg = this.cfg.extend(n)),\n          (this._xformMode = e),\n          (this._key = t),\n          this.reset();\n      },\n      reset: function () {\n        c.reset.call(this), this._doReset();\n      },\n      process: function (e) {\n        return this._append(e), this._process();\n      },\n      finalize: function (e) {\n        return e && this._append(e), this._doFinalize();\n      },\n      keySize: 4,\n      ivSize: 4,\n      _ENC_XFORM_MODE: 1,\n      _DEC_XFORM_MODE: 2,\n      _createHelper: (function () {\n        function e(e) {\n          return \"string\" == typeof e ? w : v;\n        }\n        return function (t) {\n          return {\n            encrypt: function (n, r, o) {\n              return e(r).encrypt(t, n, r, o);\n            },\n            decrypt: function (n, r, o) {\n              return e(r).decrypt(t, n, r, o);\n            },\n          };\n        };\n      })(),\n    })),\n  (i.StreamCipher = p.extend({\n    _doFinalize: function () {\n      return this._process(!0);\n    },\n    blockSize: 1,\n  })),\n  (h = o.mode = {}),\n  (f = i.BlockCipherMode =\n    s.extend({\n      createEncryptor: function (e, t) {\n        return this.Encryptor.create(e, t);\n      },\n      createDecryptor: function (e, t) {\n        return this.Decryptor.create(e, t);\n      },\n      init: function (e, t) {\n        (this._cipher = e), (this._iv = t);\n      },\n    })),\n  (m = h.CBC =\n    (function () {\n      var e = f.extend();\n      function t(e, t, n) {\n        var r,\n          o = this._iv;\n        o ? ((r = o), (this._iv = void 0)) : (r = this._prevBlock);\n        for (var i = 0; i < n; i++) e[t + i] ^= r[i];\n      }\n      return (\n        (e.Encryptor = e.extend({\n          processBlock: function (e, n) {\n            var r = this._cipher,\n              o = r.blockSize;\n            t.call(this, e, n, o),\n              r.encryptBlock(e, n),\n              (this._prevBlock = e.slice(n, n + o));\n          },\n        })),\n        (e.Decryptor = e.extend({\n          processBlock: function (e, n) {\n            var r = this._cipher,\n              o = r.blockSize,\n              i = e.slice(n, n + o);\n            r.decryptBlock(e, n), t.call(this, e, n, o), (this._prevBlock = i);\n          },\n        })),\n        e\n      );\n    })()),\n  (g = (o.pad = {}).Pkcs7 =\n    {\n      pad: function (e, t) {\n        for (\n          var n = 4 * t,\n            r = n - (e.sigBytes % n),\n            o = (r << 24) | (r << 16) | (r << 8) | r,\n            i = [],\n            s = 0;\n          s < r;\n          s += 4\n        )\n          i.push(o);\n        var c = a.create(i, r);\n        e.concat(c);\n      },\n      unpad: function (e) {\n        var t = 255 & e.words[(e.sigBytes - 1) >>> 2];\n        e.sigBytes -= t;\n      },\n    }),\n  (i.BlockCipher = p.extend({\n    cfg: p.cfg.extend({\n      mode: m,\n      padding: g,\n    }),\n    reset: function () {\n      var e;\n      p.reset.call(this);\n      var t = this.cfg,\n        n = t.iv,\n        r = t.mode;\n      this._xformMode == this._ENC_XFORM_MODE\n        ? (e = r.createEncryptor)\n        : ((e = r.createDecryptor), (this._minBufferSize = 1)),\n        this._mode && this._mode.__creator == e\n          ? this._mode.init(this, n && n.words)\n          : ((this._mode = e.call(r, this, n && n.words)),\n            (this._mode.__creator = e));\n    },\n    _doProcessBlock: function (e, t) {\n      this._mode.processBlock(e, t);\n    },\n    _doFinalize: function () {\n      var e,\n        t = this.cfg.padding;\n      return (\n        this._xformMode == this._ENC_XFORM_MODE\n          ? (t.pad(this._data, this.blockSize), (e = this._process(!0)))\n          : ((e = this._process(!0)), t.unpad(e)),\n        e\n      );\n    },\n    blockSize: 4,\n  })),\n  (_ = i.CipherParams =\n    s.extend({\n      init: function (e) {\n        this.mixIn(e);\n      },\n      toString: function (e) {\n        return (e || this.formatter).stringify(this);\n      },\n    })),\n  (y = (o.format = {}).OpenSSL =\n    {\n      stringify: function (e) {\n        var t = e.ciphertext,\n          n = e.salt;\n        return (\n          n ? a.create([1398893684, 1701076831]).concat(n).concat(t) : t\n        ).toString(u);\n      },\n      parse: function (e) {\n        var t,\n          n = u.parse(e),\n          r = n.words;\n        return (\n          1398893684 == r[0] &&\n            1701076831 == r[1] &&\n            ((t = a.create(r.slice(2, 4))), r.splice(0, 4), (n.sigBytes -= 16)),\n          _.create({\n            ciphertext: n,\n            salt: t,\n          })\n        );\n      },\n    }),\n  (v = i.SerializableCipher =\n    s.extend({\n      cfg: s.extend({\n        format: y,\n      }),\n      encrypt: function (e, t, n, r) {\n        r = this.cfg.extend(r);\n        var o = e.createEncryptor(n, r),\n          i = o.finalize(t),\n          s = o.cfg;\n        return _.create({\n          ciphertext: i,\n          key: n,\n          iv: s.iv,\n          algorithm: e,\n          mode: s.mode,\n          padding: s.padding,\n          blockSize: e.blockSize,\n          formatter: r.format,\n        });\n      },\n      decrypt: function (e, t, n, r) {\n        return (\n          (r = this.cfg.extend(r)),\n          (t = this._parse(t, r.format)),\n          e.createDecryptor(n, r).finalize(t.ciphertext)\n        );\n      },\n      _parse: function (e, t) {\n        return \"string\" == typeof e ? t.parse(e, this) : e;\n      },\n    })),\n  (b = (o.kdf = {}).OpenSSL =\n    {\n      execute: function (e, t, n, r) {\n        r || (r = a.random(8));\n        var o = d\n            .create({\n              keySize: t + n,\n            })\n            .compute(e, r),\n          i = a.create(o.words.slice(t), 4 * n);\n        return (\n          (o.sigBytes = 4 * t),\n          _.create({\n            key: o,\n            iv: i,\n            salt: r,\n          })\n        );\n      },\n    }),\n  (w = i.PasswordBasedCipher =\n    v.extend({\n      cfg: v.cfg.extend({\n        kdf: b,\n      }),\n      encrypt: function (e, t, n, r) {\n        var o = (r = this.cfg.extend(r)).kdf.execute(n, e.keySize, e.ivSize);\n        r.iv = o.iv;\n        var i = v.encrypt.call(this, e, t, o.key, r);\n        return i.mixIn(o), i;\n      },\n      decrypt: function (e, t, n, r) {\n        (r = this.cfg.extend(r)), (t = this._parse(t, r.format));\n        var o = r.kdf.execute(n, e.keySize, e.ivSize, t.salt);\n        return (r.iv = o.iv), v.decrypt.call(this, e, t, o.key, r);\n      },\n    })))\n);",
  "5120": "function editDistance(e, t, n = (e, t) => (e === t ? 0 : 1)) {\n  if (0 === t.length || 0 === e.length)\n    return {\n      distance: t.length,\n      startOffset: 0,\n      endOffset: 0,\n    };\n  let r = new Array(t.length + 1).fill(0),\n    o = new Array(t.length + 1).fill(0),\n    i = new Array(e.length + 1).fill(0),\n    s = new Array(e.length + 1).fill(0),\n    a = t[0];\n  for (let t = 0; t < e.length + 1; t++) {\n    r[t] = 0 === t ? 1 : n(e[t - 1], a, t - 1, 0);\n    o[t] = t > 0 ? t - 1 : 0;\n  }\n  for (let c = 1; c < t.length; c++) {\n    let l = i;\n    i = r;\n    r = l;\n    l = s;\n    s = o;\n    o = l;\n    a = t[c];\n    r[0] = c + 1;\n    for (let t = 1; t < e.length + 1; t++) {\n      const l = 1 + i[t],\n        u = 1 + r[t - 1],\n        d = n(e[t - 1], a, t - 1, c) + i[t - 1];\n      r[t] = Math.min(u, l, d);\n      if (r[t] === d) {\n        o[t] = s[t - 1];\n      } else {\n        if (r[t] === l) {\n          o[t] = s[t];\n        } else {\n          o[t] = o[t - 1];\n        }\n      }\n    }\n  }\n  let c = 0;\n  for (let t = 0; t < e.length + 1; t++)\n    if (r[t] < r[c]) {\n      c = t;\n    }\n  return {\n    distance: r[c],\n    startOffset: o[c],\n    endOffset: c,\n  };\n}\nfunction emptyLexDictionary() {\n  return new Map();\n}\nfunction reverseLexDictionary(e) {\n  const t = new Array(e.size);\n  for (const [n, r] of e) t[r] = n;\n  return t;\n}\nfunction* lexGeneratorWords(e) {\n  let t,\n    n = \"\";\n  !(function (e) {\n    e[(e.Word = 0)] = \"Word\";\n    e[(e.Space = 1)] = \"Space\";\n    e[(e.Other = 2)] = \"Other\";\n  })(t || (t = {}));\n  let r = t.Word;\n  for (const o of e) {\n    let e;\n    e = /(\\p{L}|\\p{Nd}|_)/u.test(o) ? t.Word : \" \" === o ? t.Space : t.Other;\n    if (e === r && e !== t.Other) {\n      n += o;\n    } else {\n      if (n.length > 0) {\n        yield n;\n      }\n      n = o;\n      r = e;\n    }\n  }\n  if (n.length > 0) {\n    yield n;\n  }\n}\nfunction lexicalAnalyzer(e, t, n, r) {\n  const o = [];\n  let i = 0;\n  for (const s of n(e)) {\n    if (r(s)) {\n      if (t.has(s)) {\n        t.set(s, t.size);\n      }\n      o.push([t.get(s), i]);\n    }\n    i += s.length;\n  }\n  return [o, t];\n}\nfunction a(e) {\n  return \" \" !== e;\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.lexEditDistance =\n  exports.lexicalAnalyzer =\n  exports.lexGeneratorWords =\n  exports.reverseLexDictionary =\n  exports.emptyLexDictionary =\n  exports.editDistance =\n    undefined;\nexports.editDistance = editDistance;\nexports.emptyLexDictionary = emptyLexDictionary;\nexports.reverseLexDictionary = reverseLexDictionary;\nexports.lexGeneratorWords = lexGeneratorWords;\nexports.lexicalAnalyzer = lexicalAnalyzer;\nexports.lexEditDistance = function (e, t, c = lexGeneratorWords) {\n  const [l, u] = lexicalAnalyzer(e, emptyLexDictionary(), c, a),\n    [d, p] = lexicalAnalyzer(t, u, c, a);\n  if (0 === d.length || 0 === l.length)\n    return {\n      lexDistance: d.length,\n      startOffset: 0,\n      endOffset: 0,\n      haystackLexLength: l.length,\n      needleLexLength: d.length,\n    };\n  const h = reverseLexDictionary(p),\n    f = d.length,\n    m = h[d[0][0]],\n    g = h[d[f - 1][0]],\n    _ = editDistance(\n      l.map((e) => e[0]),\n      d.map((e) => e[0]),\n      function (e, t, n, r) {\n        if (0 === r || r === f - 1) {\n          const e = h[l[n][0]];\n          return (0 == r && e.endsWith(m)) || (r == f - 1 && e.startsWith(g))\n            ? 0\n            : 1;\n        }\n        return e === t ? 0 : 1;\n      }\n    ),\n    y = l[_.startOffset][1];\n  let v = _.endOffset < l.length ? l[_.endOffset][1] : e.length;\n  if (v > 0 && \" \" === e[v - 1]) {\n    --v;\n  }\n  return {\n    lexDistance: _.distance,\n    startOffset: y,\n    endOffset: v,\n    haystackLexLength: l.length,\n    needleLexLength: d.length,\n  };\n};",
  "5158": "var r = require(3580),\n  o = (function () {\n    function e() {}\n    e.parse = function (t) {\n      if (!t) return {};\n      var n = t.split(e._FIELDS_SEPARATOR).reduce(function (t, n) {\n        var r = n.split(e._FIELD_KEY_VALUE_SEPARATOR);\n        if (2 === r.length) {\n          var o = r[0].toLowerCase(),\n            i = r[1];\n          t[o] = i;\n        }\n        return t;\n      }, {});\n      if (Object.keys(n).length > 0) {\n        if (n.endpointsuffix) {\n          var o = n.location ? n.location + \".\" : \"\";\n          n.ingestionendpoint =\n            n.ingestionendpoint || \"https://\" + o + \"dc.\" + n.endpointsuffix;\n          n.liveendpoint =\n            n.liveendpoint || \"https://\" + o + \"live.\" + n.endpointsuffix;\n        }\n        n.ingestionendpoint = n.ingestionendpoint || r.DEFAULT_BREEZE_ENDPOINT;\n        n.liveendpoint = n.liveendpoint || r.DEFAULT_LIVEMETRICS_ENDPOINT;\n      }\n      return n;\n    };\n    e._FIELDS_SEPARATOR = \";\";\n    e._FIELD_KEY_VALUE_SEPARATOR = \"=\";\n    return e;\n  })();\nmodule.exports = o;",
  "5173": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.resolveSchema =\n  exports.getCompilingSchema =\n  exports.resolveRef =\n  exports.compileSchema =\n  exports.SchemaEnv =\n    undefined;\nconst r = require(3487),\n  o = require(7426),\n  i = require(2141),\n  s = require(2531),\n  a = require(6776),\n  c = require(4815),\n  l = require(540);\nclass SchemaEnv {\n  constructor(e) {\n    var t;\n    let n;\n    this.refs = {};\n    this.dynamicAnchors = {};\n    if (\"object\" == typeof e.schema) {\n      n = e.schema;\n    }\n    this.schema = e.schema;\n    this.schemaId = e.schemaId;\n    this.root = e.root || this;\n    this.baseId =\n      null !== (t = e.baseId) && undefined !== t\n        ? t\n        : s.normalizeId(null == n ? undefined : n[e.schemaId || \"$id\"]);\n    this.schemaPath = e.schemaPath;\n    this.localRefs = e.localRefs;\n    this.meta = e.meta;\n    this.$async = null == n ? undefined : n.$async;\n    this.refs = {};\n  }\n}\nfunction compileSchema(e) {\n  const t = getCompilingSchema.call(this, e);\n  if (t) return t;\n  const n = s.getFullPath(e.root.baseId),\n    { es5: a, lines: l } = this.opts.code,\n    { ownProperties: u } = this.opts,\n    d = new r.CodeGen(this.scope, {\n      es5: a,\n      lines: l,\n      ownProperties: u,\n    });\n  let p;\n  if (e.$async) {\n    p = d.scopeValue(\"Error\", {\n      ref: o.default,\n      code: r._`require(\"ajv/dist/runtime/validation_error\").default`,\n    });\n  }\n  const f = d.scopeName(\"validate\");\n  e.validateName = f;\n  const m = {\n    gen: d,\n    allErrors: this.opts.allErrors,\n    data: i.default.data,\n    parentData: i.default.parentData,\n    parentDataProperty: i.default.parentDataProperty,\n    dataNames: [i.default.data],\n    dataPathArr: [r.nil],\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set(),\n    topSchemaRef: d.scopeValue(\n      \"schema\",\n      !0 === this.opts.code.source\n        ? {\n            ref: e.schema,\n            code: r.stringify(e.schema),\n          }\n        : {\n            ref: e.schema,\n          }\n    ),\n    validateName: f,\n    ValidationError: p,\n    schema: e.schema,\n    schemaEnv: e,\n    rootId: n,\n    baseId: e.baseId || n,\n    schemaPath: r.nil,\n    errSchemaPath: e.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: r._`\"\"`,\n    opts: this.opts,\n    self: this,\n  };\n  let g;\n  try {\n    this._compilations.add(e);\n    c.validateFunctionCode(m);\n    d.optimize(this.opts.code.optimize);\n    const t = d.toString();\n    g = `${d.scopeRefs(i.default.scope)}return ${t}`;\n    if (this.opts.code.process) {\n      g = this.opts.code.process(g, e);\n    }\n    const n = new Function(`${i.default.self}`, `${i.default.scope}`, g)(\n      this,\n      this.scope.get()\n    );\n    this.scope.value(f, {\n      ref: n,\n    });\n    n.errors = null;\n    n.schema = e.schema;\n    n.schemaEnv = e;\n    if (e.$async) {\n      n.$async = !0;\n    }\n    if (!0 === this.opts.code.source) {\n      n.source = {\n        validateName: f,\n        validateCode: t,\n        scopeValues: d._values,\n      };\n    }\n    if (this.opts.unevaluated) {\n      const { props: e, items: t } = m;\n      (n.evaluated = {\n        props: e instanceof r.Name ? void 0 : e,\n        items: t instanceof r.Name ? void 0 : t,\n        dynamicProps: e instanceof r.Name,\n        dynamicItems: t instanceof r.Name,\n      }),\n        n.source && (n.source.evaluated = (0, r.stringify)(n.evaluated));\n    }\n    e.validate = n;\n    return e;\n  } catch (t) {\n    throw (\n      (delete e.validate,\n      delete e.validateName,\n      g && this.logger.error(\"Error compiling schema, function code:\", g),\n      t)\n    );\n  } finally {\n    this._compilations.delete(e);\n  }\n}\nfunction p(e) {\n  return s.inlineRef(e.schema, this.opts.inlineRefs)\n    ? e.schema\n    : e.validate\n    ? e\n    : compileSchema.call(this, e);\n}\nfunction getCompilingSchema(e) {\n  for (const r of this._compilations) {\n    n = e;\n    if (\n      (t = r).schema === n.schema &&\n      t.root === n.root &&\n      t.baseId === n.baseId\n    )\n      return r;\n  }\n  var t, n;\n}\nfunction f(e, t) {\n  let n;\n  for (; \"string\" == typeof (n = this.refs[t]); ) t = n;\n  return n || this.schemas[t] || resolveSchema.call(this, e, t);\n}\nfunction resolveSchema(e, t) {\n  const n = l.parse(t),\n    r = s._getFullPath(n);\n  let o = s.getFullPath(e.baseId);\n  if (Object.keys(e.schema).length > 0 && r === o) return _.call(this, n, e);\n  const i = s.normalizeId(r),\n    a = this.refs[i] || this.schemas[i];\n  if (\"string\" == typeof a) {\n    const t = resolveSchema.call(this, e, a);\n    if (\"object\" != typeof (null == t ? undefined : t.schema)) return;\n    return _.call(this, n, t);\n  }\n  if (\"object\" == typeof (null == a ? undefined : a.schema)) {\n    if (a.validate) {\n      compileSchema.call(this, a);\n    }\n    if (i === (0, s.normalizeId)(t)) {\n      const { schema: t } = a,\n        { schemaId: n } = this.opts,\n        r = t[n];\n      return (\n        r && (o = (0, s.resolveUrl)(o, r)),\n        new SchemaEnv({\n          schema: t,\n          schemaId: n,\n          root: e,\n          baseId: o,\n        })\n      );\n    }\n    return _.call(this, n, a);\n  }\n}\nexports.SchemaEnv = SchemaEnv;\nexports.compileSchema = compileSchema;\nexports.resolveRef = function (e, t, n) {\n  var r;\n  n = s.resolveUrl(t, n);\n  const o = e.refs[n];\n  if (o) return o;\n  let i = f.call(this, e, n);\n  if (undefined === i) {\n    const o = null === (r = e.localRefs) || undefined === r ? undefined : r[n],\n      { schemaId: s } = this.opts;\n    if (o) {\n      i = new SchemaEnv({\n        schema: o,\n        schemaId: s,\n        root: e,\n        baseId: t,\n      });\n    }\n  }\n  return undefined !== i ? (e.refs[n] = p.call(this, i)) : undefined;\n};\nexports.getCompilingSchema = getCompilingSchema;\nexports.resolveSchema = resolveSchema;\nconst g = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n]);\nfunction _(e, { baseId: t, schema: n, root: r }) {\n  var o;\n  if (\"/\" !== (null === (o = e.fragment) || undefined === o ? undefined : o[0]))\n    return;\n  for (const r of e.fragment.slice(1).split(\"/\")) {\n    if (\"boolean\" == typeof n) return;\n    const e = n[a.unescapeFragment(r)];\n    if (undefined === e) return;\n    const o = \"object\" == typeof (n = e) && n[this.opts.schemaId];\n    if (!g.has(r) && o) {\n      t = s.resolveUrl(t, o);\n    }\n  }\n  let i;\n  if (\n    \"boolean\" != typeof n &&\n    n.$ref &&\n    !a.schemaHasRulesButRef(n, this.RULES)\n  ) {\n    const e = s.resolveUrl(t, n.$ref);\n    i = resolveSchema.call(this, r, e);\n  }\n  const { schemaId: c } = this.opts;\n  i =\n    i ||\n    new SchemaEnv({\n      schema: n,\n      schemaId: c,\n      root: r,\n      baseId: t,\n    });\n  return i.schema !== i.root.schema ? i : undefined;\n}",
  "5258": "module.exports = JSON.parse(\n  '{\"name\":\"@adobe/helix-fetch\",\"version\":\"3.1.1\",\"description\":\"Light-weight Fetch implementation transparently supporting both HTTP/1(.1) and HTTP/2\",\"main\":\"src/index.js\",\"scripts\":{\"test\":\"nyc mocha\",\"lint\":\"./node_modules/.bin/eslint .\",\"semantic-release\":\"semantic-release\"},\"mocha\":{\"timeout\":\"5000\",\"recursive\":\"true\",\"reporter\":\"mocha-multi-reporters\",\"reporter-options\":\"configFile=.mocha-multi.json\"},\"engines\":{\"node\":\">=12.0\"},\"types\":\"src/index.d.ts\",\"exports\":{\"import\":\"./src/index.mjs\",\"require\":\"./src/index.js\"},\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/adobe/helix-fetch\"},\"author\":\"\",\"license\":\"Apache-2.0\",\"bugs\":{\"url\":\"https://github.com/adobe/helix-fetch/issues\"},\"homepage\":\"https://github.com/adobe/helix-fetch#readme\",\"keywords\":[\"fetch\",\"whatwg\",\"Fetch API\",\"http\",\"https\",\"http2\",\"h2\",\"promise\",\"async\",\"request\",\"RFC 7234\",\"7234\",\"caching\",\"cache\"],\"dependencies\":{\"debug\":\"4.3.4\",\"http-cache-semantics\":\"4.1.0\",\"lru-cache\":\"7.13.1\"},\"devDependencies\":{\"@adobe/eslint-config-helix\":\"1.3.2\",\"@semantic-release/changelog\":\"6.0.1\",\"@semantic-release/git\":\"10.0.1\",\"chai\":\"4.3.6\",\"chai-as-promised\":\"7.1.1\",\"chai-bytes\":\"0.1.2\",\"chai-iterator\":\"3.0.2\",\"eslint\":\"8.21.0\",\"eslint-plugin-header\":\"3.1.1\",\"eslint-plugin-import\":\"2.26.0\",\"formdata-node\":\"4.3.3\",\"lint-staged\":\"13.0.3\",\"mocha\":\"10.0.0\",\"mocha-multi-reporters\":\"1.5.1\",\"nock\":\"13.2.9\",\"nyc\":\"15.1.0\",\"parse-cache-control\":\"1.0.1\",\"pem\":\"1.14.6\",\"proxy\":\"^1.0.2\",\"semantic-release\":\"19.0.3\",\"sinon\":\"14.0.0\",\"stream-buffers\":\"3.0.2\",\"tunnel\":\"^0.0.6\"},\"lint-staged\":{\"*.js\":\"eslint\"},\"config\":{\"commitizen\":{\"path\":\"node_modules/cz-conventional-changelog\"},\"ghooks\":{\"pre-commit\":\"npx lint-staged\"}}}'\n);",
  "5282": "var t = (function () {\n  function e() {}\n  e.info = function (t) {\n    for (var n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];\n    if (e.enableDebug) {\n      console.info(e.TAG + t, n);\n    }\n  };\n  e.warn = function (t) {\n    for (var n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];\n    if (e.disableWarnings) {\n      console.warn(e.TAG + t, n);\n    }\n  };\n  e.enableDebug = !1;\n  e.disableWarnings = !1;\n  e.disableErrors = !1;\n  e.TAG = \"ApplicationInsights:\";\n  return e;\n})();\nmodule.exports = t;",
  "5288": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.parseTree =\n  exports.registerLanguageSpecificParser =\n  exports.flattenVirtual =\n  exports.groupBlocks =\n  exports.combineClosersAndOpeners =\n  exports.buildLabelRules =\n  exports.labelVirtualInherited =\n  exports.labelLines =\n  exports.parseRaw =\n    undefined;\nconst r = require(9608),\n  o = require(9829);\nfunction parseRaw(e) {\n  const t = e.split(\"\\n\"),\n    n = t.map((e) => e.match(/^\\s*/)[0].length),\n    o = t.map((e) => e.trimLeft());\n  function i(e) {\n    const [t, i] = s(e + 1, n[e]);\n    return [r.lineNode(n[e], e, o[e], t), i];\n  }\n  function s(e, t) {\n    let s;\n    const a = [];\n    let c,\n      l = e;\n    for (; l < o.length && (\"\" === o[l] || n[l] > t); )\n      if (\"\" === o[l]) {\n        if (undefined === c) {\n          c = l;\n        }\n        l += 1;\n      } else {\n        if (undefined !== c) {\n          for (let e = c; e < l; e++) a.push(r.blankNode(e));\n          c = undefined;\n        }\n        [s, l] = i(l);\n        a.push(s);\n      }\n    if (undefined !== c) {\n      l = c;\n    }\n    return [a, l];\n  }\n  const [a, c] = s(0, -1);\n  let l = c;\n  for (; l < o.length && \"\" === o[l]; ) {\n    a.push(r.blankNode(l));\n    l += 1;\n  }\n  if (l < o.length)\n    throw new Error(\n      `Parsing did not go to end of file. Ended at ${l} out of ${o.length}`\n    );\n  return r.topNode(a);\n}\nfunction labelLines(e, t) {\n  o.visitTree(\n    e,\n    function (e) {\n      if (r.isLine(e)) {\n        const n = t.find((t) => t.matches(e.sourceLine));\n        if (n) {\n          e.label = n.label;\n        }\n      }\n    },\n    \"bottomUp\"\n  );\n}\nfunction buildLabelRules(e) {\n  return Object.keys(e).map((t) => {\n    let n;\n    n = e[t].test ? (n) => e[t].test(n) : e[t];\n    return {\n      matches: n,\n      label: t,\n    };\n  });\n}\nfunction combineClosersAndOpeners(e) {\n  const t = o.rebuildTree(e, function (e) {\n    if (\n      0 === e.subs.length ||\n      -1 ===\n        e.subs.findIndex((e) => \"closer\" === e.label || \"opener\" === e.label)\n    )\n      return e;\n    const t = [];\n    let n;\n    for (let o = 0; o < e.subs.length; o++) {\n      const i = e.subs[o],\n        s = e.subs[o - 1];\n      if (\"opener\" === i.label && undefined !== s && r.isLine(s)) {\n        s.subs.push(i);\n        i.subs.forEach((e) => s.subs.push(e));\n        i.subs = [];\n      } else if (\n        \"closer\" === i.label &&\n        undefined !== n &&\n        (r.isLine(i) || r.isVirtual(i)) &&\n        i.indentation >= n.indentation\n      ) {\n        let e = t.length - 1;\n        for (; e > 0 && r.isBlank(t[e]); ) e -= 1;\n        n.subs.push(...t.splice(e + 1));\n        if (i.subs.length > 0) {\n          const e = n.subs.findIndex((e) => \"newVirtual\" !== e.label),\n            t = n.subs.slice(0, e),\n            o = n.subs.slice(e),\n            s =\n              o.length > 0\n                ? [(0, r.virtualNode)(i.indentation, o, \"newVirtual\")]\n                : [];\n          n.subs = [...t, ...s, i];\n        } else n.subs.push(i);\n      } else {\n        t.push(i);\n        if (r.isBlank(i)) {\n          n = i;\n        }\n      }\n    }\n    e.subs = t;\n    return e;\n  });\n  o.clearLabelsIf(e, (e) => \"newVirtual\" === e);\n  return t;\n}\nexports.parseRaw = parseRaw;\nexports.labelLines = labelLines;\nexports.labelVirtualInherited = function (e) {\n  o.visitTree(\n    e,\n    function (e) {\n      if (r.isVirtual(e) && undefined === e.label) {\n        const t = e.subs.filter((e) => !r.isBlank(e));\n        if (1 === t.length) {\n          e.label = t[0].label;\n        }\n      }\n    },\n    \"bottomUp\"\n  );\n};\nexports.buildLabelRules = buildLabelRules;\nexports.combineClosersAndOpeners = combineClosersAndOpeners;\nexports.groupBlocks = function (e, t = r.isBlank, n) {\n  return o.rebuildTree(e, function (e) {\n    if (e.subs.length <= 1) return e;\n    const o = [];\n    let i,\n      s = [],\n      a = !1;\n    function c(e = !1) {\n      if (undefined !== i && (o.length > 0 || !e)) {\n        const e = r.virtualNode(i, s, n);\n        o.push(e);\n      } else s.forEach((e) => o.push(e));\n    }\n    for (let n = 0; n < e.subs.length; n++) {\n      const o = e.subs[n],\n        l = t(o);\n      if (!l && a) {\n        c();\n        s = [];\n      }\n      a = l;\n      s.push(o);\n      if (r.isBlank(o)) {\n        i = null != i ? i : o.indentation;\n      }\n    }\n    c(!0);\n    e.subs = o;\n    return e;\n  });\n};\nexports.flattenVirtual = function (e) {\n  return o.rebuildTree(e, function (e) {\n    return r.isVirtual(e) && undefined === e.label && e.subs.length <= 1\n      ? 0 === e.subs.length\n        ? undefined\n        : e.subs[0]\n      : (1 === e.subs.length &&\n          r.isVirtual(e.subs[0]) &&\n          undefined === e.subs[0].label &&\n          (e.subs = e.subs[0].subs),\n        e);\n  });\n};\nconst l = buildLabelRules({\n    opener: /^[\\[({]/,\n    closer: /^[\\])}]/,\n  }),\n  u = {};\nexports.registerLanguageSpecificParser = function (e, t) {\n  u[e] = t;\n};\nexports.parseTree = function (e, t) {\n  const n = parseRaw(e),\n    r = u[null != t ? t : \"\"];\n  return r ? r(n) : (labelLines(n, l), combineClosersAndOpeners(n));\n};",
  "5290": "function r(e) {\n  for (var n in e)\n    if (exports.hasOwnProperty(n)) {\n      exports[n] = e[n];\n    }\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nr(require(9382));\nr(require(9958));\nr(require(2626));",
  "5413": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getDebounceLimit = exports.GhostTextDebounceManager = undefined;\nconst r = require(9189);\nclass GhostTextDebounceManager {\n  constructor(e) {\n    this.forceDelayMs = e;\n    this.extraDebounceMs = 0;\n  }\n}\nexports.GhostTextDebounceManager = GhostTextDebounceManager;\nexports.getDebounceLimit = async function (e, t) {\n  let n;\n  if (\n    (await e.get(r.Features).debouncePredict()) &&\n    t.measurements.contextualFilterScore\n  ) {\n    const e = t.measurements.contextualFilterScore,\n      r = 0.275,\n      o = 6;\n    n = 25 + 250 / (1 + Math.pow(e / r, o));\n  } else n = await e.get(r.Features).debounceMs();\n  return (n > 0 ? n : 75) + e.get(GhostTextDebounceManager).extraDebounceMs;\n};",
  "5420": "var t = Object.prototype.toString,\n  n =\n    \"function\" == typeof Buffer.alloc &&\n    \"function\" == typeof Buffer.allocUnsafe &&\n    \"function\" == typeof Buffer.from;\nmodule.exports = function (e, r, o) {\n  if (\"number\" == typeof e)\n    throw new TypeError('\"value\" argument must not be a number');\n  i = e;\n  return \"ArrayBuffer\" === t.call(i).slice(8, -1)\n    ? (function (e, t, r) {\n        t >>>= 0;\n        var o = e.byteLength - t;\n        if (o < 0) throw new RangeError(\"'offset' is out of bounds\");\n        if (undefined === r) r = o;\n        else if ((r >>>= 0) > o)\n          throw new RangeError(\"'length' is out of bounds\");\n        return n\n          ? Buffer.from(e.slice(t, t + r))\n          : new Buffer(new Uint8Array(e.slice(t, t + r)));\n      })(e, r, o)\n    : \"string\" == typeof e\n    ? (function (e, t) {\n        if (\"string\" == typeof t && \"\" !== t) {\n          t = \"utf8\";\n        }\n        if (!Buffer.isEncoding(t))\n          throw new TypeError('\"encoding\" must be a valid string encoding');\n        return n ? Buffer.from(e, t) : new Buffer(e, t);\n      })(e, r)\n    : n\n    ? Buffer.from(e)\n    : new Buffer(e);\n  var i;\n};",
  "5468": "require(\"net\");\nvar debug,\n  o = require(3055404),\n  i = require(\"http\"),\n  s = require(\"https\"),\n  a = require(\"events\"),\n  c = (require(\"assert\"), require(\"util\"));\nfunction l(e) {\n  var t = this;\n  t.options = e || {};\n  t.proxyOptions = t.options.proxy || {};\n  t.maxSockets = t.options.maxSockets || i.Agent.defaultMaxSockets;\n  t.requests = [];\n  t.sockets = [];\n  t.on(\"free\", function (e, n, r, o) {\n    for (var i = d(n, r, o), s = 0, a = t.requests.length; s < a; ++s) {\n      var c = t.requests[s];\n      if (c.host === i.host && c.port === i.port) {\n        t.requests.splice(s, 1);\n        return void c.request.onSocket(e);\n      }\n    }\n    e.destroy();\n    t.removeSocket(e);\n  });\n}\nfunction u(e, t) {\n  var n = this;\n  l.prototype.createSocket.call(n, e, function (r) {\n    var i = e.request.getHeader(\"host\"),\n      s = p({}, n.options, {\n        socket: r,\n        servername: i ? i.replace(/:.*$/, \"\") : e.host,\n      }),\n      a = o.connect(0, s);\n    n.sockets[n.sockets.indexOf(r)] = a;\n    t(a);\n  });\n}\nfunction d(e, t, n) {\n  return \"string\" == typeof e\n    ? {\n        host: e,\n        port: t,\n        localAddress: n,\n      }\n    : e;\n}\nfunction p(e) {\n  for (var t = 1, n = arguments.length; t < n; ++t) {\n    var r = arguments[t];\n    if (\"object\" == typeof r)\n      for (var o = Object.keys(r), i = 0, s = o.length; i < s; ++i) {\n        var a = o[i];\n        if (undefined !== r[a]) {\n          e[a] = r[a];\n        }\n      }\n  }\n  return e;\n}\nexports.httpOverHttp = function (e) {\n  var t = new l(e);\n  t.request = i.request;\n  return t;\n};\nexports.httpsOverHttp = function (e) {\n  var t = new l(e);\n  t.request = i.request;\n  t.createSocket = u;\n  t.defaultPort = 443;\n  return t;\n};\nexports.httpOverHttps = function (e) {\n  var t = new l(e);\n  t.request = s.request;\n  return t;\n};\nexports.httpsOverHttps = function (e) {\n  var t = new l(e);\n  t.request = s.request;\n  t.createSocket = u;\n  t.defaultPort = 443;\n  return t;\n};\nc.inherits(l, a.EventEmitter);\nl.prototype.addRequest = function (e, t, n, r) {\n  var o = this,\n    i = p(\n      {\n        request: e,\n      },\n      o.options,\n      d(t, n, r)\n    );\n  if (o.sockets.length >= this.maxSockets) {\n    o.requests.push(i);\n  } else {\n    o.createSocket(i, function (t) {\n      function n() {\n        o.emit(\"free\", t, i);\n      }\n      function r(e) {\n        o.removeSocket(t);\n        t.removeListener(\"free\", n);\n        t.removeListener(\"close\", r);\n        t.removeListener(\"agentRemove\", r);\n      }\n      t.on(\"free\", n);\n      t.on(\"close\", r);\n      t.on(\"agentRemove\", r);\n      e.onSocket(t);\n    });\n  }\n};\nl.prototype.createSocket = function (e, t) {\n  var n = this,\n    o = {};\n  n.sockets.push(o);\n  var i = p({}, n.proxyOptions, {\n    method: \"CONNECT\",\n    path: e.host + \":\" + e.port,\n    agent: !1,\n    headers: {\n      host: e.host + \":\" + e.port,\n    },\n  });\n  if (e.localAddress) {\n    i.localAddress = e.localAddress;\n  }\n  if (i.proxyAuth) {\n    i.headers = i.headers || {};\n    i.headers[\"Proxy-Authorization\"] =\n      \"Basic \" + new Buffer(i.proxyAuth).toString(\"base64\");\n  }\n  debug(\"making CONNECT request\");\n  var s = n.request(i);\n  function a(i, a, c) {\n    var l;\n    s.removeAllListeners();\n    a.removeAllListeners();\n    return 200 !== i.statusCode\n      ? (debug(\n          \"tunneling socket could not be established, statusCode=%d\",\n          i.statusCode\n        ),\n        a.destroy(),\n        ((l = new Error(\n          \"tunneling socket could not be established, statusCode=\" +\n            i.statusCode\n        )).code = \"ECONNRESET\"),\n        e.request.emit(\"error\", l),\n        void n.removeSocket(o))\n      : c.length > 0\n      ? (debug(\"got illegal response body from proxy\"),\n        a.destroy(),\n        ((l = new Error(\"got illegal response body from proxy\")).code =\n          \"ECONNRESET\"),\n        e.request.emit(\"error\", l),\n        void n.removeSocket(o))\n      : (debug(\"tunneling connection has established\"),\n        (n.sockets[n.sockets.indexOf(o)] = a),\n        t(a));\n  }\n  s.useChunkedEncodingByDefault = !1;\n  s.once(\"response\", function (e) {\n    e.upgrade = !0;\n  });\n  s.once(\"upgrade\", function (e, t, n) {\n    process.nextTick(function () {\n      a(e, t, n);\n    });\n  });\n  s.once(\"connect\", a);\n  s.once(\"error\", function (t) {\n    s.removeAllListeners();\n    debug(\n      \"tunneling socket could not be established, cause=%s\\n\",\n      t.message,\n      t.stack\n    );\n    var i = new Error(\n      \"tunneling socket could not be established, cause=\" + t.message\n    );\n    i.code = \"ECONNRESET\";\n    e.request.emit(\"error\", i);\n    n.removeSocket(o);\n  });\n  s.end();\n};\nl.prototype.removeSocket = function (e) {\n  var t = this.sockets.indexOf(e);\n  if (-1 !== t) {\n    this.sockets.splice(t, 1);\n    var n = this.requests.shift();\n    if (n) {\n      this.createSocket(n, function (e) {\n        n.request.onSocket(e);\n      });\n    }\n  }\n};\ndebug =\n  process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)\n    ? function () {\n        var e = Array.prototype.slice.call(arguments);\n        if (\"string\" == typeof e[0]) {\n          e[0] = \"TUNNEL: \" + e[0];\n        } else {\n          e.unshift(\"TUNNEL:\");\n        }\n        console.error.apply(console, e);\n      }\n    : function () {};\nexports.debug = debug;",
  "5481": "var n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.telemetryTypeToBaseType = function (e) {\n  switch (e) {\n    case n.Event:\n      return \"EventData\";\n    case n.Exception:\n      return \"ExceptionData\";\n    case n.Trace:\n      return \"MessageData\";\n    case n.Metric:\n      return \"MetricData\";\n    case n.Request:\n      return \"RequestData\";\n    case n.Dependency:\n      return \"RemoteDependencyData\";\n    case n.Availability:\n      return \"AvailabilityData\";\n  }\n};\nexports.baseTypeToTelemetryType = function (e) {\n  switch (e) {\n    case \"EventData\":\n      return n.Event;\n    case \"ExceptionData\":\n      return n.Exception;\n    case \"MessageData\":\n      return n.Trace;\n    case \"MetricData\":\n      return n.Metric;\n    case \"RequestData\":\n      return n.Request;\n    case \"RemoteDependencyData\":\n      return n.Dependency;\n    case \"AvailabilityData\":\n      return n.Availability;\n  }\n};\nexports.TelemetryTypeString = {\n  Event: \"EventData\",\n  Exception: \"ExceptionData\",\n  Trace: \"MessageData\",\n  Metric: \"MetricData\",\n  Request: \"RequestData\",\n  Dependency: \"RemoteDependencyData\",\n  Availability: \"AvailabilityData\",\n};\n(function (e) {\n  e[(e.Event = 0)] = \"Event\";\n  e[(e.Exception = 1)] = \"Exception\";\n  e[(e.Trace = 2)] = \"Trace\";\n  e[(e.Metric = 3)] = \"Metric\";\n  e[(e.Request = 4)] = \"Request\";\n  e[(e.Dependency = 5)] = \"Dependency\";\n  e[(e.Availability = 6)] = \"Availability\";\n})((n = exports.TelemetryType || (exports.TelemetryType = {})));",
  "5600": "const { PassThrough: r, Readable: o } = require(\"stream\"),\n  {\n    types: { isAnyArrayBuffer: i },\n  } = require(\"util\"),\n  { FetchError: s, FetchBaseError: a } = require(3683),\n  { streamToBuffer: c } = require(4544),\n  l = Buffer.alloc(0),\n  u = Symbol(\"Body internals\"),\n  d = async (e) => {\n    if (e[u].disturbed) throw new TypeError(\"Already read\");\n    if (e[u].error)\n      throw new TypeError(`Stream had error: ${e[u].error.message}`);\n    e[u].disturbed = !0;\n    const { stream: t } = e[u];\n    return null === t ? l : c(t);\n  };\nclass p {\n  constructor(e) {\n    let t;\n    t =\n      null == e\n        ? null\n        : e instanceof URLSearchParams\n        ? o.from(e.toString())\n        : e instanceof o\n        ? e\n        : Buffer.isBuffer(e)\n        ? o.from(e)\n        : i(e)\n        ? o.from(Buffer.from(e))\n        : \"string\" == typeof e || e instanceof String\n        ? o.from(e)\n        : o.from(String(e));\n    this[u] = {\n      stream: t,\n      disturbed: !1,\n      error: null,\n    };\n    if (e instanceof o) {\n      t.on(\"error\", (e) => {\n        const t =\n          e instanceof a\n            ? e\n            : new s(\n                `Invalid response body while trying to fetch ${this.url}: ${e.message}`,\n                \"system\",\n                e\n              );\n        this[u].error = t;\n      });\n    }\n  }\n  get body() {\n    return this[u].stream;\n  }\n  get bodyUsed() {\n    return this[u].disturbed;\n  }\n  async buffer() {\n    return d(this);\n  }\n  async arrayBuffer() {\n    return (e = await this.buffer()).buffer.slice(\n      e.byteOffset,\n      e.byteOffset + e.byteLength\n    );\n    var e;\n  }\n  async text() {\n    return (await d(this)).toString();\n  }\n  async json() {\n    return JSON.parse(await this.text());\n  }\n}\nObject.defineProperties(p.prototype, {\n  body: {\n    enumerable: !0,\n  },\n  bodyUsed: {\n    enumerable: !0,\n  },\n  arrayBuffer: {\n    enumerable: !0,\n  },\n  json: {\n    enumerable: !0,\n  },\n  text: {\n    enumerable: !0,\n  },\n});\nmodule.exports = {\n  Body: p,\n  cloneStream: (e) => {\n    if (e[u].disturbed) throw new TypeError(\"Cannot clone: already read\");\n    const { stream: t } = e[u];\n    let n = t;\n    if (t instanceof o) {\n      n = new r();\n      const o = new r();\n      t.pipe(n);\n      t.pipe(o);\n      e[u].stream = o;\n    }\n    return n;\n  },\n  guessContentType: (e) =>\n    null === e\n      ? null\n      : \"string\" == typeof e\n      ? \"text/plain; charset=utf-8\"\n      : e instanceof URLSearchParams\n      ? \"application/x-www-form-urlencoded; charset=utf-8\"\n      : Buffer.isBuffer(e) || i(e) || e instanceof o\n      ? null\n      : \"text/plain; charset=utf-8\",\n};",
  "5667": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = undefined;\nconst r = require(4181),\n  o = require(3487),\n  i = require(2141),\n  s = {\n    message: \"boolean schema is false\",\n  };\nfunction a(e, t) {\n  const { gen: n, data: o } = e,\n    i = {\n      gen: n,\n      keyword: \"false schema\",\n      data: o,\n      schema: !1,\n      schemaCode: !1,\n      schemaValue: !1,\n      params: {},\n      it: e,\n    };\n  r.reportError(i, s, undefined, t);\n}\nexports.topBoolOrEmptySchema = function (e) {\n  const { gen: t, schema: n, validateName: r } = e;\n  if (!1 === n) {\n    a(e, !1);\n  } else {\n    if (\"object\" == typeof n && !0 === n.$async) {\n      t.return(i.default.data);\n    } else {\n      t.assign(o._`${r}.errors`, null);\n      t.return(!0);\n    }\n  }\n};\nexports.boolOrEmptySchema = function (e, t) {\n  const { gen: n, schema: r } = e;\n  if (!1 === r) {\n    n.var(t, !1);\n    a(e);\n  } else {\n    n.var(t, !0);\n  }\n};",
  "5684": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(8386),\n  o = require(8280),\n  i = [\n    \"$schema\",\n    \"$id\",\n    \"$defs\",\n    \"$vocabulary\",\n    {\n      keyword: \"$comment\",\n    },\n    \"definitions\",\n    r.default,\n    o.default,\n  ];\nexports.default = i;",
  "5697": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(6776),\n  o = {\n    keyword: \"not\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: !0,\n    code(e) {\n      const { gen: t, schema: n, it: o } = e;\n      if (r.alwaysValidSchema(o, n)) return void e.fail();\n      const i = t.name(\"valid\");\n      e.subschema(\n        {\n          keyword: \"not\",\n          compositeRule: !0,\n          createErrors: !1,\n          allErrors: !1,\n        },\n        i\n      );\n      e.failResult(\n        i,\n        () => e.reset(),\n        () => e.error()\n      );\n    },\n    error: {\n      message: \"must NOT be valid\",\n    },\n  };\nexports.default = o;",
  "5740": "var r =\n    (this && this.__assign) ||\n    Object.assign ||\n    function (e) {\n      for (var t, n = 1, r = arguments.length; n < r; n++)\n        for (var o in (t = arguments[n]))\n          if (Object.prototype.hasOwnProperty.call(t, o)) {\n            e[o] = t[o];\n          }\n      return e;\n    },\n  o = require(\"http\"),\n  i = require(\"https\"),\n  s = require(\"url\"),\n  a = require(\"constants\"),\n  c = require(5282),\n  l = require(9036),\n  u = (function () {\n    function e() {}\n    e.getCookie = function (t, n) {\n      var r = \"\";\n      if (t && t.length && \"string\" == typeof n)\n        for (var o = t + \"=\", i = n.split(\";\"), s = 0; s < i.length; s++) {\n          n = i[s];\n          if ((n = e.trim(n)) && 0 === n.indexOf(o)) {\n            r = n.substring(o.length, i[s].length);\n            break;\n          }\n        }\n      return r;\n    };\n    e.trim = function (e) {\n      return \"string\" == typeof e ? e.replace(/^\\s+|\\s+$/g, \"\") : \"\";\n    };\n    e.int32ArrayToBase64 = function (e) {\n      var t = function (e, t) {\n          return String.fromCharCode((e >> t) & 255);\n        },\n        n = e\n          .map(function (e) {\n            return t(e, 24) + t(e, 16) + t(e, 8) + t(e, 0);\n          })\n          .join(\"\"),\n        r = (\n          Buffer.from ? Buffer.from(n, \"binary\") : new Buffer(n, \"binary\")\n        ).toString(\"base64\");\n      return r.substr(0, r.indexOf(\"=\"));\n    };\n    e.random32 = function () {\n      return (4294967296 * Math.random()) | 0;\n    };\n    e.randomu32 = function () {\n      return e.random32() + 2147483648;\n    };\n    e.w3cTraceId = function () {\n      for (\n        var t,\n          n = [\n            \"0\",\n            \"1\",\n            \"2\",\n            \"3\",\n            \"4\",\n            \"5\",\n            \"6\",\n            \"7\",\n            \"8\",\n            \"9\",\n            \"a\",\n            \"b\",\n            \"c\",\n            \"d\",\n            \"e\",\n            \"f\",\n          ],\n          r = \"\",\n          o = 0;\n        o < 4;\n        o++\n      )\n        r +=\n          n[15 & (t = e.random32())] +\n          n[(t >> 4) & 15] +\n          n[(t >> 8) & 15] +\n          n[(t >> 12) & 15] +\n          n[(t >> 16) & 15] +\n          n[(t >> 20) & 15] +\n          n[(t >> 24) & 15] +\n          n[(t >> 28) & 15];\n      var i = n[(8 + 4 * Math.random()) | 0];\n      return (\n        r.substr(0, 8) +\n        r.substr(9, 4) +\n        \"4\" +\n        r.substr(13, 3) +\n        i +\n        r.substr(16, 3) +\n        r.substr(19, 12)\n      );\n    };\n    e.isValidW3CId = function (e) {\n      return 32 === e.length && \"00000000000000000000000000000000\" !== e;\n    };\n    e.isArray = function (e) {\n      return \"[object Array]\" === Object.prototype.toString.call(e);\n    };\n    e.isError = function (e) {\n      return e instanceof Error;\n    };\n    e.isPrimitive = function (e) {\n      var t = typeof e;\n      return \"string\" === t || \"number\" === t || \"boolean\" === t;\n    };\n    e.isDate = function (e) {\n      return \"[object Date]\" === Object.prototype.toString.call(e);\n    };\n    e.msToTimeSpan = function (e) {\n      if (isNaN(e) || e < 0) {\n        e = 0;\n      }\n      var t = ((e / 1e3) % 60).toFixed(7).replace(/0{0,4}$/, \"\"),\n        n = \"\" + (Math.floor(e / 6e4) % 60),\n        r = \"\" + (Math.floor(e / 36e5) % 24),\n        o = Math.floor(e / 864e5);\n      t = t.indexOf(\".\") < 2 ? \"0\" + t : t;\n      n = n.length < 2 ? \"0\" + n : n;\n      return (\n        (o > 0 ? o + \".\" : \"\") +\n        (r = r.length < 2 ? \"0\" + r : r) +\n        \":\" +\n        n +\n        \":\" +\n        t\n      );\n    };\n    e.extractError = function (e) {\n      var t = e;\n      return {\n        message: e.message,\n        code: t.code || t.id || \"\",\n      };\n    };\n    e.extractObject = function (t) {\n      return t instanceof Error\n        ? e.extractError(t)\n        : \"function\" == typeof t.toJSON\n        ? t.toJSON()\n        : t;\n    };\n    e.validateStringMap = function (t) {\n      if (\"object\" == typeof t) {\n        var n = {};\n        for (var r in t) {\n          var o = \"\",\n            i = t[r],\n            s = typeof i;\n          if (e.isPrimitive(i)) o = i.toString();\n          else if (null === i || \"undefined\" === s) o = \"\";\n          else {\n            if (\"function\" === s) {\n              c.info(\"key: \" + r + \" was function; will not serialize\");\n              continue;\n            }\n            var a = e.isArray(i) ? i : e.extractObject(i);\n            try {\n              o = e.isPrimitive(a) ? a : JSON.stringify(a);\n            } catch (e) {\n              o = i.constructor.name.toString() + \" (Error: \" + e.message + \")\";\n              c.info(\"key: \" + r + \", could not be serialized\");\n            }\n          }\n          n[r] = o.substring(0, e.MAX_PROPERTY_LENGTH);\n        }\n        return n;\n      }\n      c.info(\"Invalid properties dropped from payload\");\n    };\n    e.canIncludeCorrelationHeader = function (e, t) {\n      var n = e && e.config && e.config.correlationHeaderExcludedDomains;\n      if (!n || 0 == n.length || !t) return !0;\n      for (var r = 0; r < n.length; r++)\n        if (\n          new RegExp(n[r].replace(/\\./g, \".\").replace(/\\*/g, \".*\")).test(\n            s.parse(t).hostname\n          )\n        )\n          return !1;\n      return !0;\n    };\n    e.getCorrelationContextTarget = function (e, t) {\n      var n = e.headers && e.headers[l.requestContextHeader];\n      if (n)\n        for (var r = n.split(\",\"), o = 0; o < r.length; ++o) {\n          var i = r[o].split(\"=\");\n          if (2 == i.length && i[0] == t) return i[1];\n        }\n    };\n    e.makeRequest = function (t, n, a, l) {\n      if (n && 0 === n.indexOf(\"//\")) {\n        n = \"https:\" + n;\n      }\n      var u = s.parse(n),\n        d = r({}, a, {\n          host: u.hostname,\n          port: u.port,\n          path: u.pathname,\n        }),\n        p = undefined;\n      if (\"https:\" === u.protocol) {\n        p = t.proxyHttpsUrl || undefined;\n      }\n      if (\"http:\" === u.protocol) {\n        p = t.proxyHttpUrl || undefined;\n      }\n      if (p) {\n        0 === p.indexOf(\"//\") && (p = \"http:\" + p);\n        var h = s.parse(p);\n        \"https:\" === h.protocol\n          ? (c.info(\"Proxies that use HTTPS are not supported\"), (p = void 0))\n          : (d = r({}, d, {\n              host: h.hostname,\n              port: h.port || \"80\",\n              path: n,\n              headers: r({}, d.headers, {\n                Host: u.hostname,\n              }),\n            }));\n      }\n      var f = \"https:\" === u.protocol && !p;\n      if (f && undefined !== t.httpsAgent) {\n        d.agent = t.httpsAgent;\n      } else {\n        if (f || undefined === t.httpAgent) {\n          if (f) {\n            d.agent = e.tlsRestrictedAgent;\n          }\n        } else {\n          d.agent = t.httpAgent;\n        }\n      }\n      return f ? i.request(d, l) : o.request(d, l);\n    };\n    e.safeIncludeCorrelationHeader = function (t, n, r) {\n      var o;\n      if (\"string\" == typeof r) o = r;\n      else if (r instanceof Array) o = r.join(\",\");\n      else if (r && \"function\" == typeof r.toString)\n        try {\n          o = r.toString();\n        } catch (e) {\n          c.warn(\n            \"Outgoing request-context header could not be read. Correlation of requests may be lost.\",\n            e,\n            r\n          );\n        }\n      if (o) {\n        e.addCorrelationIdHeaderFromString(t, n, o);\n      } else {\n        n.setHeader(\n          l.requestContextHeader,\n          l.requestContextSourceKey + \"=\" + t.config.correlationId\n        );\n      }\n    };\n    e.addCorrelationIdHeaderFromString = function (e, t, n) {\n      var r = n.split(\",\"),\n        o = l.requestContextSourceKey + \"=\";\n      if (\n        r.some(function (e) {\n          return e.substring(0, o.length) === o;\n        })\n      ) {\n        t.setHeader(\n          l.requestContextHeader,\n          n + \",\" + l.requestContextSourceKey + \"=\" + e.config.correlationId\n        );\n      }\n    };\n    e.MAX_PROPERTY_LENGTH = 8192;\n    e.tlsRestrictedAgent = new i.Agent({\n      secureOptions:\n        a.SSL_OP_NO_SSLv2 |\n        a.SSL_OP_NO_SSLv3 |\n        a.SSL_OP_NO_TLSv1 |\n        a.SSL_OP_NO_TLSv1_1,\n    });\n    return e;\n  })();\nmodule.exports = u;",
  "5823": "var r = require(5290),\n  o = require(4953),\n  i = [],\n  s = {\n    10: r.SeverityLevel.Verbose,\n    20: r.SeverityLevel.Verbose,\n    30: r.SeverityLevel.Information,\n    40: r.SeverityLevel.Warning,\n    50: r.SeverityLevel.Error,\n    60: r.SeverityLevel.Critical,\n  },\n  a = function (e) {\n    var t = e.data.result;\n    i.forEach(function (n) {\n      var r = s[e.data.level];\n      if (t instanceof Error) {\n        n.trackException({\n          exception: t,\n        });\n      } else {\n        n.trackTrace({\n          message: t,\n          severity: r,\n        });\n      }\n    });\n  };\nexports.wp = function (e, t) {\n  if (e) {\n    if (0 === i.length) {\n      o.channel.subscribe(\"bunyan\", a);\n    }\n    i.push(t);\n  } else {\n    if (\n      0 ===\n      (i = i.filter(function (e) {\n        return e != t;\n      })).length\n    ) {\n      o.channel.unsubscribe(\"bunyan\", a);\n    }\n  }\n};",
  "6008": "var r = require(2337);\nmodule.exports = function (e) {\n  var t = {\n    protocols: [],\n    protocol: null,\n    port: null,\n    resource: \"\",\n    host: \"\",\n    user: \"\",\n    password: \"\",\n    pathname: \"\",\n    hash: \"\",\n    search: \"\",\n    href: e,\n    query: {},\n    parse_failed: !1,\n  };\n  try {\n    var n = new URL(e);\n    t.protocols = r(n);\n    t.protocol = t.protocols[0];\n    t.port = n.port;\n    t.resource = n.hostname;\n    t.host = n.host;\n    t.user = n.username || \"\";\n    t.password = n.password || \"\";\n    t.pathname = n.pathname;\n    t.hash = n.hash.slice(1);\n    t.search = n.search.slice(1);\n    t.href = n.href;\n    t.query = Object.fromEntries(n.searchParams);\n  } catch (n) {\n    t.protocols = [\"file\"];\n    t.protocol = t.protocols[0];\n    t.port = \"\";\n    t.resource = \"\";\n    t.user = \"\";\n    t.pathname = \"\";\n    t.hash = \"\";\n    t.search = \"\";\n    t.href = e;\n    t.query = {};\n    t.parse_failed = !0;\n  }\n  return t;\n};",
  "6143": "const { EventEmitter: r } = require(\"events\"),\n  { Readable: o } = require(\"stream\"),\n  i = require(8104)(\"helix-fetch\"),\n  s = require(8348),\n  { Body: a } = require(5600),\n  { Headers: c } = require(9872),\n  { Request: l } = require(8359),\n  { Response: u } = require(2981),\n  { FetchBaseError: d, FetchError: p, AbortError: h } = require(3683),\n  { AbortController: f, AbortSignal: m, TimeoutSignal: g } = require(6829),\n  _ = require(4193),\n  { cacheableResponse: y } = require(2500),\n  { sizeof: v } = require(4544),\n  { isFormData: b } = require(9407),\n  { context: w, RequestAbortedError: x } = require(3100),\n  E = [\"GET\", \"HEAD\"],\n  C = \"push\",\n  S = async (e, t, n) => {\n    const { request: r } = e.context,\n      i = t instanceof l && undefined === n ? t : new l(t, n),\n      {\n        method: s,\n        body: a,\n        signal: d,\n        compress: f,\n        decode: m,\n        follow: g,\n        redirect: _,\n        init: { body: y },\n      } = i;\n    let v;\n    if (d && d.aborted) {\n      const e = new h(\"The operation was aborted.\");\n      throw (i.init.body instanceof o && i.init.body.destroy(e), e);\n    }\n    try {\n      v = await r(i.url, {\n        ...n,\n        method: s,\n        headers: i.headers.plain(),\n        body: !y || y instanceof o || b(y) ? a : y,\n        compress: f,\n        decode: m,\n        follow: g,\n        redirect: _,\n        signal: d,\n      });\n    } catch (e) {\n      if (y instanceof o) {\n        y.destroy(e);\n      }\n      if (e instanceof TypeError) throw e;\n      if (e instanceof x) throw new h(\"The operation was aborted.\");\n      throw new p(e.message, \"system\", e);\n    }\n    const w = () => {\n      d.removeEventListener(\"abort\", w);\n      const e = new h(\"The operation was aborted.\");\n      if (i.init.body instanceof o) {\n        i.init.body.destroy(e);\n      }\n      v.readable.emit(\"error\", e);\n    };\n    if (d) {\n      d.addEventListener(\"abort\", w);\n    }\n    const {\n      statusCode: E,\n      statusText: C,\n      httpVersion: T,\n      headers: k,\n      readable: I,\n      decoded: P,\n    } = v;\n    if ([301, 302, 303, 307, 308].includes(E)) {\n      const { location: t } = k,\n        n = null == t ? null : new URL(t, i.url);\n      switch (i.redirect) {\n        case \"manual\":\n          break;\n        case \"error\":\n          throw (\n            (d && d.removeEventListener(\"abort\", w),\n            new p(\n              `uri requested responds with a redirect, redirect mode is set to 'error': ${i.url}`,\n              \"no-redirect\"\n            ))\n          );\n        case \"follow\": {\n          if (null === n) break;\n          if (i.counter >= i.follow)\n            throw (\n              (d && d.removeEventListener(\"abort\", w),\n              new p(`maximum redirect reached at: ${i.url}`, \"max-redirect\"))\n            );\n          const t = {\n            headers: new c(i.headers),\n            follow: i.follow,\n            compress: i.compress,\n            decode: i.decode,\n            counter: i.counter + 1,\n            method: i.method,\n            body: i.body,\n            signal: i.signal,\n          };\n          if (303 !== E && i.body && i.init.body instanceof o)\n            throw (\n              (d && d.removeEventListener(\"abort\", w),\n              new p(\n                \"Cannot follow redirect with body being a readable stream\",\n                \"unsupported-redirect\"\n              ))\n            );\n          if (303 !== E && ((301 !== E && 302 !== E) || \"POST\" !== i.method)) {\n            t.method = \"GET\";\n            t.body = undefined;\n            t.headers.delete(\"content-length\");\n          }\n          if (d) {\n            d.removeEventListener(\"abort\", w);\n          }\n          return S(e, new l(n, t));\n        }\n      }\n    }\n    if (d) {\n      I.once(\"end\", () => {\n        d.removeEventListener(\"abort\", w);\n      });\n      I.once(\"error\", () => {\n        d.removeEventListener(\"abort\", w);\n      });\n    }\n    return new u(I, {\n      url: i.url,\n      status: E,\n      statusText: C,\n      headers: k,\n      httpVersion: T,\n      decoded: P,\n      counter: i.counter,\n    });\n  },\n  T = async (e, t, n) => {\n    if (0 === e.options.maxCacheSize) return n;\n    if (!E.includes(t.method)) return n;\n    const r = new _(t, n, {\n      shared: !1,\n    });\n    if (r.storable()) {\n      const o = await y(n);\n      e.cache.set(\n        t.url,\n        {\n          policy: r,\n          response: o,\n        },\n        r.timeToLive()\n      );\n      return o;\n    }\n    return n;\n  },\n  k = (e, t = {}) => {\n    const n = new URL(e);\n    if (\"object\" != typeof t || Array.isArray(t))\n      throw new TypeError(\"qs: object expected\");\n    Object.entries(t).forEach(([e, t]) => {\n      if (Array.isArray(t)) {\n        t.forEach((t) => n.searchParams.append(e, t));\n      } else {\n        n.searchParams.append(e, t);\n      }\n    });\n    return n.href;\n  },\n  I = (e) => new g(e);\nclass P {\n  constructor(e) {\n    this.options = {\n      ...e,\n    };\n    const { maxCacheSize: t } = this.options;\n    let n = \"number\" == typeof t && t >= 0 ? t : 104857600,\n      o = 500;\n    if (0 === n) {\n      n = 1;\n      o = 1;\n    }\n    this.cache = new s({\n      max: o,\n      maxSize: n,\n      sizeCalculation: ({ response: e }, t) => v(e),\n    });\n    this.eventEmitter = new r();\n    this.options.h2 = this.options.h2 || {};\n    if (undefined === this.options.h2.enablePush) {\n      this.options.h2.enablePush = !0;\n    }\n    const { enablePush: i } = this.options.h2;\n    if (i) {\n      this.options.h2.pushPromiseHandler = (e, t, n) => {\n        const r = {\n          ...t,\n        };\n        Object.keys(r)\n          .filter((e) => e.startsWith(\":\"))\n          .forEach((e) => delete r[e]);\n        this.pushPromiseHandler(e, r, n);\n      };\n      this.options.h2.pushHandler = (e, t, n) => {\n        const r = {\n          ...t,\n        };\n        Object.keys(r)\n          .filter((e) => e.startsWith(\":\"))\n          .forEach((e) => delete r[e]);\n        const {\n          statusCode: o,\n          statusText: i,\n          httpVersion: s,\n          headers: a,\n          readable: c,\n          decoded: l,\n        } = n;\n        this.pushHandler(\n          e,\n          r,\n          new u(c, {\n            url: e,\n            status: o,\n            statusText: i,\n            headers: a,\n            httpVersion: s,\n            decoded: l,\n          })\n        );\n      };\n    }\n    this.context = w(this.options);\n  }\n  api() {\n    return {\n      fetch: async (e, t) => this.fetch(e, t),\n      Body: a,\n      Headers: c,\n      Request: l,\n      Response: u,\n      AbortController: f,\n      AbortSignal: m,\n      FetchBaseError: d,\n      FetchError: p,\n      AbortError: h,\n      context: (e = {}) => new P(e).api(),\n      noCache: (e = {}) =>\n        new P({\n          ...e,\n          maxCacheSize: 0,\n        }).api(),\n      h1: (e = {}) =>\n        new P({\n          ...e,\n          alpnProtocols: [this.context.ALPN_HTTP1_1],\n        }).api(),\n      keepAlive: (e = {}) =>\n        new P({\n          ...e,\n          alpnProtocols: [this.context.ALPN_HTTP1_1],\n          h1: {\n            keepAlive: !0,\n          },\n        }).api(),\n      h1NoCache: (e = {}) =>\n        new P({\n          ...e,\n          maxCacheSize: 0,\n          alpnProtocols: [this.context.ALPN_HTTP1_1],\n        }).api(),\n      keepAliveNoCache: (e = {}) =>\n        new P({\n          ...e,\n          maxCacheSize: 0,\n          alpnProtocols: [this.context.ALPN_HTTP1_1],\n          h1: {\n            keepAlive: !0,\n          },\n        }).api(),\n      reset: async () => this.context.reset(),\n      onPush: (e) => this.onPush(e),\n      offPush: (e) => this.offPush(e),\n      createUrl: k,\n      timeoutSignal: I,\n      clearCache: () => this.clearCache(),\n      cacheStats: () => this.cacheStats(),\n      ALPN_HTTP2: this.context.ALPN_HTTP2,\n      ALPN_HTTP2C: this.context.ALPN_HTTP2C,\n      ALPN_HTTP1_1: this.context.ALPN_HTTP1_1,\n      ALPN_HTTP1_0: this.context.ALPN_HTTP1_0,\n    };\n  }\n  async fetch(e, t) {\n    return (async (e, t, n) => {\n      const r = new l(t, n);\n      if (\n        0 !== e.options.maxCacheSize &&\n        E.includes(r.method) &&\n        ![\"no-store\", \"reload\"].includes(r.cache)\n      ) {\n        const { policy: t, response: n } = e.cache.get(r.url) || {};\n        if (t && t.satisfiesWithoutRevalidation(r)) {\n          n.headers = new c(t.responseHeaders(n));\n          const e = n.clone();\n          e.fromCache = !0;\n          return e;\n        }\n      }\n      const o = await S(e, r);\n      return \"no-store\" !== r.cache ? T(e, r, o) : o;\n    })(this, e, t);\n  }\n  onPush(e) {\n    return this.eventEmitter.on(C, e);\n  }\n  offPush(e) {\n    return this.eventEmitter.off(C, e);\n  }\n  clearCache() {\n    this.cache.clear();\n  }\n  cacheStats() {\n    return {\n      size: this.cache.calculatedSize,\n      count: this.cache.size,\n    };\n  }\n  pushPromiseHandler(e, t, n) {\n    i(`received server push promise: ${e}, headers: ${JSON.stringify(t)}`);\n    const r = new l(e, {\n        headers: t,\n      }),\n      { policy: o } = this.cache.get(e) || {};\n    if (o && o.satisfiesWithoutRevalidation(r)) {\n      i(\n        `already cached, reject push promise: ${e}, headers: ${JSON.stringify(\n          t\n        )}`\n      );\n      n();\n    }\n  }\n  async pushHandler(e, t, n) {\n    i(\n      `caching resource pushed by server: ${e}, reqHeaders: ${JSON.stringify(\n        t\n      )}, status: ${n.status}, respHeaders: ${JSON.stringify(n.headers)}`\n    );\n    const r = await T(\n      this,\n      new l(e, {\n        headers: t,\n      }),\n      n\n    );\n    this.eventEmitter.emit(C, e, r);\n  }\n}\nmodule.exports = new P().api();",
  "6157": "module.exports = {\n  i8: \"1.7.6\",\n};",
  "6167": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.contentVocabulary = exports.metadataVocabulary = undefined;\nexports.metadataVocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n];\nexports.contentVocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n];",
  "6214": "const t = new Set([200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501]),\n  n = new Set([\n    200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501,\n  ]),\n  r = new Set([500, 502, 503, 504]),\n  o = {\n    date: !0,\n    connection: !0,\n    \"keep-alive\": !0,\n    \"proxy-authenticate\": !0,\n    \"proxy-authorization\": !0,\n    te: !0,\n    trailer: !0,\n    \"transfer-encoding\": !0,\n    upgrade: !0,\n  },\n  i = {\n    \"content-length\": !0,\n    \"content-encoding\": !0,\n    \"transfer-encoding\": !0,\n    \"content-range\": !0,\n  };\nfunction s(e) {\n  const t = parseInt(e, 10);\n  return isFinite(t) ? t : 0;\n}\nfunction a(e) {\n  const t = {};\n  if (!e) return t;\n  const n = e.trim().split(/\\s*,\\s*/);\n  for (const e of n) {\n    const [n, r] = e.split(/\\s*=\\s*/, 2);\n    t[n] = undefined === r || r.replace(/^\"|\"$/g, \"\");\n  }\n  return t;\n}\nfunction c(e) {\n  let t = [];\n  for (const n in e) {\n    const r = e[n];\n    t.push(!0 === r ? n : n + \"=\" + r);\n  }\n  if (t.length) return t.join(\", \");\n}\nmodule.exports = class {\n  constructor(\n    e,\n    t,\n    {\n      shared: n,\n      cacheHeuristic: r,\n      immutableMinTimeToLive: o,\n      ignoreCargoCult: i,\n      _fromObject: s,\n    } = {}\n  ) {\n    if (s) this._fromObject(s);\n    else {\n      if (!t || !t.headers) throw Error(\"Response headers missing\");\n      this._assertRequestHasHeaders(e);\n      this._responseTime = this.now();\n      this._isShared = !1 !== n;\n      this._cacheHeuristic = undefined !== r ? r : 0.1;\n      this._immutableMinTtl = undefined !== o ? o : 864e5;\n      this._status = \"status\" in t ? t.status : 200;\n      this._resHeaders = t.headers;\n      this._rescc = a(t.headers[\"cache-control\"]);\n      this._method = \"method\" in e ? e.method : \"GET\";\n      this._url = e.url;\n      this._host = e.headers.host;\n      this._noAuthorization = !e.headers.authorization;\n      this._reqHeaders = t.headers.vary ? e.headers : null;\n      this._reqcc = a(e.headers[\"cache-control\"]);\n      if (i && \"pre-check\" in this._rescc && \"post-check\" in this._rescc) {\n        delete this._rescc[\"pre-check\"];\n        delete this._rescc[\"post-check\"];\n        delete this._rescc[\"no-cache\"];\n        delete this._rescc[\"no-store\"];\n        delete this._rescc[\"must-revalidate\"];\n        this._resHeaders = Object.assign({}, this._resHeaders, {\n          \"cache-control\": c(this._rescc),\n        });\n        delete this._resHeaders.expires;\n        delete this._resHeaders.pragma;\n      }\n      if (\n        null == t.headers[\"cache-control\"] &&\n        /no-cache/.test(t.headers.pragma)\n      ) {\n        this._rescc[\"no-cache\"] = !0;\n      }\n    }\n  }\n  now() {\n    return Date.now();\n  }\n  storable() {\n    return !(\n      this._reqcc[\"no-store\"] ||\n      !(\n        \"GET\" === this._method ||\n        \"HEAD\" === this._method ||\n        (\"POST\" === this._method && this._hasExplicitExpiration())\n      ) ||\n      !n.has(this._status) ||\n      this._rescc[\"no-store\"] ||\n      (this._isShared && this._rescc.private) ||\n      (this._isShared &&\n        !this._noAuthorization &&\n        !this._allowsStoringAuthenticated()) ||\n      !(\n        this._resHeaders.expires ||\n        this._rescc[\"max-age\"] ||\n        (this._isShared && this._rescc[\"s-maxage\"]) ||\n        this._rescc.public ||\n        t.has(this._status)\n      )\n    );\n  }\n  _hasExplicitExpiration() {\n    return (\n      (this._isShared && this._rescc[\"s-maxage\"]) ||\n      this._rescc[\"max-age\"] ||\n      this._resHeaders.expires\n    );\n  }\n  _assertRequestHasHeaders(e) {\n    if (!e || !e.headers) throw Error(\"Request headers missing\");\n  }\n  satisfiesWithoutRevalidation(e) {\n    this._assertRequestHasHeaders(e);\n    const t = a(e.headers[\"cache-control\"]);\n    return (\n      !t[\"no-cache\"] &&\n      !/no-cache/.test(e.headers.pragma) &&\n      !(t[\"max-age\"] && this.age() > t[\"max-age\"]) &&\n      !(t[\"min-fresh\"] && this.timeToLive() < 1e3 * t[\"min-fresh\"]) &&\n      !(\n        this.stale() &&\n        (!t[\"max-stale\"] ||\n          this._rescc[\"must-revalidate\"] ||\n          !(\n            !0 === t[\"max-stale\"] || t[\"max-stale\"] > this.age() - this.maxAge()\n          ))\n      ) &&\n      this._requestMatches(e, !1)\n    );\n  }\n  _requestMatches(e, t) {\n    return (\n      (!this._url || this._url === e.url) &&\n      this._host === e.headers.host &&\n      (!e.method || this._method === e.method || (t && \"HEAD\" === e.method)) &&\n      this._varyMatches(e)\n    );\n  }\n  _allowsStoringAuthenticated() {\n    return (\n      this._rescc[\"must-revalidate\"] ||\n      this._rescc.public ||\n      this._rescc[\"s-maxage\"]\n    );\n  }\n  _varyMatches(e) {\n    if (!this._resHeaders.vary) return !0;\n    if (\"*\" === this._resHeaders.vary) return !1;\n    const t = this._resHeaders.vary\n      .trim()\n      .toLowerCase()\n      .split(/\\s*,\\s*/);\n    for (const n of t) if (e.headers[n] !== this._reqHeaders[n]) return !1;\n    return !0;\n  }\n  _copyWithoutHopByHopHeaders(e) {\n    const t = {};\n    for (const n in e)\n      if (o[n]) {\n        t[n] = e[n];\n      }\n    if (e.connection) {\n      const n = e.connection.trim().split(/\\s*,\\s*/);\n      for (const e of n) delete t[e];\n    }\n    if (t.warning) {\n      const e = t.warning.split(/,/).filter((e) => !/^\\s*1[0-9][0-9]/.test(e));\n      if (e.length) {\n        t.warning = e.join(\",\").trim();\n      } else {\n        delete t.warning;\n      }\n    }\n    return t;\n  }\n  responseHeaders() {\n    const e = this._copyWithoutHopByHopHeaders(this._resHeaders),\n      t = this.age();\n    if (t > 86400 && !this._hasExplicitExpiration() && this.maxAge() > 86400) {\n      e.warning = (e.warning ? `${e.warning}, ` : \"\") + '113 - \"rfc7234 5.5.4\"';\n    }\n    e.age = `${Math.round(t)}`;\n    e.date = new Date(this.now()).toUTCString();\n    return e;\n  }\n  date() {\n    const e = Date.parse(this._resHeaders.date);\n    return isFinite(e) ? e : this._responseTime;\n  }\n  age() {\n    return this._ageValue() + (this.now() - this._responseTime) / 1e3;\n  }\n  _ageValue() {\n    return s(this._resHeaders.age);\n  }\n  maxAge() {\n    if (!this.storable() || this._rescc[\"no-cache\"]) return 0;\n    if (\n      this._isShared &&\n      this._resHeaders[\"set-cookie\"] &&\n      !this._rescc.public &&\n      !this._rescc.immutable\n    )\n      return 0;\n    if (\"*\" === this._resHeaders.vary) return 0;\n    if (this._isShared) {\n      if (this._rescc[\"proxy-revalidate\"]) return 0;\n      if (this._rescc[\"s-maxage\"]) return s(this._rescc[\"s-maxage\"]);\n    }\n    if (this._rescc[\"max-age\"]) return s(this._rescc[\"max-age\"]);\n    const e = this._rescc.immutable ? this._immutableMinTtl : 0,\n      t = this.date();\n    if (this._resHeaders.expires) {\n      const n = Date.parse(this._resHeaders.expires);\n      return Number.isNaN(n) || n < t ? 0 : Math.max(e, (n - t) / 1e3);\n    }\n    if (this._resHeaders[\"last-modified\"]) {\n      const n = Date.parse(this._resHeaders[\"last-modified\"]);\n      if (isFinite(n) && t > n)\n        return Math.max(e, ((t - n) / 1e3) * this._cacheHeuristic);\n    }\n    return e;\n  }\n  timeToLive() {\n    const e = this.maxAge() - this.age(),\n      t = e + s(this._rescc[\"stale-if-error\"]),\n      n = e + s(this._rescc[\"stale-while-revalidate\"]);\n    return 1e3 * Math.max(0, e, t, n);\n  }\n  stale() {\n    return this.maxAge() <= this.age();\n  }\n  _useStaleIfError() {\n    return this.maxAge() + s(this._rescc[\"stale-if-error\"]) > this.age();\n  }\n  useStaleWhileRevalidate() {\n    return (\n      this.maxAge() + s(this._rescc[\"stale-while-revalidate\"]) > this.age()\n    );\n  }\n  static fromObject(e) {\n    return new this(undefined, undefined, {\n      _fromObject: e,\n    });\n  }\n  _fromObject(e) {\n    if (this._responseTime) throw Error(\"Reinitialized\");\n    if (!e || 1 !== e.v) throw Error(\"Invalid serialization\");\n    this._responseTime = e.t;\n    this._isShared = e.sh;\n    this._cacheHeuristic = e.ch;\n    this._immutableMinTtl = undefined !== e.imm ? e.imm : 864e5;\n    this._status = e.st;\n    this._resHeaders = e.resh;\n    this._rescc = e.rescc;\n    this._method = e.m;\n    this._url = e.u;\n    this._host = e.h;\n    this._noAuthorization = e.a;\n    this._reqHeaders = e.reqh;\n    this._reqcc = e.reqcc;\n  }\n  toObject() {\n    return {\n      v: 1,\n      t: this._responseTime,\n      sh: this._isShared,\n      ch: this._cacheHeuristic,\n      imm: this._immutableMinTtl,\n      st: this._status,\n      resh: this._resHeaders,\n      rescc: this._rescc,\n      m: this._method,\n      u: this._url,\n      h: this._host,\n      a: this._noAuthorization,\n      reqh: this._reqHeaders,\n      reqcc: this._reqcc,\n    };\n  }\n  revalidationHeaders(e) {\n    this._assertRequestHasHeaders(e);\n    const t = this._copyWithoutHopByHopHeaders(e.headers);\n    delete t[\"if-range\"];\n    if (!this._requestMatches(e, !0) || !this.storable())\n      return delete t[\"if-none-match\"], delete t[\"if-modified-since\"], t;\n    if (this._resHeaders.etag) {\n      t[\"if-none-match\"] = t[\"if-none-match\"]\n        ? `${t[\"if-none-match\"]}, ${this._resHeaders.etag}`\n        : this._resHeaders.etag;\n    }\n    if (\n      t[\"accept-ranges\"] ||\n      t[\"if-match\"] ||\n      t[\"if-unmodified-since\"] ||\n      (this._method && \"GET\" != this._method)\n    ) {\n      if ((delete t[\"if-modified-since\"], t[\"if-none-match\"])) {\n        const e = t[\"if-none-match\"]\n          .split(/,/)\n          .filter((e) => !/^\\s*W\\//.test(e));\n        e.length\n          ? (t[\"if-none-match\"] = e.join(\",\").trim())\n          : delete t[\"if-none-match\"];\n      }\n    } else\n      this._resHeaders[\"last-modified\"] &&\n        !t[\"if-modified-since\"] &&\n        (t[\"if-modified-since\"] = this._resHeaders[\"last-modified\"]);\n    return t;\n  }\n  revalidatedPolicy(e, t) {\n    this._assertRequestHasHeaders(e);\n    if (\n      this._useStaleIfError() &&\n      (function (e) {\n        return !e || r.has(e.status);\n      })(t)\n    )\n      return {\n        modified: !1,\n        matches: !1,\n        policy: this,\n      };\n    if (!t || !t.headers) throw Error(\"Response headers missing\");\n    let n = !1;\n    if (undefined !== t.status && 304 != t.status) {\n      n = !1;\n    } else {\n      if (t.headers.etag && !/^\\s*W\\//.test(t.headers.etag)) {\n        n =\n          this._resHeaders.etag &&\n          this._resHeaders.etag.replace(/^\\s*W\\//, \"\") === t.headers.etag;\n      } else {\n        if (this._resHeaders.etag && t.headers.etag) {\n          n =\n            this._resHeaders.etag.replace(/^\\s*W\\//, \"\") ===\n            t.headers.etag.replace(/^\\s*W\\//, \"\");\n        } else {\n          if (this._resHeaders[\"last-modified\"]) {\n            n =\n              this._resHeaders[\"last-modified\"] === t.headers[\"last-modified\"];\n          } else {\n            if (\n              this._resHeaders.etag ||\n              this._resHeaders[\"last-modified\"] ||\n              t.headers.etag ||\n              t.headers[\"last-modified\"]\n            ) {\n              n = !0;\n            }\n          }\n        }\n      }\n    }\n    if (!n)\n      return {\n        policy: new this.constructor(e, t),\n        modified: 304 != t.status,\n        matches: !1,\n      };\n    const o = {};\n    for (const e in this._resHeaders)\n      o[e] = e in t.headers && !i[e] ? t.headers[e] : this._resHeaders[e];\n    const s = Object.assign({}, t, {\n      status: this._status,\n      method: this._method,\n      headers: o,\n    });\n    return {\n      policy: new this.constructor(e, s, {\n        shared: this._isShared,\n        cacheHeuristic: this._cacheHeuristic,\n        immutableMinTimeToLive: this._immutableMinTtl,\n      }),\n      modified: !1,\n      matches: !0,\n    };\n  }\n};",
  "6239": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(4815),\n  o = require(412),\n  i = require(6776),\n  s = require(9351),\n  a = {\n    keyword: \"properties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(e) {\n      const { gen: t, schema: n, parentSchema: a, data: c, it: l } = e;\n      if (\n        \"all\" === l.opts.removeAdditional &&\n        undefined === a.additionalProperties\n      ) {\n        s.default.code(new r.KeywordCxt(l, s.default, \"additionalProperties\"));\n      }\n      const u = o.allSchemaProperties(n);\n      for (const e of u) l.definedProperties.add(e);\n      if (l.opts.unevaluated && u.length && !0 !== l.props) {\n        l.props = i.mergeEvaluated.props(t, i.toHash(u), l.props);\n      }\n      const d = u.filter((e) => !i.alwaysValidSchema(l, n[e]));\n      if (0 === d.length) return;\n      const p = t.name(\"valid\");\n      for (const n of d) {\n        if (h(n)) {\n          f(n);\n        } else {\n          t.if(o.propertyInData(t, c, n, l.opts.ownProperties));\n          f(n);\n          if (l.allErrors) {\n            t.else().var(p, !0);\n          }\n          t.endIf();\n        }\n        e.it.definedProperties.add(n);\n        e.ok(p);\n      }\n      function h(e) {\n        return (\n          l.opts.useDefaults && !l.compositeRule && undefined !== n[e].default\n        );\n      }\n      function f(t) {\n        e.subschema(\n          {\n            keyword: \"properties\",\n            schemaProp: t,\n            dataProp: t,\n          },\n          p\n        );\n      }\n    },\n  };\nexports.default = a;",
  "6252": "module = require.nmd(module);\nvar r,\n  o = require(9125).SourceMapConsumer,\n  i = require(\"path\");\ntry {\n  if ((r = require(\"fs\")).existsSync && r.readFileSync) {\n    r = null;\n  }\n} catch (e) {}\nvar s = require(5420);\nfunction a(e, t) {\n  return e.require(t);\n}\nvar c = !1,\n  l = !1,\n  u = !1,\n  d = \"auto\",\n  p = {},\n  h = {},\n  f = /^data:application\\/json[^,]+base64,/,\n  m = [],\n  g = [];\nfunction _() {\n  return (\n    \"browser\" === d ||\n    (\"node\" !== d &&\n      \"undefined\" != typeof window &&\n      \"function\" == typeof XMLHttpRequest &&\n      !(\n        window.require &&\n        window.module &&\n        window.process &&\n        \"renderer\" === window.process.type\n      ))\n  );\n}\nfunction y(e) {\n  return function (t) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n](t);\n      if (r) return r;\n    }\n    return null;\n  };\n}\nvar v = y(m);\nfunction b(e, t) {\n  if (!e) return t;\n  var n = i.dirname(e),\n    r = /^\\w+:\\/\\/[^\\/]*/.exec(n),\n    o = r ? r[0] : \"\",\n    s = n.slice(o.length);\n  return o && /^\\/\\w\\:/.test(s)\n    ? (o += \"/\") + i.resolve(n.slice(o.length), t).replace(/\\\\/g, \"/\")\n    : o + i.resolve(n.slice(o.length), t);\n}\nm.push(function (e) {\n  e = e.trim();\n  if (/^file:/.test(e)) {\n    e = e.replace(/file:\\/\\/\\/(\\w:)?/, function (e, t) {\n      return t ? \"\" : \"/\";\n    });\n  }\n  if (e in p) return p[e];\n  var t = \"\";\n  try {\n    if (r) {\n      if (r.existsSync(e)) {\n        t = r.readFileSync(e, \"utf8\");\n      }\n    } else {\n      var n = new XMLHttpRequest();\n      n.open(\"GET\", e, !1);\n      n.send(null);\n      if (4 === n.readyState && 200 === n.status) {\n        t = n.responseText;\n      }\n    }\n  } catch (e) {}\n  return (p[e] = t);\n});\nvar retrieveSourceMap = y(g);\nfunction mapSourcePosition(e) {\n  var t = h[e.source];\n  if (!t) {\n    var n = retrieveSourceMap(e.source);\n    if (n) {\n      if (\n        (t = h[e.source] =\n          {\n            url: n.url,\n            map: new o(n.map),\n          }).map.sourcesContent\n      ) {\n        t.map.sources.forEach(function (e, n) {\n          var r = t.map.sourcesContent[n];\n          if (r) {\n            var o = b(t.url, e);\n            p[o] = r;\n          }\n        });\n      }\n    } else {\n      t = h[e.source] = {\n        url: null,\n        map: null,\n      };\n    }\n  }\n  if (t && t.map && \"function\" == typeof t.map.originalPositionFor) {\n    var r = t.map.originalPositionFor(e);\n    if (null !== r.source) {\n      r.source = b(t.url, r.source);\n      return r;\n    }\n  }\n  return e;\n}\nfunction E(e) {\n  var t = /^eval at ([^(]+) \\((.+):(\\d+):(\\d+)\\)$/.exec(e);\n  if (t) {\n    var n = mapSourcePosition({\n      source: t[2],\n      line: +t[3],\n      column: t[4] - 1,\n    });\n    return (\n      \"eval at \" +\n      t[1] +\n      \" (\" +\n      n.source +\n      \":\" +\n      n.line +\n      \":\" +\n      (n.column + 1) +\n      \")\"\n    );\n  }\n  return (t = /^eval at ([^(]+) \\((.+)\\)$/.exec(e))\n    ? \"eval at \" + t[1] + \" (\" + E(t[2]) + \")\"\n    : e;\n}\nfunction C() {\n  var e,\n    t = \"\";\n  if (this.isNative()) t = \"native\";\n  else {\n    if (!(e = this.getScriptNameOrSourceURL()) && this.isEval()) {\n      t = this.getEvalOrigin();\n      t += \", \";\n    }\n    t += e || \"<anonymous>\";\n    var n = this.getLineNumber();\n    if (null != n) {\n      t += \":\" + n;\n      var r = this.getColumnNumber();\n      if (r) {\n        t += \":\" + r;\n      }\n    }\n  }\n  var o = \"\",\n    i = this.getFunctionName(),\n    s = !0,\n    a = this.isConstructor();\n  if (this.isToplevel() || a) {\n    if (a) {\n      o += \"new \" + (i || \"<anonymous>\");\n    } else {\n      if (i) {\n        o += i;\n      } else {\n        o += t;\n        s = !1;\n      }\n    }\n  } else {\n    var c = this.getTypeName();\n    if (\"[object Object]\" === c) {\n      c = \"null\";\n    }\n    var l = this.getMethodName();\n    if (i) {\n      if (c && 0 != i.indexOf(c)) {\n        o += c + \".\";\n      }\n      o += i;\n      if (l && i.indexOf(\".\" + l) != i.length - l.length - 1) {\n        o += \" [as \" + l + \"]\";\n      }\n    } else {\n      o += c + \".\" + (l || \"<anonymous>\");\n    }\n  }\n  if (s) {\n    o += \" (\" + t + \")\";\n  }\n  return o;\n}\nfunction S(e) {\n  var t = {};\n  Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach(function (n) {\n    t[n] = /^(?:is|get)/.test(n)\n      ? function () {\n          return e[n].call(e);\n        }\n      : e[n];\n  });\n  t.toString = C;\n  return t;\n}\nfunction wrapCallSite(e, t) {\n  if (undefined === t) {\n    t = {\n      nextPosition: null,\n      curPosition: null,\n    };\n  }\n  if (e.isNative()) return (t.curPosition = null), e;\n  var n = e.getFileName() || e.getScriptNameOrSourceURL();\n  if (n) {\n    var r = e.getLineNumber(),\n      o = e.getColumnNumber() - 1,\n      i =\n        /^v(10\\.1[6-9]|10\\.[2-9][0-9]|10\\.[0-9]{3,}|1[2-9]\\d*|[2-9]\\d|\\d{3,}|11\\.11)/.test(\n          \"object\" == typeof process && null !== process ? process.version : \"\"\n        )\n          ? 0\n          : 62;\n    if (1 === r && o > i && !_() && !e.isEval()) {\n      o -= i;\n    }\n    var s = mapSourcePosition({\n      source: n,\n      line: r,\n      column: o,\n    });\n    t.curPosition = s;\n    var a = (e = S(e)).getFunctionName;\n    e.getFunctionName = function () {\n      return null == t.nextPosition ? a() : t.nextPosition.name || a();\n    };\n    e.getFileName = function () {\n      return s.source;\n    };\n    e.getLineNumber = function () {\n      return s.line;\n    };\n    e.getColumnNumber = function () {\n      return s.column + 1;\n    };\n    e.getScriptNameOrSourceURL = function () {\n      return s.source;\n    };\n    return e;\n  }\n  var c = e.isEval() && e.getEvalOrigin();\n  return c\n    ? ((c = E(c)),\n      ((e = S(e)).getEvalOrigin = function () {\n        return c;\n      }),\n      e)\n    : e;\n}\nfunction k(e, t) {\n  if (u) {\n    p = {};\n    h = {};\n  }\n  for (\n    var n = (e.name || \"Error\") + \": \" + (e.message || \"\"),\n      r = {\n        nextPosition: null,\n        curPosition: null,\n      },\n      o = [],\n      i = t.length - 1;\n    i >= 0;\n    i--\n  ) {\n    o.push(\"\\n    at \" + wrapCallSite(t[i], r));\n    r.nextPosition = r.curPosition;\n  }\n  r.curPosition = r.nextPosition = null;\n  return n + o.reverse().join(\"\");\n}\nfunction getErrorSource(e) {\n  var t = /\\n    at [^(]+ \\((.*):(\\d+):(\\d+)\\)/.exec(e.stack);\n  if (t) {\n    var n = t[1],\n      o = +t[2],\n      i = +t[3],\n      s = p[n];\n    if (!s && r && r.existsSync(n))\n      try {\n        s = r.readFileSync(n, \"utf8\");\n      } catch (e) {\n        s = \"\";\n      }\n    if (s) {\n      var a = s.split(/(?:\\r\\n|\\r|\\n)/)[o - 1];\n      if (a)\n        return n + \":\" + o + \"\\n\" + a + \"\\n\" + new Array(i).join(\" \") + \"^\";\n    }\n  }\n  return null;\n}\nfunction P(e) {\n  var t = getErrorSource(e),\n    n = (function () {\n      if (\"object\" == typeof process && null !== process) return process.stderr;\n    })();\n  if (n && n._handle && n._handle.setBlocking) {\n    n._handle.setBlocking(!0);\n  }\n  if (t) {\n    console.error();\n    console.error(t);\n  }\n  console.error(e.stack);\n  if (\n    \"object\" == typeof process &&\n    null !== process &&\n    \"function\" == typeof process.exit\n  ) {\n    process.exit(1);\n  }\n}\ng.push(function (e) {\n  var t,\n    n = (function (e) {\n      var t;\n      if (_())\n        try {\n          var n = new XMLHttpRequest();\n          n.open(\"GET\", e, !1);\n          n.send(null);\n          t = 4 === n.readyState ? n.responseText : null;\n          var r =\n            n.getResponseHeader(\"SourceMap\") ||\n            n.getResponseHeader(\"X-SourceMap\");\n          if (r) return r;\n        } catch (e) {}\n      t = v(e);\n      for (\n        var o,\n          i,\n          s =\n            /(?:\\/\\/[@#][\\s]*sourceMappingURL=([^\\s'\"]+)[\\s]*$)|(?:\\/\\*[@#][\\s]*sourceMappingURL=([^\\s*'\"]+)[\\s]*(?:\\*\\/)[\\s]*$)/gm;\n        (i = s.exec(t));\n\n      )\n        o = i;\n      return o ? o[1] : null;\n    })(e);\n  if (!n) return null;\n  if (f.test(n)) {\n    var r = n.slice(n.indexOf(\",\") + 1);\n    t = s(r, \"base64\").toString();\n    n = e;\n  } else {\n    n = b(e, n);\n    t = v(n);\n  }\n  return t\n    ? {\n        url: n,\n        map: t,\n      }\n    : null;\n});\nvar A = m.slice(0),\n  O = g.slice(0);\nexports.wrapCallSite = wrapCallSite;\nexports.getErrorSource = getErrorSource;\nexports.mapSourcePosition = mapSourcePosition;\nexports.retrieveSourceMap = retrieveSourceMap;\nexports.install = function (t) {\n  if (\n    (t = t || {}).environment &&\n    ((d = t.environment), -1 === [\"node\", \"browser\", \"auto\"].indexOf(d))\n  )\n    throw new Error(\n      \"environment \" +\n        d +\n        \" was unknown. Available options are {auto, browser, node}\"\n    );\n  if (t.retrieveFile) {\n    if (t.overrideRetrieveFile) {\n      m.length = 0;\n    }\n    m.unshift(t.retrieveFile);\n  }\n  if (t.retrieveSourceMap) {\n    if (t.overrideRetrieveSourceMap) {\n      g.length = 0;\n    }\n    g.unshift(t.retrieveSourceMap);\n  }\n  if (t.hookRequire && !_()) {\n    var n = a(module, \"module\"),\n      r = n.prototype._compile;\n    r.__sourceMapSupport ||\n      ((n.prototype._compile = function (e, t) {\n        return (p[t] = e), (h[t] = void 0), r.call(this, e, t);\n      }),\n      (n.prototype._compile.__sourceMapSupport = !0));\n  }\n  if (u) {\n    u = \"emptyCacheBetweenOperations\" in t && t.emptyCacheBetweenOperations;\n  }\n  if (c) {\n    c = !0;\n    Error.prepareStackTrace = k;\n  }\n  if (!l) {\n    var o = !(\"handleUncaughtExceptions\" in t) || t.handleUncaughtExceptions;\n    try {\n      !1 === a(module, \"worker_threads\").isMainThread && (o = !1);\n    } catch (e) {}\n    o &&\n      \"object\" == typeof process &&\n      null !== process &&\n      \"function\" == typeof process.on &&\n      ((l = !0),\n      (i = process.emit),\n      (process.emit = function (e) {\n        if (\"uncaughtException\" === e) {\n          var t = arguments[1] && arguments[1].stack,\n            n = this.listeners(e).length > 0;\n          if (t && !n) return P(arguments[1]);\n        }\n        return i.apply(this, arguments);\n      }));\n  }\n  var i;\n};\nexports.resetRetrieveHandlers = function () {\n  m.length = 0;\n  g.length = 0;\n  m = A.slice(0);\n  g = O.slice(0);\n  retrieveSourceMap = y(g);\n  v = y(m);\n};",
  "6267": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.commandOpenPanel = exports.completionContextForEditor = undefined;\nconst r = require(\"vscode\"),\n  o = require(256);\nfunction completionContextForEditor(e, t, n) {\n  return n || o.completionContextForDocument(e, t.document, t.selection.active);\n}\nexports.completionContextForEditor = completionContextForEditor;\nexports.commandOpenPanel = function (e, t) {\n  const n = r.window.activeTextEditor;\n  if (!n) return;\n  if (!r.workspace.getConfiguration(\"editor\", n.document.uri).get(\"codeLens\"))\n    return void r.window\n      .showInformationMessage(\n        \"GitHub Copilot Panel requires having Code Lens enabled. Please update your settings and then try again.\",\n        \"Open Settings\"\n      )\n      .then((e) => {\n        if (\"Open Settings\" === e) {\n          r.commands.executeCommand(\n            \"workbench.action.openSettings\",\n            \"editor.codeLens\"\n          );\n        }\n      });\n  t = completionContextForEditor(e, n, t);\n  const s = o.encodeLocation(n.document.uri, t),\n    a = n.document.languageId;\n  r.workspace.openTextDocument(s).then((e) => {\n    r.languages.setTextDocumentLanguage(e, a);\n    r.window.showTextDocument(e, r.ViewColumn.Beside);\n  });\n};",
  "6279": "var r,\n  o =\n    (this && this.__extends) ||\n    ((r =\n      Object.setPrototypeOf ||\n      ({\n        __proto__: [],\n      } instanceof Array &&\n        function (e, t) {\n          e.__proto__ = t;\n        }) ||\n      function (e, t) {\n        for (var n in t)\n          if (t.hasOwnProperty(n)) {\n            e[n] = t[n];\n          }\n      }),\n    function (e, t) {\n      function n() {\n        this.constructor = e;\n      }\n      r(e, t);\n      e.prototype =\n        null === t ? Object.create(t) : ((n.prototype = t.prototype), new n());\n    }),\n  i = (function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.properties = {};\n      t.measurements = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  })(require(4526));\nmodule.exports = i;",
  "6281": "var r = require(7396),\n  o = (function () {\n    function e(t) {\n      if (e.INSTANCE)\n        throw new Error(\n          \"Console logging adapter tracking should be configured from the applicationInsights object\"\n        );\n      this._client = t;\n      e.INSTANCE = this;\n    }\n    e.prototype.enable = function (e, t) {\n      if (r.IsInitialized) {\n        require(4309).wp(e && t, this._client);\n        require(5823).wp(e, this._client);\n        require(454).wp(e, this._client);\n      }\n    };\n    e.prototype.isInitialized = function () {\n      return this._isInitialized;\n    };\n    e.prototype.dispose = function () {\n      e.INSTANCE = null;\n      this.enable(!1, !1);\n    };\n    e._methodNames = [\"debug\", \"info\", \"log\", \"warn\", \"error\"];\n    return e;\n  })();\nmodule.exports = o;",
  "6290": "var r,\n  o =\n    (this && this.__extends) ||\n    ((r =\n      Object.setPrototypeOf ||\n      ({\n        __proto__: [],\n      } instanceof Array &&\n        function (e, t) {\n          e.__proto__ = t;\n        }) ||\n      function (e, t) {\n        for (var n in t)\n          if (t.hasOwnProperty(n)) {\n            e[n] = t[n];\n          }\n      }),\n    function (e, t) {\n      function n() {\n        this.constructor = e;\n      }\n      r(e, t);\n      e.prototype =\n        null === t ? Object.create(t) : ((n.prototype = t.prototype), new n());\n    }),\n  i = (function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.success = !0;\n      t.properties = {};\n      t.measurements = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  })(require(8934));\nmodule.exports = i;",
  "6333": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.forceSendingTelemetry =\n  exports.dropTelemetryConfig =\n  exports.setTelemetryConfig =\n  exports.logEnginePrompt =\n  exports.logEngineCompletion =\n  exports.telemetryError =\n  exports.telemetryException =\n  exports.telemetryRaw =\n  exports.telemetryExpProblem =\n  exports.telemetry =\n  exports.configureReporter =\n  exports.TelemetryEndpointUrl =\n  exports.now =\n  exports.telemetrizePromptLength =\n  exports.TelemetryData =\n  exports.setupEmptyReporters =\n  exports.setupStandardReporters =\n  exports.TelemetryReporters =\n  exports.APP_INSIGHTS_KEY_SECURE =\n  exports.APP_INSIGHTS_KEY =\n    undefined;\nconst r = require(1581),\n  o = require(4398),\n  i = require(1133),\n  s = require(9189),\n  a = require(6500),\n  c = require(70),\n  l = require(2499);\nexports.APP_INSIGHTS_KEY = \"7d7048df-6dd0-4048-bb23-b716c1461f8f\";\nexports.APP_INSIGHTS_KEY_SECURE = \"3fdd7f28-937a-48c8-9a21-ba337db23bd1\";\nclass TelemetryReporters {\n  constructor(e, t) {\n    this.reporter = e;\n    this.reporterSecure = t;\n  }\n  getReporter(e) {\n    return this.reporter;\n  }\n  getSecureReporter(e) {\n    if (y()) return this.reporterSecure;\n    if (c.shouldFailForDebugPurposes(e))\n      throw new Error(\"Internal error: telemetry opt-out\");\n  }\n  setReporter(e) {\n    this.reporter = e;\n  }\n  setSecureReporter(e) {\n    this.reporterSecure = e;\n  }\n  async deactivate() {\n    let e = Promise.resolve();\n    if (this.reporter) {\n      e = this.reporter.dispose();\n      this.reporter = undefined;\n    }\n    let t = Promise.resolve();\n    if (this.reporterSecure) {\n      t = this.reporterSecure.dispose();\n      this.reporterSecure = undefined;\n    }\n    await Promise.all([e, t]);\n  }\n  hackOptOutListener() {\n    this.reporter.optOutListener = {\n      dispose() {},\n    };\n    this.reporterSecure.optOutListener = {\n      dispose() {},\n    };\n  }\n  setToken(e) {\n    if (this.reporter) {\n      this.configureToken(this.reporter, e);\n    }\n    if (this.reporterSecure) {\n      this.configureToken(this.reporterSecure, e);\n    }\n  }\n  configureToken(e, t) {\n    const n = e;\n    if (n && n.appInsightsClient) {\n      n.appInsightsClient.context.tags.github_telemetry_token = t.token;\n    }\n  }\n}\nlet d;\nfunction p(e, t, n, r) {\n  const i = new o.default(t, n, r);\n  configureReporter(e, i);\n  return i;\n}\nexports.TelemetryReporters = TelemetryReporters;\nexports.setupStandardReporters = function (e, n) {\n  const r = i.getVersion(e),\n    o = p(e, n, r, exports.APP_INSIGHTS_KEY),\n    s = p(e, n, r, exports.APP_INSIGHTS_KEY_SECURE),\n    a = e.get(TelemetryReporters);\n  a.setReporter(o);\n  a.setSecureReporter(s);\n  return a;\n};\nexports.setupEmptyReporters = function () {\n  return new TelemetryReporters();\n};\nclass TelemetryData {\n  constructor(e, t, n) {\n    this.properties = e;\n    this.measurements = t;\n    this.issuedTime = n;\n  }\n  static createAndMarkAsIssued(e, t) {\n    return new TelemetryData(e || {}, t || {}, now());\n  }\n  extendedBy(e, t) {\n    const n = {\n        ...this.properties,\n        ...e,\n      },\n      r = {\n        ...this.measurements,\n        ...t,\n      },\n      o = new TelemetryData(n, r, this.issuedTime);\n    o.displayedTime = this.displayedTime;\n    o.filtersAndExp = this.filtersAndExp;\n    return o;\n  }\n  markAsDisplayed() {\n    if (undefined === this.displayedTime) {\n      this.displayedTime = now();\n    }\n  }\n  async extendWithExpTelemetry(e) {\n    if (this.filtersAndExp) {\n      await e.get(s.Features).addExpAndFilterToTelemetry(this);\n    }\n    this.filtersAndExp.exp.addToTelemetry(this);\n    this.filtersAndExp.filters.addToTelemetry(this);\n  }\n  extendWithEditorAgnosticFields(e) {\n    this.properties.editor_version = i.formatNameAndVersion(\n      e.get(i.EditorAndPluginInfo).getEditorInfo(e)\n    );\n    this.properties.editor_plugin_version = i.formatNameAndVersion(\n      e.get(i.EditorAndPluginInfo).getEditorPluginInfo(e)\n    );\n    const t = e.get(i.VscInfo);\n    this.properties.client_machineid = t.machineId;\n    this.properties.client_sessionid = t.sessionId;\n    this.properties.copilot_version = `copilot/${i.getVersion(e)}`;\n    this.properties.common_extname = e\n      .get(i.EditorAndPluginInfo)\n      .getEditorPluginInfo(e).name;\n    this.properties.common_extversion = e\n      .get(i.EditorAndPluginInfo)\n      .getEditorPluginInfo(e).version;\n  }\n  extendWithConfigProperties(e) {\n    const t = i.dumpConfig(e);\n    try {\n      t[\"copilot.build\"] = i.getBuild(e);\n      t[\"copilot.buildType\"] = i.getBuildType(e);\n    } catch (e) {}\n    if (d) {\n      t[\"copilot.trackingId\"] = d.trackingId;\n    }\n    this.properties = {\n      ...this.properties,\n      ...t,\n    };\n  }\n  extendWithRequestId(e) {\n    const t = {\n      completionId: e.completionId,\n      created: e.created.toString(),\n      headerRequestId: e.headerRequestId,\n      serverExperiments: e.serverExperiments,\n      deploymentId: e.deploymentId,\n    };\n    this.properties = {\n      ...this.properties,\n      ...t,\n    };\n  }\n  static maybeRemoveRepoInfoFromPropertiesHack(e, t) {\n    if (e) return t;\n    const n = {};\n    for (const e in t)\n      if (TelemetryData.keysToRemoveFromStandardTelemetryHack.includes(e)) {\n        n[e] = t[e];\n      }\n    return n;\n  }\n  sanitizeKeys() {\n    this.properties = TelemetryData.sanitizeKeys(this.properties);\n    this.measurements = TelemetryData.sanitizeKeys(this.measurements);\n  }\n  static sanitizeKeys(e) {\n    e = e || {};\n    const t = {};\n    for (const n in e)\n      t[\n        TelemetryData.keysExemptedFromSanitization.includes(n)\n          ? n\n          : n.replace(/\\./g, \"_\")\n      ] = e[n];\n    return t;\n  }\n  updateTimeSinceIssuedAndDisplayed() {\n    const e = now() - this.issuedTime;\n    this.measurements.timeSinceIssuedMs = e;\n    if (void 0 !== this.displayedTime) {\n      const e = now() - this.displayedTime;\n      this.measurements.timeSinceDisplayedMs = e;\n    }\n  }\n  validateData(e, t) {\n    var n;\n    let r;\n    if (TelemetryData.validateTelemetryProperties(this.properties)) {\n      r = {\n        problem: \"properties\",\n        error: JSON.stringify(TelemetryData.validateTelemetryProperties.errors),\n      };\n    }\n    if (!TelemetryData.validateTelemetryMeasurements(this.measurements)) {\n      const e = JSON.stringify(\n        TelemetryData.validateTelemetryMeasurements.errors\n      );\n      void 0 === r\n        ? (r = {\n            problem: \"measurements\",\n            error: e,\n          })\n        : ((r.problem = \"both\"), (r.error += `; ${e}`));\n    }\n    if (undefined === r) return !0;\n    if (c.shouldFailForDebugPurposes(e))\n      throw new Error(\n        `Invalid telemetry data: ${r.problem} ${\n          r.error\n        } properties=${JSON.stringify(\n          this.properties\n        )} measurements=${JSON.stringify(this.measurements)}`\n      );\n    telemetryError(\n      e,\n      \"invalidTelemetryData\",\n      TelemetryData.createAndMarkAsIssued({\n        properties: JSON.stringify(this.properties),\n        measurements: JSON.stringify(this.measurements),\n        problem: r.problem,\n        validationError: r.error,\n      }),\n      t\n    );\n    if (t) {\n      telemetryError(\n        e,\n        \"invalidTelemetryData_in_secure\",\n        TelemetryData.createAndMarkAsIssued({\n          problem: r.problem,\n          requestId:\n            null !== (n = this.properties.requestId) && undefined !== n\n              ? n\n              : \"unknown\",\n        }),\n        !1\n      );\n    }\n    return !1;\n  }\n  async makeReadyForSending(e, t, n) {\n    this.extendWithConfigProperties(e);\n    this.extendWithEditorAgnosticFields(e);\n    this.sanitizeKeys();\n    if (\"IncludeExp\" === n) {\n      await this.extendWithExpTelemetry(e);\n    }\n    this.updateTimeSinceIssuedAndDisplayed();\n    if (this.validateData(e, t)) {\n      this.properties.telemetry_failed_validation = \"true\";\n    }\n  }\n}\nfunction f(e, t, n, r) {\n  const o = t\n    ? e.get(TelemetryReporters).getSecureReporter(e)\n    : e.get(TelemetryReporters).getReporter(e);\n  if (o) {\n    o.sendTelemetryEvent(\n      n,\n      TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(t, r.properties),\n      r.measurements\n    );\n  }\n}\nfunction now() {\n  return new Date().getTime();\n}\nexports.TelemetryData = TelemetryData;\nTelemetryData.ajv = new r.default({\n  strictNumbers: !1,\n});\nTelemetryData.validateTelemetryProperties = TelemetryData.ajv.compile({\n  type: \"object\",\n  additionalProperties: {\n    type: \"string\",\n  },\n  required: [],\n});\nTelemetryData.validateTelemetryMeasurements = TelemetryData.ajv.compile({\n  type: \"object\",\n  properties: {\n    meanLogProb: {\n      type: \"number\",\n      nullable: !0,\n    },\n    meanAlternativeLogProb: {\n      type: \"number\",\n      nullable: !0,\n    },\n  },\n  additionalProperties: {\n    type: \"number\",\n  },\n  required: [],\n});\nTelemetryData.keysExemptedFromSanitization = [\n  a.ExpServiceTelemetryNames.assignmentContextTelemetryPropertyName,\n  a.ExpServiceTelemetryNames.featuresTelemetryPropertyName,\n];\nTelemetryData.keysToRemoveFromStandardTelemetryHack = [\n  \"gitRepoHost\",\n  \"gitRepoName\",\n  \"gitRepoOwner\",\n  \"gitRepoUrl\",\n  \"gitRepoPath\",\n  \"repo\",\n  \"request_option_nwo\",\n];\nexports.telemetrizePromptLength = function (e) {\n  return e.isFimEnabled\n    ? {\n        promptPrefixCharLen: e.prefix.length,\n        promptSuffixCharLen: e.suffix.length,\n      }\n    : {\n        promptCharLen: e.prefix.length,\n      };\n};\nexports.now = now;\nclass TelemetryEndpointUrl {\n  constructor(e = \"https://copilot-telemetry.githubusercontent.com/telemetry\") {\n    this.url = e;\n  }\n  getUrl() {\n    return this.url;\n  }\n  setUrlForTesting(e) {\n    this.url = e;\n  }\n}\nfunction configureReporter(e, t) {\n  const n = t;\n  if (n.appInsightsClient) {\n    const t = n.appInsightsClient.commonProperties,\n      r = TelemetryData.sanitizeKeys(t);\n    n.appInsightsClient.commonProperties = r;\n    n.appInsightsClient.context.tags[\n      n.appInsightsClient.context.keys.cloudRoleInstance\n    ] = \"REDACTED\";\n    const o = e.get(TelemetryEndpointUrl).getUrl();\n    n.appInsightsClient.config.endpointUrl = o;\n  }\n}\nfunction y() {\n  var e;\n  return (\n    null !== (e = null == d ? undefined : d.optedIn) && undefined !== e && e\n  );\n}\nasync function telemetry(e, t, n, r) {\n  if (r && !y()) return;\n  const o = n || TelemetryData.createAndMarkAsIssued({}, {});\n  await o.makeReadyForSending(e, null != r && r, \"IncludeExp\");\n  f(e, null != r && r, t, o);\n}\nasync function telemetryError(e, t, n, r) {\n  if (r && !y()) return;\n  const o = n || TelemetryData.createAndMarkAsIssued({}, {});\n  await o.makeReadyForSending(e, null != r && r, \"IncludeExp\");\n  (function (e, t, n, r) {\n    const o = t\n      ? e.get(TelemetryReporters).getSecureReporter(e)\n      : e.get(TelemetryReporters).getReporter(e);\n    if (o) {\n      o.sendTelemetryErrorEvent(\n        n,\n        TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(t, r.properties),\n        r.measurements\n      );\n    }\n  })(e, null != r && r, t, o);\n}\nexports.TelemetryEndpointUrl = TelemetryEndpointUrl;\nexports.configureReporter = configureReporter;\nexports.telemetry = telemetry;\nexports.telemetryExpProblem = async function (e, t) {\n  const n = TelemetryData.createAndMarkAsIssued(t, {});\n  await n.makeReadyForSending(e, !1, \"SkipExp\");\n  f(e, !1, \"expProblem\", n);\n};\nexports.telemetryRaw = async function (e, t, n, r) {\n  f(e, !1, t, {\n    properties: n,\n    measurements: r,\n  });\n};\nexports.telemetryException = async function (e, t, n, r) {\n  const o = t instanceof Error ? t : new Error(\"Non-error thrown: \" + t),\n    i = y(),\n    s = TelemetryData.createAndMarkAsIssued({\n      origin: l.redactPaths(n),\n      reason: i\n        ? \"Exception logged to restricted telemetry\"\n        : \"Exception, not logged due to opt-out\",\n      ...r,\n    });\n  await s.makeReadyForSending(e, !1, \"IncludeExp\");\n  f(e, !1, \"exception\", s);\n  if (!i) return;\n  const a = TelemetryData.createAndMarkAsIssued({\n    origin: n,\n    ...r,\n  });\n  await a.makeReadyForSending(e, !0, \"IncludeExp\");\n  (function (e, t, n, r) {\n    const o = e.get(TelemetryReporters).getSecureReporter(e);\n    if (o) {\n      o.sendTelemetryException(\n        n,\n        TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(true, r.properties),\n        r.measurements\n      );\n    }\n  })(e, 0, o, a);\n};\nexports.telemetryError = telemetryError;\nexports.logEngineCompletion = async function (e, t, n, r, o) {\n  var i;\n  const s = TelemetryData.createAndMarkAsIssued({\n    completionTextJson: JSON.stringify(t),\n    choiceIndex: o.toString(),\n  });\n  if (n.logprobs)\n    for (const [e, t] of Object.entries(n.logprobs))\n      s.properties[\"logprobs_\" + e] =\n        null !== (i = JSON.stringify(t)) && undefined !== i ? i : \"unset\";\n  s.extendWithRequestId(r);\n  await telemetry(e, \"engine.completion\", s, !0);\n};\nexports.logEnginePrompt = async function (e, t, n) {\n  let r;\n  r = t.isFimEnabled\n    ? {\n        promptPrefixJson: JSON.stringify(t.prefix),\n        promptSuffixJson: JSON.stringify(t.suffix),\n        promptElementRanges: JSON.stringify(t.promptElementRanges),\n      }\n    : {\n        promptJson: JSON.stringify(t.prefix),\n        promptElementRanges: JSON.stringify(t.promptElementRanges),\n      };\n  const o = n.extendedBy(r);\n  await telemetry(e, \"engine.prompt\", o, !0);\n};\nexports.setTelemetryConfig = function (e) {\n  d = e;\n};\nexports.dropTelemetryConfig = function () {\n  d = undefined;\n};\nexports.forceSendingTelemetry = function (e, n) {\n  const r = n.getReporter(e);\n  if (r) {\n    const n = r;\n    n.userOptIn = !0;\n    n.createAppInsightsClient(exports.APP_INSIGHTS_KEY);\n    configureReporter(e, r);\n  }\n  try {\n    const r = n.getSecureReporter(e);\n    if (r) {\n      const n = r;\n      n.userOptIn = !0;\n      n.createAppInsightsClient(exports.APP_INSIGHTS_KEY_SECURE);\n      configureReporter(e, r);\n    }\n  } catch (e) {}\n};",
  "6372": "function t(e) {\n  return \"function\" == typeof e;\n}\nvar n = console.error.bind(console);\nfunction r(e, t, n) {\n  var r = !!e[t] && e.propertyIsEnumerable(t);\n  Object.defineProperty(e, t, {\n    configurable: !0,\n    enumerable: r,\n    writable: !0,\n    value: n,\n  });\n}\nfunction o(e) {\n  if (e && e.logger) {\n    if (t(e.logger)) {\n      n = e.logger;\n    } else {\n      n(\"new logger isn't a function, not replacing\");\n    }\n  }\n}\nfunction i(e, o, i) {\n  if (e && e[o]) {\n    if (!i) {\n      n(\"no wrapper function\");\n      return void n(new Error().stack);\n    }\n    if (t(e[o]) && t(i)) {\n      var s = e[o],\n        a = i(s, o);\n      r(a, \"__original\", s);\n      r(a, \"__unwrap\", function () {\n        if (e[o] === a) {\n          r(e, o, s);\n        }\n      });\n      r(a, \"__wrapped\", !0);\n      r(e, o, a);\n      return a;\n    }\n    n(\"original object and wrapper must be functions\");\n  } else n(\"no original function \" + o + \" to wrap\");\n}\nfunction s(e, t) {\n  return e && e[t]\n    ? e[t].__unwrap\n      ? e[t].__unwrap()\n      : void n(\n          \"no original to unwrap to -- has \" + t + \" already been unwrapped?\"\n        )\n    : (n(\"no function to unwrap.\"), void n(new Error().stack));\n}\no.wrap = i;\no.massWrap = function (e, t, r) {\n  if (!e) {\n    n(\"must provide one or more modules to patch\");\n    return void n(new Error().stack);\n  }\n  if (Array.isArray(e)) {\n    e = [e];\n  }\n  if (t && Array.isArray(t)) {\n    e.forEach(function (e) {\n      t.forEach(function (t) {\n        i(e, t, r);\n      });\n    });\n  } else {\n    n(\"must provide one or more functions to wrap on modules\");\n  }\n};\no.unwrap = s;\no.massUnwrap = function (e, t) {\n  if (!e) {\n    n(\"must provide one or more modules to patch\");\n    return void n(new Error().stack);\n  }\n  if (Array.isArray(e)) {\n    e = [e];\n  }\n  if (t && Array.isArray(t)) {\n    e.forEach(function (e) {\n      t.forEach(function (t) {\n        s(e, t);\n      });\n    });\n  } else {\n    n(\"must provide one or more functions to unwrap on modules\");\n  }\n};\nmodule.exports = o;",
  "6400": "var r = require(7923);\nexports.encode = function (e) {\n  var t,\n    n = \"\",\n    o = (function (e) {\n      return e < 0 ? 1 + (-e << 1) : 0 + (e << 1);\n    })(e);\n  do {\n    t = 31 & o;\n    if ((o >>>= 5) > 0) {\n      t |= 32;\n    }\n    n += r.encode(t);\n  } while (o > 0);\n  return n;\n};\nexports.decode = function (e, t, n) {\n  var o,\n    i,\n    s,\n    a,\n    c = e.length,\n    l = 0,\n    u = 0;\n  do {\n    if (t >= c) throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    if (-1 === (i = r.decode(e.charCodeAt(t++))))\n      throw new Error(\"Invalid base64 digit: \" + e.charAt(t - 1));\n    o = !!(32 & i);\n    l += (i &= 31) << u;\n    u += 5;\n  } while (o);\n  a = (s = l) >> 1;\n  n.value = 1 == (1 & s) ? -a : a;\n  n.rest = t;\n};",
  "6403": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.LocationFactory = undefined;\nexports.LocationFactory = class {};",
  "6475": "var r;\nr = require(8249);\nrequire(5109);\nr.pad.ZeroPadding = {\n  pad: function (e, t) {\n    var n = 4 * t;\n    e.clamp();\n    e.sigBytes += n - (e.sigBytes % n || n);\n  },\n  unpad: function (e) {\n    var t = e.words,\n      n = e.sigBytes - 1;\n    for (n = e.sigBytes - 1; n >= 0; n--)\n      if ((t[n >>> 2] >>> (24 - (n % 4) * 8)) & 255) {\n        e.sigBytes = n + 1;\n        break;\n      }\n  },\n};\nmodule.exports = r.pad.ZeroPadding;",
  "6500": "var n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.ExpServiceTelemetryNames = undefined;\n(n =\n  exports.ExpServiceTelemetryNames ||\n  (exports.ExpServiceTelemetryNames = {})).featuresTelemetryPropertyName =\n  \"VSCode.ABExp.Features\";\nn.assignmentContextTelemetryPropertyName = \"abexp.assignmentcontext\";",
  "6552": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(6776),\n  o = {\n    keyword: [\"then\", \"else\"],\n    schemaType: [\"object\", \"boolean\"],\n    code({ keyword: e, parentSchema: t, it: n }) {\n      if (undefined === t.if) {\n        r.checkStrictMode(n, `\"${e}\" without \"if\" is ignored`);\n      }\n    },\n  };\nexports.default = o;",
  "6560": "module.exports = (e, t) => {\n  t = t || process.argv;\n  const n = e.startsWith(\"-\") ? \"\" : 1 === e.length ? \"-\" : \"--\",\n    r = t.indexOf(n + e),\n    o = t.indexOf(\"--\");\n  return -1 !== r && (-1 === o || r < o);\n};",
  "6639": "var t = (function () {\n  function e(t) {\n    if (e.INSTANCE)\n      throw new Error(\n        \"Exception tracking should be configured from the applicationInsights object\"\n      );\n    e.INSTANCE = this;\n    this._client = t;\n    var n = process.versions.node.split(\".\");\n    e._canUseUncaughtExceptionMonitor =\n      parseInt(n[0]) > 13 || (13 === parseInt(n[0]) && parseInt(n[1]) >= 7);\n  }\n  e.prototype.isInitialized = function () {\n    return this._isInitialized;\n  };\n  e.prototype.enable = function (t) {\n    var n = this;\n    if (t) {\n      this._isInitialized = !0;\n      if (!this._exceptionListenerHandle) {\n        var r = function (t, r, o) {\n          void 0 === o && (o = new Error(e._FALLBACK_ERROR_MESSAGE)),\n            n._client.trackException({\n              exception: o,\n            }),\n            n._client.flush({\n              isAppCrashing: !0,\n            }),\n            t &&\n              r &&\n              1 === process.listeners(r).length &&\n              (console.error(o), process.exit(1));\n        };\n        e._canUseUncaughtExceptionMonitor\n          ? ((this._exceptionListenerHandle = r.bind(this, !1)),\n            process.on(\n              e.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME,\n              this._exceptionListenerHandle\n            ))\n          : ((this._exceptionListenerHandle = r.bind(\n              this,\n              !0,\n              e.UNCAUGHT_EXCEPTION_HANDLER_NAME\n            )),\n            (this._rejectionListenerHandle = r.bind(this, !1)),\n            process.on(\n              e.UNCAUGHT_EXCEPTION_HANDLER_NAME,\n              this._exceptionListenerHandle\n            ),\n            process.on(\n              e.UNHANDLED_REJECTION_HANDLER_NAME,\n              this._rejectionListenerHandle\n            ));\n      }\n    } else if (this._exceptionListenerHandle) {\n      if (e._canUseUncaughtExceptionMonitor) {\n        process.removeListener(\n          e.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME,\n          this._exceptionListenerHandle\n        );\n      } else {\n        process.removeListener(\n          e.UNCAUGHT_EXCEPTION_HANDLER_NAME,\n          this._exceptionListenerHandle\n        );\n        process.removeListener(\n          e.UNHANDLED_REJECTION_HANDLER_NAME,\n          this._rejectionListenerHandle\n        );\n      }\n      this._exceptionListenerHandle = undefined;\n      this._rejectionListenerHandle = undefined;\n      delete this._exceptionListenerHandle;\n      delete this._rejectionListenerHandle;\n    }\n  };\n  e.prototype.dispose = function () {\n    e.INSTANCE = null;\n    this.enable(!1);\n    this._isInitialized = !1;\n  };\n  e.INSTANCE = null;\n  e.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME = \"uncaughtExceptionMonitor\";\n  e.UNCAUGHT_EXCEPTION_HANDLER_NAME = \"uncaughtException\";\n  e.UNHANDLED_REJECTION_HANDLER_NAME = \"unhandledRejection\";\n  e._RETHROW_EXIT_MESSAGE = \"Application Insights Rethrow Exception Handler\";\n  e._FALLBACK_ERROR_MESSAGE =\n    \"A promise was rejected without providing an error. Application Insights generated this error stack for you.\";\n  e._canUseUncaughtExceptionMonitor = !1;\n  return e;\n})();\nmodule.exports = t;",
  "6646": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(2531);\nclass o extends Error {\n  constructor(e, t, n) {\n    super(n || `can't resolve reference ${t} from id ${e}`);\n    this.missingRef = r.resolveUrl(e, t);\n    this.missingSchema = r.normalizeId(r.getFullPath(this.missingRef));\n  }\n}\nexports.default = o;",
  "6661": "var r =\n  (this && this.__assign) ||\n  Object.assign ||\n  function (e) {\n    for (var t, n = 1, r = arguments.length; n < r; n++)\n      for (var o in (t = arguments[n]))\n        if (Object.prototype.hasOwnProperty.call(t, o)) {\n          e[o] = t[o];\n        }\n    return e;\n  };\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar o = require(4953);\nexports.tedious = {\n  versionSpecifier: \">= 6.0.0 < 9.0.0\",\n  patch: function (e) {\n    var t = e.Connection.prototype.makeRequest;\n    e.Connection.prototype.makeRequest = function () {\n      function e(e) {\n        var t = process.hrtime(),\n          n = {\n            query: {},\n            database: {\n              host: null,\n              port: null,\n            },\n            result: null,\n            error: null,\n            duration: 0,\n          };\n        return o.channel.bindToContext(function (i, s, a) {\n          var c = process.hrtime(t);\n          n = r({}, n, {\n            database: {\n              host: this.connection.config.server,\n              port: this.connection.config.options.port,\n            },\n            result: !i && {\n              rowCount: s,\n              rows: a,\n            },\n            query: {\n              text: this.parametersByName.statement.value,\n            },\n            error: i,\n            duration: Math.ceil(1e3 * c[0] + c[1] / 1e6),\n          });\n          o.channel.publish(\"tedious\", n);\n          e.call(this, i, s, a);\n        });\n      }\n      var n = arguments[0];\n      arguments[0].callback = e(n.callback);\n      t.apply(this, arguments);\n    };\n    return e;\n  },\n};\nexports.enable = function () {\n  o.channel.registerMonkeyPatch(\"tedious\", exports.tedious);\n};",
  "6694": "var r,\n  o =\n    (this && this.__extends) ||\n    ((r =\n      Object.setPrototypeOf ||\n      ({\n        __proto__: [],\n      } instanceof Array &&\n        function (e, t) {\n          e.__proto__ = t;\n        }) ||\n      function (e, t) {\n        for (var n in t)\n          if (t.hasOwnProperty(n)) {\n            e[n] = t[n];\n          }\n      }),\n    function (e, t) {\n      function n() {\n        this.constructor = e;\n      }\n      r(e, t);\n      e.prototype =\n        null === t ? Object.create(t) : ((n.prototype = t.prototype), new n());\n    }),\n  i = require(\"url\"),\n  s = require(5290),\n  a = require(5740),\n  c = require(9036),\n  l = require(3054),\n  u = require(9962),\n  d = require(1974),\n  p = require(8090),\n  h = (function (e) {\n    function t(t, n) {\n      var r = e.call(this) || this;\n      if (t) {\n        r.method = t.method;\n        r.url = r._getAbsoluteUrl(t);\n        r.startTime = +new Date();\n        r.socketRemoteAddress = t.socket && t.socket.remoteAddress;\n        r.parseHeaders(t, n);\n        if (t.connection) {\n          r.connectionRemoteAddress = t.connection.remoteAddress;\n          r.legacySocketRemoteAddress =\n            t.connection.socket && t.connection.socket.remoteAddress;\n        }\n      }\n      return r;\n    }\n    o(t, e);\n    t.prototype.onError = function (e, t) {\n      this._setStatus(undefined, e);\n      if (t) {\n        this.duration = t;\n      }\n    };\n    t.prototype.onResponse = function (e, t) {\n      this._setStatus(e.statusCode, undefined);\n      if (t) {\n        this.duration = t;\n      }\n    };\n    t.prototype.getRequestTelemetry = function (e) {\n      var t = {\n        id: this.requestId,\n        name: this.method + \" \" + i.parse(this.url).pathname,\n        url: this.url,\n        source: this.sourceCorrelationId,\n        duration: this.duration,\n        resultCode: this.statusCode ? this.statusCode.toString() : null,\n        success: this._isSuccess(),\n        properties: this.properties,\n      };\n      if (e) {\n        for (var n in e)\n          if (t[n]) {\n            t[n] = e[n];\n          }\n        if (e.properties)\n          for (var n in e.properties) t.properties[n] = e.properties[n];\n      }\n      return t;\n    };\n    t.prototype.getRequestTags = function (e) {\n      var n = {};\n      for (var r in e) n[r] = e[r];\n      n[t.keys.locationIp] = e[t.keys.locationIp] || this._getIp();\n      n[t.keys.sessionId] = e[t.keys.sessionId] || this._getId(\"ai_session\");\n      n[t.keys.userId] = e[t.keys.userId] || this._getId(\"ai_user\");\n      n[t.keys.userAuthUserId] =\n        e[t.keys.userAuthUserId] || this._getId(\"ai_authUser\");\n      n[t.keys.operationName] = this.getOperationName(e);\n      n[t.keys.operationParentId] = this.getOperationParentId(e);\n      n[t.keys.operationId] = this.getOperationId(e);\n      return n;\n    };\n    t.prototype.getOperationId = function (e) {\n      return e[t.keys.operationId] || this.operationId;\n    };\n    t.prototype.getOperationParentId = function (e) {\n      return (\n        e[t.keys.operationParentId] || this.parentId || this.getOperationId(e)\n      );\n    };\n    t.prototype.getOperationName = function (e) {\n      return (\n        e[t.keys.operationName] ||\n        this.method + \" \" + i.parse(this.url).pathname\n      );\n    };\n    t.prototype.getRequestId = function () {\n      return this.requestId;\n    };\n    t.prototype.getCorrelationContextHeader = function () {\n      return this.correlationContextHeader;\n    };\n    t.prototype.getTraceparent = function () {\n      return this.traceparent;\n    };\n    t.prototype.getTracestate = function () {\n      return this.tracestate;\n    };\n    t.prototype.getLegacyRootId = function () {\n      return this.legacyRootId;\n    };\n    t.prototype._getAbsoluteUrl = function (e) {\n      if (!e.headers) return e.url;\n      var t = e.connection ? e.connection.encrypted : null,\n        n = i.parse(e.url),\n        r = n.pathname,\n        o = n.search;\n      return i.format({\n        protocol: t ? \"https\" : \"http\",\n        host: e.headers.host,\n        pathname: r,\n        search: o,\n      });\n    };\n    t.prototype._getIp = function () {\n      var e = /[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}/,\n        t = function (t) {\n          var n = e.exec(t);\n          if (n) return n[0];\n        },\n        n =\n          t(this.rawHeaders[\"x-forwarded-for\"]) ||\n          t(this.rawHeaders[\"x-client-ip\"]) ||\n          t(this.rawHeaders[\"x-real-ip\"]) ||\n          t(this.connectionRemoteAddress) ||\n          t(this.socketRemoteAddress) ||\n          t(this.legacySocketRemoteAddress);\n      if (\n        !n &&\n        this.connectionRemoteAddress &&\n        this.connectionRemoteAddress.substr &&\n        \"::\" === this.connectionRemoteAddress.substr(0, 2)\n      ) {\n        n = \"127.0.0.1\";\n      }\n      return n;\n    };\n    t.prototype._getId = function (e) {\n      var n =\n        (this.rawHeaders &&\n          this.rawHeaders.cookie &&\n          \"string\" == typeof this.rawHeaders.cookie &&\n          this.rawHeaders.cookie) ||\n        \"\";\n      return t.parseId(a.getCookie(e, n));\n    };\n    t.prototype.setBackCompatFromThisTraceContext = function () {\n      this.operationId = this.traceparent.traceId;\n      if (this.traceparent.legacyRootId) {\n        this.legacyRootId = this.traceparent.legacyRootId;\n      }\n      this.parentId = this.traceparent.parentId;\n      this.traceparent.updateSpanId();\n      this.requestId = this.traceparent.getBackCompatRequestId();\n    };\n    t.prototype.parseHeaders = function (e, t) {\n      this.rawHeaders = e.headers || e.rawHeaders;\n      this.userAgent = e.headers && e.headers[\"user-agent\"];\n      this.sourceCorrelationId = a.getCorrelationContextTarget(\n        e,\n        c.requestContextSourceKey\n      );\n      if (e.headers) {\n        var n = e.headers[c.traceStateHeader],\n          r = e.headers[c.traceparentHeader],\n          o = e.headers[c.requestIdHeader],\n          i = e.headers[c.parentIdHeader],\n          s = e.headers[c.rootIdHeader];\n        (this.correlationContextHeader = e.headers[c.correlationContextHeader]),\n          u.w3cEnabled && (r || n)\n            ? ((this.traceparent = new p(r)),\n              (this.tracestate = r && n && new d(n)),\n              this.setBackCompatFromThisTraceContext())\n            : o\n            ? u.w3cEnabled\n              ? ((this.traceparent = new p(null, o)),\n                this.setBackCompatFromThisTraceContext())\n              : ((this.parentId = o),\n                (this.requestId = u.generateRequestId(this.parentId)),\n                (this.operationId = u.getRootId(this.requestId)))\n            : u.w3cEnabled\n            ? ((this.traceparent = new p()),\n              (this.traceparent.parentId = i),\n              (this.traceparent.legacyRootId = s || i),\n              this.setBackCompatFromThisTraceContext())\n            : ((this.parentId = i),\n              (this.requestId = u.generateRequestId(s || this.parentId)),\n              (this.correlationContextHeader = null),\n              (this.operationId = u.getRootId(this.requestId))),\n          t &&\n            ((this.requestId = t),\n            (this.operationId = u.getRootId(this.requestId)));\n      }\n    };\n    t.parseId = function (e) {\n      var t = e.split(\"|\");\n      return t.length > 0 ? t[0] : \"\";\n    };\n    t.keys = new s.ContextTagKeys();\n    return t;\n  })(l);\nmodule.exports = h;",
  "6722": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.NoOpStatusReporter = exports.StatusReporter = undefined;\nclass StatusReporter {}\nexports.StatusReporter = StatusReporter;\nexports.NoOpStatusReporter = class extends StatusReporter {\n  setProgress() {}\n  removeProgress() {}\n  setWarning() {}\n  setError(e) {}\n  forceNormal() {}\n};",
  "6771": "var r = require(2728),\n  o = require(9216),\n  i = require(8213).I,\n  s = require(6400),\n  a = require(2826).U;\nfunction SourceMapConsumer(e, t) {\n  var n = e;\n  if (\"string\" == typeof e) {\n    n = r.parseSourceMapInput(e);\n  }\n  return null != n.sections ? new d(n, t) : new l(n, t);\n}\nfunction l(e, t) {\n  var n = e;\n  if (\"string\" == typeof e) {\n    n = r.parseSourceMapInput(e);\n  }\n  var o = r.getArg(n, \"version\"),\n    s = r.getArg(n, \"sources\"),\n    a = r.getArg(n, \"names\", []),\n    c = r.getArg(n, \"sourceRoot\", null),\n    l = r.getArg(n, \"sourcesContent\", null),\n    u = r.getArg(n, \"mappings\"),\n    d = r.getArg(n, \"file\", null);\n  if (o != this._version) throw new Error(\"Unsupported version: \" + o);\n  if (c) {\n    c = r.normalize(c);\n  }\n  s = s\n    .map(String)\n    .map(r.normalize)\n    .map(function (e) {\n      return c && r.isAbsolute(c) && r.isAbsolute(e) ? r.relative(c, e) : e;\n    });\n  this._names = i.fromArray(a.map(String), !0);\n  this._sources = i.fromArray(s, !0);\n  this._absoluteSources = this._sources.toArray().map(function (e) {\n    return r.computeSourceURL(c, e, t);\n  });\n  this.sourceRoot = c;\n  this.sourcesContent = l;\n  this._mappings = u;\n  this._sourceMapURL = t;\n  this.file = d;\n}\nfunction u() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\nfunction d(e, t) {\n  var n = e;\n  if (\"string\" == typeof e) {\n    n = r.parseSourceMapInput(e);\n  }\n  var o = r.getArg(n, \"version\"),\n    s = r.getArg(n, \"sections\");\n  if (o != this._version) throw new Error(\"Unsupported version: \" + o);\n  this._sources = new i();\n  this._names = new i();\n  var a = {\n    line: -1,\n    column: 0,\n  };\n  this._sections = s.map(function (e) {\n    if (e.url)\n      throw new Error(\"Support for url field in sections not implemented.\");\n    var n = r.getArg(e, \"offset\"),\n      o = r.getArg(n, \"line\"),\n      i = r.getArg(n, \"column\");\n    if (o < a.line || (o === a.line && i < a.column))\n      throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n    a = n;\n    return {\n      generatedOffset: {\n        generatedLine: o + 1,\n        generatedColumn: i + 1,\n      },\n      consumer: new SourceMapConsumer(r.getArg(e, \"map\"), t),\n    };\n  });\n}\nSourceMapConsumer.fromSourceMap = function (e, t) {\n  return l.fromSourceMap(e, t);\n};\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, \"_generatedMappings\", {\n  configurable: !0,\n  enumerable: !0,\n  get: function () {\n    if (this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n    return this.__generatedMappings;\n  },\n});\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, \"_originalMappings\", {\n  configurable: !0,\n  enumerable: !0,\n  get: function () {\n    if (this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n    return this.__originalMappings;\n  },\n});\nSourceMapConsumer.prototype._charIsMappingSeparator = function (e, t) {\n  var n = e.charAt(t);\n  return \";\" === n || \",\" === n;\n};\nSourceMapConsumer.prototype._parseMappings = function (e, t) {\n  throw new Error(\"Subclasses must implement _parseMappings\");\n};\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\nSourceMapConsumer.prototype.eachMapping = function (e, t, n) {\n  var o,\n    i = t || null;\n  switch (n || SourceMapConsumer.GENERATED_ORDER) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      o = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      o = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n  }\n  var s = this.sourceRoot;\n  o.map(function (e) {\n    var t = null === e.source ? null : this._sources.at(e.source);\n    return {\n      source: (t = r.computeSourceURL(s, t, this._sourceMapURL)),\n      generatedLine: e.generatedLine,\n      generatedColumn: e.generatedColumn,\n      originalLine: e.originalLine,\n      originalColumn: e.originalColumn,\n      name: null === e.name ? null : this._names.at(e.name),\n    };\n  }, this).forEach(e, i);\n};\nSourceMapConsumer.prototype.allGeneratedPositionsFor = function (e) {\n  var t = r.getArg(e, \"line\"),\n    n = {\n      source: r.getArg(e, \"source\"),\n      originalLine: t,\n      originalColumn: r.getArg(e, \"column\", 0),\n    };\n  n.source = this._findSourceIndex(n.source);\n  if (n.source < 0) return [];\n  var i = [],\n    s = this._findMapping(\n      n,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      r.compareByOriginalPositions,\n      o.LEAST_UPPER_BOUND\n    );\n  if (s >= 0) {\n    var a = this._originalMappings[s];\n    if (undefined === e.column)\n      for (var c = a.originalLine; a && a.originalLine === c; ) {\n        i.push({\n          line: r.getArg(a, \"generatedLine\", null),\n          column: r.getArg(a, \"generatedColumn\", null),\n          lastColumn: r.getArg(a, \"lastGeneratedColumn\", null),\n        });\n        a = this._originalMappings[++s];\n      }\n    else\n      for (\n        var l = a.originalColumn;\n        a && a.originalLine === t && a.originalColumn == l;\n\n      ) {\n        i.push({\n          line: r.getArg(a, \"generatedLine\", null),\n          column: r.getArg(a, \"generatedColumn\", null),\n          lastColumn: r.getArg(a, \"lastGeneratedColumn\", null),\n        });\n        a = this._originalMappings[++s];\n      }\n  }\n  return i;\n};\nexports.SourceMapConsumer = SourceMapConsumer;\nl.prototype = Object.create(SourceMapConsumer.prototype);\nl.prototype.consumer = SourceMapConsumer;\nl.prototype._findSourceIndex = function (e) {\n  var t,\n    n = e;\n  if (null != this.sourceRoot) {\n    n = r.relative(this.sourceRoot, n);\n  }\n  if (this._sources.has(n)) return this._sources.indexOf(n);\n  for (t = 0; t < this._absoluteSources.length; ++t)\n    if (this._absoluteSources[t] == e) return t;\n  return -1;\n};\nl.fromSourceMap = function (e, t) {\n  var n = Object.create(l.prototype),\n    o = (n._names = i.fromArray(e._names.toArray(), !0)),\n    s = (n._sources = i.fromArray(e._sources.toArray(), !0));\n  n.sourceRoot = e._sourceRoot;\n  n.sourcesContent = e._generateSourcesContent(\n    n._sources.toArray(),\n    n.sourceRoot\n  );\n  n.file = e._file;\n  n._sourceMapURL = t;\n  n._absoluteSources = n._sources.toArray().map(function (e) {\n    return r.computeSourceURL(n.sourceRoot, e, t);\n  });\n  for (\n    var c = e._mappings.toArray().slice(),\n      d = (n.__generatedMappings = []),\n      p = (n.__originalMappings = []),\n      h = 0,\n      f = c.length;\n    h < f;\n    h++\n  ) {\n    var m = c[h],\n      g = new u();\n    g.generatedLine = m.generatedLine;\n    g.generatedColumn = m.generatedColumn;\n    if (m.source) {\n      g.source = s.indexOf(m.source);\n      g.originalLine = m.originalLine;\n      g.originalColumn = m.originalColumn;\n      if (m.name) {\n        g.name = o.indexOf(m.name);\n      }\n      p.push(g);\n    }\n    d.push(g);\n  }\n  a(n.__originalMappings, r.compareByOriginalPositions);\n  return n;\n};\nl.prototype._version = 3;\nObject.defineProperty(l.prototype, \"sources\", {\n  get: function () {\n    return this._absoluteSources.slice();\n  },\n});\nl.prototype._parseMappings = function (e, t) {\n  for (\n    var n,\n      o,\n      i,\n      c,\n      l,\n      d = 1,\n      p = 0,\n      h = 0,\n      f = 0,\n      m = 0,\n      g = 0,\n      _ = e.length,\n      y = 0,\n      v = {},\n      b = {},\n      w = [],\n      x = [];\n    y < _;\n\n  )\n    if (\";\" === e.charAt(y)) {\n      d++;\n      y++;\n      p = 0;\n    } else if (\",\" === e.charAt(y)) y++;\n    else {\n      for (\n        (n = new u()).generatedLine = d, c = y;\n        c < _ && !this._charIsMappingSeparator(e, c);\n        c++\n      );\n      if ((i = v[(o = e.slice(y, c))])) y += o.length;\n      else {\n        for (i = []; y < c; ) {\n          s.decode(e, y, b);\n          l = b.value;\n          y = b.rest;\n          i.push(l);\n        }\n        if (2 === i.length)\n          throw new Error(\"Found a source, but no line and column\");\n        if (3 === i.length)\n          throw new Error(\"Found a source and line, but no column\");\n        v[o] = i;\n      }\n      n.generatedColumn = p + i[0];\n      p = n.generatedColumn;\n      if (i.length > 1) {\n        n.source = m + i[1];\n        m += i[1];\n        n.originalLine = h + i[2];\n        h = n.originalLine;\n        n.originalLine += 1;\n        n.originalColumn = f + i[3];\n        f = n.originalColumn;\n        if (i.length > 4) {\n          n.name = g + i[4];\n          g += i[4];\n        }\n      }\n      x.push(n);\n      if (\"number\" == typeof n.originalLine) {\n        w.push(n);\n      }\n    }\n  a(x, r.compareByGeneratedPositionsDeflated);\n  this.__generatedMappings = x;\n  a(w, r.compareByOriginalPositions);\n  this.__originalMappings = w;\n};\nl.prototype._findMapping = function (e, t, n, r, i, s) {\n  if (e[n] <= 0)\n    throw new TypeError(\"Line must be greater than or equal to 1, got \" + e[n]);\n  if (e[r] < 0)\n    throw new TypeError(\n      \"Column must be greater than or equal to 0, got \" + e[r]\n    );\n  return o.search(e, t, i, s);\n};\nl.prototype.computeColumnSpans = function () {\n  for (var e = 0; e < this._generatedMappings.length; ++e) {\n    var t = this._generatedMappings[e];\n    if (e + 1 < this._generatedMappings.length) {\n      var n = this._generatedMappings[e + 1];\n      if (t.generatedLine === n.generatedLine) {\n        t.lastGeneratedColumn = n.generatedColumn - 1;\n        continue;\n      }\n    }\n    t.lastGeneratedColumn = 1 / 0;\n  }\n};\nl.prototype.originalPositionFor = function (e) {\n  var t = {\n      generatedLine: r.getArg(e, \"line\"),\n      generatedColumn: r.getArg(e, \"column\"),\n    },\n    n = this._findMapping(\n      t,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      r.compareByGeneratedPositionsDeflated,\n      r.getArg(e, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n  if (n >= 0) {\n    var o = this._generatedMappings[n];\n    if (o.generatedLine === t.generatedLine) {\n      var i = r.getArg(o, \"source\", null);\n      if (null !== i) {\n        i = this._sources.at(i);\n        i = r.computeSourceURL(this.sourceRoot, i, this._sourceMapURL);\n      }\n      var s = r.getArg(o, \"name\", null);\n      if (null !== s) {\n        s = this._names.at(s);\n      }\n      return {\n        source: i,\n        line: r.getArg(o, \"originalLine\", null),\n        column: r.getArg(o, \"originalColumn\", null),\n        name: s,\n      };\n    }\n  }\n  return {\n    source: null,\n    line: null,\n    column: null,\n    name: null,\n  };\n};\nl.prototype.hasContentsOfAllSources = function () {\n  return (\n    !!this.sourcesContent &&\n    this.sourcesContent.length >= this._sources.size() &&\n    !this.sourcesContent.some(function (e) {\n      return null == e;\n    })\n  );\n};\nl.prototype.sourceContentFor = function (e, t) {\n  if (!this.sourcesContent) return null;\n  var n = this._findSourceIndex(e);\n  if (n >= 0) return this.sourcesContent[n];\n  var o,\n    i = e;\n  if (null != this.sourceRoot) {\n    i = r.relative(this.sourceRoot, i);\n  }\n  if (null != this.sourceRoot && (o = r.urlParse(this.sourceRoot))) {\n    var s = i.replace(/^file:\\/\\//, \"\");\n    if (\"file\" == o.scheme && this._sources.has(s))\n      return this.sourcesContent[this._sources.indexOf(s)];\n    if ((!o.path || \"/\" == o.path) && this._sources.has(\"/\" + i))\n      return this.sourcesContent[this._sources.indexOf(\"/\" + i)];\n  }\n  if (t) return null;\n  throw new Error('\"' + i + '\" is not in the SourceMap.');\n};\nl.prototype.generatedPositionFor = function (e) {\n  var t = r.getArg(e, \"source\");\n  if ((t = this._findSourceIndex(t)) < 0)\n    return {\n      line: null,\n      column: null,\n      lastColumn: null,\n    };\n  var n = {\n      source: t,\n      originalLine: r.getArg(e, \"line\"),\n      originalColumn: r.getArg(e, \"column\"),\n    },\n    o = this._findMapping(\n      n,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      r.compareByOriginalPositions,\n      r.getArg(e, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n  if (o >= 0) {\n    var i = this._originalMappings[o];\n    if (i.source === n.source)\n      return {\n        line: r.getArg(i, \"generatedLine\", null),\n        column: r.getArg(i, \"generatedColumn\", null),\n        lastColumn: r.getArg(i, \"lastGeneratedColumn\", null),\n      };\n  }\n  return {\n    line: null,\n    column: null,\n    lastColumn: null,\n  };\n};\nd.prototype = Object.create(SourceMapConsumer.prototype);\nd.prototype.constructor = SourceMapConsumer;\nd.prototype._version = 3;\nObject.defineProperty(d.prototype, \"sources\", {\n  get: function () {\n    for (var e = [], t = 0; t < this._sections.length; t++)\n      for (var n = 0; n < this._sections[t].consumer.sources.length; n++)\n        e.push(this._sections[t].consumer.sources[n]);\n    return e;\n  },\n});\nd.prototype.originalPositionFor = function (e) {\n  var t = {\n      generatedLine: r.getArg(e, \"line\"),\n      generatedColumn: r.getArg(e, \"column\"),\n    },\n    n = o.search(t, this._sections, function (e, t) {\n      return (\n        e.generatedLine - t.generatedOffset.generatedLine ||\n        e.generatedColumn - t.generatedOffset.generatedColumn\n      );\n    }),\n    i = this._sections[n];\n  return i\n    ? i.consumer.originalPositionFor({\n        line: t.generatedLine - (i.generatedOffset.generatedLine - 1),\n        column:\n          t.generatedColumn -\n          (i.generatedOffset.generatedLine === t.generatedLine\n            ? i.generatedOffset.generatedColumn - 1\n            : 0),\n        bias: e.bias,\n      })\n    : {\n        source: null,\n        line: null,\n        column: null,\n        name: null,\n      };\n};\nd.prototype.hasContentsOfAllSources = function () {\n  return this._sections.every(function (e) {\n    return e.consumer.hasContentsOfAllSources();\n  });\n};\nd.prototype.sourceContentFor = function (e, t) {\n  for (var n = 0; n < this._sections.length; n++) {\n    var r = this._sections[n].consumer.sourceContentFor(e, !0);\n    if (r) return r;\n  }\n  if (t) return null;\n  throw new Error('\"' + e + '\" is not in the SourceMap.');\n};\nd.prototype.generatedPositionFor = function (e) {\n  for (var t = 0; t < this._sections.length; t++) {\n    var n = this._sections[t];\n    if (-1 !== n.consumer._findSourceIndex(r.getArg(e, \"source\"))) {\n      var o = n.consumer.generatedPositionFor(e);\n      if (o)\n        return {\n          line: o.line + (n.generatedOffset.generatedLine - 1),\n          column:\n            o.column +\n            (n.generatedOffset.generatedLine === o.line\n              ? n.generatedOffset.generatedColumn - 1\n              : 0),\n        };\n    }\n  }\n  return {\n    line: null,\n    column: null,\n  };\n};\nd.prototype._parseMappings = function (e, t) {\n  this.__generatedMappings = [];\n  this.__originalMappings = [];\n  for (var n = 0; n < this._sections.length; n++)\n    for (\n      var o = this._sections[n], i = o.consumer._generatedMappings, s = 0;\n      s < i.length;\n      s++\n    ) {\n      var c = i[s],\n        l = o.consumer._sources.at(c.source);\n      l = r.computeSourceURL(o.consumer.sourceRoot, l, this._sourceMapURL);\n      this._sources.add(l);\n      l = this._sources.indexOf(l);\n      var u = null;\n      if (c.name) {\n        u = o.consumer._names.at(c.name);\n        this._names.add(u);\n        u = this._names.indexOf(u);\n      }\n      var d = {\n        source: l,\n        generatedLine: c.generatedLine + (o.generatedOffset.generatedLine - 1),\n        generatedColumn:\n          c.generatedColumn +\n          (o.generatedOffset.generatedLine === c.generatedLine\n            ? o.generatedOffset.generatedColumn - 1\n            : 0),\n        originalLine: c.originalLine,\n        originalColumn: c.originalColumn,\n        name: u,\n      };\n      this.__generatedMappings.push(d);\n      if (\"number\" == typeof d.originalLine) {\n        this.__originalMappings.push(d);\n      }\n    }\n  a(this.__generatedMappings, r.compareByGeneratedPositionsDeflated);\n  a(this.__originalMappings, r.compareByOriginalPositions);\n};",
  "6776": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.checkStrictMode =\n  exports.getErrorPath =\n  exports.Type =\n  exports.useFunc =\n  exports.setEvaluated =\n  exports.evaluatedPropsToName =\n  exports.mergeEvaluated =\n  exports.eachItem =\n  exports.unescapeJsonPointer =\n  exports.escapeJsonPointer =\n  exports.escapeFragment =\n  exports.unescapeFragment =\n  exports.schemaRefOrVal =\n  exports.schemaHasRulesButRef =\n  exports.schemaHasRules =\n  exports.checkUnknownRules =\n  exports.alwaysValidSchema =\n  exports.toHash =\n    undefined;\nconst r = require(3487),\n  o = require(7023);\nfunction checkUnknownRules(e, t = e.schema) {\n  const { opts: n, self: r } = e;\n  if (!n.strictSchema) return;\n  if (\"boolean\" == typeof t) return;\n  const o = r.RULES.keywords;\n  for (const n in t)\n    if (o[n]) {\n      checkStrictMode(e, `unknown keyword: \"${n}\"`);\n    }\n}\nfunction schemaHasRules(e, t) {\n  if (\"boolean\" == typeof e) return !e;\n  for (const n in e) if (t[n]) return !0;\n  return !1;\n}\nfunction escapeJsonPointer(e) {\n  return \"number\" == typeof e\n    ? `${e}`\n    : e.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nfunction unescapeJsonPointer(e) {\n  return e.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nfunction l({ mergeNames: e, mergeToName: t, mergeValues: n, resultToName: o }) {\n  return (i, s, a, c) => {\n    const l =\n      undefined === a\n        ? s\n        : a instanceof r.Name\n        ? (s instanceof r.Name ? e(i, s, a) : t(i, s, a), a)\n        : s instanceof r.Name\n        ? (t(i, a, s), s)\n        : n(s, a);\n    return c !== r.Name || l instanceof r.Name ? l : o(i, l);\n  };\n}\nfunction evaluatedPropsToName(e, t) {\n  if (!0 === t) return e.var(\"props\", !0);\n  const n = e.var(\"props\", r._`{}`);\n  if (undefined !== t) {\n    setEvaluated(e, n, t);\n  }\n  return n;\n}\nfunction setEvaluated(e, t, n) {\n  Object.keys(n).forEach((n) => e.assign(r._`${t}${r.getProperty(n)}`, !0));\n}\nexports.toHash = function (e) {\n  const t = {};\n  for (const n of e) t[n] = !0;\n  return t;\n};\nexports.alwaysValidSchema = function (e, t) {\n  return \"boolean\" == typeof t\n    ? t\n    : 0 === Object.keys(t).length ||\n        (checkUnknownRules(e, t), !schemaHasRules(t, e.self.RULES.all));\n};\nexports.checkUnknownRules = checkUnknownRules;\nexports.schemaHasRules = schemaHasRules;\nexports.schemaHasRulesButRef = function (e, t) {\n  if (\"boolean\" == typeof e) return !e;\n  for (const n in e) if (\"$ref\" !== n && t.all[n]) return !0;\n  return !1;\n};\nexports.schemaRefOrVal = function (\n  { topSchemaRef: e, schemaPath: t },\n  n,\n  o,\n  i\n) {\n  if (!i) {\n    if (\"number\" == typeof n || \"boolean\" == typeof n) return n;\n    if (\"string\" == typeof n) return r._`${n}`;\n  }\n  return r._`${e}${t}${r.getProperty(o)}`;\n};\nexports.unescapeFragment = function (e) {\n  return unescapeJsonPointer(decodeURIComponent(e));\n};\nexports.escapeFragment = function (e) {\n  return encodeURIComponent(escapeJsonPointer(e));\n};\nexports.escapeJsonPointer = escapeJsonPointer;\nexports.unescapeJsonPointer = unescapeJsonPointer;\nexports.eachItem = function (e, t) {\n  if (Array.isArray(e)) for (const n of e) t(n);\n  else t(e);\n};\nexports.mergeEvaluated = {\n  props: l({\n    mergeNames: (e, t, n) =>\n      e.if(r._`${n} !== true && ${t} !== undefined`, () => {\n        e.if(\n          r._`${t} === true`,\n          () => e.assign(n, !0),\n          () =>\n            e.assign(n, r._`${n} || {}`).code(r._`Object.assign(${n}, ${t})`)\n        );\n      }),\n    mergeToName: (e, t, n) =>\n      e.if(r._`${n} !== true`, () => {\n        if (!0 === t) {\n          e.assign(n, !0);\n        } else {\n          e.assign(n, r._`${n} || {}`);\n          setEvaluated(e, n, t);\n        }\n      }),\n    mergeValues: (e, t) =>\n      !0 === e || {\n        ...e,\n        ...t,\n      },\n    resultToName: evaluatedPropsToName,\n  }),\n  items: l({\n    mergeNames: (e, t, n) =>\n      e.if(r._`${n} !== true && ${t} !== undefined`, () =>\n        e.assign(n, r._`${t} === true ? true : ${n} > ${t} ? ${n} : ${t}`)\n      ),\n    mergeToName: (e, t, n) =>\n      e.if(r._`${n} !== true`, () =>\n        e.assign(n, !0 === t || r._`${n} > ${t} ? ${n} : ${t}`)\n      ),\n    mergeValues: (e, t) => !0 === e || Math.max(e, t),\n    resultToName: (e, t) => e.var(\"items\", t),\n  }),\n};\nexports.evaluatedPropsToName = evaluatedPropsToName;\nexports.setEvaluated = setEvaluated;\nconst p = {};\nvar h;\nfunction checkStrictMode(e, t, n = e.opts.strictSchema) {\n  if (n) {\n    t = `strict mode: ${t}`;\n    if (!0 === n) throw new Error(t);\n    e.self.logger.warn(t);\n  }\n}\nexports.useFunc = function (e, t) {\n  return e.scopeValue(\"func\", {\n    ref: t,\n    code: p[t.code] || (p[t.code] = new o._Code(t.code)),\n  });\n};\n(function (e) {\n  e[(e.Num = 0)] = \"Num\";\n  e[(e.Str = 1)] = \"Str\";\n})((h = exports.Type || (exports.Type = {})));\nexports.getErrorPath = function (e, t, n) {\n  if (e instanceof r.Name) {\n    const o = t === h.Num;\n    return n\n      ? o\n        ? r._`\"[\" + ${e} + \"]\"`\n        : r._`\"['\" + ${e} + \"']\"`\n      : o\n      ? r._`\"/\" + ${e}`\n      : r._`\"/\" + ${e}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`;\n  }\n  return n ? r.getProperty(e).toString() : \"/\" + escapeJsonPointer(e);\n};\nexports.checkStrictMode = checkStrictMode;",
  "6794": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.TELEMETRY_TERMS_URL = exports.LAST_TELEMETRY_TERMS_UPDATE = undefined;\nexports.LAST_TELEMETRY_TERMS_UPDATE = \"2021-10-14\";\nexports.TELEMETRY_TERMS_URL = \"https://github.co/copilot-telemetry-terms\";",
  "6829": "const { EventEmitter: r } = require(\"events\"),\n  o = Symbol(\"AbortSignal internals\");\nclass i {\n  constructor() {\n    this[o] = {\n      eventEmitter: new r(),\n      onabort: null,\n      aborted: !1,\n    };\n  }\n  get aborted() {\n    return this[o].aborted;\n  }\n  get onabort() {\n    return this[o].onabort;\n  }\n  set onabort(e) {\n    this[o].onabort = e;\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n  removeEventListener(e, t) {\n    this[o].eventEmitter.removeListener(e, t);\n  }\n  addEventListener(e, t) {\n    this[o].eventEmitter.on(e, t);\n  }\n  dispatchEvent(e) {\n    const t = {\n        type: e,\n        target: this,\n      },\n      n = `on${e}`;\n    if (\"function\" == typeof this[o][n]) {\n      this[n](t);\n    }\n    this[o].eventEmitter.emit(e, t);\n  }\n  fire() {\n    this[o].aborted = !0;\n    this.dispatchEvent(\"abort\");\n  }\n}\nObject.defineProperties(i.prototype, {\n  addEventListener: {\n    enumerable: !0,\n  },\n  removeEventListener: {\n    enumerable: !0,\n  },\n  dispatchEvent: {\n    enumerable: !0,\n  },\n  aborted: {\n    enumerable: !0,\n  },\n  onabort: {\n    enumerable: !0,\n  },\n});\nclass s extends i {\n  constructor(e) {\n    if (!Number.isInteger(e))\n      throw new TypeError(\"Expected an integer, got \" + typeof e);\n    super();\n    this[o].timerId = setTimeout(() => {\n      this.fire();\n    }, e);\n  }\n  clear() {\n    clearTimeout(this[o].timerId);\n  }\n}\nObject.defineProperties(s.prototype, {\n  clear: {\n    enumerable: !0,\n  },\n});\nconst a = Symbol(\"AbortController internals\");\nclass c {\n  constructor() {\n    this[a] = {\n      signal: new i(),\n    };\n  }\n  get signal() {\n    return this[a].signal;\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n  abort() {\n    if (this[a].signal.aborted) {\n      this[a].signal.fire();\n    }\n  }\n}\nObject.defineProperties(c.prototype, {\n  signal: {\n    enumerable: !0,\n  },\n  abort: {\n    enumerable: !0,\n  },\n});\nmodule.exports = {\n  AbortController: c,\n  AbortSignal: i,\n  TimeoutSignal: s,\n};",
  "6857": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.extensionFileSystem = undefined;\nconst r = require(\"vscode\");\nexports.extensionFileSystem = {\n  readFile: async function (e) {\n    return await r.workspace.fs.readFile(r.Uri.file(e));\n  },\n  mtime: async function (e) {\n    return (await r.workspace.fs.stat(r.Uri.file(e))).mtime;\n  },\n  stat: async function (e) {\n    return await r.workspace.fs.stat(r.Uri.file(e));\n  },\n};",
  "6881": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.ChangeTracker = undefined;\nconst r = require(3136);\nexports.ChangeTracker = class {\n  constructor(e, t, n) {\n    this._referenceCount = 0;\n    this._isDisposed = !1;\n    this._offset = n;\n    const o = e.get(r.TextDocumentManager);\n    this._tracker = o.onDidChangeTextDocument(async (e) => {\n      if (e.document.uri === t)\n        for (const t of e.contentChanges)\n          if (t.rangeOffset + t.rangeLength <= this.offset) {\n            const e = t.text.length - t.rangeLength;\n            this._offset = this._offset + e;\n          }\n    });\n  }\n  get offset() {\n    return this._offset;\n  }\n  push(e, t) {\n    if (this._isDisposed)\n      throw new Error(\"Unable to push new actions to a disposed ChangeTracker\");\n    this._referenceCount++;\n    setTimeout(() => {\n      e();\n      this._referenceCount--;\n      if (0 === this._referenceCount) {\n        this._tracker.dispose();\n        this._isDisposed = !0;\n      }\n    }, t);\n  }\n};",
  "6932": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.asyncIterableFromArray =\n  exports.asyncIterableMapFilter =\n  exports.asyncIterableFilter =\n  exports.asyncIterableMap =\n    undefined;\nexports.asyncIterableMap = async function* (e, t) {\n  for await (const n of e) yield t(n);\n};\nexports.asyncIterableFilter = async function* (e, t) {\n  for await (const n of e)\n    if (await t(n)) {\n      yield n;\n    }\n};\nexports.asyncIterableMapFilter = async function* (e, t) {\n  for await (const n of e) {\n    const e = await t(n);\n    if (undefined !== e) {\n      yield e;\n    }\n  }\n};\nexports.asyncIterableFromArray = async function* (e) {\n  for (const t of e) yield t;\n};",
  "6991": "var r;\nr = require(8249);\nrequire(5109);\nr.pad.NoPadding = {\n  pad: function () {},\n  unpad: function () {},\n};\nmodule.exports = r.pad.NoPadding;",
  "7017": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.postInsertionTasks =\n  exports.postRejectionTasks =\n  exports.captureCode =\n    undefined;\nconst r = require(6881),\n  o = require(750),\n  i = require(9899),\n  s = require(7727),\n  a = require(4969),\n  c = require(5120),\n  l = require(6333),\n  u = require(3136),\n  d = new i.Logger(i.LogLevel.INFO, \"post-insertion\"),\n  p = [\n    {\n      seconds: 15,\n      captureCode: !1,\n      captureRejection: !1,\n    },\n    {\n      seconds: 30,\n      captureCode: !0,\n      captureRejection: !0,\n    },\n    {\n      seconds: 120,\n      captureCode: !1,\n      captureRejection: !1,\n    },\n    {\n      seconds: 300,\n      captureCode: !1,\n      captureRejection: !1,\n    },\n    {\n      seconds: 600,\n      captureCode: !1,\n      captureRejection: !1,\n    },\n  ];\nasync function captureCode(e, t, n) {\n  const r = await e.get(u.TextDocumentManager).getTextDocument(t);\n  if (!r) {\n    d.info(\n      e,\n      `Could not get document for ${t.fsPath}. Maybe it was closed by the editor.`\n    );\n    return {\n      prompt: {\n        prefix: \"\",\n        suffix: \"\",\n        isFimEnabled: !1,\n        promptElementRanges: [],\n      },\n      capturedCode: \"\",\n      terminationOffset: 0,\n    };\n  }\n  const o = r.getText(),\n    i = o.substring(0, n),\n    c = r.positionAt(n),\n    l = await a.extractPrompt(e, r, c),\n    p =\n      \"prompt\" === l.type\n        ? l.prompt\n        : {\n            prefix: i,\n            suffix: \"\",\n            isFimEnabled: !1,\n            promptElementRanges: [],\n          },\n    h = o.substring(n),\n    f = s.contextIndentationFromText(i, n, r.languageId),\n    m = s.indentationBlockFinished(f, undefined),\n    g = await m(h),\n    _ = Math.min(o.length, n + (g ? 2 * g : 500));\n  return {\n    prompt: p,\n    capturedCode: o.substring(n, _),\n    terminationOffset: null != g ? g : -1,\n  };\n}\nfunction f(e, t, n, r) {\n  const o = e.substring(\n      Math.max(0, r - n),\n      Math.min(e.length, r + t.length + n)\n    ),\n    i = c.lexEditDistance(o, t),\n    s = i.lexDistance / i.needleLexLength,\n    { distance: a } = c.editDistance(\n      o.substring(i.startOffset, i.endOffset),\n      t\n    );\n  return {\n    relativeLexEditDistance: s,\n    charEditDistance: a,\n    completionLexLength: i.needleLexLength,\n    foundOffset: i.startOffset + Math.max(0, r - n),\n    lexEditDistance: i.lexDistance,\n    stillInCodeHeuristic: s <= 0.5 ? 1 : 0,\n  };\n}\nexports.captureCode = captureCode;\nexports.postRejectionTasks = function (e, t, n, i, s) {\n  s.forEach(({ completionText: n, completionTelemetryData: r }) => {\n    d.debug(e, `${t}.rejected choiceIndex: ${r.properties.choiceIndex}`);\n    o.telemetryRejected(e, t, r);\n  });\n  const a = new r.ChangeTracker(e, i, n);\n  p.filter((e) => e.captureRejection).map((r) => {\n    a.push(async () => {\n      d.debug(e, `Original offset: ${n}, Tracked offset: ${a.offset}`);\n      const { completionTelemetryData: o } = s[0],\n        {\n          prompt: c,\n          capturedCode: u,\n          terminationOffset: p,\n        } = await captureCode(e, i, a.offset);\n      let f;\n      f = c.isFimEnabled\n        ? {\n            hypotheticalPromptPrefixJson: JSON.stringify(c.prefix),\n            hypotheticalPromptSuffixJson: JSON.stringify(c.suffix),\n          }\n        : {\n            hypotheticalPromptJson: JSON.stringify(c.prefix),\n          };\n      const m = o.extendedBy(\n        {\n          ...f,\n          capturedCodeJson: JSON.stringify(u),\n        },\n        {\n          timeout: r.seconds,\n          insertionOffset: n,\n          trackedOffset: a.offset,\n          terminationOffsetInCapturedCode: p,\n        }\n      );\n      d.debug(\n        e,\n        `${t}.capturedAfterRejected choiceIndex: ${o.properties.choiceIndex}`,\n        m\n      );\n      l.telemetry(e, t + \".capturedAfterRejected\", m, !0);\n    }, 1e3 * r.seconds);\n  });\n};\nexports.postInsertionTasks = async function (e, t, n, i, s, a) {\n  d.debug(e, `${t}.accepted choiceIndex: ${a.properties.choiceIndex}`);\n  o.telemetryAccepted(e, t, a);\n  const c = new r.ChangeTracker(e, s, i),\n    m = n.trim();\n  p.map((n) =>\n    c.push(\n      () =>\n        (async function (e, t, n, r, o, i, s, a) {\n          const c = await e.get(u.TextDocumentManager).getTextDocument(o);\n          if (c) {\n            const u = c.getText();\n            let p = f(u, n, 50, a.offset);\n            if (p.stillInCodeHeuristic) {\n              p = f(u, n, 1500, a.offset);\n            }\n            d.debug(\n              e,\n              `stillInCode: ${\n                p.stillInCodeHeuristic ? \"Found\" : \"Not found\"\n              }! Completion '${n}' in file ${\n                o.fsPath\n              }. lexEditDistance fraction was ${\n                p.relativeLexEditDistance\n              }. Char edit distance was ${\n                p.charEditDistance\n              }. Inserted at ${r}, tracked at ${a.offset}, found at ${\n                p.foundOffset\n              }. choiceIndex: ${s.properties.choiceIndex}`\n            );\n            const m = s\n              .extendedBy(\n                {},\n                {\n                  timeout: i.seconds,\n                  insertionOffset: r,\n                  trackedOffset: a.offset,\n                }\n              )\n              .extendedBy({}, p);\n            l.telemetry(e, t + \".stillInCode\", m);\n            if (i.captureCode) {\n              const {\n                prompt: n,\n                capturedCode: c,\n                terminationOffset: u,\n              } = await captureCode(e, o, a.offset);\n              let p;\n              p = n.isFimEnabled\n                ? {\n                    hypotheticalPromptPrefixJson: JSON.stringify(n.prefix),\n                    hypotheticalPromptSuffixJson: JSON.stringify(n.suffix),\n                  }\n                : {\n                    hypotheticalPromptJson: JSON.stringify(n.prefix),\n                  };\n              const f = s.extendedBy(\n                {\n                  ...p,\n                  capturedCodeJson: JSON.stringify(c),\n                },\n                {\n                  timeout: i.seconds,\n                  insertionOffset: r,\n                  trackedOffset: a.offset,\n                  terminationOffsetInCapturedCode: u,\n                }\n              );\n              d.debug(\n                e,\n                `${t}.capturedAfterAccepted choiceIndex: ${s.properties.choiceIndex}`,\n                m\n              ),\n                (0, l.telemetry)(e, t + \".capturedAfterAccepted\", f, !0);\n            }\n          }\n        })(e, t, m, i, s, n, a, c),\n      1e3 * n.seconds\n    )\n  );\n};",
  "7023": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.regexpCode =\n  exports.getProperty =\n  exports.safeStringify =\n  exports.stringify =\n  exports.strConcat =\n  exports.addCodeArg =\n  exports.str =\n  exports._ =\n  exports.nil =\n  exports._Code =\n  exports.Name =\n  exports.IDENTIFIER =\n  exports._CodeOrName =\n    undefined;\nclass _CodeOrName {}\nexports._CodeOrName = _CodeOrName;\nexports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nclass Name extends _CodeOrName {\n  constructor(e) {\n    super();\n    if (!exports.IDENTIFIER.test(e))\n      throw new Error(\"CodeGen: name must be a valid identifier\");\n    this.str = e;\n  }\n  toString() {\n    return this.str;\n  }\n  emptyStr() {\n    return !1;\n  }\n  get names() {\n    return {\n      [this.str]: 1,\n    };\n  }\n}\nexports.Name = Name;\nclass _Code extends _CodeOrName {\n  constructor(e) {\n    super();\n    this._items = \"string\" == typeof e ? [e] : e;\n  }\n  toString() {\n    return this.str;\n  }\n  emptyStr() {\n    if (this._items.length > 1) return !1;\n    const e = this._items[0];\n    return \"\" === e || '\"\"' === e;\n  }\n  get str() {\n    var e;\n    return null !== (e = this._str) && undefined !== e\n      ? e\n      : (this._str = this._items.reduce((e, t) => `${e}${t}`, \"\"));\n  }\n  get names() {\n    var e;\n    return null !== (e = this._names) && undefined !== e\n      ? e\n      : (this._names = this._items.reduce(\n          (e, t) => (t instanceof Name && (e[t.str] = (e[t.str] || 0) + 1), e),\n          {}\n        ));\n  }\n}\nfunction _(e, ...t) {\n  const n = [e[0]];\n  let r = 0;\n  for (; r < t.length; ) {\n    addCodeArg(n, t[r]);\n    n.push(e[++r]);\n  }\n  return new _Code(n);\n}\nexports._Code = _Code;\nexports.nil = new _Code(\"\");\nexports._ = _;\nconst s = new _Code(\"+\");\nfunction str(e, ...t) {\n  const n = [safeStringify(e[0])];\n  let r = 0;\n  for (; r < t.length; ) {\n    n.push(s);\n    addCodeArg(n, t[r]);\n    n.push(s, safeStringify(e[++r]));\n  }\n  (function (e) {\n    let t = 1;\n    for (; t < e.length - 1; ) {\n      if (e[t] === s) {\n        const n = l(e[t - 1], e[t + 1]);\n        if (undefined !== n) {\n          e.splice(t - 1, 3, n);\n          continue;\n        }\n        e[t++] = \"+\";\n      }\n      t++;\n    }\n  })(n);\n  return new _Code(n);\n}\nfunction addCodeArg(e, t) {\n  var n;\n  if (t instanceof _Code) {\n    e.push(...t._items);\n  } else {\n    if (t instanceof Name) {\n      e.push(t);\n    } else {\n      e.push(\n        \"number\" == typeof (n = t) || \"boolean\" == typeof n || null === n\n          ? n\n          : safeStringify(Array.isArray(n) ? n.join(\",\") : n)\n      );\n    }\n  }\n}\nfunction l(e, t) {\n  if ('\"\"' === t) return e;\n  if ('\"\"' === e) return t;\n  if (\"string\" == typeof e) {\n    if (t instanceof Name || '\"' !== e[e.length - 1]) return;\n    return \"string\" != typeof t\n      ? `${e.slice(0, -1)}${t}\"`\n      : '\"' === t[0]\n      ? e.slice(0, -1) + t.slice(1)\n      : undefined;\n  }\n  return \"string\" != typeof t || '\"' !== t[0] || e instanceof Name\n    ? undefined\n    : `\"${e}${t.slice(1)}`;\n}\nfunction safeStringify(e) {\n  return JSON.stringify(e)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\");\n}\nexports.str = str;\nexports.addCodeArg = addCodeArg;\nexports.strConcat = function (e, t) {\n  return t.emptyStr() ? e : e.emptyStr() ? t : str`${e}${t}`;\n};\nexports.stringify = function (e) {\n  return new _Code(safeStringify(e));\n};\nexports.safeStringify = safeStringify;\nexports.getProperty = function (e) {\n  return \"string\" == typeof e && exports.IDENTIFIER.test(e)\n    ? new _Code(`.${e}`)\n    : _`[${e}]`;\n};\nexports.regexpCode = function (e) {\n  return new _Code(e.toString());\n};",
  "7057": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.RealUrlOpener = exports.UrlOpener = undefined;\nconst r = require(8318);\nexports.UrlOpener = class {};\nexports.RealUrlOpener = class {\n  async open(e) {\n    await r(e);\n  }\n};",
  "7085": "var r = require(4433).h,\n  o = require(2728),\n  i = /(\\r?\\n)/,\n  s = \"$$$isSourceNode$$$\";\nfunction a(e, t, n, r, o) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = null == e ? null : e;\n  this.column = null == t ? null : t;\n  this.source = null == n ? null : n;\n  this.name = null == o ? null : o;\n  this[s] = !0;\n  if (null != r) {\n    this.add(r);\n  }\n}\na.fromStringWithSourceMap = function (e, t, n) {\n  var r = new a(),\n    s = e.split(i),\n    c = 0,\n    l = function () {\n      return e() + (e() || \"\");\n      function e() {\n        return c < s.length ? s[c++] : undefined;\n      }\n    },\n    u = 1,\n    d = 0,\n    p = null;\n  t.eachMapping(function (e) {\n    if (null !== p) {\n      if (!(u < e.generatedLine)) {\n        var t = (n = s[c] || \"\").substr(0, e.generatedColumn - d);\n        s[c] = n.substr(e.generatedColumn - d);\n        d = e.generatedColumn;\n        h(p, t);\n        return void (p = e);\n      }\n      h(p, l());\n      u++;\n      d = 0;\n    }\n    for (; u < e.generatedLine; ) {\n      r.add(l());\n      u++;\n    }\n    if (d < e.generatedColumn) {\n      var n = s[c] || \"\";\n      r.add(n.substr(0, e.generatedColumn));\n      s[c] = n.substr(e.generatedColumn);\n      d = e.generatedColumn;\n    }\n    p = e;\n  }, this);\n  if (c < s.length) {\n    if (p) {\n      h(p, l());\n    }\n    r.add(s.splice(c).join(\"\"));\n  }\n  t.sources.forEach(function (e) {\n    var i = t.sourceContentFor(e);\n    if (null != i) {\n      if (null != n) {\n        e = o.join(n, e);\n      }\n      r.setSourceContent(e, i);\n    }\n  });\n  return r;\n  function h(e, t) {\n    if (null === e || undefined === e.source) r.add(t);\n    else {\n      var i = n ? o.join(n, e.source) : e.source;\n      r.add(new a(e.originalLine, e.originalColumn, i, t, e.name));\n    }\n  }\n};\na.prototype.add = function (e) {\n  if (Array.isArray(e))\n    e.forEach(function (e) {\n      this.add(e);\n    }, this);\n  else {\n    if (!e[s] && \"string\" != typeof e)\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" +\n          e\n      );\n    if (e) {\n      this.children.push(e);\n    }\n  }\n  return this;\n};\na.prototype.prepend = function (e) {\n  if (Array.isArray(e))\n    for (var t = e.length - 1; t >= 0; t--) this.prepend(e[t]);\n  else {\n    if (!e[s] && \"string\" != typeof e)\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" +\n          e\n      );\n    this.children.unshift(e);\n  }\n  return this;\n};\na.prototype.walk = function (e) {\n  for (var t, n = 0, r = this.children.length; n < r; n++)\n    if ((t = this.children[n])[s]) {\n      t.walk(e);\n    } else {\n      if (\"\" !== t) {\n        e(t, {\n          source: this.source,\n          line: this.line,\n          column: this.column,\n          name: this.name,\n        });\n      }\n    }\n};\na.prototype.join = function (e) {\n  var t,\n    n,\n    r = this.children.length;\n  if (r > 0) {\n    for (t = [], n = 0; n < r - 1; n++) {\n      t.push(this.children[n]);\n      t.push(e);\n    }\n    t.push(this.children[n]);\n    this.children = t;\n  }\n  return this;\n};\na.prototype.replaceRight = function (e, t) {\n  var n = this.children[this.children.length - 1];\n  if (n[s]) {\n    n.replaceRight(e, t);\n  } else {\n    if (\"string\" == typeof n) {\n      this.children[this.children.length - 1] = n.replace(e, t);\n    } else {\n      this.children.push(\"\".replace(e, t));\n    }\n  }\n  return this;\n};\na.prototype.setSourceContent = function (e, t) {\n  this.sourceContents[o.toSetString(e)] = t;\n};\na.prototype.walkSourceContents = function (e) {\n  for (var t = 0, n = this.children.length; t < n; t++)\n    if (this.children[t][s]) {\n      this.children[t].walkSourceContents(e);\n    }\n  var r = Object.keys(this.sourceContents);\n  for (t = 0, n = r.length; t < n; t++)\n    e(o.fromSetString(r[t]), this.sourceContents[r[t]]);\n};\na.prototype.toString = function () {\n  var e = \"\";\n  this.walk(function (t) {\n    e += t;\n  });\n  return e;\n};\na.prototype.toStringWithSourceMap = function (e) {\n  var t = {\n      code: \"\",\n      line: 1,\n      column: 0,\n    },\n    n = new r(e),\n    o = !1,\n    i = null,\n    s = null,\n    a = null,\n    c = null;\n  this.walk(function (e, r) {\n    t.code += e;\n    if (null !== r.source && null !== r.line && null !== r.column) {\n      if (i === r.source && s === r.line && a === r.column && c === r.name) {\n        n.addMapping({\n          source: r.source,\n          original: {\n            line: r.line,\n            column: r.column,\n          },\n          generated: {\n            line: t.line,\n            column: t.column,\n          },\n          name: r.name,\n        });\n      }\n      i = r.source;\n      s = r.line;\n      a = r.column;\n      c = r.name;\n      o = !0;\n    } else {\n      if (o) {\n        n.addMapping({\n          generated: {\n            line: t.line,\n            column: t.column,\n          },\n        });\n        i = null;\n        o = !1;\n      }\n    }\n    for (var l = 0, u = e.length; l < u; l++)\n      if (10 === e.charCodeAt(l)) {\n        t.line++;\n        t.column = 0;\n        if (l + 1 === u) {\n          i = null;\n          o = !1;\n        } else {\n          if (o) {\n            n.addMapping({\n              source: r.source,\n              original: {\n                line: r.line,\n                column: r.column,\n              },\n              generated: {\n                line: t.line,\n                column: t.column,\n              },\n              name: r.name,\n            });\n          }\n        }\n      } else {\n        t.column++;\n      }\n  });\n  this.walkSourceContents(function (e, t) {\n    n.setSourceContent(e, t);\n  });\n  return {\n    code: t.code,\n    map: n,\n  };\n};",
  "7148": "var r =\n    (this && this.__assign) ||\n    Object.assign ||\n    function (e) {\n      for (var t, n = 1, r = arguments.length; n < r; n++)\n        for (var o in (t = arguments[n]))\n          if (Object.prototype.hasOwnProperty.call(t, o)) {\n            e[o] = t[o];\n          }\n      return e;\n    },\n  o = require(\"os\"),\n  i = require(5290),\n  s = require(3580),\n  a = require(5740),\n  c = require(5282),\n  l = a.w3cTraceId(),\n  u = (function () {\n    function e() {}\n    e.createQuickPulseEnvelope = function (e, t, n, r) {\n      var i =\n          (o && \"function\" == typeof o.hostname && o.hostname()) || \"Unknown\",\n        s =\n          (r.tags &&\n            r.keys &&\n            r.keys.cloudRoleInstance &&\n            r.tags[r.keys.cloudRoleInstance]) ||\n          i;\n      return {\n        Documents: t.length > 0 ? t : null,\n        InstrumentationKey: n.instrumentationKey || \"\",\n        Metrics: e.length > 0 ? e : null,\n        InvariantVersion: 1,\n        Timestamp: \"/Date(\" + Date.now() + \")/\",\n        Version: r.tags[r.keys.internalSdkVersion],\n        StreamId: l,\n        MachineName: i,\n        Instance: s,\n      };\n    };\n    e.createQuickPulseMetric = function (e) {\n      return {\n        Name: e.name,\n        Value: e.value,\n        Weight: e.count || 1,\n      };\n    };\n    e.telemetryEnvelopeToQuickPulseDocument = function (t) {\n      switch (t.data.baseType) {\n        case i.TelemetryTypeString.Event:\n          return e.createQuickPulseEventDocument(t);\n        case i.TelemetryTypeString.Exception:\n          return e.createQuickPulseExceptionDocument(t);\n        case i.TelemetryTypeString.Trace:\n          return e.createQuickPulseTraceDocument(t);\n        case i.TelemetryTypeString.Dependency:\n          return e.createQuickPulseDependencyDocument(t);\n        case i.TelemetryTypeString.Request:\n          return e.createQuickPulseRequestDocument(t);\n      }\n      return null;\n    };\n    e.createQuickPulseEventDocument = function (t) {\n      var n = e.createQuickPulseDocument(t),\n        o = t.data.baseData.name;\n      return r({}, n, {\n        Name: o,\n      });\n    };\n    e.createQuickPulseTraceDocument = function (t) {\n      var n = e.createQuickPulseDocument(t),\n        o = t.data.baseData.severityLevel || 0;\n      return r({}, n, {\n        Message: t.data.baseData.message,\n        SeverityLevel: i.SeverityLevel[o],\n      });\n    };\n    e.createQuickPulseExceptionDocument = function (t) {\n      var n = e.createQuickPulseDocument(t),\n        o = t.data.baseData.exceptions,\n        i = \"\",\n        s = \"\",\n        a = \"\";\n      if (o && o.length > 0) {\n        if (o[0].parsedStack && o[0].parsedStack.length > 0) {\n          o[0].parsedStack.forEach(function (e) {\n            i += e.assembly + \"\\n\";\n          });\n        } else {\n          if (o[0].stack && o[0].stack.length > 0) {\n            i = o[0].stack;\n          }\n        }\n        s = o[0].message;\n        a = o[0].typeName;\n      }\n      return r({}, n, {\n        Exception: i,\n        ExceptionMessage: s,\n        ExceptionType: a,\n      });\n    };\n    e.createQuickPulseRequestDocument = function (t) {\n      var n = e.createQuickPulseDocument(t),\n        o = t.data.baseData;\n      return r({}, n, {\n        Name: o.name,\n        Success: o.success,\n        Duration: o.duration,\n        ResponseCode: o.responseCode,\n        OperationName: o.name,\n      });\n    };\n    e.createQuickPulseDependencyDocument = function (t) {\n      var n = e.createQuickPulseDocument(t),\n        o = t.data.baseData;\n      return r({}, n, {\n        Name: o.name,\n        Target: o.target,\n        Success: o.success,\n        Duration: o.duration,\n        ResultCode: o.resultCode,\n        CommandName: o.data,\n        OperationName: n.OperationId,\n        DependencyTypeName: o.type,\n      });\n    };\n    e.createQuickPulseDocument = function (t) {\n      var n, r;\n      if (t.data.baseType) {\n        r = s.TelemetryTypeStringToQuickPulseType[t.data.baseType];\n        n = s.TelemetryTypeStringToQuickPulseDocumentType[t.data.baseType];\n      } else {\n        c.warn(\n          \"Document type invalid; not sending live metric document\",\n          t.data.baseType\n        );\n      }\n      return {\n        DocumentType: n,\n        __type: r,\n        OperationId: t.tags[e.keys.operationId],\n        Version: \"1.0\",\n        Properties: e.aggregateProperties(t),\n      };\n    };\n    e.aggregateProperties = function (e) {\n      var t = [],\n        n = e.data.baseData.measurements || {};\n      for (var r in n)\n        if (n.hasOwnProperty(r)) {\n          var o = {\n            key: r,\n            value: n[r],\n          };\n          t.push(o);\n        }\n      var i = e.data.baseData.properties || {};\n      for (var r in i)\n        if (i.hasOwnProperty(r)) {\n          o = {\n            key: r,\n            value: i[r],\n          };\n          t.push(o);\n        }\n      return t;\n    };\n    e.keys = new i.ContextTagKeys();\n    return e;\n  })();\nmodule.exports = u;",
  "7159": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.CodeGen =\n  exports.Name =\n  exports.nil =\n  exports.stringify =\n  exports.str =\n  exports._ =\n  exports.KeywordCxt =\n    undefined;\nvar r = require(4815);\nexports.KeywordCxt = r.KeywordCxt;\nvar o = require(3487);\nexports._ = o._;\nexports.str = o.str;\nexports.stringify = o.stringify;\nexports.nil = o.nil;\nexports.Name = o.Name;\nexports.CodeGen = o.CodeGen;\nconst i = require(7426),\n  s = require(6646),\n  a = require(3141),\n  c = require(5173),\n  l = require(3487),\n  u = require(2531),\n  d = require(453),\n  p = require(6776),\n  h = require(4775),\n  f = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"],\n  m = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n  ]),\n  g = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs:\n      \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode:\n      \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats:\n      \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n  },\n  _ = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode:\n      '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n  };\nfunction y(e) {\n  var t, n, r, o, i, s, a, c, l, u, d, p, h, f, m, g, _, y, v, b, w, x;\n  const E = e.strict,\n    C = null === (t = e.code) || undefined === t ? undefined : t.optimize,\n    S = !0 === C || undefined === C ? 1 : C || 0;\n  return {\n    strictSchema:\n      null === (r = null !== (n = e.strictSchema) && undefined !== n ? n : E) ||\n      undefined === r ||\n      r,\n    strictNumbers:\n      null ===\n        (i = null !== (o = e.strictNumbers) && undefined !== o ? o : E) ||\n      undefined === i ||\n      i,\n    strictTypes:\n      null !== (a = null !== (s = e.strictTypes) && undefined !== s ? s : E) &&\n      undefined !== a\n        ? a\n        : \"log\",\n    strictTuples:\n      null !== (l = null !== (c = e.strictTuples) && undefined !== c ? c : E) &&\n      undefined !== l\n        ? l\n        : \"log\",\n    strictRequired:\n      null !==\n        (d = null !== (u = e.strictRequired) && undefined !== u ? u : E) &&\n      undefined !== d &&\n      d,\n    code: e.code\n      ? {\n          ...e.code,\n          optimize: S,\n        }\n      : {\n          optimize: S,\n        },\n    loopRequired: null !== (p = e.loopRequired) && undefined !== p ? p : 200,\n    loopEnum: null !== (h = e.loopEnum) && undefined !== h ? h : 200,\n    meta: null === (f = e.meta) || undefined === f || f,\n    messages: null === (m = e.messages) || undefined === m || m,\n    inlineRefs: null === (g = e.inlineRefs) || undefined === g || g,\n    schemaId: null !== (_ = e.schemaId) && undefined !== _ ? _ : \"$id\",\n    addUsedSchema: null === (y = e.addUsedSchema) || undefined === y || y,\n    validateSchema: null === (v = e.validateSchema) || undefined === v || v,\n    validateFormats: null === (b = e.validateFormats) || undefined === b || b,\n    unicodeRegExp: null === (w = e.unicodeRegExp) || undefined === w || w,\n    int32range: null === (x = e.int32range) || undefined === x || x,\n  };\n}\nclass v {\n  constructor(e = {}) {\n    this.schemas = {};\n    this.refs = {};\n    this.formats = {};\n    this._compilations = new Set();\n    this._loading = {};\n    this._cache = new Map();\n    e = this.opts = {\n      ...e,\n      ...y(e),\n    };\n    const { es5: t, lines: n } = this.opts.code;\n    this.scope = new l.ValueScope({\n      scope: {},\n      prefixes: m,\n      es5: t,\n      lines: n,\n    });\n    this.logger = (function (e) {\n      if (!1 === e) return T;\n      if (undefined === e) return console;\n      if (e.log && e.warn && e.error) return e;\n      throw new Error(\"logger must implement log, warn and error methods\");\n    })(e.logger);\n    const r = e.validateFormats;\n    e.validateFormats = !1;\n    this.RULES = a.getRules();\n    b.call(this, g, e, \"NOT SUPPORTED\");\n    b.call(this, _, e, \"DEPRECATED\", \"warn\");\n    this._metaOpts = S.call(this);\n    if (e.formats) {\n      E.call(this);\n    }\n    this._addVocabularies();\n    this._addDefaultMetaSchema();\n    if (e.keywords) {\n      C.call(this, e.keywords);\n    }\n    if (\"object\" == typeof e.meta) {\n      this.addMetaSchema(e.meta);\n    }\n    x.call(this);\n    e.validateFormats = r;\n  }\n  _addVocabularies() {\n    this.addKeyword(\"$async\");\n  }\n  _addDefaultMetaSchema() {\n    const { $data: e, meta: t, schemaId: n } = this.opts;\n    let r = h;\n    if (\"id\" === n) {\n      r = {\n        ...h,\n      };\n      r.id = r.$id;\n      delete r.$id;\n    }\n    if (t && e) {\n      this.addMetaSchema(r, r[n], !1);\n    }\n  }\n  defaultMeta() {\n    const { meta: e, schemaId: t } = this.opts;\n    return (this.opts.defaultMeta =\n      \"object\" == typeof e ? e[t] || e : undefined);\n  }\n  validate(e, t) {\n    let n;\n    if (\"string\" == typeof e) {\n      n = this.getSchema(e);\n      if (!n) throw new Error(`no schema with key or ref \"${e}\"`);\n    } else n = this.compile(e);\n    const r = n(t);\n    if (\"$async\" in n) {\n      this.errors = n.errors;\n    }\n    return r;\n  }\n  compile(e, t) {\n    const n = this._addSchema(e, t);\n    return n.validate || this._compileSchemaEnv(n);\n  }\n  compileAsync(e, t) {\n    if (\"function\" != typeof this.opts.loadSchema)\n      throw new Error(\"options.loadSchema should be a function\");\n    const { loadSchema: n } = this.opts;\n    return r.call(this, e, t);\n    async function r(e, t) {\n      await o.call(this, e.$schema);\n      const n = this._addSchema(e, t);\n      return n.validate || i.call(this, n);\n    }\n    async function o(e) {\n      if (e && !this.getSchema(e)) {\n        await r.call(\n          this,\n          {\n            $ref: e,\n          },\n          !0\n        );\n      }\n    }\n    async function i(e) {\n      try {\n        return this._compileSchemaEnv(e);\n      } catch (t) {\n        if (!(t instanceof s.default)) throw t;\n        a.call(this, t);\n        await c.call(this, t.missingSchema);\n        return i.call(this, e);\n      }\n    }\n    function a({ missingSchema: e, missingRef: t }) {\n      if (this.refs[e])\n        throw new Error(`AnySchema ${e} is loaded but ${t} cannot be resolved`);\n    }\n    async function c(e) {\n      const n = await l.call(this, e);\n      if (this.refs[e]) {\n        await o.call(this, n.$schema);\n      }\n      if (this.refs[e]) {\n        this.addSchema(n, e, t);\n      }\n    }\n    async function l(e) {\n      const t = this._loading[e];\n      if (t) return t;\n      try {\n        return await (this._loading[e] = n(e));\n      } finally {\n        delete this._loading[e];\n      }\n    }\n  }\n  addSchema(e, t, n, r = this.opts.validateSchema) {\n    if (Array.isArray(e)) {\n      for (const t of e) this.addSchema(t, undefined, n, r);\n      return this;\n    }\n    let o;\n    if (\"object\" == typeof e) {\n      const { schemaId: t } = this.opts;\n      o = e[t];\n      if (void 0 !== o && \"string\" != typeof o)\n        throw new Error(`schema ${t} must be string`);\n    }\n    t = u.normalizeId(t || o);\n    this._checkUnique(t);\n    this.schemas[t] = this._addSchema(e, n, t, r, !0);\n    return this;\n  }\n  addMetaSchema(e, t, n = this.opts.validateSchema) {\n    this.addSchema(e, t, !0, n);\n    return this;\n  }\n  validateSchema(e, t) {\n    if (\"boolean\" == typeof e) return !0;\n    let n;\n    n = e.$schema;\n    if (void 0 !== n && \"string\" != typeof n)\n      throw new Error(\"$schema must be a string\");\n    n = n || this.opts.defaultMeta || this.defaultMeta();\n    if (!n)\n      return (\n        this.logger.warn(\"meta-schema not available\"), (this.errors = null), !0\n      );\n    const r = this.validate(n, e);\n    if (!r && t) {\n      const e = \"schema is invalid: \" + this.errorsText();\n      if (\"log\" !== this.opts.validateSchema) throw new Error(e);\n      this.logger.error(e);\n    }\n    return r;\n  }\n  getSchema(e) {\n    let t;\n    for (; \"string\" == typeof (t = w.call(this, e)); ) e = t;\n    if (undefined === t) {\n      const { schemaId: n } = this.opts,\n        r = new c.SchemaEnv({\n          schema: {},\n          schemaId: n,\n        });\n      t = c.resolveSchema.call(this, r, e);\n      if (!t) return;\n      this.refs[e] = t;\n    }\n    return t.validate || this._compileSchemaEnv(t);\n  }\n  removeSchema(e) {\n    if (e instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, e);\n      this._removeAllSchemas(this.refs, e);\n      return this;\n    }\n    switch (typeof e) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas);\n        this._removeAllSchemas(this.refs);\n        this._cache.clear();\n        return this;\n      case \"string\": {\n        const t = w.call(this, e);\n        if (\"object\" == typeof t) {\n          this._cache.delete(t.schema);\n        }\n        delete this.schemas[e];\n        delete this.refs[e];\n        return this;\n      }\n      case \"object\": {\n        const t = e;\n        this._cache.delete(t);\n        let n = e[this.opts.schemaId];\n        if (n) {\n          n = u.normalizeId(n);\n          delete this.schemas[n];\n          delete this.refs[n];\n        }\n        return this;\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\");\n    }\n  }\n  addVocabulary(e) {\n    for (const t of e) this.addKeyword(t);\n    return this;\n  }\n  addKeyword(e, t) {\n    let n;\n    if (\"string\" == typeof e) {\n      n = e;\n      if (\"object\" == typeof t) {\n        this.logger.warn(\n          \"these parameters are deprecated, see docs for addKeyword\"\n        );\n        t.keyword = n;\n      }\n    } else {\n      if (\"object\" != typeof e || undefined !== t)\n        throw new Error(\"invalid addKeywords parameters\");\n      n = (t = e).keyword;\n      if (Array.isArray(n) && !n.length)\n        throw new Error(\n          \"addKeywords: keyword must be string or non-empty array\"\n        );\n    }\n    I.call(this, n, t);\n    if (!t) return (0, p.eachItem)(n, (e) => P.call(this, e)), this;\n    O.call(this, t);\n    const r = {\n      ...t,\n      type: d.getJSONTypes(t.type),\n      schemaType: d.getJSONTypes(t.schemaType),\n    };\n    p.eachItem(\n      n,\n      0 === r.type.length\n        ? (e) => P.call(this, e, r)\n        : (e) => r.type.forEach((t) => P.call(this, e, r, t))\n    );\n    return this;\n  }\n  getKeyword(e) {\n    const t = this.RULES.all[e];\n    return \"object\" == typeof t ? t.definition : !!t;\n  }\n  removeKeyword(e) {\n    const { RULES: t } = this;\n    delete t.keywords[e];\n    delete t.all[e];\n    for (const n of t.rules) {\n      const t = n.rules.findIndex((t) => t.keyword === e);\n      if (t >= 0) {\n        n.rules.splice(t, 1);\n      }\n    }\n    return this;\n  }\n  addFormat(e, t) {\n    if (\"string\" == typeof t) {\n      t = new RegExp(t);\n    }\n    this.formats[e] = t;\n    return this;\n  }\n  errorsText(\n    e = this.errors,\n    { separator: t = \", \", dataVar: n = \"data\" } = {}\n  ) {\n    return e && 0 !== e.length\n      ? e\n          .map((e) => `${n}${e.instancePath} ${e.message}`)\n          .reduce((e, n) => e + t + n)\n      : \"No errors\";\n  }\n  $dataMetaSchema(e, t) {\n    const n = this.RULES.all;\n    e = JSON.parse(JSON.stringify(e));\n    for (const r of t) {\n      const t = r.split(\"/\").slice(1);\n      let o = e;\n      for (const e of t) o = o[e];\n      for (const e in n) {\n        const t = n[e];\n        if (\"object\" != typeof t) continue;\n        const { $data: r } = t.definition,\n          i = o[e];\n        if (r && i) {\n          o[e] = R(i);\n        }\n      }\n    }\n    return e;\n  }\n  _removeAllSchemas(e, t) {\n    for (const n in e) {\n      const r = e[n];\n      if (t && !t.test(n)) {\n        if (\"string\" == typeof r) {\n          delete e[n];\n        } else {\n          if (r && !r.meta) {\n            this._cache.delete(r.schema);\n            delete e[n];\n          }\n        }\n      }\n    }\n  }\n  _addSchema(\n    e,\n    t,\n    n,\n    r = this.opts.validateSchema,\n    o = this.opts.addUsedSchema\n  ) {\n    let i;\n    const { schemaId: s } = this.opts;\n    if (\"object\" == typeof e) i = e[s];\n    else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\");\n      if (\"boolean\" != typeof e)\n        throw new Error(\"schema must be object or boolean\");\n    }\n    let a = this._cache.get(e);\n    if (undefined !== a) return a;\n    n = u.normalizeId(i || n);\n    const l = u.getSchemaRefs.call(this, e, n);\n    a = new c.SchemaEnv({\n      schema: e,\n      schemaId: s,\n      meta: t,\n      baseId: n,\n      localRefs: l,\n    });\n    this._cache.set(a.schema, a);\n    if (o && !n.startsWith(\"#\")) {\n      if (n) {\n        this._checkUnique(n);\n      }\n      this.refs[n] = a;\n    }\n    if (r) {\n      this.validateSchema(e, !0);\n    }\n    return a;\n  }\n  _checkUnique(e) {\n    if (this.schemas[e] || this.refs[e])\n      throw new Error(`schema with key or id \"${e}\" already exists`);\n  }\n  _compileSchemaEnv(e) {\n    if (e.meta) {\n      this._compileMetaSchema(e);\n    } else {\n      c.compileSchema.call(this, e);\n    }\n    if (!e.validate) throw new Error(\"ajv implementation error\");\n    return e.validate;\n  }\n  _compileMetaSchema(e) {\n    const t = this.opts;\n    this.opts = this._metaOpts;\n    try {\n      c.compileSchema.call(this, e);\n    } finally {\n      this.opts = t;\n    }\n  }\n}\nfunction b(e, t, n, r = \"error\") {\n  for (const o in e) {\n    const i = o;\n    if (i in t) {\n      this.logger[r](`${n}: option ${o}. ${e[i]}`);\n    }\n  }\n}\nfunction w(e) {\n  e = u.normalizeId(e);\n  return this.schemas[e] || this.refs[e];\n}\nfunction x() {\n  const e = this.opts.schemas;\n  if (e)\n    if (Array.isArray(e)) this.addSchema(e);\n    else for (const t in e) this.addSchema(e[t], t);\n}\nfunction E() {\n  for (const e in this.opts.formats) {\n    const t = this.opts.formats[e];\n    if (t) {\n      this.addFormat(e, t);\n    }\n  }\n}\nfunction C(e) {\n  if (Array.isArray(e)) this.addVocabulary(e);\n  else {\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const t in e) {\n      const n = e[t];\n      if (n.keyword) {\n        n.keyword = t;\n      }\n      this.addKeyword(n);\n    }\n  }\n}\nfunction S() {\n  const e = {\n    ...this.opts,\n  };\n  for (const t of f) delete e[t];\n  return e;\n}\nexports.default = v;\nv.ValidationError = i.default;\nv.MissingRefError = s.default;\nconst T = {\n    log() {},\n    warn() {},\n    error() {},\n  },\n  k = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction I(e, t) {\n  const { RULES: n } = this;\n  p.eachItem(e, (e) => {\n    if (n.keywords[e]) throw new Error(`Keyword ${e} is already defined`);\n    if (!k.test(e)) throw new Error(`Keyword ${e} has invalid name`);\n  });\n  if (t && t.$data && !(\"code\" in t) && !(\"validate\" in t))\n    throw new Error('$data keyword must have \"code\" or \"validate\" function');\n}\nfunction P(e, t, n) {\n  var r;\n  const o = null == t ? undefined : t.post;\n  if (n && o) throw new Error('keyword with \"post\" flag cannot have \"type\"');\n  const { RULES: i } = this;\n  let s = o ? i.post : i.rules.find(({ type: e }) => e === n);\n  if (s) {\n    s = {\n      type: n,\n      rules: [],\n    };\n    i.rules.push(s);\n  }\n  i.keywords[e] = !0;\n  if (!t) return;\n  const a = {\n    keyword: e,\n    definition: {\n      ...t,\n      type: d.getJSONTypes(t.type),\n      schemaType: d.getJSONTypes(t.schemaType),\n    },\n  };\n  if (t.before) {\n    A.call(this, s, a, t.before);\n  } else {\n    s.rules.push(a);\n  }\n  i.all[e] = a;\n  if (null === (r = t.implements) || undefined === r) {\n    r.forEach((e) => this.addKeyword(e));\n  }\n}\nfunction A(e, t, n) {\n  const r = e.rules.findIndex((e) => e.keyword === n);\n  if (r >= 0) {\n    e.rules.splice(r, 0, t);\n  } else {\n    e.rules.push(t);\n    this.logger.warn(`rule ${n} is not defined`);\n  }\n}\nfunction O(e) {\n  let { metaSchema: t } = e;\n  if (undefined !== t) {\n    if (e.$data && this.opts.$data) {\n      t = R(t);\n    }\n    e.validateSchema = this.compile(t, !0);\n  }\n}\nconst N = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction R(e) {\n  return {\n    anyOf: [e, N],\n  };\n}",
  "7190": "const r = require(\"timers\");\nfunction o() {}\nfunction i() {}\nfunction s() {}\nconst a = new Map(),\n  c = new Map(),\n  l = new Map();\nlet u = null,\n  d = !1;\nfunction p(e, t, n, o, i, s, a) {\n  const c = r[n],\n    l = r[o];\n  r[n] = function () {\n    if (!t.enabled) return c.apply(r, arguments);\n    const n = new Array(arguments.length);\n    for (let e = 0; e < arguments.length; e++) n[e] = arguments[e];\n    const o = n[0];\n    if (\"function\" != typeof o)\n      throw new TypeError('\"callback\" argument must be a function');\n    const l = new i(),\n      p = --t.counter;\n    let h;\n    e.init.call(l, p, 0, null, null);\n    n[0] = function () {\n      u = h;\n      e.pre.call(l, p);\n      let t = !0;\n      try {\n        o.apply(this, arguments);\n        t = !1;\n      } finally {\n        if (t && process.listenerCount(\"uncaughtException\") > 0) {\n          process.once(\"uncaughtException\", function () {\n            e.post.call(l, p, !0);\n            s.delete(h);\n            e.destroy.call(null, p);\n          });\n        }\n      }\n      e.post.call(l, p, !1);\n      u = null;\n      if (a || d) {\n        d = !1;\n        s.delete(h);\n        e.destroy.call(null, p);\n      }\n    };\n    h = c.apply(r, n);\n    s.set(h, p);\n    return h;\n  };\n  r[o] = function (t) {\n    if (u === t && null !== t) d = !0;\n    else if (s.has(t)) {\n      const n = s.get(t);\n      s.delete(t);\n      e.destroy.call(null, n);\n    }\n    l.apply(r, arguments);\n  };\n}\nmodule.exports = function () {\n  p(this._hooks, this._state, \"setTimeout\", \"clearTimeout\", o, a, !0);\n  p(this._hooks, this._state, \"setInterval\", \"clearInterval\", i, c, !1);\n  p(this._hooks, this._state, \"setImmediate\", \"clearImmediate\", s, l, !0);\n  global.setTimeout = r.setTimeout;\n  global.setInterval = r.setInterval;\n  global.setImmediate = r.setImmediate;\n  global.clearTimeout = r.clearTimeout;\n  global.clearInterval = r.clearInterval;\n  global.clearImmediate = r.clearImmediate;\n};",
  "7220": "var r,\n  o =\n    (this && this.__extends) ||\n    ((r =\n      Object.setPrototypeOf ||\n      ({\n        __proto__: [],\n      } instanceof Array &&\n        function (e, t) {\n          e.__proto__ = t;\n        }) ||\n      function (e, t) {\n        for (var n in t)\n          if (t.hasOwnProperty(n)) {\n            e[n] = t[n];\n          }\n      }),\n    function (e, t) {\n      function n() {\n        this.constructor = e;\n      }\n      r(e, t);\n      e.prototype =\n        null === t ? Object.create(t) : ((n.prototype = t.prototype), new n());\n    }),\n  i = (function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.properties = {};\n      t.measurements = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  })(require(8934));\nmodule.exports = i;",
  "7254": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.CopilotStatusBar = undefined;\nconst r = require(\"vscode\"),\n  o = require(106),\n  i = require(1133),\n  s = require(6333),\n  a = require(3060);\nexports.CopilotStatusBar = class {\n  constructor(e) {\n    this.ctx = e;\n    this.showingMessage = !1;\n    this.status = \"Normal\";\n    this.errorMessage = \"\";\n    this.disabledColor = new r.ThemeColor(\"statusBarItem.warningBackground\");\n    this.delayedUpdateDisplay = o.debounce(100, () => {\n      this.updateDisplay();\n    });\n    this.enabled = this.checkEnabledForLanguage();\n    this.item = r.window.createStatusBarItem(r.StatusBarAlignment.Right, 0);\n    this.updateDisplay();\n    this.item.show();\n    r.window.onDidChangeActiveTextEditor(() => {\n      this.updateStatusBarIndicator();\n    });\n    r.workspace.onDidCloseTextDocument(() => {\n      this.updateStatusBarIndicator();\n    });\n    r.workspace.onDidOpenTextDocument(() => {\n      this.updateStatusBarIndicator();\n    });\n  }\n  updateStatusBarIndicator() {\n    this.enabled = this.checkEnabledForLanguage();\n    this.updateDisplay();\n  }\n  checkEnabledForLanguage() {\n    return i.getEnabledConfig(this.ctx) || !1;\n  }\n  updateDisplay() {\n    switch (this.status) {\n      case \"Error\":\n        this.item.text = \"$(copilot-notconnected)\";\n        this.item.command = a.CMDShowActivationErrors;\n        this.item.tooltip = \"Copilot activation failed\";\n        break;\n      case \"Warning\":\n        this.item.text = \"$(copilot-warning)\";\n        this.item.command = undefined;\n        this.item.tooltip = \"Copilot is encountering temporary issues\";\n        break;\n      case \"InProgress\":\n        this.item.text = \"$(loading~spin)\";\n        break;\n      case \"Normal\":\n        this.item.text = \"$(copilot-logo)\";\n        this.item.command = a.CMDToggleCopilot;\n        this.item.tooltip = this.enabled\n          ? \"Deactivate Copilot\"\n          : \"Activate Copilot\";\n        this.item.backgroundColor = this.enabled\n          ? undefined\n          : this.disabledColor;\n    }\n  }\n  getStatusBarItem() {\n    return this.item;\n  }\n  setProgress() {\n    if (\"Error\" !== this.status) {\n      this.status = \"InProgress\";\n      this.delayedUpdateDisplay();\n    }\n  }\n  removeProgress() {\n    if (\"Error\" !== this.status && \"Warning\" !== this.status) {\n      this.status = \"Normal\";\n      this.delayedUpdateDisplay();\n    }\n  }\n  setWarning() {\n    if (\"Error\" !== this.status) {\n      this.status = \"Warning\";\n      this.updateDisplay();\n    }\n  }\n  setError(e, t) {\n    this.status = \"Error\";\n    this.errorMessage = e;\n    this.errorRetry = t;\n    this.updateDisplay();\n  }\n  forceNormal() {\n    this.status = \"Normal\";\n    this.errorMessage = \"\";\n    this.errorRetry = undefined;\n    this.updateDisplay();\n  }\n  toggleStatusBar() {\n    var e;\n    const t = this.ctx.get(i.ConfigProvider),\n      n = this.enabled,\n      o =\n        null === (e = r.window.activeTextEditor) || undefined === e\n          ? undefined\n          : e.document.languageId,\n      a = \"editor.action.inlineSuggest.hide\";\n    if (this.showingMessage) return;\n    const c = s.TelemetryData.createAndMarkAsIssued({\n      languageId: o || \"*\",\n    });\n    if (i.getEnabledConfig(this.ctx, \"*\") == i.getEnabledConfig(this.ctx, o)) {\n      this.showingMessage = !0;\n      setTimeout(() => {\n        this.showingMessage = !1;\n      }, 15e3);\n      const e = n ? \"Disable\" : \"Enable\",\n        i = `${e} Globally`,\n        l = `${e} for ${o}`,\n        u = o ? [i, l] : [i];\n      r.window\n        .showInformationMessage(\n          `Would you like to ${n ? \"disable\" : \"enable\"} Copilot?`,\n          ...u\n        )\n        .then((e) => {\n          const l = e === i;\n          this.showingMessage = !1;\n          if (void 0 === e)\n            return void (0, s.telemetry)(this.ctx, \"statusBar.cancelToggle\");\n          s.telemetry(\n            this.ctx,\n            \"statusBar\" + (l ? \".global\" : \".language\") + (n ? \"Off\" : \"On\"),\n            c\n          );\n          if (n) {\n            r.commands.executeCommand(a);\n          }\n          const u = l ? \"*\" : o;\n          t.updateEnabledConfig(this.ctx, u, !n).then(() => {\n            this.enabled = !n;\n            this.updateDisplay();\n          });\n        });\n    } else {\n      s.telemetry(this.ctx, \"statusBar.language\" + (n ? \"Off\" : \"On\"), c);\n      if (n) {\n        r.commands.executeCommand(a);\n      }\n      t.updateEnabledConfig(this.ctx, o || \"*\", !n).then(() => {\n        this.enabled = !n;\n        this.updateDisplay();\n      });\n    }\n    this.updateDisplay();\n  }\n  showActivationErrors(e) {\n    if (this.showingMessage) return;\n    this.showingMessage = !0;\n    const t = [\"Show output log\"];\n    if (this.errorRetry) {\n      t.push(\"Retry\");\n    }\n    r.window.showWarningMessage(this.errorMessage, ...t).then((t) => {\n      this.showingMessage = !1;\n      if (\"Show Output log\" === t) {\n        e.show();\n      }\n      if (\"Retry\" === t && this.errorRetry) {\n        this.errorRetry();\n      }\n    });\n  }\n};",
  "7262": "const { connect: r, constants: o } = require(\"http2\"),\n  { Readable: i } = require(\"stream\"),\n  s = require(8104)(\"helix-fetch:h2\"),\n  { RequestAbortedError: a } = require(1787),\n  { decodeStream: c } = require(4544),\n  { NGHTTP2_CANCEL: l } = o,\n  u = 3e5,\n  d = 5e3,\n  p = (e, t, n, r = () => {}) => {\n    const o = {\n        ...e,\n      },\n      i = o[\":status\"];\n    delete o[\":status\"];\n    const s = n ? c(i, e, t, r) : t;\n    return {\n      statusCode: i,\n      statusText: \"\",\n      httpVersion: \"2.0\",\n      httpVersionMajor: 2,\n      httpVersionMinor: 0,\n      headers: o,\n      readable: s,\n      decoded: !(!n || s === t),\n    };\n  };\nmodule.exports = {\n  request: async (e, t, n) => {\n    const { origin: o, pathname: c, search: h, hash: f } = t,\n      m = `${c}${h}${f}`,\n      {\n        options: { h2: g = {} },\n        h2: { sessionCache: _ },\n      } = e,\n      { idleSessionTimeout: y = u, pushPromiseHandler: v, pushHandler: b } = g,\n      w = {\n        ...n,\n      },\n      { method: x, headers: E, socket: C, body: S, decode: T } = w;\n    if (C) {\n      delete w.socket;\n    }\n    if (E.host) {\n      E[\":authority\"] = E.host;\n      delete E.host;\n    }\n    return new Promise((n, c) => {\n      let u,\n        h = _[o];\n      if (!h || h.closed || h.destroyed) {\n        const t = !(\n            !1 === e.options.rejectUnauthorized || !1 === g.rejectUnauthorized\n          ),\n          n = {\n            ...g,\n            rejectUnauthorized: t,\n          };\n        if (C && !C.inUse) {\n          n.createConnection = () => (\n            s(`reusing socket #${C.id} (${C.servername})`), (C.inUse = !0), C\n          );\n        }\n        const i = !(!v && !b);\n        h = r(o, {\n          ...n,\n          settings: {\n            enablePush: i,\n          },\n        });\n        h.setMaxListeners(1e3);\n        h.setTimeout(y, () => {\n          s(`closing session ${o} after ${y} ms of inactivity`);\n          h.close();\n        });\n        h.once(\"connect\", () => {\n          s(`session ${o} established`);\n          s(`caching session ${o}`);\n          _[o] = h;\n        });\n        h.on(\"localSettings\", (e) => {\n          s(`session ${o} localSettings: ${JSON.stringify(e)}`);\n        });\n        h.on(\"remoteSettings\", (e) => {\n          s(`session ${o} remoteSettings: ${JSON.stringify(e)}`);\n        });\n        h.once(\"close\", () => {\n          s(`session ${o} closed`);\n          if (_[o] === h) {\n            s(`discarding cached session ${o}`);\n            delete _[o];\n          }\n        });\n        h.once(\"error\", (e) => {\n          s(`session ${o} encountered error: ${e}`);\n          if (_[o] === h) {\n            s(`discarding cached session ${o}`);\n            delete _[o];\n          }\n        });\n        h.on(\"frameError\", (e, t, n) => {\n          s(\n            `session ${o} encountered frameError: type: ${e}, code: ${t}, id: ${n}`\n          );\n        });\n        h.once(\"goaway\", (e, t, n) => {\n          s(\n            `session ${o} received GOAWAY frame: errorCode: ${e}, lastStreamID: ${t}, opaqueData: ${\n              n ? n.toString() : undefined\n            }`\n          );\n        });\n        h.on(\"stream\", (t, n, r) => {\n          ((e, t, n, r, o, i) => {\n            const {\n                options: {\n                  h2: {\n                    pushPromiseHandler: a,\n                    pushHandler: c,\n                    pushedStreamIdleTimeout: u = d,\n                  },\n                },\n              } = e,\n              h = o[\":path\"],\n              f = `${t}${h}`;\n            s(\n              `received PUSH_PROMISE: ${f}, stream #${\n                r.id\n              }, headers: ${JSON.stringify(o)}, flags: ${i}`\n            );\n            if (a) {\n              a(f, o, () => {\n                r.close(l);\n              });\n            }\n            r.on(\"push\", (e, i) => {\n              s(\n                `received push headers for ${t}${h}, stream #${\n                  r.id\n                }, headers: ${JSON.stringify(e)}, flags: ${i}`\n              );\n              r.setTimeout(u, () => {\n                s(`closing pushed stream #${r.id} after ${u} ms of inactivity`);\n                r.close(l);\n              });\n              if (c) {\n                c(f, o, p(e, r, n));\n              }\n            });\n            r.on(\"aborted\", () => {\n              s(`pushed stream #${r.id} aborted`);\n            });\n            r.on(\"error\", (e) => {\n              s(`pushed stream #${r.id} encountered error: ${e}`);\n            });\n            r.on(\"frameError\", (e, t, n) => {\n              s(\n                `pushed stream #${r.id} encountered frameError: type: ${e}, code: ${t}, id: ${n}`\n              );\n            });\n          })(e, o, T, t, n, r);\n        });\n      } else if (C && C.id !== h.socket.id && !C.inUse) {\n        s(\n          `discarding redundant socket used for ALPN: #${C.id} ${C.servername}`\n        );\n        C.destroy();\n      }\n      s(`${x} ${t.host}${m}`);\n      const { signal: f } = w,\n        k = () => {\n          f.removeEventListener(\"abort\", k);\n          c(new a());\n          if (u) {\n            u.close(l);\n          }\n        };\n      if (f) {\n        if (f.aborted) return void c(new a());\n        f.addEventListener(\"abort\", k);\n      }\n      const I = (e) => {\n        s(`session ${o} encountered error during ${w.method} ${t.href}: ${e}`);\n        c(e);\n      };\n      h.once(\"error\", I);\n      u = h.request({\n        \":method\": x,\n        \":path\": m,\n        ...E,\n      });\n      u.once(\"response\", (e) => {\n        h.off(\"error\", I);\n        if (f) {\n          f.removeEventListener(\"abort\", k);\n        }\n        n(p(e, u, w.decode, c));\n      });\n      u.once(\"error\", (e) => {\n        h.off(\"error\", I);\n        if (f) {\n          f.removeEventListener(\"abort\", k);\n        }\n        if (u.rstCode !== l) {\n          s(`${w.method} ${t.href} failed with: ${e.message}`);\n          u.close(l);\n          c(e);\n        }\n      });\n      u.once(\"frameError\", (e, n, r) => {\n        h.off(\"error\", I);\n        s(\n          `encountered frameError during ${w.method} ${t.href}: type: ${e}, code: ${n}, id: ${r}`\n        );\n      });\n      u.on(\"push\", (e, t) => {\n        s(`received 'push' event: headers: ${JSON.stringify(e)}, flags: ${t}`);\n      });\n      if (S instanceof i) {\n        S.pipe(u);\n      } else {\n        if (S) {\n          u.write(S);\n        }\n        u.end();\n      }\n    });\n  },\n  setupContext: (e) => {\n    e.h2 = {\n      sessionCache: {},\n    };\n  },\n  resetContext: async ({ h2: e }) =>\n    Promise.all(\n      Object.values(e.sessionCache).map(\n        (e) =>\n          new Promise((t) => {\n            e.on(\"close\", t);\n            s(\n              `resetContext: destroying session (socket #${\n                e.socket && e.socket.id\n              }, ${e.socket && e.socket.servername})`\n            );\n            e.destroy();\n          })\n      )\n    ),\n};",
  "7300": "module.exports = function () {\n  this.ver = 1;\n  this.sampleRate = 100;\n  this.tags = {};\n};",
  "7339": "var r,\n  o =\n    (this && this.__extends) ||\n    ((r =\n      Object.setPrototypeOf ||\n      ({\n        __proto__: [],\n      } instanceof Array &&\n        function (e, t) {\n          e.__proto__ = t;\n        }) ||\n      function (e, t) {\n        for (var n in t)\n          if (t.hasOwnProperty(n)) {\n            e[n] = t[n];\n          }\n      }),\n    function (e, t) {\n      function n() {\n        this.constructor = e;\n      }\n      r(e, t);\n      e.prototype =\n        null === t ? Object.create(t) : ((n.prototype = t.prototype), new n());\n    }),\n  i = (function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.properties = {};\n      t.measurements = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  })(require(8934));\nmodule.exports = i;",
  "7373": "var r;\nrequire.r(exports);\nrequire.d(exports, {\n  URI: () => o,\n  Utils: () => i,\n});\nr = (() => {\n  var e = {\n      470: (e) => {\n        function t(e) {\n          if (\"string\" != typeof e)\n            throw new TypeError(\n              \"Path must be a string. Received \" + JSON.stringify(e)\n            );\n        }\n        function n(e, t) {\n          for (var n, r = \"\", o = 0, i = -1, s = 0, a = 0; a <= e.length; ++a) {\n            if (a < e.length) n = e.charCodeAt(a);\n            else {\n              if (47 === n) break;\n              n = 47;\n            }\n            if (47 === n) {\n              if (i === a - 1 || 1 === s);\n              else if (i !== a - 1 && 2 === s) {\n                if (\n                  r.length < 2 ||\n                  2 !== o ||\n                  46 !== r.charCodeAt(r.length - 1) ||\n                  46 !== r.charCodeAt(r.length - 2)\n                )\n                  if (r.length > 2) {\n                    var c = r.lastIndexOf(\"/\");\n                    if (c !== r.length - 1) {\n                      if (-1 === c) {\n                        r = \"\";\n                        o = 0;\n                      } else {\n                        o = (r = r.slice(0, c)).length - 1 - r.lastIndexOf(\"/\");\n                      }\n                      i = a;\n                      s = 0;\n                      continue;\n                    }\n                  } else if (2 === r.length || 1 === r.length) {\n                    r = \"\";\n                    o = 0;\n                    i = a;\n                    s = 0;\n                    continue;\n                  }\n                if (t) {\n                  if (r.length > 0) {\n                    r += \"/..\";\n                  } else {\n                    r = \"..\";\n                  }\n                  o = 2;\n                }\n              } else {\n                if (r.length > 0) {\n                  r += \"/\" + e.slice(i + 1, a);\n                } else {\n                  r = e.slice(i + 1, a);\n                }\n                o = a - i - 1;\n              }\n              i = a;\n              s = 0;\n            } else if (46 === n && -1 !== s) {\n              ++s;\n            } else {\n              s = -1;\n            }\n          }\n          return r;\n        }\n        var r = {\n          resolve: function () {\n            for (\n              var e, r = \"\", o = !1, i = arguments.length - 1;\n              i >= -1 && !o;\n              i--\n            ) {\n              var s;\n              if (i >= 0) {\n                s = arguments[i];\n              } else {\n                if (undefined === e) {\n                  e = process.cwd();\n                }\n                s = e;\n              }\n              t(s);\n              if (0 !== s.length) {\n                r = s + \"/\" + r;\n                o = 47 === s.charCodeAt(0);\n              }\n            }\n            r = n(r, !o);\n            return o ? (r.length > 0 ? \"/\" + r : \"/\") : r.length > 0 ? r : \".\";\n          },\n          normalize: function (e) {\n            t(e);\n            if (0 === e.length) return \".\";\n            var r = 47 === e.charCodeAt(0),\n              o = 47 === e.charCodeAt(e.length - 1);\n            if (0 !== (e = n(e, !r)).length || r) {\n              e = \".\";\n            }\n            if (e.length > 0 && o) {\n              e += \"/\";\n            }\n            return r ? \"/\" + e : e;\n          },\n          isAbsolute: function (e) {\n            t(e);\n            return e.length > 0 && 47 === e.charCodeAt(0);\n          },\n          join: function () {\n            if (0 === arguments.length) return \".\";\n            for (var e, n = 0; n < arguments.length; ++n) {\n              var o = arguments[n];\n              t(o);\n              if (o.length > 0) {\n                if (undefined === e) {\n                  e = o;\n                } else {\n                  e += \"/\" + o;\n                }\n              }\n            }\n            return undefined === e ? \".\" : r.normalize(e);\n          },\n          relative: function (e, n) {\n            t(e);\n            t(n);\n            if (e === n) return \"\";\n            if ((e = r.resolve(e)) === (n = r.resolve(n))) return \"\";\n            for (var o = 1; o < e.length && 47 === e.charCodeAt(o); ++o);\n            for (\n              var i = e.length, s = i - o, a = 1;\n              a < n.length && 47 === n.charCodeAt(a);\n              ++a\n            );\n            for (\n              var c = n.length - a, l = s < c ? s : c, u = -1, d = 0;\n              d <= l;\n              ++d\n            ) {\n              if (d === l) {\n                if (c > l) {\n                  if (47 === n.charCodeAt(a + d)) return n.slice(a + d + 1);\n                  if (0 === d) return n.slice(a + d);\n                } else if (s > l) {\n                  if (47 === e.charCodeAt(o + d)) {\n                    u = d;\n                  } else {\n                    if (0 === d) {\n                      u = 0;\n                    }\n                  }\n                }\n                break;\n              }\n              var p = e.charCodeAt(o + d);\n              if (p !== n.charCodeAt(a + d)) break;\n              if (47 === p) {\n                u = d;\n              }\n            }\n            var h = \"\";\n            for (d = o + u + 1; d <= i; ++d)\n              if (d !== i && 47 !== e.charCodeAt(d)) {\n                if (0 === h.length) {\n                  h += \"..\";\n                } else {\n                  h += \"/..\";\n                }\n              }\n            return h.length > 0\n              ? h + n.slice(a + u)\n              : ((a += u), 47 === n.charCodeAt(a) && ++a, n.slice(a));\n          },\n          _makeLong: function (e) {\n            return e;\n          },\n          dirname: function (e) {\n            t(e);\n            if (0 === e.length) return \".\";\n            for (\n              var n = e.charCodeAt(0),\n                r = 47 === n,\n                o = -1,\n                i = !0,\n                s = e.length - 1;\n              s >= 1;\n              --s\n            )\n              if (47 === (n = e.charCodeAt(s))) {\n                if (!i) {\n                  o = s;\n                  break;\n                }\n              } else i = !1;\n            return -1 === o\n              ? r\n                ? \"/\"\n                : \".\"\n              : r && 1 === o\n              ? \"//\"\n              : e.slice(0, o);\n          },\n          basename: function (e, n) {\n            if (undefined !== n && \"string\" != typeof n)\n              throw new TypeError('\"ext\" argument must be a string');\n            t(e);\n            var r,\n              o = 0,\n              i = -1,\n              s = !0;\n            if (undefined !== n && n.length > 0 && n.length <= e.length) {\n              if (n.length === e.length && n === e) return \"\";\n              var a = n.length - 1,\n                c = -1;\n              for (r = e.length - 1; r >= 0; --r) {\n                var l = e.charCodeAt(r);\n                if (47 === l) {\n                  if (!s) {\n                    o = r + 1;\n                    break;\n                  }\n                } else {\n                  if (-1 === c) {\n                    s = !1;\n                    c = r + 1;\n                  }\n                  if (a >= 0) {\n                    if (l === n.charCodeAt(a)) {\n                      if (-1 == --a) {\n                        i = r;\n                      }\n                    } else {\n                      a = -1;\n                      i = c;\n                    }\n                  }\n                }\n              }\n              if (o === i) {\n                i = c;\n              } else {\n                if (-1 === i) {\n                  i = e.length;\n                }\n              }\n              return e.slice(o, i);\n            }\n            for (r = e.length - 1; r >= 0; --r)\n              if (47 === e.charCodeAt(r)) {\n                if (!s) {\n                  o = r + 1;\n                  break;\n                }\n              } else if (-1 === i) {\n                s = !1;\n                i = r + 1;\n              }\n            return -1 === i ? \"\" : e.slice(o, i);\n          },\n          extname: function (e) {\n            t(e);\n            for (\n              var n = -1, r = 0, o = -1, i = !0, s = 0, a = e.length - 1;\n              a >= 0;\n              --a\n            ) {\n              var c = e.charCodeAt(a);\n              if (47 !== c) {\n                if (-1 === o) {\n                  i = !1;\n                  o = a + 1;\n                }\n                if (46 === c) {\n                  if (-1 === n) {\n                    n = a;\n                  } else {\n                    if (1 !== s) {\n                      s = 1;\n                    }\n                  }\n                } else {\n                  if (-1 !== n) {\n                    s = -1;\n                  }\n                }\n              } else if (!i) {\n                r = a + 1;\n                break;\n              }\n            }\n            return -1 === n ||\n              -1 === o ||\n              0 === s ||\n              (1 === s && n === o - 1 && n === r + 1)\n              ? \"\"\n              : e.slice(n, o);\n          },\n          format: function (e) {\n            if (null === e || \"object\" != typeof e)\n              throw new TypeError(\n                'The \"pathObject\" argument must be of type Object. Received type ' +\n                  typeof e\n              );\n            return (function (e, t) {\n              var n = t.dir || t.root,\n                r = t.base || (t.name || \"\") + (t.ext || \"\");\n              return n ? (n === t.root ? n + r : n + \"/\" + r) : r;\n            })(0, e);\n          },\n          parse: function (e) {\n            t(e);\n            var n = {\n              root: \"\",\n              dir: \"\",\n              base: \"\",\n              ext: \"\",\n              name: \"\",\n            };\n            if (0 === e.length) return n;\n            var r,\n              o = e.charCodeAt(0),\n              i = 47 === o;\n            if (i) {\n              n.root = \"/\";\n              r = 1;\n            } else {\n              r = 0;\n            }\n            for (\n              var s = -1, a = 0, c = -1, l = !0, u = e.length - 1, d = 0;\n              u >= r;\n              --u\n            )\n              if (47 !== (o = e.charCodeAt(u))) {\n                if (-1 === c) {\n                  l = !1;\n                  c = u + 1;\n                }\n                if (46 === o) {\n                  if (-1 === s) {\n                    s = u;\n                  } else {\n                    if (1 !== d) {\n                      d = 1;\n                    }\n                  }\n                } else {\n                  if (-1 !== s) {\n                    d = -1;\n                  }\n                }\n              } else if (!l) {\n                a = u + 1;\n                break;\n              }\n            if (\n              -1 === s ||\n              -1 === c ||\n              0 === d ||\n              (1 === d && s === c - 1 && s === a + 1)\n            ) {\n              if (-1 !== c) {\n                n.base = n.name = 0 === a && i ? e.slice(1, c) : e.slice(a, c);\n              }\n            } else {\n              if (0 === a && i) {\n                n.name = e.slice(1, s);\n                n.base = e.slice(1, c);\n              } else {\n                n.name = e.slice(a, s);\n                n.base = e.slice(a, c);\n              }\n              n.ext = e.slice(s, c);\n            }\n            if (a > 0) {\n              n.dir = e.slice(0, a - 1);\n            } else {\n              if (i) {\n                n.dir = \"/\";\n              }\n            }\n            return n;\n          },\n          sep: \"/\",\n          delimiter: \":\",\n          win32: null,\n          posix: null,\n        };\n        r.posix = r;\n        e.exports = r;\n      },\n      447: (e, t, n) => {\n        var r;\n        n.r(t);\n        n.d(t, {\n          URI: () => f,\n          Utils: () => S,\n        });\n        if (\"object\" == typeof process) r = \"win32\" === process.platform;\n        else if (\"object\" == typeof navigator) {\n          var o = navigator.userAgent;\n          r = o.indexOf(\"Windows\") >= 0;\n        }\n        var i,\n          s,\n          a =\n            ((i = function (e, t) {\n              return (i =\n                Object.setPrototypeOf ||\n                ({\n                  __proto__: [],\n                } instanceof Array &&\n                  function (e, t) {\n                    e.__proto__ = t;\n                  }) ||\n                function (e, t) {\n                  for (var n in t)\n                    if (Object.prototype.hasOwnProperty.call(t, n)) {\n                      e[n] = t[n];\n                    }\n                })(e, t);\n            }),\n            function (e, t) {\n              function n() {\n                this.constructor = e;\n              }\n              i(e, t);\n              e.prototype =\n                null === t\n                  ? Object.create(t)\n                  : ((n.prototype = t.prototype), new n());\n            }),\n          c = /^\\w[\\w\\d+.-]*$/,\n          l = /^\\//,\n          u = /^\\/\\//,\n          d = \"\",\n          p = \"/\",\n          h = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/,\n          f = (function () {\n            function e(e, t, n, r, o, i) {\n              if (undefined === i) {\n                i = !1;\n              }\n              if (\"object\" == typeof e) {\n                this.scheme = e.scheme || d;\n                this.authority = e.authority || d;\n                this.path = e.path || d;\n                this.query = e.query || d;\n                this.fragment = e.fragment || d;\n              } else {\n                this.scheme = (function (e, t) {\n                  return e || t ? e : \"file\";\n                })(e, i);\n                this.authority = t || d;\n                this.path = (function (e, t) {\n                  switch (e) {\n                    case \"https\":\n                    case \"http\":\n                    case \"file\":\n                      if (t) {\n                        if (t[0] !== p) {\n                          t = p + t;\n                        }\n                      } else {\n                        t = p;\n                      }\n                  }\n                  return t;\n                })(this.scheme, n || d);\n                this.query = r || d;\n                this.fragment = o || d;\n                (function (e, t) {\n                  if (!e.scheme && t)\n                    throw new Error(\n                      '[UriError]: Scheme is missing: {scheme: \"\", authority: \"' +\n                        e.authority +\n                        '\", path: \"' +\n                        e.path +\n                        '\", query: \"' +\n                        e.query +\n                        '\", fragment: \"' +\n                        e.fragment +\n                        '\"}'\n                    );\n                  if (e.scheme && !c.test(e.scheme))\n                    throw new Error(\n                      \"[UriError]: Scheme contains illegal characters.\"\n                    );\n                  if (e.path)\n                    if (e.authority) {\n                      if (!l.test(e.path))\n                        throw new Error(\n                          '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character'\n                        );\n                    } else if (u.test(e.path))\n                      throw new Error(\n                        '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")'\n                      );\n                })(this, i);\n              }\n            }\n            e.isUri = function (t) {\n              return (\n                t instanceof e ||\n                (!!t &&\n                  \"string\" == typeof t.authority &&\n                  \"string\" == typeof t.fragment &&\n                  \"string\" == typeof t.path &&\n                  \"string\" == typeof t.query &&\n                  \"string\" == typeof t.scheme &&\n                  \"function\" == typeof t.fsPath &&\n                  \"function\" == typeof t.with &&\n                  \"function\" == typeof t.toString)\n              );\n            };\n            Object.defineProperty(e.prototype, \"fsPath\", {\n              get: function () {\n                return b(this, !1);\n              },\n              enumerable: !1,\n              configurable: !0,\n            });\n            e.prototype.with = function (e) {\n              if (!e) return this;\n              var t = e.scheme,\n                n = e.authority,\n                r = e.path,\n                o = e.query,\n                i = e.fragment;\n              if (undefined === t) {\n                t = this.scheme;\n              } else {\n                if (null === t) {\n                  t = d;\n                }\n              }\n              if (undefined === n) {\n                n = this.authority;\n              } else {\n                if (null === n) {\n                  n = d;\n                }\n              }\n              if (undefined === r) {\n                r = this.path;\n              } else {\n                if (null === r) {\n                  r = d;\n                }\n              }\n              if (undefined === o) {\n                o = this.query;\n              } else {\n                if (null === o) {\n                  o = d;\n                }\n              }\n              if (undefined === i) {\n                i = this.fragment;\n              } else {\n                if (null === i) {\n                  i = d;\n                }\n              }\n              return t === this.scheme &&\n                n === this.authority &&\n                r === this.path &&\n                o === this.query &&\n                i === this.fragment\n                ? this\n                : new g(t, n, r, o, i);\n            };\n            e.parse = function (e, t) {\n              if (undefined === t) {\n                t = !1;\n              }\n              var n = h.exec(e);\n              return n\n                ? new g(\n                    n[2] || d,\n                    C(n[4] || d),\n                    C(n[5] || d),\n                    C(n[7] || d),\n                    C(n[9] || d),\n                    t\n                  )\n                : new g(d, d, d, d, d);\n            };\n            e.file = function (e) {\n              var t = d;\n              if (r) {\n                e = e.replace(/\\\\/g, p);\n              }\n              if (e[0] === p && e[1] === p) {\n                var n = e.indexOf(p, 2);\n                -1 === n\n                  ? ((t = e.substring(2)), (e = p))\n                  : ((t = e.substring(2, n)), (e = e.substring(n) || p));\n              }\n              return new g(\"file\", t, e, d, d);\n            };\n            e.from = function (e) {\n              return new g(e.scheme, e.authority, e.path, e.query, e.fragment);\n            };\n            e.prototype.toString = function (e) {\n              if (undefined === e) {\n                e = !1;\n              }\n              return w(this, e);\n            };\n            e.prototype.toJSON = function () {\n              return this;\n            };\n            e.revive = function (t) {\n              if (t) {\n                if (t instanceof e) return t;\n                var n = new g(t);\n                n._formatted = t.external;\n                n._fsPath = t._sep === m ? t.fsPath : null;\n                return n;\n              }\n              return t;\n            };\n            return e;\n          })(),\n          m = r ? 1 : undefined,\n          g = (function (e) {\n            function t() {\n              var t = (null !== e && e.apply(this, arguments)) || this;\n              t._formatted = null;\n              t._fsPath = null;\n              return t;\n            }\n            a(t, e);\n            Object.defineProperty(t.prototype, \"fsPath\", {\n              get: function () {\n                if (this._fsPath) {\n                  this._fsPath = b(this, !1);\n                }\n                return this._fsPath;\n              },\n              enumerable: !1,\n              configurable: !0,\n            });\n            t.prototype.toString = function (e) {\n              if (undefined === e) {\n                e = !1;\n              }\n              return e\n                ? w(this, !0)\n                : (this._formatted || (this._formatted = w(this, !1)),\n                  this._formatted);\n            };\n            t.prototype.toJSON = function () {\n              var e = {\n                $mid: 1,\n              };\n              if (this._fsPath) {\n                e.fsPath = this._fsPath;\n                e._sep = m;\n              }\n              if (this._formatted) {\n                e.external = this._formatted;\n              }\n              if (this.path) {\n                e.path = this.path;\n              }\n              if (this.scheme) {\n                e.scheme = this.scheme;\n              }\n              if (this.authority) {\n                e.authority = this.authority;\n              }\n              if (this.query) {\n                e.query = this.query;\n              }\n              if (this.fragment) {\n                e.fragment = this.fragment;\n              }\n              return e;\n            };\n            return t;\n          })(f),\n          _ =\n            (((s = {})[58] = \"%3A\"),\n            (s[47] = \"%2F\"),\n            (s[63] = \"%3F\"),\n            (s[35] = \"%23\"),\n            (s[91] = \"%5B\"),\n            (s[93] = \"%5D\"),\n            (s[64] = \"%40\"),\n            (s[33] = \"%21\"),\n            (s[36] = \"%24\"),\n            (s[38] = \"%26\"),\n            (s[39] = \"%27\"),\n            (s[40] = \"%28\"),\n            (s[41] = \"%29\"),\n            (s[42] = \"%2A\"),\n            (s[43] = \"%2B\"),\n            (s[44] = \"%2C\"),\n            (s[59] = \"%3B\"),\n            (s[61] = \"%3D\"),\n            (s[32] = \"%20\"),\n            s);\n        function y(e, t) {\n          for (var n = undefined, r = -1, o = 0; o < e.length; o++) {\n            var i = e.charCodeAt(o);\n            if (\n              (i >= 97 && i <= 122) ||\n              (i >= 65 && i <= 90) ||\n              (i >= 48 && i <= 57) ||\n              45 === i ||\n              46 === i ||\n              95 === i ||\n              126 === i ||\n              (t && 47 === i)\n            ) {\n              if (-1 !== r) {\n                n += encodeURIComponent(e.substring(r, o));\n                r = -1;\n              }\n              if (undefined !== n) {\n                n += e.charAt(o);\n              }\n            } else {\n              if (undefined === n) {\n                n = e.substr(0, o);\n              }\n              var s = _[i];\n              if (undefined !== s) {\n                if (-1 !== r) {\n                  n += encodeURIComponent(e.substring(r, o));\n                  r = -1;\n                }\n                n += s;\n              } else {\n                if (-1 === r) {\n                  r = o;\n                }\n              }\n            }\n          }\n          if (-1 !== r) {\n            n += encodeURIComponent(e.substring(r));\n          }\n          return undefined !== n ? n : e;\n        }\n        function v(e) {\n          for (var t = undefined, n = 0; n < e.length; n++) {\n            var r = e.charCodeAt(n);\n            if (35 === r || 63 === r) {\n              if (undefined === t) {\n                t = e.substr(0, n);\n              }\n              t += _[r];\n            } else {\n              if (undefined !== t) {\n                t += e[n];\n              }\n            }\n          }\n          return undefined !== t ? t : e;\n        }\n        function b(e, t) {\n          var n;\n          n =\n            e.authority && e.path.length > 1 && \"file\" === e.scheme\n              ? \"//\" + e.authority + e.path\n              : 47 === e.path.charCodeAt(0) &&\n                ((e.path.charCodeAt(1) >= 65 && e.path.charCodeAt(1) <= 90) ||\n                  (e.path.charCodeAt(1) >= 97 &&\n                    e.path.charCodeAt(1) <= 122)) &&\n                58 === e.path.charCodeAt(2)\n              ? t\n                ? e.path.substr(1)\n                : e.path[1].toLowerCase() + e.path.substr(2)\n              : e.path;\n          if (r) {\n            n = n.replace(/\\//g, \"\\\\\");\n          }\n          return n;\n        }\n        function w(e, t) {\n          var n = t ? v : y,\n            r = \"\",\n            o = e.scheme,\n            i = e.authority,\n            s = e.path,\n            a = e.query,\n            c = e.fragment;\n          if (o) {\n            r += o;\n            r += \":\";\n          }\n          if (i || \"file\" === o) {\n            r += p;\n            r += p;\n          }\n          if (i) {\n            var l = i.indexOf(\"@\");\n            if (-1 !== l) {\n              var u = i.substr(0, l);\n              (i = i.substr(l + 1)),\n                -1 === (l = u.indexOf(\":\"))\n                  ? (r += n(u, !1))\n                  : ((r += n(u.substr(0, l), !1)),\n                    (r += \":\"),\n                    (r += n(u.substr(l + 1), !1))),\n                (r += \"@\");\n            }\n            -1 === (l = (i = i.toLowerCase()).indexOf(\":\"))\n              ? (r += n(i, !1))\n              : ((r += n(i.substr(0, l), !1)), (r += i.substr(l)));\n          }\n          if (s) {\n            if (\n              s.length >= 3 &&\n              47 === s.charCodeAt(0) &&\n              58 === s.charCodeAt(2)\n            ) {\n              if ((d = s.charCodeAt(1)) >= 65 && d <= 90) {\n                s = \"/\" + String.fromCharCode(d + 32) + \":\" + s.substr(3);\n              }\n            } else if (s.length >= 2 && 58 === s.charCodeAt(1)) {\n              var d;\n              if ((d = s.charCodeAt(0)) >= 65 && d <= 90) {\n                s = String.fromCharCode(d + 32) + \":\" + s.substr(2);\n              }\n            }\n            r += n(s, !0);\n          }\n          if (a) {\n            r += \"?\";\n            r += n(a, !1);\n          }\n          if (c) {\n            r += \"#\";\n            r += t ? c : y(c, !1);\n          }\n          return r;\n        }\n        function x(e) {\n          try {\n            return decodeURIComponent(e);\n          } catch (t) {\n            return e.length > 3 ? e.substr(0, 3) + x(e.substr(3)) : e;\n          }\n        }\n        var E = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n        function C(e) {\n          return e.match(E)\n            ? e.replace(E, function (e) {\n                return x(e);\n              })\n            : e;\n        }\n        var S,\n          T = n(470),\n          k = function () {\n            for (var e = 0, t = 0, n = arguments.length; t < n; t++)\n              e += arguments[t].length;\n            var r = Array(e),\n              o = 0;\n            for (t = 0; t < n; t++)\n              for (var i = arguments[t], s = 0, a = i.length; s < a; s++, o++)\n                r[o] = i[s];\n            return r;\n          },\n          I = T.posix || T;\n        !(function (e) {\n          e.joinPath = function (e) {\n            for (var t = [], n = 1; n < arguments.length; n++)\n              t[n - 1] = arguments[n];\n            return e.with({\n              path: I.join.apply(I, k([e.path], t)),\n            });\n          };\n          e.resolvePath = function (e) {\n            for (var t = [], n = 1; n < arguments.length; n++)\n              t[n - 1] = arguments[n];\n            var r = e.path || \"/\";\n            return e.with({\n              path: I.resolve.apply(I, k([r], t)),\n            });\n          };\n          e.dirname = function (e) {\n            var t = I.dirname(e.path);\n            return 1 === t.length && 46 === t.charCodeAt(0)\n              ? e\n              : e.with({\n                  path: t,\n                });\n          };\n          e.basename = function (e) {\n            return I.basename(e.path);\n          };\n          e.extname = function (e) {\n            return I.extname(e.path);\n          };\n        })(S || (S = {}));\n      },\n    },\n    t = {};\n  function n(r) {\n    if (t[r]) return t[r].exports;\n    var o = (t[r] = {\n      exports: {},\n    });\n    e[r](o, o.exports, n);\n    return o.exports;\n  }\n  n.d = (e, t) => {\n    for (var r in t)\n      if (n.o(t, r) && !n.o(e, r)) {\n        Object.defineProperty(e, r, {\n          enumerable: !0,\n          get: t[r],\n        });\n      }\n  };\n  n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t);\n  n.r = (e) => {\n    if (\"undefined\" != typeof Symbol && Symbol.toStringTag) {\n      Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\",\n      });\n    }\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0,\n    });\n  };\n  return n(447);\n})();\nconst { URI: o, Utils: i } = r;",
  "7396": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r = require(5282);\nexports.IsInitialized = !process.env.APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL;\nvar o = \"DiagnosticChannel\";\nif (exports.IsInitialized) {\n  var i = require(4106),\n    s = (process.env.APPLICATION_INSIGHTS_NO_PATCH_MODULES || \"\").split(\",\"),\n    a = {\n      bunyan: i.bunyan,\n      console: i.console,\n      mongodb: i.mongodb,\n      mongodbCore: i.mongodbCore,\n      mysql: i.mysql,\n      redis: i.redis,\n      pg: i.pg,\n      pgPool: i.pgPool,\n      winston: i.winston,\n    };\n  for (var c in a)\n    if (-1 === s.indexOf(c)) {\n      a[c].enable();\n      r.info(o, \"Subscribed to \" + c + \" events\");\n    }\n  if (s.length > 0) {\n    r.info(o, \"Some modules will not be patched\", s);\n  }\n} else\n  r.info(\n    o,\n    \"Not subscribing to dependency autocollection because APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL was set\"\n  );\nexports.registerContextPreservation = function (e) {\n  if (exports.IsInitialized) {\n    require(4953).channel.addContextPreservation(e);\n  }\n};",
  "7408": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.Priorities =\n  exports.PromptWishlist =\n  exports.PromptElementRanges =\n  exports.PromptChoices =\n  exports.PromptBackground =\n  exports.PromptElementKind =\n    undefined;\nconst r = require(1747),\n  o = require(9852);\nvar i;\n!(function (e) {\n  e.BeforeCursor = \"BeforeCursor\";\n  e.AfterCursor = \"AfterCursor\";\n  e.SimilarFile = \"SimilarFile\";\n  e.ImportedFile = \"ImportedFile\";\n  e.LanguageMarker = \"LanguageMarker\";\n  e.PathMarker = \"PathMarker\";\n})((i = exports.PromptElementKind || (exports.PromptElementKind = {})));\nclass PromptBackground {\n  constructor() {\n    this.used = new Map();\n    this.unused = new Map();\n  }\n  markUsed(e) {\n    if (this.IsNeighboringTab(e)) {\n      this.used.set(e.id, this.convert(e));\n    }\n  }\n  undoMarkUsed(e) {\n    if (this.IsNeighboringTab(e)) {\n      this.used.delete(e.id);\n    }\n  }\n  markUnused(e) {\n    if (this.IsNeighboringTab(e)) {\n      this.unused.set(e.id, this.convert(e));\n    }\n  }\n  convert(e) {\n    return {\n      score: e.score.toFixed(4),\n      length: e.text.length,\n    };\n  }\n  IsNeighboringTab(e) {\n    return e.kind == i.SimilarFile;\n  }\n}\nexports.PromptBackground = PromptBackground;\nclass PromptChoices {\n  constructor() {\n    this.used = new Map();\n    this.unused = new Map();\n  }\n  markUsed(e) {\n    this.used.set(e.kind, (this.used.get(e.kind) || 0) + e.tokens);\n  }\n  undoMarkUsed(e) {\n    this.used.set(e.kind, (this.used.get(e.kind) || 0) - e.tokens);\n  }\n  markUnused(e) {\n    this.unused.set(e.kind, (this.used.get(e.kind) || 0) + e.tokens);\n  }\n}\nexports.PromptChoices = PromptChoices;\nclass PromptElementRanges {\n  constructor(e) {\n    this.ranges = new Array();\n    let t,\n      n = 0;\n    for (const { element: r } of e)\n      if (0 !== r.text.length) {\n        if (t === i.BeforeCursor && r.kind === i.BeforeCursor) {\n          this.ranges[this.ranges.length - 1].end += r.text.length;\n        } else {\n          this.ranges.push({\n            kind: r.kind,\n            start: n,\n            end: n + r.text.length,\n          });\n        }\n        t = r.kind;\n        n += r.text.length;\n      }\n  }\n}\nexports.PromptElementRanges = PromptElementRanges;\nexports.PromptWishlist = class {\n  constructor(e) {\n    this.content = [];\n    this.lineEndingOption = e;\n  }\n  getContent() {\n    return [...this.content];\n  }\n  convertLineEndings(e) {\n    if (this.lineEndingOption === r.LineEndingOptions.ConvertToUnix) {\n      e = e.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n    }\n    return e;\n  }\n  append(e, t, n, r = o.tokenLength(e), i = NaN) {\n    e = this.convertLineEndings(e);\n    const s = this.content.length;\n    this.content.push({\n      id: s,\n      text: e,\n      kind: t,\n      priority: n,\n      tokens: r,\n      requires: [],\n      excludes: [],\n      score: i,\n    });\n    return s;\n  }\n  appendLineForLine(e, t, n) {\n    const r = (e = this.convertLineEndings(e)).split(\"\\n\");\n    for (let e = 0; e < r.length - 1; e++) r[e] += \"\\n\";\n    const o = [];\n    r.forEach((e, t) => {\n      if (\"\\n\" === e && o.length > 0 && !o[o.length - 1].endsWith(\"\\n\\n\")) {\n        o[o.length - 1] += \"\\n\";\n      } else {\n        o.push(e);\n      }\n    });\n    const i = [];\n    o.forEach((e, r) => {\n      if (\"\" !== e) {\n        i.push(this.append(e, t, n));\n        if (r > 0) {\n          this.content[this.content.length - 2].requires = [\n            this.content[this.content.length - 1],\n          ];\n        }\n      }\n    });\n    return i;\n  }\n  require(e, t) {\n    const n = this.content.find((t) => t.id === e),\n      r = this.content.find((e) => e.id === t);\n    if (n && r) {\n      n.requires.push(r);\n    }\n  }\n  exclude(e, t) {\n    const n = this.content.find((t) => t.id === e),\n      r = this.content.find((e) => e.id === t);\n    if (n && r) {\n      n.excludes.push(r);\n    }\n  }\n  fulfill(e) {\n    const t = new PromptChoices(),\n      n = new PromptBackground(),\n      r = this.content.map((e, t) => ({\n        element: e,\n        index: t,\n      }));\n    r.sort((e, t) =>\n      e.element.priority === t.element.priority\n        ? t.index - e.index\n        : t.element.priority - e.element.priority\n    );\n    const i = new Set(),\n      l = new Set();\n    let u;\n    const d = [];\n    let p = e;\n    r.forEach((e) => {\n      var r;\n      const o = e.element,\n        s = e.index;\n      if (\n        p >= 0 &&\n        (p > 0 || undefined === u) &&\n        o.requires.every((e) => i.has(e.id)) &&\n        !l.has(o.id)\n      ) {\n        let a = o.tokens;\n        const c =\n          null ===\n            (r = (function (e, t) {\n              let n,\n                r = 1 / 0;\n              for (const o of e)\n                if (o.index > t && o.index < r) {\n                  n = o;\n                  r = o.index;\n                }\n              return n;\n            })(d, s)) || undefined === r\n            ? undefined\n            : r.element;\n        if (o.text.endsWith(\"\\n\\n\") && c && !c.text.match(/^\\s/)) {\n          a++;\n        }\n        if (p >= a) {\n          p -= a;\n          i.add(o.id);\n          o.excludes.forEach((e) => l.add(e.id));\n          t.markUsed(o);\n          n.markUsed(o);\n          d.push(e);\n        } else {\n          u = null != u ? u : e;\n        }\n      } else {\n        t.markUnused(o);\n        n.markUnused(o);\n      }\n    });\n    d.sort((e, t) => e.index - t.index);\n    let h = d.reduce((e, t) => e + t.element.text, \"\"),\n      f = o.tokenLength(h);\n    for (; f > e; ) {\n      d.sort((e, t) =>\n        t.element.priority === e.element.priority\n          ? t.index - e.index\n          : t.element.priority - e.element.priority\n      );\n      const e = d.pop();\n      if (e) {\n        t.undoMarkUsed(e.element);\n        t.markUnused(e.element);\n        n.undoMarkUsed(e.element);\n        n.markUnused(e.element);\n        u = undefined;\n      }\n      d.sort((e, t) => e.index - t.index);\n      h = d.reduce((e, t) => e + t.element.text, \"\");\n      f = o.tokenLength(h);\n    }\n    const m = [...d];\n    if (undefined !== u) {\n      m.push(u);\n      m.sort((e, t) => e.index - t.index);\n      const r = m.reduce((e, t) => e + t.element.text, \"\"),\n        i = o.tokenLength(r);\n      if (i <= e) {\n        t.markUsed(u.element);\n        n.markUsed(u.element);\n        const e = new PromptElementRanges(m);\n        return {\n          prefix: r,\n          suffix: \"\",\n          prefixLength: i,\n          suffixLength: 0,\n          promptChoices: t,\n          promptBackground: n,\n          promptElementRanges: e,\n        };\n      }\n      t.markUnused(u.element);\n      n.markUnused(u.element);\n    }\n    const g = new PromptElementRanges(d);\n    return {\n      prefix: h,\n      suffix: \"\",\n      prefixLength: f,\n      suffixLength: 0,\n      promptChoices: t,\n      promptBackground: n,\n      promptElementRanges: g,\n    };\n  }\n};\nclass Priorities {\n  constructor() {\n    this.registeredPriorities = [0, 1];\n  }\n  register(e) {\n    if (e > Priorities.TOP || e < Priorities.BOTTOM)\n      throw new Error(\"Priority must be between 0 and 1\");\n    this.registeredPriorities.push(e);\n    return e;\n  }\n  justAbove(...e) {\n    const t = Math.max(...e),\n      n = Math.min(...this.registeredPriorities.filter((e) => e > t));\n    return this.register((n + t) / 2);\n  }\n  justBelow(...e) {\n    const t = Math.min(...e),\n      n = Math.max(...this.registeredPriorities.filter((e) => e < t));\n    return this.register((n + t) / 2);\n  }\n  between(e, t) {\n    if (\n      this.registeredPriorities.some((n) => n > e && n < t) ||\n      !this.registeredPriorities.includes(e) ||\n      !this.registeredPriorities.includes(t)\n    )\n      throw new Error(\"Priorities must be adjacent in the list of priorities\");\n    return this.register((e + t) / 2);\n  }\n}\nexports.Priorities = Priorities;\nPriorities.TOP = 1;\nPriorities.BOTTOM = 0;",
  "7424": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r = require(\"path\"),\n  o = require(4014),\n  i = require(\"module\"),\n  s = Object.keys(process.binding(\"natives\")),\n  a = i.prototype.require;\nexports.makePatchingRequire = function (e) {\n  var t = {};\n  return function (n) {\n    var c = a.apply(this, arguments);\n    if (e[n]) {\n      var l = i._resolveFilename(n, this);\n      if (t.hasOwnProperty(l)) return t[l];\n      var u = undefined;\n      if (s.indexOf(n) < 0)\n        try {\n          u = a.call(this, r.join(n, \"package.json\")).version;\n        } catch (e) {\n          return c;\n        }\n      else u = process.version.substring(1);\n      var d = u.indexOf(\"-\");\n      if (d >= 0) {\n        u = u.substring(0, d);\n      }\n      for (var p = c, h = 0, f = e[n]; h < f.length; h++) {\n        var m = f[h];\n        if (o.satisfies(u, m.versionSpecifier)) {\n          p = m.patch(p, l);\n        }\n      }\n      return (t[l] = p);\n    }\n    return c;\n  };\n};",
  "7426": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nclass n extends Error {\n  constructor(e) {\n    super(\"validation failed\");\n    this.errors = e;\n    this.ajv = this.validation = !0;\n  }\n}\nexports.default = n;",
  "7460": "var r, o, i, s, a, c, l, u;\nu = require(8249);\nrequire(4938);\nrequire(34);\no = (r = u).x64;\ni = o.Word;\ns = o.WordArray;\na = r.algo;\nc = a.SHA512;\nl = a.SHA384 = c.extend({\n  _doReset: function () {\n    this._hash = new s.init([\n      new i.init(3418070365, 3238371032),\n      new i.init(1654270250, 914150663),\n      new i.init(2438529370, 812702999),\n      new i.init(355462360, 4144912697),\n      new i.init(1731405415, 4290775857),\n      new i.init(2394180231, 1750603025),\n      new i.init(3675008525, 1694076839),\n      new i.init(1203062813, 3204075428),\n    ]);\n  },\n  _doFinalize: function () {\n    var e = c._doFinalize.call(this);\n    e.sigBytes -= 16;\n    return e;\n  },\n});\nr.SHA384 = c._createHelper(l);\nr.HmacSHA384 = c._createHmacHelper(l);\nmodule.exports = u.SHA384;",
  "7481": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.ghostTextDisplayQuantiles =\n  exports.ghostTextDisplayLanguageParameters =\n  exports.ghostTextDisplayMeanAlternativeLogProbParameter =\n  exports.ghostTextDisplayMeanLogProbParameter =\n  exports.ghostTextDisplayLog1pcompCharLenParameter =\n  exports.ghostTextDisplayInterceptParameter =\n    undefined;\nexports.ghostTextDisplayInterceptParameter = 2.98410452738298;\nexports.ghostTextDisplayLog1pcompCharLenParameter = -0.838732736843507;\nexports.ghostTextDisplayMeanLogProbParameter = 1.50314646255716;\nexports.ghostTextDisplayMeanAlternativeLogProbParameter = -0.237798634012662;\nexports.ghostTextDisplayLanguageParameters = {\n  python: 0.314368072478742,\n};\nexports.ghostTextDisplayQuantiles = {\n  0.01: 0.225800751784931,\n  0.02: 0.290204307767402,\n  0.03: 0.333153496466045,\n  0.05: 0.404516749849559,\n  0.1: 0.513216040545626,\n  0.2: 0.626904979128674,\n  0.3: 0.694880719658273,\n  0.4: 0.743100684947291,\n  0.5: 0.782524520571946,\n  0.6: 0.816856186092243,\n  0.7: 0.84922977716585,\n  0.8: 0.883694877241999,\n  0.9: 0.921859050950077,\n  0.95: 0.944571268106974,\n  0.99: 0.969535563141733,\n};",
  "7625": "var r = require(\"url\"),\n  o = require(9253),\n  i = require(4470),\n  s = require(5290),\n  a = require(3504),\n  c = require(9428),\n  l = require(894),\n  u = require(2588),\n  d = require(5740),\n  p = require(5282),\n  h = require(9813),\n  f = (function () {\n    function e(e) {\n      this._telemetryProcessors = [];\n      var t = new o(e);\n      this.config = t;\n      this.context = new i();\n      this.commonProperties = {};\n      var n = new u(this.config);\n      this.channel = new a(\n        function () {\n          return t.disableAppInsights;\n        },\n        function () {\n          return t.maxBatchSize;\n        },\n        function () {\n          return t.maxBatchIntervalMs;\n        },\n        n\n      );\n    }\n    e.prototype.trackAvailability = function (e) {\n      this.track(e, s.TelemetryType.Availability);\n    };\n    e.prototype.trackTrace = function (e) {\n      this.track(e, s.TelemetryType.Trace);\n    };\n    e.prototype.trackMetric = function (e) {\n      this.track(e, s.TelemetryType.Metric);\n    };\n    e.prototype.trackException = function (e) {\n      if (e && e.exception && !d.isError(e.exception)) {\n        e.exception = new Error(e.exception.toString());\n      }\n      this.track(e, s.TelemetryType.Exception);\n    };\n    e.prototype.trackEvent = function (e) {\n      this.track(e, s.TelemetryType.Event);\n    };\n    e.prototype.trackRequest = function (e) {\n      this.track(e, s.TelemetryType.Request);\n    };\n    e.prototype.trackDependency = function (e) {\n      if (e && !e.target && e.data) {\n        e.target = r.parse(e.data).host;\n      }\n      this.track(e, s.TelemetryType.Dependency);\n    };\n    e.prototype.flush = function (e) {\n      this.channel.triggerSend(\n        !!e && !!e.isAppCrashing,\n        e ? e.callback : undefined\n      );\n    };\n    e.prototype.track = function (e, t) {\n      if (e && s.telemetryTypeToBaseType(t)) {\n        var n = h.createEnvelope(\n          e,\n          t,\n          this.commonProperties,\n          this.context,\n          this.config\n        );\n        if (e.time) {\n          n.time = e.time.toISOString();\n        }\n        var r = this.runTelemetryProcessors(n, e.contextObjects);\n        r =\n          r &&\n          c.samplingTelemetryProcessor(n, {\n            correlationContext: l.CorrelationContextManager.getCurrentContext(),\n          });\n        c.performanceMetricsTelemetryProcessor(n, this.quickPulseClient);\n        if (r) {\n          this.channel.send(n);\n        }\n      } else\n        p.warn(\n          \"track() requires telemetry object and telemetryType to be specified.\"\n        );\n    };\n    e.prototype.addTelemetryProcessor = function (e) {\n      this._telemetryProcessors.push(e);\n    };\n    e.prototype.clearTelemetryProcessors = function () {\n      this._telemetryProcessors = [];\n    };\n    e.prototype.runTelemetryProcessors = function (e, t) {\n      var n = !0,\n        r = this._telemetryProcessors.length;\n      if (0 === r) return n;\n      (t = t || {}).correlationContext =\n        l.CorrelationContextManager.getCurrentContext();\n      for (var o = 0; o < r; ++o)\n        try {\n          var i = this._telemetryProcessors[o];\n          if (i && !1 === i.apply(null, [e, t])) {\n            n = !1;\n            break;\n          }\n        } catch (t) {\n          n = !0;\n          p.warn(\n            \"One of telemetry processors failed, telemetry item will be sent.\",\n            t,\n            e\n          );\n        }\n      return n;\n    };\n    return e;\n  })();\nmodule.exports = f;",
  "7645": "if (process.addAsyncListener)\n  throw new Error(\"Don't require polyfill unless needed\");\nvar r = require(6372),\n  o = require(2249),\n  i = r.wrap,\n  s = r.massWrap,\n  a = require(9090),\n  c = require(\"util\"),\n  l = o.gte(process.version, \"6.0.0\"),\n  u = o.gte(process.version, \"7.0.0\"),\n  d = o.gte(process.version, \"8.0.0\"),\n  p = o.gte(process.version, \"11.0.0\"),\n  h = require(\"net\");\nfunction f(e) {\n  return function () {\n    this.on(\"connection\", function (e) {\n      if (e._handle) {\n        e._handle.onread = a(e._handle.onread);\n      }\n    });\n    try {\n      return e.apply(this, arguments);\n    } finally {\n      if (this._handle && this._handle.onconnection) {\n        this._handle.onconnection = a(this._handle.onconnection);\n      }\n    }\n  };\n}\nfunction m(e) {\n  if (e && e._handle) {\n    var t = e._handle;\n    if (t._originalOnread) {\n      t._originalOnread = t.onread;\n    }\n    t.onread = a(t._originalOnread);\n  }\n}\nif (u && !h._normalizeArgs) {\n  h._normalizeArgs = function (e) {\n    if (0 === e.length) return [{}, null];\n    var t,\n      n,\n      r = e[0],\n      o = {};\n    if (\"object\" == typeof r && null !== r) {\n      o = r;\n    } else {\n      if (\n        \"string\" == typeof (t = r) &&\n        !1 === ((n = t), (n = Number(n)) >= 0 && n)\n      ) {\n        o.path = r;\n      } else {\n        o.port = r;\n        if (e.length > 1 && \"string\" == typeof e[1]) {\n          o.host = e[1];\n        }\n      }\n    }\n    var i = e[e.length - 1];\n    return \"function\" != typeof i ? [o, null] : [o, i];\n  };\n} else {\n  if (u || h._normalizeConnectArgs) {\n    h._normalizeConnectArgs = function (e) {\n      var t,\n        n = {};\n      if (\"object\" == typeof e[0] && null !== e[0]) {\n        n = e[0];\n      } else {\n        if (\n          \"string\" == typeof e[0] &&\n          !1 === ((t = e[0]), (t = Number(t)) >= 0 && t)\n        ) {\n          n.path = e[0];\n        } else {\n          n.port = e[0];\n          if (\"string\" == typeof e[1]) {\n            n.host = e[1];\n          }\n        }\n      }\n      var r = e[e.length - 1];\n      return \"function\" == typeof r ? [n, r] : [n];\n    };\n  }\n}\nif (\"_setUpListenHandle\" in h.Server.prototype) {\n  i(h.Server.prototype, \"_setUpListenHandle\", f);\n} else {\n  i(h.Server.prototype, \"_listen2\", f);\n}\ni(h.Socket.prototype, \"connect\", function (e) {\n  return function () {\n    var t;\n    if (\n      (t =\n        d &&\n        Array.isArray(arguments[0]) &&\n        Object.getOwnPropertySymbols(arguments[0]).length > 0\n          ? arguments[0]\n          : u\n          ? h._normalizeArgs(arguments)\n          : h._normalizeConnectArgs(arguments))[1]\n    ) {\n      t[1] = a(t[1]);\n    }\n    var n = e.apply(this, t);\n    m(this);\n    return n;\n  };\n});\nvar g = require(\"http\");\ni(g.Agent.prototype, \"addRequest\", function (e) {\n  return function (t) {\n    var n = t.onSocket;\n    t.onSocket = a(function (e) {\n      m(e);\n      return n.apply(this, arguments);\n    });\n    return e.apply(this, arguments);\n  };\n});\nvar _ = require(\"child_process\");\nfunction y(e) {\n  if (Array.isArray(e.stdio)) {\n    e.stdio.forEach(function (e) {\n      if (e && e._handle) {\n        e._handle.onread = a(e._handle.onread);\n        i(e._handle, \"close\", N);\n      }\n    });\n  }\n  if (e._handle) {\n    e._handle.onexit = a(e._handle.onexit);\n  }\n}\nif (_.ChildProcess) {\n  i(_.ChildProcess.prototype, \"spawn\", function (e) {\n    return function () {\n      var t = e.apply(this, arguments);\n      y(this);\n      return t;\n    };\n  });\n} else {\n  s(_, [\"execFile\", \"fork\", \"spawn\"], function (e) {\n    return function () {\n      var t = e.apply(this, arguments);\n      y(t);\n      return t;\n    };\n  });\n}\nif (process._fatalException) {\n  process._originalNextTick = process.nextTick;\n}\nvar v = [];\nif (process._nextDomainTick) {\n  v.push(\"_nextDomainTick\");\n}\nif (process._tickDomainCallback) {\n  v.push(\"_tickDomainCallback\");\n}\ns(process, v, O);\ni(process, \"nextTick\", N);\nvar b = [\"setTimeout\", \"setInterval\"];\nif (global.setImmediate) {\n  b.push(\"setImmediate\");\n}\nvar w = require(\"timers\"),\n  x = global.setTimeout === w.setTimeout;\ns(w, b, N);\nif (x) {\n  s(global, b, N);\n}\nvar E = require(\"dns\");\ns(\n  E,\n  [\n    \"lookup\",\n    \"resolve\",\n    \"resolve4\",\n    \"resolve6\",\n    \"resolveCname\",\n    \"resolveMx\",\n    \"resolveNs\",\n    \"resolveTxt\",\n    \"resolveSrv\",\n    \"reverse\",\n  ],\n  O\n);\nif (E.resolveNaptr) {\n  i(E, \"resolveNaptr\", O);\n}\nvar C,\n  S,\n  T = require(\"fs\");\ns(\n  T,\n  [\n    \"watch\",\n    \"rename\",\n    \"truncate\",\n    \"chown\",\n    \"fchown\",\n    \"chmod\",\n    \"fchmod\",\n    \"stat\",\n    \"lstat\",\n    \"fstat\",\n    \"link\",\n    \"symlink\",\n    \"readlink\",\n    \"realpath\",\n    \"unlink\",\n    \"rmdir\",\n    \"mkdir\",\n    \"readdir\",\n    \"close\",\n    \"open\",\n    \"utimes\",\n    \"futimes\",\n    \"fsync\",\n    \"write\",\n    \"read\",\n    \"readFile\",\n    \"writeFile\",\n    \"appendFile\",\n    \"watchFile\",\n    \"unwatchFile\",\n    \"exists\",\n  ],\n  O\n);\nif (T.lchown) {\n  i(T, \"lchown\", O);\n}\nif (T.lchmod) {\n  i(T, \"lchmod\", O);\n}\nif (T.ftruncate) {\n  i(T, \"ftruncate\", O);\n}\ntry {\n  C = require(\"zlib\");\n} catch (e) {}\nif (C && C.Deflate && C.Deflate.prototype) {\n  var k = Object.getPrototypeOf(C.Deflate.prototype);\n  if (k._transform) {\n    i(k, \"_transform\", O);\n  } else {\n    if (k.write && k.flush && k.end) {\n      s(k, [\"write\", \"flush\", \"end\"], O);\n    }\n  }\n}\ntry {\n  S = require(\"crypto\");\n} catch (e) {}\nif (S) {\n  var I = [\"pbkdf2\", \"randomBytes\"];\n  if (p) {\n    I.push(\"pseudoRandomBytes\");\n  }\n  s(S, I, O);\n}\nvar P =\n  !!global.Promise &&\n  \"function Promise() { [native code] }\" === Promise.toString() &&\n  \"function toString() { [native code] }\" === Promise.toString.toString();\nif (P) {\n  var A = process.addAsyncListener({\n    create: function () {\n      P = !1;\n    },\n  });\n  global.Promise.resolve(!0).then(function () {\n    P = !1;\n  });\n  process.removeAsyncListener(A);\n}\nfunction O(e) {\n  var t = function () {\n    var t,\n      n = arguments.length - 1;\n    if (\"function\" == typeof arguments[n]) {\n      t = Array(arguments.length);\n      for (var r = 0; r < arguments.length - 1; r++) t[r] = arguments[r];\n      t[n] = a(arguments[n]);\n    }\n    return e.apply(this, t || arguments);\n  };\n  switch (e.length) {\n    case 1:\n      return function (n) {\n        return 1 !== arguments.length\n          ? t.apply(this, arguments)\n          : (\"function\" == typeof n && (n = a(n)), e.call(this, n));\n      };\n    case 2:\n      return function (n, r) {\n        return 2 !== arguments.length\n          ? t.apply(this, arguments)\n          : (\"function\" == typeof r && (r = a(r)), e.call(this, n, r));\n      };\n    case 3:\n      return function (n, r, o) {\n        return 3 !== arguments.length\n          ? t.apply(this, arguments)\n          : (\"function\" == typeof o && (o = a(o)), e.call(this, n, r, o));\n      };\n    case 4:\n      return function (n, r, o, i) {\n        return 4 !== arguments.length\n          ? t.apply(this, arguments)\n          : (\"function\" == typeof i && (i = a(i)), e.call(this, n, r, o, i));\n      };\n    case 5:\n      return function (n, r, o, i, s) {\n        return 5 !== arguments.length\n          ? t.apply(this, arguments)\n          : (\"function\" == typeof s && (s = a(s)), e.call(this, n, r, o, i, s));\n      };\n    case 6:\n      return function (n, r, o, i, s, c) {\n        return 6 !== arguments.length\n          ? t.apply(this, arguments)\n          : (\"function\" == typeof c && (c = a(c)),\n            e.call(this, n, r, o, i, s, c));\n      };\n    default:\n      return t;\n  }\n}\nfunction N(e) {\n  var t = function () {\n    var t;\n    if (\"function\" == typeof arguments[0]) {\n      (t = Array(arguments.length))[0] = a(arguments[0]);\n      for (var n = 1; n < arguments.length; n++) t[n] = arguments[n];\n    }\n    return e.apply(this, t || arguments);\n  };\n  switch (e.length) {\n    case 1:\n      return function (n) {\n        return 1 !== arguments.length\n          ? t.apply(this, arguments)\n          : (\"function\" == typeof n && (n = a(n)), e.call(this, n));\n      };\n    case 2:\n      return function (n, r) {\n        return 2 !== arguments.length\n          ? t.apply(this, arguments)\n          : (\"function\" == typeof n && (n = a(n)), e.call(this, n, r));\n      };\n    case 3:\n      return function (n, r, o) {\n        return 3 !== arguments.length\n          ? t.apply(this, arguments)\n          : (\"function\" == typeof n && (n = a(n)), e.call(this, n, r, o));\n      };\n    case 4:\n      return function (n, r, o, i) {\n        return 4 !== arguments.length\n          ? t.apply(this, arguments)\n          : (\"function\" == typeof n && (n = a(n)), e.call(this, n, r, o, i));\n      };\n    case 5:\n      return function (n, r, o, i, s) {\n        return 5 !== arguments.length\n          ? t.apply(this, arguments)\n          : (\"function\" == typeof n && (n = a(n)), e.call(this, n, r, o, i, s));\n      };\n    case 6:\n      return function (n, r, o, i, s, c) {\n        return 6 !== arguments.length\n          ? t.apply(this, arguments)\n          : (\"function\" == typeof n && (n = a(n)),\n            e.call(this, n, r, o, i, s, c));\n      };\n    default:\n      return t;\n  }\n}\nif (P) {\n  (function () {\n    var e = global.Promise;\n    function t(n) {\n      if (!(this instanceof t)) return e(n);\n      if (\"function\" != typeof n) return new e(n);\n      var o,\n        i,\n        s = new e(function (e, t) {\n          o = this;\n          i = [\n            function (t) {\n              r(s, !1);\n              return e(t);\n            },\n            function (e) {\n              r(s, !1);\n              return t(e);\n            },\n          ];\n        });\n      s.__proto__ = t.prototype;\n      try {\n        n.apply(o, i);\n      } catch (e) {\n        i[1](e);\n      }\n      return s;\n    }\n    function r(e, t) {\n      if (e.__asl_wrapper && !t) {\n        e.__asl_wrapper = a(o);\n      }\n    }\n    function o(t, n, i, s) {\n      var a;\n      try {\n        return {\n          returnVal: (a = n.call(t, i)),\n          error: !1,\n        };\n      } catch (e) {\n        return {\n          errorVal: e,\n          error: !0,\n        };\n      } finally {\n        if (a instanceof e) {\n          s.__asl_wrapper = function () {\n            return (a.__asl_wrapper || o).apply(this, arguments);\n          };\n        } else {\n          r(s, !0);\n        }\n      }\n    }\n    function s(e) {\n      return function () {\n        var t = this,\n          n = e.apply(t, Array.prototype.map.call(arguments, r));\n        n.__asl_wrapper = function (e, r, i, s) {\n          return t.__asl_wrapper\n            ? (t.__asl_wrapper(e, function () {}, null, n),\n              n.__asl_wrapper(e, r, i, s))\n            : o(e, r, i, s);\n        };\n        return n;\n        function r(e) {\n          return \"function\" != typeof e\n            ? e\n            : a(function (r) {\n                var i = (t.__asl_wrapper || o)(this, e, r, n);\n                if (i.error) throw i.errorVal;\n                return i.returnVal;\n              });\n        }\n      };\n    }\n    c.inherits(t, e);\n    i(e.prototype, \"then\", s);\n    if (e.prototype.chain) {\n      i(e.prototype, \"chain\", s);\n    }\n    if (l) {\n      global.Promise = require(8286)(e, r);\n    } else {\n      [\"all\", \"race\", \"reject\", \"resolve\", \"accept\", \"defer\"].forEach(function (\n        n\n      ) {\n        if (\"function\" == typeof e[n]) {\n          t[n] = e[n];\n        }\n      });\n      global.Promise = t;\n    }\n  })();\n}",
  "7660": "var r, o, i;\ni = require(8249);\nrequire(5109);\no = (r = i.lib.BlockCipherMode.extend()).Encryptor = r.extend({\n  processBlock: function (e, t) {\n    var n = this._cipher,\n      r = n.blockSize,\n      o = this._iv,\n      i = this._keystream;\n    if (o) {\n      i = this._keystream = o.slice(0);\n      this._iv = undefined;\n    }\n    n.encryptBlock(i, 0);\n    for (var s = 0; s < r; s++) e[t + s] ^= i[s];\n  },\n});\nr.Decryptor = o;\ni.mode.OFB = r;\nmodule.exports = i.mode.OFB;",
  "7727": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.indentationBlockFinished =\n  exports.completionCutOrContinue =\n  exports.contextIndentationFromText =\n  exports.contextIndentation =\n  exports.getNodeStart =\n  exports.isBlockBodyFinishedWithPrefix =\n  exports.isBlockBodyFinished =\n  exports.isEmptyBlockStart =\n    undefined;\nconst r = require(6403),\n  o = require(2533);\nexports.isEmptyBlockStart = function (e, t) {\n  return o.isEmptyBlockStart(e.languageId, e.getText(), e.offsetAt(t));\n};\nexports.isBlockBodyFinished = function (e, t, n, i) {\n  const s = e.get(r.LocationFactory),\n    a = t.getText(s.range(s.position(0, 0), n)),\n    c = t.offsetAt(n);\n  return o.isBlockBodyFinished(t.languageId, a, i, c);\n};\nexports.isBlockBodyFinishedWithPrefix = function (e, t, n, i, s) {\n  const a = e.get(r.LocationFactory),\n    c = t.getText(a.range(a.position(0, 0), n)),\n    l = t.offsetAt(n);\n  return o.isBlockBodyFinished(t.languageId, c + s, i, l + s.length);\n};\nexports.getNodeStart = async function (e, t, n, i) {\n  const s = e.get(r.LocationFactory),\n    a = t.getText(s.range(s.position(0, 0), n)) + i,\n    c = await o.getNodeStart(t.languageId, a, t.offsetAt(n));\n  if (c) return t.positionAt(c);\n};\nconst i = [\"\\\\{\", \"\\\\}\", \"\\\\[\", \"\\\\]\", \"\\\\(\", \"\\\\)\"].concat(\n    [\n      \"then\",\n      \"else\",\n      \"elseif\",\n      \"elif\",\n      \"catch\",\n      \"finally\",\n      \"fi\",\n      \"done\",\n      \"end\",\n      \"loop\",\n      \"until\",\n      \"where\",\n      \"when\",\n    ].map((e) => e + \"\\\\b\")\n  ),\n  s = new RegExp(`^(${i.join(\"|\")})`);\nfunction a(e) {\n  return s.test(e.trimLeft().toLowerCase());\n}\nfunction c(e) {\n  const t = /^(\\s*)([^]*)$/.exec(e);\n  return t && t[2] && t[2].length > 0 ? t[1].length : undefined;\n}\nfunction contextIndentationFromText(e, t, n) {\n  const r = e.slice(0, t).split(\"\\n\"),\n    o = e.slice(t).split(\"\\n\");\n  function i(e, t, r) {\n    let o,\n      i,\n      s = t;\n    for (; undefined === o && s >= 0 && s < e.length; ) {\n      o = c(e[s]);\n      i = s;\n      s += r;\n    }\n    if (\"python\" === n && -1 === r) {\n      s++;\n      const t = e[s].trim();\n      if (t.endsWith('\"\"\"')) {\n        if (!t.startsWith('\"\"\"') || '\"\"\"' === t)\n          for (s--; s >= 0 && !e[s].trim().startsWith('\"\"\"'); ) s--;\n        if (s >= 0)\n          for (o = undefined, s--; undefined === o && s >= 0; ) {\n            o = c(e[s]);\n            i = s;\n            s--;\n          }\n      }\n    }\n    return [o, i];\n  }\n  const [s, a] = i(r, r.length - 1, -1),\n    l = (() => {\n      if (undefined !== s && undefined !== a)\n        for (let e = a - 1; e >= 0; e--) {\n          const t = c(r[e]);\n          if (undefined !== t && t < s) return t;\n        }\n    })(),\n    [u] = i(o, 1, 1);\n  return {\n    prev: l,\n    current: null != s ? s : 0,\n    next: u,\n  };\n}\nfunction completionCutOrContinue(e, t, n) {\n  var r;\n  const o = e.split(\"\\n\"),\n    i = undefined !== n,\n    s = null == n ? undefined : n.split(\"\\n\").pop();\n  let l = 0;\n  if (i && \"\" != (null == s ? undefined : s.trim()) && \"\" !== o[0].trim()) {\n    l++;\n  }\n  if (i) {\n    l++;\n  }\n  if (o.length === l) return \"continue\";\n  const u = Math.max(\n    t.current,\n    null !== (r = t.next) && undefined !== r ? r : 0\n  );\n  for (let e = l; e < o.length; e++) {\n    let t = o[e];\n    if (0 == e && undefined !== s) {\n      t = s + t;\n    }\n    const n = c(t);\n    if (undefined !== n && (n < u || (n === u && !a(t))))\n      return o.slice(0, e).join(\"\\n\").length;\n  }\n  return \"continue\";\n}\nexports.contextIndentation = function (e, t) {\n  return contextIndentationFromText(e.getText(), e.offsetAt(t), e.languageId);\n};\nexports.contextIndentationFromText = contextIndentationFromText;\nexports.completionCutOrContinue = completionCutOrContinue;\nexports.indentationBlockFinished = function (e, t) {\n  return async (n) => {\n    const r = completionCutOrContinue(n, e, t);\n    return \"continue\" === r ? undefined : r;\n  };\n};",
  "7744": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.contextualFilterCharacterMap =\n  exports.contextualFilterLanguageMap =\n  exports.contextualFilterWeights =\n  exports.contextualFilterIntercept =\n  exports.contextualFilterAcceptThreshold =\n    undefined;\nexports.contextualFilterAcceptThreshold = 15;\nexports.contextualFilterIntercept = -0.3043572714994554;\nexports.contextualFilterWeights = [\n  0.9978708359643611, 0.7001905605239328, -0.1736749244124868,\n  -0.22994157947320112, 0.13406692641682572, -0.007751370662011853,\n  0.0057783222035240715, 0.41910878254476003, -0.1621657125711092,\n  0.13770814958908187, -0.06036011308184006, -0.07351180985800129, 0,\n  -0.05584878151248109, 0.30618794079412015, -0.1282197982598485,\n  0.10951859303997555, 0.1700461782788777, -0.3346057842644757,\n  0.22497985923128136, 0, -0.44038101825774356, -0.6540115939236782,\n  0.16595600081341702, 0.20733910722385135, -0.1337033766105696,\n  -0.06923072125290894, -0.05806684191976292, 0.3583334671633344,\n  -0.47357732824944315, 0.17810871365594377, 0.42268219963946685, 0, 0,\n  -0.16379620467004602, -0.43893868831061167, 0, 0.11570094006709251,\n  0.9326431262654882, -0.9990110509203912, -0.44125275652726503,\n  -0.15840786997162004, -0.4600396256644451, -0.018814811994044403,\n  0.09230944537175266, 0.025814790934742798, -1.0940162204190154,\n  -0.9407503631235489, -0.9854303778694269, -1.1045822488262245,\n  -1.1417299456573262, -1.5623704405345513, -0.4157473855795939,\n  -1.0244257735561713, -0.7477401944601753, -1.1275109699068402,\n  -0.0714715633552533, -1.1408628006786907, -1.0409898655074672,\n  -0.2288889836518878, -0.5469549893760344, -0.181946611106845,\n  0.1264329316374918, 0, 0, 0.312206968554707, -0.3656436392517924,\n  0.23655650686038968, 0.1014912419901576, 0, 0.06287549221765308, 0, 0,\n  0.19027065218932154, -0.8519502045974378, 0, 0.23753599905971923,\n  0.2488809322489166, 0.019969251907983224, 0, 0.06916505526229488,\n  0.29053356359188204, -0.14484456555431657, 0.014768129429370188,\n  -0.15051464926341374, 0.07614835502776021, -0.3317489901313935, 0, 0,\n  0.04921938684669103, -0.28248576768353445, -0.9708816204525345,\n  -1.3560464522265527, 0.014165375212383239, -0.23924166472544983,\n  0.10006595730248855, 0.09867233147279562, 0.32330430333220644,\n  -0.058625706114180595, 0.17149853105783947, 0.4436484054395367,\n  0.047189049576707255, 0.16832520944790552, 0.1117259900942179,\n  -0.35469010329927253, 0, -0.1528189124465582, -0.3804848349564939,\n  0.07278077320753953, 0.13263786480064088, 0.22920682659292527,\n  1.1512955314336537, 0, 0.016939862282340023, 0.4242994650403408,\n  0.12759835577444986, -0.5577261135825583, -0.19764560943067672,\n  -0.4042102444736004, 0.12063461617733708, -0.2933966817484834,\n  0.2715683893968593, 0, -0.7138548251238751, 0, -0.023066228703035277, 0,\n  -0.06383043976746139, 0.09683723720709651, -0.7337151424080791, 0,\n  -0.27191370124625525, 0.2819781269656171, -0.08711496549050252,\n  0.11048604909969338, -0.0934849550450534, 0.0721001250772912,\n  0.2589126797890794, 0.6729582659532254, -0.21921032738244908,\n  -0.21535277468651456, -0.45474006124091354, -0.05861820126419139,\n  -0.007875306207720204, -0.056661261678809284, 0.17727881404222662,\n  0.23603713348534658, 0.17485861412377932, -0.5737483768696752,\n  -0.38220029570342745, -0.5202722985519168, -0.37187947527657256,\n  0.47155277792990113, -0.12077912346691123, 0.47825628981545326,\n  0.4736704404000214, -0.1615218651546898, 0.18362447973513005, 0, 0,\n  -0.18183417425866824, 0, 0, -0.2538532305733833, -0.1303692690676528,\n  -0.4073577969188216, 0.04172985870928789, -0.1704527388573901, 0, 0,\n  0.7536858953385828, -0.44703159588787644, 0, -0.7246484085580873,\n  -0.21378128540782063, 0, 0.037461090552656146, -0.16205852364367032,\n  -0.10973952064404884, 0.017468043407647377, -0.1288980387397392, 0, 0, 0,\n  -1.218692715379445, 0.05536949662193305, -0.3763799844799116,\n  -0.1845001725624579, -0.1615576298149558, 0, -0.15373262203249874,\n  -0.04603412604270418, 0, -0.3068149681460828, 0.09412352468269412, 0,\n  0.09116543650609721, 0.06065865264082559, 0.05688267379386188,\n  -0.05873945477722306, 0, 0.14532465133322153, 0.1870857769705463,\n  0.36304258043185555, 0.1411392422180405, 0.0630388629716367, 0,\n  -1.1170522012450395, 0.16133697772771127, 0.15908534390781448,\n  -0.23485453704002232, -0.1419980841417892, 0.21909510179526218,\n  0.39948420260153766, 0.40802294284289187, 0.15403767653746853, 0,\n  0.19764784115096676, 0.584914157527457, 0, -0.4573883817015294,\n];\nexports.contextualFilterLanguageMap = {\n  javascript: 1,\n  typescript: 2,\n  typescriptreact: 3,\n  python: 4,\n  vue: 5,\n  php: 6,\n  dart: 7,\n  javascriptreact: 8,\n  go: 9,\n  css: 10,\n  cpp: 11,\n  html: 12,\n  scss: 13,\n  markdown: 14,\n  csharp: 15,\n  java: 16,\n  json: 17,\n  rust: 18,\n  ruby: 19,\n  c: 20,\n};\nexports.contextualFilterCharacterMap = {\n  \" \": 1,\n  \"!\": 2,\n  '\"': 3,\n  \"#\": 4,\n  $: 5,\n  \"%\": 6,\n  \"&\": 7,\n  \"'\": 8,\n  \"(\": 9,\n  \")\": 10,\n  \"*\": 11,\n  \"+\": 12,\n  \",\": 13,\n  \"-\": 14,\n  \".\": 15,\n  \"/\": 16,\n  0: 17,\n  1: 18,\n  2: 19,\n  3: 20,\n  4: 21,\n  5: 22,\n  6: 23,\n  7: 24,\n  8: 25,\n  9: 26,\n  \":\": 27,\n  \";\": 28,\n  \"<\": 29,\n  \"=\": 30,\n  \">\": 31,\n  \"?\": 32,\n  \"@\": 33,\n  A: 34,\n  B: 35,\n  C: 36,\n  D: 37,\n  E: 38,\n  F: 39,\n  G: 40,\n  H: 41,\n  I: 42,\n  J: 43,\n  K: 44,\n  L: 45,\n  M: 46,\n  N: 47,\n  O: 48,\n  P: 49,\n  Q: 50,\n  R: 51,\n  S: 52,\n  T: 53,\n  U: 54,\n  V: 55,\n  W: 56,\n  X: 57,\n  Y: 58,\n  Z: 59,\n  \"[\": 60,\n  \"\\\\\": 61,\n  \"]\": 62,\n  \"^\": 63,\n  _: 64,\n  \"`\": 65,\n  a: 66,\n  b: 67,\n  c: 68,\n  d: 69,\n  e: 70,\n  f: 71,\n  g: 72,\n  h: 73,\n  i: 74,\n  j: 75,\n  k: 76,\n  l: 77,\n  m: 78,\n  n: 79,\n  o: 80,\n  p: 81,\n  q: 82,\n  r: 83,\n  s: 84,\n  t: 85,\n  u: 86,\n  v: 87,\n  w: 88,\n  x: 89,\n  y: 90,\n  z: 91,\n  \"{\": 92,\n  \"|\": 93,\n  \"}\": 94,\n  \"~\": 95,\n};",
  "7772": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.validateSchemaDeps =\n  exports.validatePropertyDeps =\n  exports.error =\n    undefined;\nconst r = require(3487),\n  o = require(6776),\n  i = require(412);\nexports.error = {\n  message: ({ params: { property: e, depsCount: t, deps: n } }) => {\n    const o = 1 === t ? \"property\" : \"properties\";\n    return r.str`must have ${o} ${n} when property ${e} is present`;\n  },\n  params: ({\n    params: { property: e, depsCount: t, deps: n, missingProperty: o },\n  }) => r._`{property: ${e},\n    missingProperty: ${o},\n    depsCount: ${t},\n    deps: ${n}}`,\n};\nconst s = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error: exports.error,\n  code(e) {\n    const [t, n] = (function ({ schema: e }) {\n      const t = {},\n        n = {};\n      for (const r in e)\n        if (\"__proto__\" !== r) {\n          (Array.isArray(e[r]) ? t : n)[r] = e[r];\n        }\n      return [t, n];\n    })(e);\n    validatePropertyDeps(e, t);\n    validateSchemaDeps(e, n);\n  },\n};\nfunction validatePropertyDeps(e, t = e.schema) {\n  const { gen: n, data: o, it: s } = e;\n  if (0 === Object.keys(t).length) return;\n  const a = n.let(\"missing\");\n  for (const c in t) {\n    const l = t[c];\n    if (0 === l.length) continue;\n    const u = i.propertyInData(n, o, c, s.opts.ownProperties);\n    e.setParams({\n      property: c,\n      depsCount: l.length,\n      deps: l.join(\", \"),\n    });\n    if (s.allErrors) {\n      n.if(u, () => {\n        for (const t of l) i.checkReportMissingProp(e, t);\n      });\n    } else {\n      n.if(r._`${u} && (${i.checkMissingProp(e, l, a)})`);\n      i.reportMissingProp(e, a);\n      n.else();\n    }\n  }\n}\nfunction validateSchemaDeps(e, t = e.schema) {\n  const { gen: n, data: r, keyword: s, it: a } = e,\n    c = n.name(\"valid\");\n  for (const l in t)\n    if (o.alwaysValidSchema(a, t[l])) {\n      n.if(\n        i.propertyInData(n, r, l, a.opts.ownProperties),\n        () => {\n          const t = e.subschema(\n            {\n              keyword: s,\n              schemaProp: l,\n            },\n            c\n          );\n          e.mergeValidEvaluated(t, c);\n        },\n        () => n.var(c, !0)\n      );\n      e.ok(c);\n    }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nexports.validateSchemaDeps = validateSchemaDeps;\nexports.default = s;",
  "7792": "var r, o, i, s, a, c;\nc = require(8249);\nrequire(2153);\no = (r = c).lib.WordArray;\ni = r.algo;\ns = i.SHA256;\na = i.SHA224 = s.extend({\n  _doReset: function () {\n    this._hash = new o.init([\n      3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025,\n      1694076839, 3204075428,\n    ]);\n  },\n  _doFinalize: function () {\n    var e = s._doFinalize.call(this);\n    e.sigBytes -= 4;\n    return e;\n  },\n});\nr.SHA224 = s._createHelper(a);\nr.HmacSHA224 = s._createHmacHelper(a);\nmodule.exports = c.SHA224;",
  "7824": "var t = 1e3,\n  n = 60 * t,\n  r = 60 * n,\n  o = 24 * r;\nfunction i(e, t, n, r) {\n  var o = t >= 1.5 * n;\n  return Math.round(e / n) + \" \" + r + (o ? \"s\" : \"\");\n}\nmodule.exports = function (e, s) {\n  s = s || {};\n  var a,\n    c,\n    l = typeof e;\n  if (\"string\" === l && e.length > 0)\n    return (function (e) {\n      if (!((e = String(e)).length > 100)) {\n        var i =\n          /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n            e\n          );\n        if (i) {\n          var s = parseFloat(i[1]);\n          switch ((i[2] || \"ms\").toLowerCase()) {\n            case \"years\":\n            case \"year\":\n            case \"yrs\":\n            case \"yr\":\n            case \"y\":\n              return 315576e5 * s;\n            case \"weeks\":\n            case \"week\":\n            case \"w\":\n              return 6048e5 * s;\n            case \"days\":\n            case \"day\":\n            case \"d\":\n              return s * o;\n            case \"hours\":\n            case \"hour\":\n            case \"hrs\":\n            case \"hr\":\n            case \"h\":\n              return s * r;\n            case \"minutes\":\n            case \"minute\":\n            case \"mins\":\n            case \"min\":\n            case \"m\":\n              return s * n;\n            case \"seconds\":\n            case \"second\":\n            case \"secs\":\n            case \"sec\":\n            case \"s\":\n              return s * t;\n            case \"milliseconds\":\n            case \"millisecond\":\n            case \"msecs\":\n            case \"msec\":\n            case \"ms\":\n              return s;\n            default:\n              return;\n          }\n        }\n      }\n    })(e);\n  if (\"number\" === l && isFinite(e))\n    return s.long\n      ? ((a = e),\n        (c = Math.abs(a)) >= o\n          ? i(a, c, o, \"day\")\n          : c >= r\n          ? i(a, c, r, \"hour\")\n          : c >= n\n          ? i(a, c, n, \"minute\")\n          : c >= t\n          ? i(a, c, t, \"second\")\n          : a + \" ms\")\n      : (function (e) {\n          var i = Math.abs(e);\n          return i >= o\n            ? Math.round(e / o) + \"d\"\n            : i >= r\n            ? Math.round(e / r) + \"h\"\n            : i >= n\n            ? Math.round(e / n) + \"m\"\n            : i >= t\n            ? Math.round(e / t) + \"s\"\n            : e + \"ms\";\n        })(e);\n  throw new Error(\n    \"val is not a non-empty string or a valid number. val=\" + JSON.stringify(e)\n  );\n};",
  "7870": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.Context = undefined;\nexports.Context = class {\n  constructor(e) {\n    var t;\n    this.baseContext = e;\n    this.constructionStack = [];\n    this.instances = new Map();\n    const n =\n      null === (t = new Error().stack) || undefined === t\n        ? undefined\n        : t.split(\"\\n\");\n    if (n) {\n      this.constructionStack.push(...n.slice(1));\n    }\n  }\n  get(e) {\n    const t = this.tryGet(e);\n    if (t) return t;\n    throw new Error(`No instance of ${e.name} has been registered.\\n${this}`);\n  }\n  tryGet(e) {\n    return (\n      this.instances.get(e) ||\n      (this.baseContext ? this.baseContext.tryGet(e) : undefined)\n    );\n  }\n  set(e, t) {\n    if (this.tryGet(e))\n      throw new Error(\n        `An instance of ${e.name} has already been registered. Use forceSet() if you're sure it's a good idea.`\n      );\n    this.instances.set(e, t);\n  }\n  forceSet(e, t) {\n    this.instances.set(e, t);\n  }\n  toString() {\n    var e, t;\n    let n = \"    Context created at:\\n\";\n    for (const e of this.constructionStack || []) n += `    ${e}\\n`;\n    n +=\n      null !==\n        (t =\n          null === (e = this.baseContext) || undefined === e\n            ? undefined\n            : e.toString()) && undefined !== t\n        ? t\n        : \"\";\n    return n;\n  }\n  get debug() {\n    const e = {};\n    for (const [t, n] of this.instances) e[t.name] = n;\n    return e;\n  }\n};",
  "7886": "var r = require(4953),\n  o = [];\nexports.qP = function (e) {\n  e.data.event.commandName;\n  o.forEach(function (t) {\n    var n =\n      (e.data.startedData && e.data.startedData.databaseName) ||\n      \"Unknown database\";\n    t.trackDependency({\n      target: n,\n      data: e.data.event.commandName,\n      name: e.data.event.commandName,\n      duration: e.data.event.duration,\n      success: e.data.succeeded,\n      resultCode: e.data.succeeded ? \"0\" : \"1\",\n      dependencyTypeName: \"mongodb\",\n    });\n  });\n};\nexports.wp = function (e, n) {\n  if (e) {\n    if (0 === o.length) {\n      r.channel.subscribe(\"mongodb\", exports.qP);\n    }\n    o.push(n);\n  } else {\n    if (\n      0 ===\n      (o = o.filter(function (e) {\n        return e != n;\n      })).length\n    ) {\n      r.channel.unsubscribe(\"mongodb\", exports.qP);\n    }\n  }\n};",
  "7898": "var r = require(465);\nfunction o() {\n  this.extend = new a();\n  this.filter = new a();\n  this.format = new c();\n  this.version = require(2301).i8;\n}\nvar i = !1;\no.prototype.callSite = function e(t) {\n  if (t) {\n    t = {};\n  }\n  i = !0;\n  var n = {};\n  Error.captureStackTrace(n, e);\n  var r = n.stack;\n  i = !1;\n  r = r.slice(t.slice || 0);\n  if (t.extend) {\n    r = this.extend._modify(n, r);\n  }\n  if (t.filter) {\n    r = this.filter._modify(n, r);\n  }\n  return r;\n};\nvar s = new o();\nfunction a() {\n  this._modifiers = [];\n}\nfunction c() {\n  this._formater = r;\n  this._previous = undefined;\n}\na.prototype._modify = function (e, t) {\n  for (var n = 0, r = this._modifiers.length; n < r; n++)\n    t = this._modifiers[n](e, t);\n  return t;\n};\na.prototype.attach = function (e) {\n  this._modifiers.push(e);\n};\na.prototype.deattach = function (e) {\n  var t = this._modifiers.indexOf(e);\n  return -1 !== t && (this._modifiers.splice(t, 1), !0);\n};\nc.prototype.replace = function (e) {\n  if (e) {\n    this._formater = e;\n  } else {\n    this.restore();\n  }\n};\nc.prototype.restore = function () {\n  this._formater = r;\n  this._previous = undefined;\n};\nc.prototype._backup = function () {\n  this._previous = this._formater;\n};\nc.prototype._roolback = function () {\n  if (this._previous === r) {\n    this.replace(undefined);\n  } else {\n    this.replace(this._previous);\n  }\n  this._previous = undefined;\n};\nif (Error.prepareStackTrace) {\n  s.format.replace(Error.prepareStackTrace);\n}\nvar l = !1;\nfunction u(e, t) {\n  if (i) return t;\n  if (l) return r(e, t);\n  var n = t.concat();\n  n = s.extend._modify(e, n);\n  n = (n = s.filter._modify(e, n)).slice(0, Error.stackTraceLimit);\n  if (\n    Object.isExtensible(e) &&\n    undefined === Object.getOwnPropertyDescriptor(e, \"callSite\")\n  ) {\n    e.callSite = {\n      original: t,\n      mutated: n,\n    };\n  }\n  l = !0;\n  var o = s.format._formater(e, n);\n  l = !1;\n  return o;\n}\nObject.defineProperty(Error, \"prepareStackTrace\", {\n  get: function () {\n    return u;\n  },\n  set: function (e) {\n    if (e === u) {\n      s.format._roolback();\n    } else {\n      s.format._backup();\n      s.format.replace(e);\n    }\n  },\n});\nObject.defineProperty(Error.prototype, \"callSite\", {\n  get: function () {\n    this.stack;\n    return this.callSite;\n  },\n  set: function (e) {\n    Object.defineProperty(this, \"callSite\", {\n      value: e,\n      writable: !0,\n      configurable: !0,\n    });\n  },\n  configurable: !0,\n});\nmodule.exports = s;",
  "7923": "var n =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\nexports.encode = function (e) {\n  if (0 <= e && e < n.length) return n[e];\n  throw new TypeError(\"Must be between 0 and 63: \" + e);\n};\nexports.decode = function (e) {\n  return 65 <= e && e <= 90\n    ? e - 65\n    : 97 <= e && e <= 122\n    ? e - 97 + 26\n    : 48 <= e && e <= 57\n    ? e - 48 + 52\n    : 43 == e\n    ? 62\n    : 47 == e\n    ? 63\n    : -1;\n};",
  "8002": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r = require(4953),\n  o = require(\"path\");\nexports.mysql = {\n  versionSpecifier: \">= 2.0.0 < 3.0.0\",\n  patch: function (e, t) {\n    var i = function (e, t) {\n        return function (t, n) {\n          var o = e[t];\n          if (o) {\n            e[t] = function () {\n              for (\n                var e = arguments.length - 1, t = arguments.length - 1;\n                t >= 0;\n                --t\n              ) {\n                if (\"function\" == typeof arguments[t]) {\n                  e = t;\n                  break;\n                }\n                if (undefined !== arguments[t]) break;\n              }\n              var i = arguments[e],\n                s = {\n                  result: null,\n                  startTime: null,\n                  startDate: null,\n                };\n              if (\"function\" == typeof i) {\n                if (n) {\n                  s.startTime = process.hrtime();\n                  s.startDate = new Date();\n                  arguments[e] = r.channel.bindToContext(n(s, i));\n                } else {\n                  arguments[e] = r.channel.bindToContext(i);\n                }\n              }\n              var a = o.apply(this, arguments);\n              s.result = a;\n              return a;\n            };\n          }\n        };\n      },\n      s = function (e, t) {\n        return i(e.prototype);\n      },\n      a = require(4694)(o.dirname(t) + \"/lib/Connection\");\n    [\"connect\", \"changeUser\", \"ping\", \"statistics\", \"end\"].forEach(function (\n      e\n    ) {\n      return s(a)(e);\n    });\n    i(a)(\"createQuery\", function (e, t) {\n      return function (n) {\n        var o = process.hrtime(e.startTime),\n          i = (1e3 * o[0] + o[1] / 1e6) | 0;\n        r.channel.publish(\"mysql\", {\n          query: e.result,\n          callbackArgs: arguments,\n          err: n,\n          duration: i,\n          time: e.startDate,\n        });\n        t.apply(this, arguments);\n      };\n    });\n    var c = require(420)(o.dirname(t) + \"/lib/Pool\");\n    [\"_enqueueCallback\"].forEach(function (e) {\n      return s(c)(e);\n    });\n    return e;\n  },\n};\nexports.enable = function () {\n  r.channel.registerMonkeyPatch(\"mysql\", exports.mysql);\n};",
  "8060": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r = require(4953),\n  o = require(\"events\");\nexports.postgres6 = {\n  versionSpecifier: \"6.*\",\n  patch: function (e, t) {\n    var n = e.Client.prototype.query,\n      i = \"__diagnosticOriginalFunc\";\n    e.Client.prototype.query = function (e, t, s) {\n      var a,\n        c = {\n          query: {},\n          database: {\n            host: this.connectionParameters.host,\n            port: this.connectionParameters.port,\n          },\n          result: null,\n          error: null,\n          duration: 0,\n          time: new Date(),\n        },\n        l = process.hrtime();\n      function u(e) {\n        if (e && e[i]) {\n          e = e[i];\n        }\n        var t = r.channel.bindToContext(function (t, n) {\n          var i = process.hrtime(l);\n          c.result = n && {\n            rowCount: n.rowCount,\n            command: n.command,\n          };\n          c.error = t;\n          c.duration = Math.ceil(1e3 * i[0] + i[1] / 1e6);\n          r.channel.publish(\"postgres\", c);\n          if (t) {\n            if (e) return e.apply(this, arguments);\n            a && a instanceof o.EventEmitter && a.emit(\"error\", t);\n          } else e && e.apply(this, arguments);\n        });\n        try {\n          Object.defineProperty(t, i, {\n            value: e,\n          });\n          return t;\n        } catch (t) {\n          return e;\n        }\n      }\n      try {\n        if (\"string\" == typeof e) {\n          if (t instanceof Array) {\n            c.query.preparable = {\n              text: e,\n              args: t,\n            };\n            s = u(s);\n          } else {\n            c.query.text = e;\n            if (s) {\n              s = u(s);\n            } else {\n              t = u(t);\n            }\n          }\n        } else {\n          if (\"string\" == typeof e.name) {\n            c.query.plan = e.name;\n          } else {\n            if (e.values instanceof Array) {\n              c.query.preparable = {\n                text: e.text,\n                args: e.values,\n              };\n            } else {\n              c.query.text = e.text;\n            }\n          }\n          if (s) {\n            s = u(s);\n          } else {\n            if (t) {\n              t = u(t);\n            } else {\n              e.callback = u(e.callback);\n            }\n          }\n        }\n      } catch (e) {\n        return n.apply(this, arguments);\n      }\n      arguments[0] = e;\n      arguments[1] = t;\n      arguments[2] = s;\n      arguments.length = arguments.length > 3 ? arguments.length : 3;\n      return (a = n.apply(this, arguments));\n    };\n    return e;\n  },\n};\nexports.postgres7 = {\n  versionSpecifier: \">=7.* <=8.*\",\n  patch: function (e, t) {\n    var n = e.Client.prototype.query,\n      i = \"__diagnosticOriginalFunc\";\n    e.Client.prototype.query = function (e, t, s) {\n      var a,\n        c = this,\n        l = !!s,\n        u = {\n          query: {},\n          database: {\n            host: this.connectionParameters.host,\n            port: this.connectionParameters.port,\n          },\n          result: null,\n          error: null,\n          duration: 0,\n          time: new Date(),\n        },\n        d = process.hrtime();\n      function p(e) {\n        if (e && e[i]) {\n          e = e[i];\n        }\n        var t = r.channel.bindToContext(function (t, n) {\n          var i = process.hrtime(d);\n          u.result = n && {\n            rowCount: n.rowCount,\n            command: n.command,\n          };\n          u.error = t;\n          u.duration = Math.ceil(1e3 * i[0] + i[1] / 1e6);\n          r.channel.publish(\"postgres\", u);\n          if (t) {\n            if (e) return e.apply(this, arguments);\n            a && a instanceof o.EventEmitter && a.emit(\"error\", t);\n          } else e && e.apply(this, arguments);\n        });\n        try {\n          Object.defineProperty(t, i, {\n            value: e,\n          });\n          return t;\n        } catch (t) {\n          return e;\n        }\n      }\n      try {\n        if (\"string\" == typeof e) {\n          if (t instanceof Array) {\n            u.query.preparable = {\n              text: e,\n              args: t,\n            };\n            s = (l = \"function\" == typeof s) ? p(s) : s;\n          } else {\n            u.query.text = e;\n            if (s) {\n              s = (l = \"function\" == typeof s) ? p(s) : s;\n            } else {\n              t = (l = \"function\" == typeof t) ? p(t) : t;\n            }\n          }\n        } else {\n          if (\"string\" == typeof e.name) {\n            u.query.plan = e.name;\n          } else {\n            if (e.values instanceof Array) {\n              u.query.preparable = {\n                text: e.text,\n                args: e.values,\n              };\n            } else {\n              u.query.text = e.text;\n            }\n          }\n          if (s) {\n            l = \"function\" == typeof s;\n            s = p(s);\n          } else {\n            if (t) {\n              t = (l = \"function\" == typeof t) ? p(t) : t;\n            } else {\n              l = \"function\" == typeof e.callback;\n              e.callback = l ? p(e.callback) : e.callback;\n            }\n          }\n        }\n      } catch (e) {\n        return n.apply(this, arguments);\n      }\n      arguments[0] = e;\n      arguments[1] = t;\n      arguments[2] = s;\n      arguments.length = arguments.length > 3 ? arguments.length : 3;\n      a = n.apply(this, arguments);\n      return l\n        ? a\n        : a\n            .then(function (e) {\n              p()(undefined, e);\n              return new c._Promise(function (t, n) {\n                t(e);\n              });\n            })\n            .catch(function (e) {\n              p()(e, undefined);\n              return new c._Promise(function (t, n) {\n                n(e);\n              });\n            });\n    };\n    return e;\n  },\n};\nexports.enable = function () {\n  r.channel.registerMonkeyPatch(\"pg\", exports.postgres6);\n  r.channel.registerMonkeyPatch(\"pg\", exports.postgres7);\n};",
  "8082": "module.exports = function () {\n  this.hasFullStack = !0;\n  this.parsedStack = [];\n};",
  "8090": "var r = require(5740),\n  o = require(9962),\n  i = (function () {\n    function e(t, n) {\n      this.traceFlag = e.DEFAULT_TRACE_FLAG;\n      this.version = e.DEFAULT_VERSION;\n      if (t && \"string\" == typeof t) {\n        if (t.split(\",\").length > 1)\n          (this.traceId = r.w3cTraceId()),\n            (this.spanId = r.w3cTraceId().substr(0, 16));\n        else {\n          var i = t.trim().split(\"-\"),\n            s = i.length;\n          s >= 4\n            ? ((this.version = i[0]),\n              (this.traceId = i[1]),\n              (this.spanId = i[2]),\n              (this.traceFlag = i[3]))\n            : ((this.traceId = r.w3cTraceId()),\n              (this.spanId = r.w3cTraceId().substr(0, 16))),\n            this.version.match(/^[0-9a-f]{2}$/g) ||\n              ((this.version = e.DEFAULT_VERSION),\n              (this.traceId = r.w3cTraceId())),\n            \"00\" === this.version &&\n              4 !== s &&\n              ((this.traceId = r.w3cTraceId()),\n              (this.spanId = r.w3cTraceId().substr(0, 16))),\n            \"ff\" === this.version &&\n              ((this.version = e.DEFAULT_VERSION),\n              (this.traceId = r.w3cTraceId()),\n              (this.spanId = r.w3cTraceId().substr(0, 16))),\n            this.version.match(/^0[0-9a-f]$/g) ||\n              (this.version = e.DEFAULT_VERSION),\n            this.traceFlag.match(/^[0-9a-f]{2}$/g) ||\n              ((this.traceFlag = e.DEFAULT_TRACE_FLAG),\n              (this.traceId = r.w3cTraceId())),\n            e.isValidTraceId(this.traceId) || (this.traceId = r.w3cTraceId()),\n            e.isValidSpanId(this.spanId) ||\n              ((this.spanId = r.w3cTraceId().substr(0, 16)),\n              (this.traceId = r.w3cTraceId())),\n            (this.parentId = this.getBackCompatRequestId());\n        }\n      } else if (n) {\n        this.parentId = n.slice();\n        var a = o.getRootId(n);\n        e.isValidTraceId(a) || ((this.legacyRootId = a), (a = r.w3cTraceId())),\n          -1 !== n.indexOf(\"|\") &&\n            (n = n.substring(\n              1 + n.substring(0, n.length - 1).lastIndexOf(\".\"),\n              n.length - 1\n            )),\n          (this.traceId = a),\n          (this.spanId = n);\n      } else\n        (this.traceId = r.w3cTraceId()),\n          (this.spanId = r.w3cTraceId().substr(0, 16));\n    }\n    e.isValidTraceId = function (e) {\n      return (\n        e.match(/^[0-9a-f]{32}$/) && \"00000000000000000000000000000000\" !== e\n      );\n    };\n    e.isValidSpanId = function (e) {\n      return e.match(/^[0-9a-f]{16}$/) && \"0000000000000000\" !== e;\n    };\n    e.prototype.getBackCompatRequestId = function () {\n      return \"|\" + this.traceId + \".\" + this.spanId + \".\";\n    };\n    e.prototype.toString = function () {\n      return (\n        this.version +\n        \"-\" +\n        this.traceId +\n        \"-\" +\n        this.spanId +\n        \"-\" +\n        this.traceFlag\n      );\n    };\n    e.prototype.updateSpanId = function () {\n      this.spanId = r.w3cTraceId().substr(0, 16);\n    };\n    e.DEFAULT_TRACE_FLAG = \"01\";\n    e.DEFAULT_VERSION = \"00\";\n    return e;\n  })();\nmodule.exports = i;",
  "8104": "if (\n  \"undefined\" == typeof process ||\n  \"renderer\" === process.type ||\n  !0 === process.browser ||\n  process.__nwjs\n) {\n  module.exports = require(1758);\n} else {\n  module.exports = require(39);\n}",
  "8129": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.ExtensionLocationFactory = undefined;\nconst r = require(\"vscode\"),\n  o = require(6403);\nclass ExtensionLocationFactory extends o.LocationFactory {\n  range(e, t, n, o) {\n    return undefined !== n && undefined !== o\n      ? new r.Range(e, t, n, o)\n      : new r.Range(e, t);\n  }\n  position(e, t) {\n    return new r.Position(e, t);\n  }\n}\nexports.ExtensionLocationFactory = ExtensionLocationFactory;",
  "8142": "var n, r;\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.FilterSettings =\n  exports.telmetryNames =\n  exports.TargetPopulation =\n  exports.Filter =\n    undefined;\n(function (e) {\n  e.Market = \"X-MSEdge-Market\";\n  e.CorpNet = \"X-FD-Corpnet\";\n  e.ApplicationVersion = \"X-VSCode-AppVersion\";\n  e.Build = \"X-VSCode-Build\";\n  e.ClientId = \"X-MSEdge-ClientId\";\n  e.ExtensionName = \"X-VSCode-ExtensionName\";\n  e.ExtensionVersion = \"X-VSCode-ExtensionVersion\";\n  e.Language = \"X-VSCode-Language\";\n  e.TargetPopulation = \"X-VSCode-TargetPopulation\";\n  e.CopilotClientTimeBucket = \"X-Copilot-ClientTimeBucket\";\n  e.CopilotOverrideEngine = \"X-Copilot-OverrideEngine\";\n  e.CopilotRepository = \"X-Copilot-Repository\";\n  e.CopilotFileType = \"X-Copilot-FileType\";\n  e.CopilotUserKind = \"X-Copilot-UserKind\";\n  e.CopilotDogfood = \"X-Copilot-Dogfood\";\n})((n = exports.Filter || (exports.Filter = {})));\n(r = exports.TargetPopulation || (exports.TargetPopulation = {})).Team = \"team\";\nr.Internal = \"internal\";\nr.Insiders = \"insider\";\nr.Public = \"public\";\nexports.telmetryNames = {\n  [n.CopilotClientTimeBucket]: \"timeBucket\",\n  [n.CopilotOverrideEngine]: \"engine\",\n  [n.CopilotRepository]: \"repo\",\n  [n.CopilotFileType]: \"fileType\",\n  [n.CopilotUserKind]: \"userKind\",\n};\nclass FilterSettings {\n  constructor(e) {\n    this.filters = e;\n    for (const [e, t] of Object.entries(this.filters))\n      if (\"\" === t) {\n        delete this.filters[e];\n      }\n  }\n  extends(e) {\n    for (const [t, n] of Object.entries(e.filters))\n      if (this.filters[t] !== n) return !1;\n    return !0;\n  }\n  addToTelemetry(e) {\n    for (const [n, r] of Object.entries(this.filters)) {\n      const o = exports.telmetryNames[n];\n      if (undefined !== o) {\n        e.properties[o] = r;\n      }\n    }\n  }\n  stringify() {\n    const e = Object.keys(this.filters);\n    e.sort();\n    return e.map((e) => `${e}:${this.filters[e]}`).join(\";\");\n  }\n  toHeaders() {\n    return {\n      ...this.filters,\n    };\n  }\n  withChange(e, t) {\n    return new FilterSettings({\n      ...this.filters,\n      [e]: t,\n    });\n  }\n}\nexports.FilterSettings = FilterSettings;",
  "8200": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(4783),\n  o = require(2924),\n  i = require(4665),\n  s = require(1119),\n  a = require(9864),\n  c = require(7772),\n  l = require(3708),\n  u = require(9351),\n  d = require(6239),\n  p = require(2296),\n  h = require(5697),\n  f = require(19),\n  m = require(4200),\n  g = require(1125),\n  _ = require(9434),\n  y = require(6552);\nexports.default = function (e = !1) {\n  const t = [\n    h.default,\n    f.default,\n    m.default,\n    g.default,\n    _.default,\n    y.default,\n    l.default,\n    u.default,\n    c.default,\n    d.default,\n    p.default,\n  ];\n  if (e) {\n    t.push(o.default, s.default);\n  } else {\n    t.push(r.default, i.default);\n  }\n  t.push(a.default);\n  return t;\n};",
  "8213": "var r = require(2728),\n  o = Object.prototype.hasOwnProperty,\n  i = \"undefined\" != typeof Map;\nfunction I() {\n  this._array = [];\n  this._set = i ? new Map() : Object.create(null);\n}\nI.fromArray = function (e, t) {\n  for (var n = new I(), r = 0, o = e.length; r < o; r++) n.add(e[r], t);\n  return n;\n};\nI.prototype.size = function () {\n  return i ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\nI.prototype.add = function (e, t) {\n  var n = i ? e : r.toSetString(e),\n    s = i ? this.has(e) : o.call(this._set, n),\n    a = this._array.length;\n  if (s && !t) {\n    this._array.push(e);\n  }\n  if (s) {\n    if (i) {\n      this._set.set(e, a);\n    } else {\n      this._set[n] = a;\n    }\n  }\n};\nI.prototype.has = function (e) {\n  if (i) return this._set.has(e);\n  var t = r.toSetString(e);\n  return o.call(this._set, t);\n};\nI.prototype.indexOf = function (e) {\n  if (i) {\n    var t = this._set.get(e);\n    if (t >= 0) return t;\n  } else {\n    var n = r.toSetString(e);\n    if (o.call(this._set, n)) return this._set[n];\n  }\n  throw new Error('\"' + e + '\" is not in the set.');\n};\nI.prototype.at = function (e) {\n  if (e >= 0 && e < this._array.length) return this._array[e];\n  throw new Error(\"No element indexed by \" + e);\n};\nI.prototype.toArray = function () {\n  return this._array.slice();\n};\nexports.I = I;",
  "8214": "var r;\nr = require(8249);\n(function (e) {\n  var t = r,\n    n = t.lib,\n    o = n.WordArray,\n    i = n.Hasher,\n    s = t.algo,\n    a = [];\n  !(function () {\n    for (var t = 0; t < 64; t++) a[t] = (4294967296 * e.abs(e.sin(t + 1))) | 0;\n  })();\n  var c = (s.MD5 = i.extend({\n    _doReset: function () {\n      this._hash = new o.init([1732584193, 4023233417, 2562383102, 271733878]);\n    },\n    _doProcessBlock: function (e, t) {\n      for (var n = 0; n < 16; n++) {\n        var r = t + n,\n          o = e[r];\n        e[r] =\n          (16711935 & ((o << 8) | (o >>> 24))) |\n          (4278255360 & ((o << 24) | (o >>> 8)));\n      }\n      var i = this._hash.words,\n        s = e[t + 0],\n        c = e[t + 1],\n        h = e[t + 2],\n        f = e[t + 3],\n        m = e[t + 4],\n        g = e[t + 5],\n        _ = e[t + 6],\n        y = e[t + 7],\n        v = e[t + 8],\n        b = e[t + 9],\n        w = e[t + 10],\n        x = e[t + 11],\n        E = e[t + 12],\n        C = e[t + 13],\n        S = e[t + 14],\n        T = e[t + 15],\n        k = i[0],\n        I = i[1],\n        P = i[2],\n        A = i[3];\n      k = l(k, I, P, A, s, 7, a[0]);\n      A = l(A, k, I, P, c, 12, a[1]);\n      P = l(P, A, k, I, h, 17, a[2]);\n      I = l(I, P, A, k, f, 22, a[3]);\n      k = l(k, I, P, A, m, 7, a[4]);\n      A = l(A, k, I, P, g, 12, a[5]);\n      P = l(P, A, k, I, _, 17, a[6]);\n      I = l(I, P, A, k, y, 22, a[7]);\n      k = l(k, I, P, A, v, 7, a[8]);\n      A = l(A, k, I, P, b, 12, a[9]);\n      P = l(P, A, k, I, w, 17, a[10]);\n      I = l(I, P, A, k, x, 22, a[11]);\n      k = l(k, I, P, A, E, 7, a[12]);\n      A = l(A, k, I, P, C, 12, a[13]);\n      P = l(P, A, k, I, S, 17, a[14]);\n      k = u(k, (I = l(I, P, A, k, T, 22, a[15])), P, A, c, 5, a[16]);\n      A = u(A, k, I, P, _, 9, a[17]);\n      P = u(P, A, k, I, x, 14, a[18]);\n      I = u(I, P, A, k, s, 20, a[19]);\n      k = u(k, I, P, A, g, 5, a[20]);\n      A = u(A, k, I, P, w, 9, a[21]);\n      P = u(P, A, k, I, T, 14, a[22]);\n      I = u(I, P, A, k, m, 20, a[23]);\n      k = u(k, I, P, A, b, 5, a[24]);\n      A = u(A, k, I, P, S, 9, a[25]);\n      P = u(P, A, k, I, f, 14, a[26]);\n      I = u(I, P, A, k, v, 20, a[27]);\n      k = u(k, I, P, A, C, 5, a[28]);\n      A = u(A, k, I, P, h, 9, a[29]);\n      P = u(P, A, k, I, y, 14, a[30]);\n      k = d(k, (I = u(I, P, A, k, E, 20, a[31])), P, A, g, 4, a[32]);\n      A = d(A, k, I, P, v, 11, a[33]);\n      P = d(P, A, k, I, x, 16, a[34]);\n      I = d(I, P, A, k, S, 23, a[35]);\n      k = d(k, I, P, A, c, 4, a[36]);\n      A = d(A, k, I, P, m, 11, a[37]);\n      P = d(P, A, k, I, y, 16, a[38]);\n      I = d(I, P, A, k, w, 23, a[39]);\n      k = d(k, I, P, A, C, 4, a[40]);\n      A = d(A, k, I, P, s, 11, a[41]);\n      P = d(P, A, k, I, f, 16, a[42]);\n      I = d(I, P, A, k, _, 23, a[43]);\n      k = d(k, I, P, A, b, 4, a[44]);\n      A = d(A, k, I, P, E, 11, a[45]);\n      P = d(P, A, k, I, T, 16, a[46]);\n      k = p(k, (I = d(I, P, A, k, h, 23, a[47])), P, A, s, 6, a[48]);\n      A = p(A, k, I, P, y, 10, a[49]);\n      P = p(P, A, k, I, S, 15, a[50]);\n      I = p(I, P, A, k, g, 21, a[51]);\n      k = p(k, I, P, A, E, 6, a[52]);\n      A = p(A, k, I, P, f, 10, a[53]);\n      P = p(P, A, k, I, w, 15, a[54]);\n      I = p(I, P, A, k, c, 21, a[55]);\n      k = p(k, I, P, A, v, 6, a[56]);\n      A = p(A, k, I, P, T, 10, a[57]);\n      P = p(P, A, k, I, _, 15, a[58]);\n      I = p(I, P, A, k, C, 21, a[59]);\n      k = p(k, I, P, A, m, 6, a[60]);\n      A = p(A, k, I, P, x, 10, a[61]);\n      P = p(P, A, k, I, h, 15, a[62]);\n      I = p(I, P, A, k, b, 21, a[63]);\n      i[0] = (i[0] + k) | 0;\n      i[1] = (i[1] + I) | 0;\n      i[2] = (i[2] + P) | 0;\n      i[3] = (i[3] + A) | 0;\n    },\n    _doFinalize: function () {\n      var t = this._data,\n        n = t.words,\n        r = 8 * this._nDataBytes,\n        o = 8 * t.sigBytes;\n      n[o >>> 5] |= 128 << (24 - (o % 32));\n      var i = e.floor(r / 4294967296),\n        s = r;\n      n[15 + (((o + 64) >>> 9) << 4)] =\n        (16711935 & ((i << 8) | (i >>> 24))) |\n        (4278255360 & ((i << 24) | (i >>> 8)));\n      n[14 + (((o + 64) >>> 9) << 4)] =\n        (16711935 & ((s << 8) | (s >>> 24))) |\n        (4278255360 & ((s << 24) | (s >>> 8)));\n      t.sigBytes = 4 * (n.length + 1);\n      this._process();\n      for (var a = this._hash, c = a.words, l = 0; l < 4; l++) {\n        var u = c[l];\n        c[l] =\n          (16711935 & ((u << 8) | (u >>> 24))) |\n          (4278255360 & ((u << 24) | (u >>> 8)));\n      }\n      return a;\n    },\n    clone: function () {\n      var e = i.clone.call(this);\n      e._hash = this._hash.clone();\n      return e;\n    },\n  }));\n  function l(e, t, n, r, o, i, s) {\n    var a = e + ((t & n) | (~t & r)) + o + s;\n    return ((a << i) | (a >>> (32 - i))) + t;\n  }\n  function u(e, t, n, r, o, i, s) {\n    var a = e + ((t & r) | (n & ~r)) + o + s;\n    return ((a << i) | (a >>> (32 - i))) + t;\n  }\n  function d(e, t, n, r, o, i, s) {\n    var a = e + (t ^ n ^ r) + o + s;\n    return ((a << i) | (a >>> (32 - i))) + t;\n  }\n  function p(e, t, n, r, o, i, s) {\n    var a = e + (n ^ (t | ~r)) + o + s;\n    return ((a << i) | (a >>> (32 - i))) + t;\n  }\n  t.MD5 = i._createHelper(c);\n  t.HmacMD5 = i._createHmacHelper(c);\n})(Math);\nmodule.exports = r.MD5;",
  "8249": "var r;\nr =\n  r ||\n  (function (e, t) {\n    var r;\n    if (\"undefined\" != typeof window && window.crypto) {\n      r = window.crypto;\n    }\n    if (!r && \"undefined\" != typeof window && window.msCrypto) {\n      r = window.msCrypto;\n    }\n    if (!r && \"undefined\" != typeof global && global.crypto) {\n      r = global.crypto;\n    }\n    if (!r)\n      try {\n        r = require(\"crypto\");\n      } catch (e) {}\n    var o = function () {\n        if (r) {\n          if (\"function\" == typeof r.getRandomValues)\n            try {\n              return r.getRandomValues(new Uint32Array(1))[0];\n            } catch (e) {}\n          if (\"function\" == typeof r.randomBytes)\n            try {\n              return r.randomBytes(4).readInt32LE();\n            } catch (e) {}\n        }\n        throw new Error(\n          \"Native crypto module could not be used to get secure random number.\"\n        );\n      },\n      i =\n        Object.create ||\n        (function () {\n          function e() {}\n          return function (t) {\n            var n;\n            e.prototype = t;\n            n = new e();\n            e.prototype = null;\n            return n;\n          };\n        })(),\n      s = {},\n      a = (s.lib = {}),\n      c = (a.Base = {\n        extend: function (e) {\n          var t = i(this);\n          if (e) {\n            t.mixIn(e);\n          }\n          if (t.hasOwnProperty(\"init\") && this.init !== t.init) {\n            t.init = function () {\n              t.$super.init.apply(this, arguments);\n            };\n          }\n          t.init.prototype = t;\n          t.$super = this;\n          return t;\n        },\n        create: function () {\n          var e = this.extend();\n          e.init.apply(e, arguments);\n          return e;\n        },\n        init: function () {},\n        mixIn: function (e) {\n          for (var t in e)\n            if (e.hasOwnProperty(t)) {\n              this[t] = e[t];\n            }\n          if (e.hasOwnProperty(\"toString\")) {\n            this.toString = e.toString;\n          }\n        },\n        clone: function () {\n          return this.init.prototype.extend(this);\n        },\n      }),\n      l = (a.WordArray = c.extend({\n        init: function (e, t) {\n          e = this.words = e || [];\n          this.sigBytes = null != t ? t : 4 * e.length;\n        },\n        toString: function (e) {\n          return (e || d).stringify(this);\n        },\n        concat: function (e) {\n          var t = this.words,\n            n = e.words,\n            r = this.sigBytes,\n            o = e.sigBytes;\n          this.clamp();\n          if (r % 4)\n            for (var i = 0; i < o; i++) {\n              var s = (n[i >>> 2] >>> (24 - (i % 4) * 8)) & 255;\n              t[(r + i) >>> 2] |= s << (24 - ((r + i) % 4) * 8);\n            }\n          else for (i = 0; i < o; i += 4) t[(r + i) >>> 2] = n[i >>> 2];\n          this.sigBytes += o;\n          return this;\n        },\n        clamp: function () {\n          var t = this.words,\n            n = this.sigBytes;\n          t[n >>> 2] &= 4294967295 << (32 - (n % 4) * 8);\n          t.length = e.ceil(n / 4);\n        },\n        clone: function () {\n          var e = c.clone.call(this);\n          e.words = this.words.slice(0);\n          return e;\n        },\n        random: function (e) {\n          for (var t = [], n = 0; n < e; n += 4) t.push(o());\n          return new l.init(t, e);\n        },\n      })),\n      u = (s.enc = {}),\n      d = (u.Hex = {\n        stringify: function (e) {\n          for (var t = e.words, n = e.sigBytes, r = [], o = 0; o < n; o++) {\n            var i = (t[o >>> 2] >>> (24 - (o % 4) * 8)) & 255;\n            r.push((i >>> 4).toString(16));\n            r.push((15 & i).toString(16));\n          }\n          return r.join(\"\");\n        },\n        parse: function (e) {\n          for (var t = e.length, n = [], r = 0; r < t; r += 2)\n            n[r >>> 3] |= parseInt(e.substr(r, 2), 16) << (24 - (r % 8) * 4);\n          return new l.init(n, t / 2);\n        },\n      }),\n      p = (u.Latin1 = {\n        stringify: function (e) {\n          for (var t = e.words, n = e.sigBytes, r = [], o = 0; o < n; o++) {\n            var i = (t[o >>> 2] >>> (24 - (o % 4) * 8)) & 255;\n            r.push(String.fromCharCode(i));\n          }\n          return r.join(\"\");\n        },\n        parse: function (e) {\n          for (var t = e.length, n = [], r = 0; r < t; r++)\n            n[r >>> 2] |= (255 & e.charCodeAt(r)) << (24 - (r % 4) * 8);\n          return new l.init(n, t);\n        },\n      }),\n      h = (u.Utf8 = {\n        stringify: function (e) {\n          try {\n            return decodeURIComponent(escape(p.stringify(e)));\n          } catch (e) {\n            throw new Error(\"Malformed UTF-8 data\");\n          }\n        },\n        parse: function (e) {\n          return p.parse(unescape(encodeURIComponent(e)));\n        },\n      }),\n      f = (a.BufferedBlockAlgorithm = c.extend({\n        reset: function () {\n          this._data = new l.init();\n          this._nDataBytes = 0;\n        },\n        _append: function (e) {\n          if (\"string\" == typeof e) {\n            e = h.parse(e);\n          }\n          this._data.concat(e);\n          this._nDataBytes += e.sigBytes;\n        },\n        _process: function (t) {\n          var n,\n            r = this._data,\n            o = r.words,\n            i = r.sigBytes,\n            s = this.blockSize,\n            a = i / (4 * s),\n            c =\n              (a = t ? e.ceil(a) : e.max((0 | a) - this._minBufferSize, 0)) * s,\n            u = e.min(4 * c, i);\n          if (c) {\n            for (var d = 0; d < c; d += s) this._doProcessBlock(o, d);\n            n = o.splice(0, c);\n            r.sigBytes -= u;\n          }\n          return new l.init(n, u);\n        },\n        clone: function () {\n          var e = c.clone.call(this);\n          e._data = this._data.clone();\n          return e;\n        },\n        _minBufferSize: 0,\n      })),\n      m =\n        ((a.Hasher = f.extend({\n          cfg: c.extend(),\n          init: function (e) {\n            this.cfg = this.cfg.extend(e);\n            this.reset();\n          },\n          reset: function () {\n            f.reset.call(this);\n            this._doReset();\n          },\n          update: function (e) {\n            this._append(e);\n            this._process();\n            return this;\n          },\n          finalize: function (e) {\n            if (e) {\n              this._append(e);\n            }\n            return this._doFinalize();\n          },\n          blockSize: 16,\n          _createHelper: function (e) {\n            return function (t, n) {\n              return new e.init(n).finalize(t);\n            };\n          },\n          _createHmacHelper: function (e) {\n            return function (t, n) {\n              return new m.HMAC.init(e, n).finalize(t);\n            };\n          },\n        })),\n        (s.algo = {}));\n    return s;\n  })(Math);\nmodule.exports = r;",
  "8269": "var r, o, i;\nr = require(8249);\ni = (o = r).lib.WordArray;\no.enc.Base64 = {\n  stringify: function (e) {\n    var t = e.words,\n      n = e.sigBytes,\n      r = this._map;\n    e.clamp();\n    for (var o = [], i = 0; i < n; i += 3)\n      for (\n        var s =\n            (((t[i >>> 2] >>> (24 - (i % 4) * 8)) & 255) << 16) |\n            (((t[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 255) << 8) |\n            ((t[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 255),\n          a = 0;\n        a < 4 && i + 0.75 * a < n;\n        a++\n      )\n        o.push(r.charAt((s >>> (6 * (3 - a))) & 63));\n    var c = r.charAt(64);\n    if (c) for (; o.length % 4; ) o.push(c);\n    return o.join(\"\");\n  },\n  parse: function (e) {\n    var t = e.length,\n      n = this._map,\n      r = this._reverseMap;\n    if (!r) {\n      r = this._reverseMap = [];\n      for (var o = 0; o < n.length; o++) r[n.charCodeAt(o)] = o;\n    }\n    var s = n.charAt(64);\n    if (s) {\n      var a = e.indexOf(s);\n      if (-1 !== a) {\n        t = a;\n      }\n    }\n    return (function (e, t, n) {\n      for (var r = [], o = 0, s = 0; s < t; s++)\n        if (s % 4) {\n          var a =\n            (n[e.charCodeAt(s - 1)] << ((s % 4) * 2)) |\n            (n[e.charCodeAt(s)] >>> (6 - (s % 4) * 2));\n          r[o >>> 2] |= a << (24 - (o % 4) * 8);\n          o++;\n        }\n      return i.create(r, o);\n    })(e, t, r);\n  },\n  _map: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n};\nmodule.exports = r.enc.Base64;",
  "8280": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.callRef = exports.getValidate = undefined;\nconst r = require(6646),\n  o = require(412),\n  i = require(3487),\n  s = require(2141),\n  a = require(5173),\n  c = require(6776),\n  l = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(e) {\n      const { gen: t, schema: n, it: o } = e,\n        { baseId: s, schemaEnv: c, validateName: l, opts: p, self: h } = o,\n        { root: f } = c;\n      if ((\"#\" === n || \"#/\" === n) && s === f.baseId)\n        return (function () {\n          if (c === f) return callRef(e, l, c, c.$async);\n          const n = t.scopeValue(\"root\", {\n            ref: f,\n          });\n          return callRef(e, i._`${n}.validate`, f, f.$async);\n        })();\n      const m = a.resolveRef.call(h, f, s, n);\n      if (undefined === m) throw new r.default(s, n);\n      return m instanceof a.SchemaEnv\n        ? (function (t) {\n            const n = getValidate(e, t);\n            callRef(e, n, t, t.$async);\n          })(m)\n        : (function (r) {\n            const o = t.scopeValue(\n                \"schema\",\n                !0 === p.code.source\n                  ? {\n                      ref: r,\n                      code: i.stringify(r),\n                    }\n                  : {\n                      ref: r,\n                    }\n              ),\n              s = t.name(\"valid\"),\n              a = e.subschema(\n                {\n                  schema: r,\n                  dataTypes: [],\n                  schemaPath: i.nil,\n                  topSchemaRef: o,\n                  errSchemaPath: n,\n                },\n                s\n              );\n            e.mergeEvaluated(a);\n            e.ok(s);\n          })(m);\n    },\n  };\nfunction getValidate(e, t) {\n  const { gen: n } = e;\n  return t.validate\n    ? n.scopeValue(\"validate\", {\n        ref: t.validate,\n      })\n    : i._`${n.scopeValue(\"wrapper\", {\n        ref: t,\n      })}.validate`;\n}\nfunction callRef(e, t, n, r) {\n  const { gen: a, it: l } = e,\n    { allErrors: u, schemaEnv: d, opts: p } = l,\n    h = p.passContext ? s.default.this : i.nil;\n  function f(e) {\n    const t = i._`${e}.errors`;\n    a.assign(\n      s.default.vErrors,\n      i._`${s.default.vErrors} === null ? ${t} : ${s.default.vErrors}.concat(${t})`\n    );\n    a.assign(s.default.errors, i._`${s.default.vErrors}.length`);\n  }\n  function m(e) {\n    var t;\n    if (!l.opts.unevaluated) return;\n    const r =\n      null === (t = null == n ? undefined : n.validate) || undefined === t\n        ? undefined\n        : t.evaluated;\n    if (!0 !== l.props)\n      if (r && !r.dynamicProps) {\n        if (undefined !== r.props) {\n          l.props = c.mergeEvaluated.props(a, r.props, l.props);\n        }\n      } else {\n        const t = a.var(\"props\", i._`${e}.evaluated.props`);\n        l.props = c.mergeEvaluated.props(a, t, l.props, i.Name);\n      }\n    if (!0 !== l.items)\n      if (r && !r.dynamicItems) {\n        if (undefined !== r.items) {\n          l.items = c.mergeEvaluated.items(a, r.items, l.items);\n        }\n      } else {\n        const t = a.var(\"items\", i._`${e}.evaluated.items`);\n        l.items = c.mergeEvaluated.items(a, t, l.items, i.Name);\n      }\n  }\n  if (r) {\n    (function () {\n      if (!d.$async) throw new Error(\"async schema referenced by sync schema\");\n      const n = a.let(\"valid\");\n      a.try(\n        () => {\n          a.code(i._`await ${o.callValidateCode(e, t, h)}`);\n          m(t);\n          if (u) {\n            a.assign(n, !0);\n          }\n        },\n        (e) => {\n          a.if(i._`!(${e} instanceof ${l.ValidationError})`, () => a.throw(e));\n          f(e);\n          if (u) {\n            a.assign(n, !1);\n          }\n        }\n      );\n      e.ok(n);\n    })();\n  } else {\n    e.result(\n      o.callValidateCode(e, t, h),\n      () => m(t),\n      () => f(t)\n    );\n  }\n}\nexports.getValidate = getValidate;\nexports.callRef = callRef;\nexports.default = l;",
  "8286": "module.exports = (e, t) =>\n  class extends e {\n    constructor(e) {\n      var n, r;\n      super(function (e, i) {\n        n = this;\n        r = [\n          function (n) {\n            t(o, !1);\n            return e(n);\n          },\n          function (e) {\n            t(o, !1);\n            return i(e);\n          },\n        ];\n      });\n      var o = this;\n      try {\n        e.apply(n, r);\n      } catch (e) {\n        r[1](e);\n      }\n      return o;\n    }\n  };",
  "8318": "const r = require(\"path\"),\n  o = require(\"child_process\"),\n  { promises: i, constants: s } = require(\"fs\"),\n  a = require(2818),\n  c = require(1595),\n  l = require(1906),\n  u = r.join(__dirname, \"xdg-open\"),\n  { platform: d, arch: p } = process,\n  h = (() => {\n    const e = \"/mnt/\";\n    let t;\n    return async function () {\n      if (t) return t;\n      const n = \"/etc/wsl.conf\";\n      let r = !1;\n      try {\n        await i.access(n, s.F_OK);\n        r = !0;\n      } catch {}\n      if (!r) return e;\n      const o = await i.readFile(n, {\n          encoding: \"utf8\",\n        }),\n        a = /(?<!#.*)root\\s*=\\s*(?<mountPoint>.*)/g.exec(o);\n      return a\n        ? ((t = a.groups.mountPoint.trim()),\n          (t = t.endsWith(\"/\") ? t : `${t}/`),\n          t)\n        : e;\n    };\n  })(),\n  f = async (e, t) => {\n    let n;\n    for (const r of e)\n      try {\n        return await t(r);\n      } catch (e) {\n        n = e;\n      }\n    throw n;\n  },\n  m = async (e) => {\n    e = {\n      wait: !1,\n      background: !1,\n      newInstance: !1,\n      allowNonzeroExitCode: !1,\n      ...e,\n    };\n    if (Array.isArray(e.app))\n      return f(e.app, (t) =>\n        m({\n          ...e,\n          app: t,\n        })\n      );\n    let t,\n      { name: n, arguments: r = [] } = e.app || {};\n    r = [...r];\n    if (Array.isArray(n))\n      return f(n, (t) =>\n        m({\n          ...e,\n          app: {\n            name: t,\n            arguments: r,\n          },\n        })\n      );\n    const l = [],\n      p = {};\n    if (\"darwin\" === d) {\n      t = \"open\";\n      if (e.wait) {\n        l.push(\"--wait-apps\");\n      }\n      if (e.background) {\n        l.push(\"--background\");\n      }\n      if (e.newInstance) {\n        l.push(\"--new\");\n      }\n      if (n) {\n        l.push(\"-a\", n);\n      }\n    } else if (\"win32\" === d || (a && !c())) {\n      const o = await h();\n      t = a\n        ? `${o}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`\n        : `${process.env.SYSTEMROOT}\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell`;\n      l.push(\n        \"-NoProfile\",\n        \"-NonInteractive\",\n        \"ExecutionPolicy\",\n        \"Bypass\",\n        \"-EncodedCommand\"\n      );\n      if (a) {\n        p.windowsVerbatimArguments = !0;\n      }\n      const i = [\"Start\"];\n      if (e.wait) {\n        i.push(\"-Wait\");\n      }\n      if (n) {\n        i.push(`\"\\`\"${n}\\`\"\"`, \"-ArgumentList\");\n        if (e.target) {\n          r.unshift(e.target);\n        }\n      } else {\n        if (e.target) {\n          i.push(`\"${e.target}\"`);\n        }\n      }\n      if (r.length > 0) {\n        r = r.map((e) => `\"\\`\"${e}\\`\"\"`);\n        i.push(r.join(\",\"));\n      }\n      e.target = Buffer.from(i.join(\" \"), \"utf16le\").toString(\"base64\");\n    } else {\n      if (n) t = n;\n      else {\n        const e = \"/\" === __dirname;\n        let n = !1;\n        try {\n          await i.access(u, s.X_OK);\n          n = !0;\n        } catch {}\n        t =\n          process.versions.electron || \"android\" === d || e || !n\n            ? \"xdg-open\"\n            : u;\n      }\n      if (r.length > 0) {\n        l.push(...r);\n      }\n      if (e.wait) {\n        p.stdio = \"ignore\";\n        p.detached = !0;\n      }\n    }\n    if (e.target) {\n      l.push(e.target);\n    }\n    if (\"darwin\" === d && r.length > 0) {\n      l.push(\"--args\", ...r);\n    }\n    const g = o.spawn(t, l, p);\n    return e.wait\n      ? new Promise((t, n) => {\n          g.once(\"error\", n);\n          g.once(\"close\", (r) => {\n            if (e.allowNonzeroExitCode && r > 0) {\n              n(new Error(`Exited with code ${r}`));\n            } else {\n              t(g);\n            }\n          });\n        })\n      : (g.unref(), g);\n  },\n  g = (e, t) => {\n    if (\"string\" != typeof e) throw new TypeError(\"Expected a `target`\");\n    return m({\n      ...t,\n      target: e,\n    });\n  };\nfunction _(e) {\n  if (\"string\" == typeof e || Array.isArray(e)) return e;\n  const { [p]: t } = e;\n  if (!t) throw new Error(`${p} is not supported`);\n  return t;\n}\nfunction y({ [d]: e }, { wsl: t }) {\n  if (t && a) return _(t);\n  if (!e) throw new Error(`${d} is not supported`);\n  return _(e);\n}\nconst v = {};\nl(v, \"chrome\", () =>\n  y(\n    {\n      darwin: \"google chrome\",\n      win32: \"chrome\",\n      linux: [\"google-chrome\", \"google-chrome-stable\", \"chromium\"],\n    },\n    {\n      wsl: {\n        ia32: \"/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe\",\n        x64: [\n          \"/mnt/c/Program Files/Google/Chrome/Application/chrome.exe\",\n          \"/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe\",\n        ],\n      },\n    }\n  )\n);\nl(v, \"firefox\", () =>\n  y(\n    {\n      darwin: \"firefox\",\n      win32: \"C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe\",\n      linux: \"firefox\",\n    },\n    {\n      wsl: \"/mnt/c/Program Files/Mozilla Firefox/firefox.exe\",\n    }\n  )\n);\nl(v, \"edge\", () =>\n  y(\n    {\n      darwin: \"microsoft edge\",\n      win32: \"msedge\",\n      linux: [\"microsoft-edge\", \"microsoft-edge-dev\"],\n    },\n    {\n      wsl: \"/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe\",\n    }\n  )\n);\ng.apps = v;\ng.openApp = (e, t) => {\n  if (\"string\" != typeof e) throw new TypeError(\"Expected a `name`\");\n  const { arguments: n = [] } = t || {};\n  if (null != n && !Array.isArray(n))\n    throw new TypeError(\"Expected `appArguments` as Array type\");\n  return m({\n    ...t,\n    app: {\n      name: e,\n      arguments: n,\n    },\n  });\n};\nmodule.exports = g;",
  "8339": "var r,\n  o =\n    (this && this.__extends) ||\n    ((r =\n      Object.setPrototypeOf ||\n      ({\n        __proto__: [],\n      } instanceof Array &&\n        function (e, t) {\n          e.__proto__ = t;\n        }) ||\n      function (e, t) {\n        for (var n in t)\n          if (t.hasOwnProperty(n)) {\n            e[n] = t[n];\n          }\n      }),\n    function (e, t) {\n      function n() {\n        this.constructor = e;\n      }\n      r(e, t);\n      e.prototype =\n        null === t ? Object.create(t) : ((n.prototype = t.prototype), new n());\n    }),\n  i = require(\"url\"),\n  s = require(5290),\n  a = require(5740),\n  c = require(9036),\n  l = require(3054),\n  u = require(9962),\n  d = (function (e) {\n    function t(n, r) {\n      var o = e.call(this) || this;\n      if (r && r.method && n) {\n        o.method = r.method;\n        o.url = t._getUrlFromRequestOptions(n, r);\n        o.startTime = +new Date();\n      }\n      return o;\n    }\n    o(t, e);\n    t.prototype.onError = function (e) {\n      this._setStatus(undefined, e);\n    };\n    t.prototype.onResponse = function (e) {\n      this._setStatus(e.statusCode, undefined);\n      this.correlationId = a.getCorrelationContextTarget(\n        e,\n        c.requestContextTargetKey\n      );\n    };\n    t.prototype.getDependencyTelemetry = function (e, t) {\n      var n = i.parse(this.url);\n      n.search = undefined;\n      n.hash = undefined;\n      var r = this.method.toUpperCase() + \" \" + n.pathname,\n        o = s.RemoteDependencyDataConstants.TYPE_HTTP,\n        a = n.hostname;\n      if (this.correlationId) {\n        o = s.RemoteDependencyDataConstants.TYPE_AI;\n        if (this.correlationId !== u.correlationIdPrefix) {\n          a = n.hostname + \" | \" + this.correlationId;\n        }\n      } else {\n        o = s.RemoteDependencyDataConstants.TYPE_HTTP;\n      }\n      if (n.port) {\n        a += \":\" + n.port;\n      }\n      var c = {\n        id: t,\n        name: r,\n        data: this.url,\n        duration: this.duration,\n        success: this._isSuccess(),\n        resultCode: this.statusCode ? this.statusCode.toString() : null,\n        properties: this.properties || {},\n        dependencyTypeName: o,\n        target: a,\n      };\n      if (e) {\n        for (var l in e)\n          if (c[l]) {\n            c[l] = e[l];\n          }\n        if (e.properties)\n          for (var l in e.properties) c.properties[l] = e.properties[l];\n      }\n      return c;\n    };\n    t._getUrlFromRequestOptions = function (e, t) {\n      if (\"string\" == typeof e) e = i.parse(e);\n      else {\n        var n = e;\n        e = {};\n        if (n) {\n          Object.keys(n).forEach(function (t) {\n            e[t] = n[t];\n          });\n        }\n      }\n      if (e.path) {\n        var r = i.parse(e.path);\n        e.pathname = r.pathname;\n        e.search = r.search;\n      }\n      if (e.host && e.port && !i.parse(\"http://\" + e.host).port && e.port) {\n        e.hostname = e.host;\n        delete e.host;\n      }\n      e.protocol = e.protocol || (t.agent && t.agent.protocol) || undefined;\n      e.hostname = e.hostname || \"localhost\";\n      return i.format(e);\n    };\n    return t;\n  })(l);\nmodule.exports = d;",
  "8348": "const t =\n    \"object\" == typeof performance &&\n    performance &&\n    \"function\" == typeof performance.now\n      ? performance\n      : Date,\n  n =\n    \"function\" == typeof AbortController\n      ? AbortController\n      : class {\n          constructor() {\n            this.signal = new i();\n          }\n          abort() {\n            this.signal.dispatchEvent(\"abort\");\n          }\n        },\n  r = \"function\" == typeof AbortSignal,\n  o = \"function\" == typeof n.AbortSignal,\n  i = r\n    ? AbortSignal\n    : o\n    ? n.AbortController\n    : class {\n        constructor() {\n          this.aborted = !1;\n          this._listeners = [];\n        }\n        dispatchEvent(e) {\n          if (\"abort\" === e) {\n            this.aborted = !0;\n            const t = {\n              type: e,\n              target: this,\n            };\n            this.onabort(t);\n            this._listeners.forEach((e) => e(t), this);\n          }\n        }\n        onabort() {}\n        addEventListener(e, t) {\n          if (\"abort\" === e) {\n            this._listeners.push(t);\n          }\n        }\n        removeEventListener(e, t) {\n          if (\"abort\" === e) {\n            this._listeners = this._listeners.filter((e) => e !== t);\n          }\n        }\n      },\n  s = new Set(),\n  a = (e, t) => {\n    const n = `LRU_CACHE_OPTION_${e}`;\n    if (u(n)) {\n      d(n, `${e} option`, `options.${t}`, g);\n    }\n  },\n  c = (e, t) => {\n    const n = `LRU_CACHE_METHOD_${e}`;\n    if (u(n)) {\n      const { prototype: r } = g,\n        { get: o } = Object.getOwnPropertyDescriptor(r, e);\n      d(n, `${e} method`, `cache.${t}()`, o);\n    }\n  },\n  l = (...e) => {\n    if (\n      \"object\" == typeof process &&\n      process &&\n      \"function\" == typeof process.emitWarning\n    ) {\n      process.emitWarning(...e);\n    } else {\n      console.error(...e);\n    }\n  },\n  u = (e) => !s.has(e),\n  d = (e, t, n, r) => {\n    s.add(e);\n    l(\n      `The ${t} is deprecated. Please use ${n} instead.`,\n      \"DeprecationWarning\",\n      e,\n      r\n    );\n  },\n  p = (e) => e && e === Math.floor(e) && e > 0 && isFinite(e),\n  h = (e) =>\n    p(e)\n      ? e <= Math.pow(2, 8)\n        ? Uint8Array\n        : e <= Math.pow(2, 16)\n        ? Uint16Array\n        : e <= Math.pow(2, 32)\n        ? Uint32Array\n        : e <= Number.MAX_SAFE_INTEGER\n        ? f\n        : null\n      : null;\nclass f extends Array {\n  constructor(e) {\n    super(e);\n    this.fill(0);\n  }\n}\nclass m {\n  constructor(e) {\n    if (0 === e) return [];\n    const t = h(e);\n    this.heap = new t(e);\n    this.length = 0;\n  }\n  push(e) {\n    this.heap[this.length++] = e;\n  }\n  pop() {\n    return this.heap[--this.length];\n  }\n}\nclass g {\n  constructor(e = {}) {\n    const {\n        max: t = 0,\n        ttl: n,\n        ttlResolution: r = 1,\n        ttlAutopurge: o,\n        updateAgeOnGet: i,\n        updateAgeOnHas: c,\n        allowStale: d,\n        dispose: f,\n        disposeAfter: _,\n        noDisposeOnSet: y,\n        noUpdateTTL: v,\n        maxSize: b = 0,\n        sizeCalculation: w,\n        fetchMethod: x,\n        fetchContext: E,\n        noDeleteOnFetchRejection: C,\n        noDeleteOnStaleGet: S,\n      } = e,\n      { length: T, maxAge: k, stale: I } = e instanceof g ? {} : e;\n    if (0 !== t && !p(t))\n      throw new TypeError(\"max option must be a nonnegative integer\");\n    const P = t ? h(t) : Array;\n    if (!P) throw new Error(\"invalid max value: \" + t);\n    this.max = t;\n    this.maxSize = b;\n    this.sizeCalculation = w || T;\n    if (this.sizeCalculation) {\n      if (!this.maxSize)\n        throw new TypeError(\n          \"cannot set sizeCalculation without setting maxSize\"\n        );\n      if (\"function\" != typeof this.sizeCalculation)\n        throw new TypeError(\"sizeCalculation set to non-function\");\n    }\n    this.fetchMethod = x || null;\n    if (this.fetchMethod && \"function\" != typeof this.fetchMethod)\n      throw new TypeError(\"fetchMethod must be a function if specified\");\n    this.fetchContext = E;\n    if (!this.fetchMethod && void 0 !== E)\n      throw new TypeError(\"cannot set fetchContext without fetchMethod\");\n    this.keyMap = new Map();\n    this.keyList = new Array(t).fill(null);\n    this.valList = new Array(t).fill(null);\n    this.next = new P(t);\n    this.prev = new P(t);\n    this.head = 0;\n    this.tail = 0;\n    this.free = new m(t);\n    this.initialFill = 1;\n    this.size = 0;\n    if (\"function\" == typeof f) {\n      this.dispose = f;\n    }\n    if (\"function\" == typeof _) {\n      this.disposeAfter = _;\n      this.disposed = [];\n    } else {\n      this.disposeAfter = null;\n      this.disposed = null;\n    }\n    this.noDisposeOnSet = !!y;\n    this.noUpdateTTL = !!v;\n    this.noDeleteOnFetchRejection = !!C;\n    if (0 !== this.maxSize) {\n      if (!p(this.maxSize))\n        throw new TypeError(\"maxSize must be a positive integer if specified\");\n      this.initializeSizeTracking();\n    }\n    this.allowStale = !!d || !!I;\n    this.noDeleteOnStaleGet = !!S;\n    this.updateAgeOnGet = !!i;\n    this.updateAgeOnHas = !!c;\n    this.ttlResolution = p(r) || 0 === r ? r : 1;\n    this.ttlAutopurge = !!o;\n    this.ttl = n || k || 0;\n    if (this.ttl) {\n      if (!p(this.ttl))\n        throw new TypeError(\"ttl must be a positive integer if specified\");\n      this.initializeTTLTracking();\n    }\n    if (0 === this.max && 0 === this.ttl && 0 === this.maxSize)\n      throw new TypeError(\"At least one of max, maxSize, or ttl is required\");\n    if (!this.ttlAutopurge && !this.max && !this.maxSize) {\n      const e = \"LRU_CACHE_UNBOUNDED\";\n      if (u(e)) {\n        s.add(e);\n        l(\n          \"TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.\",\n          \"UnboundedCacheWarning\",\n          e,\n          g\n        );\n      }\n    }\n    if (I) {\n      a(\"stale\", \"allowStale\");\n    }\n    if (k) {\n      a(\"maxAge\", \"ttl\");\n    }\n    if (T) {\n      a(\"length\", \"sizeCalculation\");\n    }\n  }\n  getRemainingTTL(e) {\n    return this.has(e, {\n      updateAgeOnHas: !1,\n    })\n      ? 1 / 0\n      : 0;\n  }\n  initializeTTLTracking() {\n    this.ttls = new f(this.max);\n    this.starts = new f(this.max);\n    this.setItemTTL = (e, n, r = t.now()) => {\n      this.starts[e] = 0 !== n ? r : 0;\n      this.ttls[e] = n;\n      if (0 !== n && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          this.isStale(e) && this.delete(this.keyList[e]);\n        }, n + 1);\n        t.unref && t.unref();\n      }\n    };\n    this.updateItemAge = (e) => {\n      this.starts[e] = 0 !== this.ttls[e] ? t.now() : 0;\n    };\n    let e = 0;\n    const n = () => {\n      const n = t.now();\n      if (this.ttlResolution > 0) {\n        e = n;\n        const t = setTimeout(() => (e = 0), this.ttlResolution);\n        if (t.unref) {\n          t.unref();\n        }\n      }\n      return n;\n    };\n    this.getRemainingTTL = (t) => {\n      const r = this.keyMap.get(t);\n      return undefined === r\n        ? 0\n        : 0 === this.ttls[r] || 0 === this.starts[r]\n        ? 1 / 0\n        : this.starts[r] + this.ttls[r] - (e || n());\n    };\n    this.isStale = (t) =>\n      0 !== this.ttls[t] &&\n      0 !== this.starts[t] &&\n      (e || n()) - this.starts[t] > this.ttls[t];\n  }\n  updateItemAge(e) {}\n  setItemTTL(e, t, n) {}\n  isStale(e) {\n    return !1;\n  }\n  initializeSizeTracking() {\n    this.calculatedSize = 0;\n    this.sizes = new f(this.max);\n    this.removeItemSize = (e) => {\n      this.calculatedSize -= this.sizes[e];\n      this.sizes[e] = 0;\n    };\n    this.requireSize = (e, t, n, r) => {\n      if (!p(n)) {\n        if (!r)\n          throw new TypeError(\"invalid size value (must be positive integer)\");\n        if (\"function\" != typeof r)\n          throw new TypeError(\"sizeCalculation must be a function\");\n        n = r(t, e);\n        if (!p(n))\n          throw new TypeError(\n            \"sizeCalculation return invalid (expect positive integer)\"\n          );\n      }\n      return n;\n    };\n    this.addItemSize = (e, t) => {\n      this.sizes[e] = t;\n      const n = this.maxSize - this.sizes[e];\n      for (; this.calculatedSize > n; ) this.evict(!0);\n      this.calculatedSize += this.sizes[e];\n    };\n  }\n  removeItemSize(e) {}\n  addItemSize(e, t) {}\n  requireSize(e, t, n, r) {\n    if (n || r)\n      throw new TypeError(\"cannot set size without setting maxSize on cache\");\n  }\n  *indexes({ allowStale: e = this.allowStale } = {}) {\n    if (this.size)\n      for (\n        let t = this.tail;\n        this.isValidIndex(t) &&\n        ((!e && this.isStale(t)) || (yield t), t !== this.head);\n\n      )\n        t = this.prev[t];\n  }\n  *rindexes({ allowStale: e = this.allowStale } = {}) {\n    if (this.size)\n      for (\n        let t = this.head;\n        this.isValidIndex(t) &&\n        ((!e && this.isStale(t)) || (yield t), t !== this.tail);\n\n      )\n        t = this.next[t];\n  }\n  isValidIndex(e) {\n    return this.keyMap.get(this.keyList[e]) === e;\n  }\n  *entries() {\n    for (const e of this.indexes()) yield [this.keyList[e], this.valList[e]];\n  }\n  *rentries() {\n    for (const e of this.rindexes()) yield [this.keyList[e], this.valList[e]];\n  }\n  *keys() {\n    for (const e of this.indexes()) yield this.keyList[e];\n  }\n  *rkeys() {\n    for (const e of this.rindexes()) yield this.keyList[e];\n  }\n  *values() {\n    for (const e of this.indexes()) yield this.valList[e];\n  }\n  *rvalues() {\n    for (const e of this.rindexes()) yield this.valList[e];\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  find(e, t = {}) {\n    for (const n of this.indexes())\n      if (e(this.valList[n], this.keyList[n], this))\n        return this.get(this.keyList[n], t);\n  }\n  forEach(e, t = this) {\n    for (const n of this.indexes())\n      e.call(t, this.valList[n], this.keyList[n], this);\n  }\n  rforEach(e, t = this) {\n    for (const n of this.rindexes())\n      e.call(t, this.valList[n], this.keyList[n], this);\n  }\n  get prune() {\n    c(\"prune\", \"purgeStale\");\n    return this.purgeStale;\n  }\n  purgeStale() {\n    let e = !1;\n    for (const t of this.rindexes({\n      allowStale: !0,\n    }))\n      if (this.isStale(t)) {\n        this.delete(this.keyList[t]);\n        e = !0;\n      }\n    return e;\n  }\n  dump() {\n    const e = [];\n    for (const n of this.indexes({\n      allowStale: !0,\n    })) {\n      const r = this.keyList[n],\n        o = this.valList[n],\n        i = {\n          value: this.isBackgroundFetch(o) ? o.__staleWhileFetching : o,\n        };\n      if (this.ttls) {\n        i.ttl = this.ttls[n];\n        const e = t.now() - this.starts[n];\n        i.start = Math.floor(Date.now() - e);\n      }\n      if (this.sizes) {\n        i.size = this.sizes[n];\n      }\n      e.unshift([r, i]);\n    }\n    return e;\n  }\n  load(e) {\n    this.clear();\n    for (const [n, r] of e) {\n      if (r.start) {\n        const e = Date.now() - r.start;\n        r.start = t.now() - e;\n      }\n      this.set(n, r.value, r);\n    }\n  }\n  dispose(e, t, n) {}\n  set(\n    e,\n    t,\n    {\n      ttl: n = this.ttl,\n      start: r,\n      noDisposeOnSet: o = this.noDisposeOnSet,\n      size: i = 0,\n      sizeCalculation: s = this.sizeCalculation,\n      noUpdateTTL: a = this.noUpdateTTL,\n    } = {}\n  ) {\n    i = this.requireSize(e, t, i, s);\n    if (this.maxSize && i > this.maxSize) return this;\n    let c = 0 === this.size ? undefined : this.keyMap.get(e);\n    if (undefined === c) {\n      c = this.newIndex();\n      this.keyList[c] = e;\n      this.valList[c] = t;\n      this.keyMap.set(e, c);\n      this.next[this.tail] = c;\n      this.prev[c] = this.tail;\n      this.tail = c;\n      this.size++;\n      this.addItemSize(c, i);\n      a = !1;\n    } else {\n      const n = this.valList[c];\n      if (t !== n) {\n        if (this.isBackgroundFetch(n)) {\n          n.__abortController.abort();\n        } else {\n          if (o) {\n            this.dispose(n, e, \"set\");\n            if (this.disposeAfter) {\n              this.disposed.push([n, e, \"set\"]);\n            }\n          }\n        }\n        this.removeItemSize(c);\n        this.valList[c] = t;\n        this.addItemSize(c, i);\n      }\n      this.moveToTail(c);\n    }\n    if (0 === n || 0 !== this.ttl || this.ttls) {\n      this.initializeTTLTracking();\n    }\n    if (a) {\n      this.setItemTTL(c, n, r);\n    }\n    if (this.disposeAfter)\n      for (; this.disposed.length; )\n        this.disposeAfter(...this.disposed.shift());\n    return this;\n  }\n  newIndex() {\n    return 0 === this.size\n      ? this.tail\n      : this.size === this.max && 0 !== this.max\n      ? this.evict(!1)\n      : 0 !== this.free.length\n      ? this.free.pop()\n      : this.initialFill++;\n  }\n  pop() {\n    if (this.size) {\n      const e = this.valList[this.head];\n      this.evict(!0);\n      return e;\n    }\n  }\n  evict(e) {\n    const t = this.head,\n      n = this.keyList[t],\n      r = this.valList[t];\n    if (this.isBackgroundFetch(r)) {\n      r.__abortController.abort();\n    } else {\n      this.dispose(r, n, \"evict\");\n      if (this.disposeAfter) {\n        this.disposed.push([r, n, \"evict\"]);\n      }\n    }\n    this.removeItemSize(t);\n    if (e) {\n      this.keyList[t] = null;\n      this.valList[t] = null;\n      this.free.push(t);\n    }\n    this.head = this.next[t];\n    this.keyMap.delete(n);\n    this.size--;\n    return t;\n  }\n  has(e, { updateAgeOnHas: t = this.updateAgeOnHas } = {}) {\n    const n = this.keyMap.get(e);\n    return (\n      undefined !== n && !this.isStale(n) && (t && this.updateItemAge(n), !0)\n    );\n  }\n  peek(e, { allowStale: t = this.allowStale } = {}) {\n    const n = this.keyMap.get(e);\n    if (undefined !== n && (t || !this.isStale(n))) {\n      const e = this.valList[n];\n      return this.isBackgroundFetch(e) ? e.__staleWhileFetching : e;\n    }\n  }\n  backgroundFetch(e, t, r, o) {\n    const i = undefined === t ? undefined : this.valList[t];\n    if (this.isBackgroundFetch(i)) return i;\n    const s = new n(),\n      a = {\n        signal: s.signal,\n        options: r,\n        context: o,\n      },\n      c = new Promise((t) => t(this.fetchMethod(e, i, a))).then(\n        (t) => (s.signal.aborted || this.set(e, t, a.options), t),\n        (n) => {\n          if (this.valList[t] === c) {\n            if (\n              r.noDeleteOnFetchRejection &&\n              undefined !== c.__staleWhileFetching\n            ) {\n              this.valList[t] = c.__staleWhileFetching;\n            } else {\n              this.delete(e);\n            }\n          }\n          if (c.__returned === c) throw n;\n        }\n      );\n    c.__abortController = s;\n    c.__staleWhileFetching = i;\n    c.__returned = null;\n    if (undefined === t) {\n      this.set(e, c, a.options);\n      t = this.keyMap.get(e);\n    } else {\n      this.valList[t] = c;\n    }\n    return c;\n  }\n  isBackgroundFetch(e) {\n    return (\n      e &&\n      \"object\" == typeof e &&\n      \"function\" == typeof e.then &&\n      Object.prototype.hasOwnProperty.call(e, \"__staleWhileFetching\") &&\n      Object.prototype.hasOwnProperty.call(e, \"__returned\") &&\n      (e.__returned === e || null === e.__returned)\n    );\n  }\n  async fetch(\n    e,\n    {\n      allowStale: t = this.allowStale,\n      updateAgeOnGet: n = this.updateAgeOnGet,\n      noDeleteOnStaleGet: r = this.noDeleteOnStaleGet,\n      ttl: o = this.ttl,\n      noDisposeOnSet: i = this.noDisposeOnSet,\n      size: s = 0,\n      sizeCalculation: a = this.sizeCalculation,\n      noUpdateTTL: c = this.noUpdateTTL,\n      noDeleteOnFetchRejection: l = this.noDeleteOnFetchRejection,\n      fetchContext: u = this.fetchContext,\n      forceRefresh: d = !1,\n    } = {}\n  ) {\n    if (!this.fetchMethod)\n      return this.get(e, {\n        allowStale: t,\n        updateAgeOnGet: n,\n        noDeleteOnStaleGet: r,\n      });\n    const p = {\n      allowStale: t,\n      updateAgeOnGet: n,\n      noDeleteOnStaleGet: r,\n      ttl: o,\n      noDisposeOnSet: i,\n      size: s,\n      sizeCalculation: a,\n      noUpdateTTL: c,\n      noDeleteOnFetchRejection: l,\n    };\n    let h = this.keyMap.get(e);\n    if (undefined === h) {\n      const t = this.backgroundFetch(e, h, p, u);\n      return (t.__returned = t);\n    }\n    {\n      const r = this.valList[h];\n      if (this.isBackgroundFetch(r))\n        return t && undefined !== r.__staleWhileFetching\n          ? r.__staleWhileFetching\n          : (r.__returned = r);\n      if (!d && !this.isStale(h)) {\n        this.moveToTail(h);\n        if (n) {\n          this.updateItemAge(h);\n        }\n        return r;\n      }\n      const o = this.backgroundFetch(e, h, p, u);\n      return t && undefined !== o.__staleWhileFetching\n        ? o.__staleWhileFetching\n        : (o.__returned = o);\n    }\n  }\n  get(\n    e,\n    {\n      allowStale: t = this.allowStale,\n      updateAgeOnGet: n = this.updateAgeOnGet,\n      noDeleteOnStaleGet: r = this.noDeleteOnStaleGet,\n    } = {}\n  ) {\n    const o = this.keyMap.get(e);\n    if (undefined !== o) {\n      const i = this.valList[o],\n        s = this.isBackgroundFetch(i);\n      if (this.isStale(o))\n        return s\n          ? t\n            ? i.__staleWhileFetching\n            : undefined\n          : (r || this.delete(e), t ? i : undefined);\n      if (s) return;\n      this.moveToTail(o);\n      if (n) {\n        this.updateItemAge(o);\n      }\n      return i;\n    }\n  }\n  connect(e, t) {\n    this.prev[t] = e;\n    this.next[e] = t;\n  }\n  moveToTail(e) {\n    if (e !== this.tail) {\n      if (e === this.head) {\n        this.head = this.next[e];\n      } else {\n        this.connect(this.prev[e], this.next[e]);\n      }\n      this.connect(this.tail, e);\n      this.tail = e;\n    }\n  }\n  get del() {\n    c(\"del\", \"delete\");\n    return this.delete;\n  }\n  delete(e) {\n    let t = !1;\n    if (0 !== this.size) {\n      const n = this.keyMap.get(e);\n      if (undefined !== n) {\n        t = !0;\n        if (1 === this.size) this.clear();\n        else {\n          this.removeItemSize(n);\n          const t = this.valList[n];\n          if (this.isBackgroundFetch(t)) {\n            t.__abortController.abort();\n          } else {\n            this.dispose(t, e, \"delete\");\n            if (this.disposeAfter) {\n              this.disposed.push([t, e, \"delete\"]);\n            }\n          }\n          this.keyMap.delete(e);\n          this.keyList[n] = null;\n          this.valList[n] = null;\n          if (n === this.tail) {\n            this.tail = this.prev[n];\n          } else {\n            if (n === this.head) {\n              this.head = this.next[n];\n            } else {\n              this.next[this.prev[n]] = this.next[n];\n              this.prev[this.next[n]] = this.prev[n];\n            }\n          }\n          this.size--;\n          this.free.push(n);\n        }\n      }\n    }\n    if (this.disposed)\n      for (; this.disposed.length; )\n        this.disposeAfter(...this.disposed.shift());\n    return t;\n  }\n  clear() {\n    for (const e of this.rindexes({\n      allowStale: !0,\n    })) {\n      const t = this.valList[e];\n      if (this.isBackgroundFetch(t)) t.__abortController.abort();\n      else {\n        const n = this.keyList[e];\n        this.dispose(t, n, \"delete\");\n        if (this.disposeAfter) {\n          this.disposed.push([t, n, \"delete\"]);\n        }\n      }\n    }\n    this.keyMap.clear();\n    this.valList.fill(null);\n    this.keyList.fill(null);\n    if (this.ttls) {\n      this.ttls.fill(0);\n      this.starts.fill(0);\n    }\n    if (this.sizes) {\n      this.sizes.fill(0);\n    }\n    this.head = 0;\n    this.tail = 0;\n    this.initialFill = 1;\n    this.free.length = 0;\n    this.calculatedSize = 0;\n    this.size = 0;\n    if (this.disposed)\n      for (; this.disposed.length; )\n        this.disposeAfter(...this.disposed.shift());\n  }\n  get reset() {\n    c(\"reset\", \"clear\");\n    return this.clear;\n  }\n  get length() {\n    ((e, t) => {\n      const n = \"LRU_CACHE_PROPERTY_length\";\n      if (u(n)) {\n        const { prototype: t } = g,\n          { get: r } = Object.getOwnPropertyDescriptor(t, e);\n        d(n, \"length property\", \"cache.size\", r);\n      }\n    })(\"length\");\n    return this.size;\n  }\n  static get AbortController() {\n    return n;\n  }\n  static get AbortSignal() {\n    return i;\n  }\n}\nmodule.exports = g;",
  "8359": "const { AbortSignal: r } = require(6829),\n  { Body: o, cloneStream: i, guessContentType: s } = require(5600),\n  { Headers: a } = require(9872),\n  { isPlainObject: c } = require(4544),\n  { isFormData: l, FormDataSerializer: u } = require(9407),\n  d = Symbol(\"Request internals\");\nclass p extends o {\n  constructor(e, t = {}) {\n    const n = e instanceof p ? e : null,\n      o = n ? new URL(n.url) : new URL(e);\n    let h = t.method || (n && n.method) || \"GET\";\n    h = h.toUpperCase();\n    if (\n      (null != t.body || (n && null !== n.body)) &&\n      [\"GET\", \"HEAD\"].includes(h)\n    )\n      throw new TypeError(\"Request with GET/HEAD method cannot have body\");\n    let f = t.body || (n && n.body ? i(n) : null);\n    const m = new a(t.headers || (n && n.headers) || {});\n    if (l(f) && !m.has(\"content-type\")) {\n      const e = new u(f);\n      f = e.stream();\n      m.set(\"content-type\", e.contentType());\n      if (m.has(\"transfer-encoding\") || m.has(\"content-length\")) {\n        m.set(\"content-length\", e.length());\n      }\n    }\n    if (!m.has(\"content-type\"))\n      if (c(f)) {\n        f = JSON.stringify(f);\n        m.set(\"content-type\", \"application/json\");\n      } else {\n        const e = s(f);\n        if (e) {\n          m.set(\"content-type\", e);\n        }\n      }\n    super(f);\n    let g = n ? n.signal : null;\n    if (\"signal\" in t) {\n      g = t.signal;\n    }\n    if (g && !(g instanceof r))\n      throw new TypeError(\"signal needs to be an instance of AbortSignal\");\n    const _ = t.redirect || (n && n.redirect) || \"follow\";\n    if (![\"follow\", \"error\", \"manual\"].includes(_))\n      throw new TypeError(`'${_}' is not a valid redirect option`);\n    const y = t.cache || (n && n.cache) || \"default\";\n    if (\n      ![\n        \"default\",\n        \"no-store\",\n        \"reload\",\n        \"no-cache\",\n        \"force-cache\",\n        \"only-if-cached\",\n      ].includes(y)\n    )\n      throw new TypeError(`'${y}' is not a valid cache option`);\n    this[d] = {\n      init: {\n        ...t,\n      },\n      method: h,\n      redirect: _,\n      cache: y,\n      headers: m,\n      parsedURL: o,\n      signal: g,\n    };\n    if (undefined === t.follow) {\n      if (n && undefined !== n.follow) {\n        this.follow = n.follow;\n      } else {\n        this.follow = 20;\n      }\n    } else {\n      this.follow = t.follow;\n    }\n    this.counter = t.counter || (n && n.counter) || 0;\n    if (undefined === t.compress) {\n      if (n && undefined !== n.compress) {\n        this.compress = n.compress;\n      } else {\n        this.compress = !0;\n      }\n    } else {\n      this.compress = t.compress;\n    }\n    if (undefined === t.decode) {\n      if (n && undefined !== n.decode) {\n        this.decode = n.decode;\n      } else {\n        this.decode = !0;\n      }\n    } else {\n      this.decode = t.decode;\n    }\n  }\n  get method() {\n    return this[d].method;\n  }\n  get url() {\n    return this[d].parsedURL.toString();\n  }\n  get headers() {\n    return this[d].headers;\n  }\n  get redirect() {\n    return this[d].redirect;\n  }\n  get cache() {\n    return this[d].cache;\n  }\n  get signal() {\n    return this[d].signal;\n  }\n  clone() {\n    return new p(this);\n  }\n  get init() {\n    return this[d].init;\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\nObject.defineProperties(p.prototype, {\n  method: {\n    enumerable: !0,\n  },\n  url: {\n    enumerable: !0,\n  },\n  headers: {\n    enumerable: !0,\n  },\n  redirect: {\n    enumerable: !0,\n  },\n  cache: {\n    enumerable: !0,\n  },\n  clone: {\n    enumerable: !0,\n  },\n  signal: {\n    enumerable: !0,\n  },\n});\nmodule.exports = {\n  Request: p,\n};",
  "8386": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst n = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID');\n  },\n};\nexports.default = n;",
  "8436": "var r =\n  (this && this.__assign) ||\n  Object.assign ||\n  function (e) {\n    for (var t, n = 1, r = arguments.length; n < r; n++)\n      for (var o in (t = arguments[n]))\n        if (Object.prototype.hasOwnProperty.call(t, o)) {\n          e[o] = t[o];\n        }\n    return e;\n  };\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar o = require(4953);\nexports.mongo2 = {\n  versionSpecifier: \">= 2.0.0 <= 3.0.5\",\n  patch: function (e) {\n    var t = e.instrument({\n        operationIdGenerator: {\n          next: function () {\n            return o.channel.bindToContext(function (e) {\n              return e();\n            });\n          },\n        },\n      }),\n      n = {};\n    t.on(\"started\", function (e) {\n      if (n[e.requestId]) {\n        n[e.requestId] = r({}, e, {\n          time: new Date(),\n        });\n      }\n    });\n    t.on(\"succeeded\", function (e) {\n      var t = n[e.requestId];\n      if (t) {\n        delete n[e.requestId];\n      }\n      if (\"function\" == typeof e.operationId) {\n        e.operationId(function () {\n          return o.channel.publish(\"mongodb\", {\n            startedData: t,\n            event: e,\n            succeeded: !0,\n          });\n        });\n      } else {\n        o.channel.publish(\"mongodb\", {\n          startedData: t,\n          event: e,\n          succeeded: !0,\n        });\n      }\n    });\n    t.on(\"failed\", function (e) {\n      var t = n[e.requestId];\n      if (t) {\n        delete n[e.requestId];\n      }\n      if (\"function\" == typeof e.operationId) {\n        e.operationId(function () {\n          return o.channel.publish(\"mongodb\", {\n            startedData: t,\n            event: e,\n            succeeded: !1,\n          });\n        });\n      } else {\n        o.channel.publish(\"mongodb\", {\n          startedData: t,\n          event: e,\n          succeeded: !1,\n        });\n      }\n    });\n    return e;\n  },\n};\nexports.mongo3 = {\n  versionSpecifier: \"> 3.0.5 < 3.3.0\",\n  patch: function (e) {\n    var t = e.instrument(),\n      n = {},\n      i = {};\n    t.on(\"started\", function (e) {\n      if (n[e.requestId]) {\n        i[e.requestId] = o.channel.bindToContext(function (e) {\n          return e();\n        });\n        n[e.requestId] = r({}, e, {\n          time: new Date(),\n        });\n      }\n    });\n    t.on(\"succeeded\", function (e) {\n      var t = n[e.requestId];\n      if (t) {\n        delete n[e.requestId];\n      }\n      if (\"object\" == typeof e && \"function\" == typeof i[e.requestId]) {\n        i[e.requestId](function () {\n          return o.channel.publish(\"mongodb\", {\n            startedData: t,\n            event: e,\n            succeeded: !0,\n          });\n        });\n        delete i[e.requestId];\n      }\n    });\n    t.on(\"failed\", function (e) {\n      var t = n[e.requestId];\n      if (t) {\n        delete n[e.requestId];\n      }\n      if (\"object\" == typeof e && \"function\" == typeof i[e.requestId]) {\n        i[e.requestId](function () {\n          return o.channel.publish(\"mongodb\", {\n            startedData: t,\n            event: e,\n            succeeded: !1,\n          });\n        });\n        delete i[e.requestId];\n      }\n    });\n    return e;\n  },\n};\nexports.mongo330 = {\n  versionSpecifier: \">= 3.3.0 < 4.0.0\",\n  patch: function (e) {\n    !(function (e) {\n      var t = e.Server.prototype.connect;\n      e.Server.prototype.connect = function () {\n        var e = t.apply(this, arguments),\n          n = this.s.coreTopology.s.pool.write;\n        this.s.coreTopology.s.pool.write = function () {\n          var e = \"function\" == typeof arguments[1] ? 1 : 2;\n          if (\"function\" == typeof arguments[e]) {\n            arguments[e] = o.channel.bindToContext(arguments[e]);\n          }\n          return n.apply(this, arguments);\n        };\n        var r = this.s.coreTopology.s.pool.logout;\n        this.s.coreTopology.s.pool.logout = function () {\n          if (\"function\" == typeof arguments[1]) {\n            arguments[1] = o.channel.bindToContext(arguments[1]);\n          }\n          return r.apply(this, arguments);\n        };\n        return e;\n      };\n    })(e);\n    var t = e.instrument(),\n      n = {},\n      r = {};\n    t.on(\"started\", function (e) {\n      if (n[e.requestId]) {\n        r[e.requestId] = o.channel.bindToContext(function (e) {\n          return e();\n        });\n        n[e.requestId] = e;\n      }\n    });\n    t.on(\"succeeded\", function (e) {\n      var t = n[e.requestId];\n      if (t) {\n        delete n[e.requestId];\n      }\n      if (\"object\" == typeof e && \"function\" == typeof r[e.requestId]) {\n        r[e.requestId](function () {\n          return o.channel.publish(\"mongodb\", {\n            startedData: t,\n            event: e,\n            succeeded: !0,\n          });\n        });\n        delete r[e.requestId];\n      }\n    });\n    t.on(\"failed\", function (e) {\n      var t = n[e.requestId];\n      if (t) {\n        delete n[e.requestId];\n      }\n      if (\"object\" == typeof e && \"function\" == typeof r[e.requestId]) {\n        r[e.requestId](function () {\n          return o.channel.publish(\"mongodb\", {\n            startedData: t,\n            event: e,\n            succeeded: !1,\n          });\n        });\n        delete r[e.requestId];\n      }\n    });\n    return e;\n  },\n};\nexports.enable = function () {\n  o.channel.registerMonkeyPatch(\"mongodb\", exports.mongo2);\n  o.channel.registerMonkeyPatch(\"mongodb\", exports.mongo3);\n  o.channel.registerMonkeyPatch(\"mongodb\", exports.mongo330);\n};",
  "8490": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.ValueScope =\n  exports.ValueScopeName =\n  exports.Scope =\n  exports.varKinds =\n  exports.UsedValueState =\n    undefined;\nconst r = require(7023);\nclass o extends Error {\n  constructor(e) {\n    super(`CodeGen: \"code\" for ${e} not defined`);\n    this.value = e.value;\n  }\n}\nvar i;\n!(function (e) {\n  e[(e.Started = 0)] = \"Started\";\n  e[(e.Completed = 1)] = \"Completed\";\n})((i = exports.UsedValueState || (exports.UsedValueState = {})));\nexports.varKinds = {\n  const: new r.Name(\"const\"),\n  let: new r.Name(\"let\"),\n  var: new r.Name(\"var\"),\n};\nclass Scope {\n  constructor({ prefixes: e, parent: t } = {}) {\n    this._names = {};\n    this._prefixes = e;\n    this._parent = t;\n  }\n  toName(e) {\n    return e instanceof r.Name ? e : this.name(e);\n  }\n  name(e) {\n    return new r.Name(this._newName(e));\n  }\n  _newName(e) {\n    return `${e}${(this._names[e] || this._nameGroup(e)).index++}`;\n  }\n  _nameGroup(e) {\n    var t, n;\n    if (\n      (null ===\n        (n =\n          null === (t = this._parent) || undefined === t\n            ? undefined\n            : t._prefixes) || undefined === n\n        ? undefined\n        : n.has(e)) ||\n      (this._prefixes && !this._prefixes.has(e))\n    )\n      throw new Error(`CodeGen: prefix \"${e}\" is not allowed in this scope`);\n    return (this._names[e] = {\n      prefix: e,\n      index: 0,\n    });\n  }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends r.Name {\n  constructor(e, t) {\n    super(t);\n    this.prefix = e;\n  }\n  setValue(e, { property: t, itemIndex: n }) {\n    this.value = e;\n    this.scopePath = r._`.${new r.Name(t)}[${n}]`;\n  }\n}\nexports.ValueScopeName = ValueScopeName;\nconst c = r._`\\n`;\nexports.ValueScope = class extends Scope {\n  constructor(e) {\n    super(e);\n    this._values = {};\n    this._scope = e.scope;\n    this.opts = {\n      ...e,\n      _n: e.lines ? c : r.nil,\n    };\n  }\n  get() {\n    return this._scope;\n  }\n  name(e) {\n    return new ValueScopeName(e, this._newName(e));\n  }\n  value(e, t) {\n    var n;\n    if (undefined === t.ref)\n      throw new Error(\"CodeGen: ref must be passed in value\");\n    const r = this.toName(e),\n      { prefix: o } = r,\n      i = null !== (n = t.key) && undefined !== n ? n : t.ref;\n    let s = this._values[o];\n    if (s) {\n      const e = s.get(i);\n      if (e) return e;\n    } else s = this._values[o] = new Map();\n    s.set(i, r);\n    const a = this._scope[o] || (this._scope[o] = []),\n      c = a.length;\n    a[c] = t.ref;\n    r.setValue(t, {\n      property: o,\n      itemIndex: c,\n    });\n    return r;\n  }\n  getValue(e, t) {\n    const n = this._values[e];\n    if (n) return n.get(t);\n  }\n  scopeRefs(e, t = this._values) {\n    return this._reduceValues(t, (t) => {\n      if (undefined === t.scopePath)\n        throw new Error(`CodeGen: name \"${t}\" has no value`);\n      return r._`${e}${t.scopePath}`;\n    });\n  }\n  scopeCode(e = this._values, t, n) {\n    return this._reduceValues(\n      e,\n      (e) => {\n        if (undefined === e.value)\n          throw new Error(`CodeGen: name \"${e}\" has no value`);\n        return e.value.code;\n      },\n      t,\n      n\n    );\n  }\n  _reduceValues(e, n, s = {}, a) {\n    let c = r.nil;\n    for (const l in e) {\n      const u = e[l];\n      if (!u) continue;\n      const d = (s[l] = s[l] || new Map());\n      u.forEach((e) => {\n        if (d.has(e)) return;\n        d.set(e, i.Started);\n        let s = n(e);\n        if (s) {\n          const n = this.opts.es5\n            ? exports.varKinds.var\n            : exports.varKinds.const;\n          c = r._`${c}${n} ${e} = ${s};${this.opts._n}`;\n        } else {\n          if (!(s = null == a ? undefined : a(e))) throw new o(e);\n          c = r._`${c}${s}${this.opts._n}`;\n        }\n        d.set(e, i.Completed);\n      });\n    }\n    return c;\n  }\n};",
  "8568": "var r;\nr = require(8249);\nrequire(5109);\nr.mode.CFB = (function () {\n  var e = r.lib.BlockCipherMode.extend();\n  function t(e, t, n, r) {\n    var o,\n      i = this._iv;\n    if (i) {\n      o = i.slice(0);\n      this._iv = undefined;\n    } else {\n      o = this._prevBlock;\n    }\n    r.encryptBlock(o, 0);\n    for (var s = 0; s < n; s++) e[t + s] ^= o[s];\n  }\n  e.Encryptor = e.extend({\n    processBlock: function (e, n) {\n      var r = this._cipher,\n        o = r.blockSize;\n      t.call(this, e, n, o, r);\n      this._prevBlock = e.slice(n, n + o);\n    },\n  });\n  e.Decryptor = e.extend({\n    processBlock: function (e, n) {\n      var r = this._cipher,\n        o = r.blockSize,\n        i = e.slice(n, n + o);\n      t.call(this, e, n, o, r);\n      this._prevBlock = i;\n    },\n  });\n  return e;\n})();\nmodule.exports = r.mode.CFB;",
  "8602": "var r = require(495);\nmodule.exports = function () {\n  this.kind = r.Measurement;\n};",
  "8604": "var r =\n  (this && this.__assign) ||\n  Object.assign ||\n  function (e) {\n    for (var t, n = 1, r = arguments.length; n < r; n++)\n      for (var o in (t = arguments[n]))\n        if (Object.prototype.hasOwnProperty.call(t, o)) {\n          e[o] = t[o];\n        }\n    return e;\n  };\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar o = require(4953);\nexports.AzureMonitorSymbol = \"Azure_Monitor_Tracer\";\nvar i = (function () {\n  function e() {}\n  e.prototype.onStart = function (e) {};\n  e.prototype.onEnd = function (e) {\n    o.channel.publish(\"azure-coretracing\", e);\n  };\n  e.prototype.shutdown = function () {};\n  return e;\n})();\nexports.azureCoreTracing = {\n  versionSpecifier: \">= 1.0.0 < 2.0.0\",\n  patch: function (e) {\n    try {\n      var s = new (0, require(\"@opentelemetry/tracing\").BasicTracer)(\n          o.channel.spanContextPropagator\n            ? {\n                scopeManager: o.channel.spanContextPropagator,\n              }\n            : undefined\n        ),\n        a = s.startSpan;\n      s.startSpan = function (e, t) {\n        if (!t || !t.parent) {\n          var n = s.getCurrentSpan();\n          if (n && n.operation && n.operation.traceparent) {\n            t = r({}, t, {\n              parent: {\n                traceId: n.operation.traceparent.traceId,\n                spanId: n.operation.traceparent.spanId,\n              },\n            });\n          }\n        }\n        var o = a.call(this, e, t);\n        o.addEvent(\"Application Insights Integration enabled\");\n        return o;\n      };\n      s.addSpanProcessor(new i());\n      s[exports.AzureMonitorSymbol] = !0;\n      e.setTracer(s);\n    } catch (e) {}\n    return e;\n  },\n};\nexports.enable = function () {\n  o.channel.registerMonkeyPatch(\n    \"@azure/core-tracing\",\n    exports.azureCoreTracing\n  );\n};",
  "8723": "var r = require(\"http\"),\n  o = require(\"https\"),\n  i = require(5282),\n  s = require(5740),\n  a = require(9036),\n  c = require(8339),\n  l = require(894),\n  u = require(9962),\n  d = require(8090),\n  p = require(7396),\n  h = (function () {\n    function e(t) {\n      if (e.INSTANCE)\n        throw new Error(\n          \"Client request tracking should be configured from the applicationInsights object\"\n        );\n      e.INSTANCE = this;\n      this._client = t;\n    }\n    e.prototype.enable = function (e) {\n      this._isEnabled = e;\n      if (this._isEnabled && !this._isInitialized) {\n        this._initialize();\n      }\n      if (p.IsInitialized) {\n        require(7886).wp(e, this._client);\n        require(4777).wp(e, this._client);\n        require(5071).wp(e, this._client);\n        require(1227).wp(e, this._client);\n      }\n    };\n    e.prototype.isInitialized = function () {\n      return this._isInitialized;\n    };\n    e.prototype._initialize = function () {\n      var t = this;\n      this._isInitialized = !0;\n      r.get;\n      var n = r.request,\n        i = o.request,\n        s = function (n, r) {\n          var o =\n            !r[e.disableCollectionRequestOption] &&\n            !n[e.alreadyAutoCollectedFlag];\n          n[e.alreadyAutoCollectedFlag] = !0;\n          if (n && r && o) {\n            l.CorrelationContextManager.wrapEmitter(n);\n            e.trackRequest(t._client, {\n              options: r,\n              request: n,\n            });\n          }\n        };\n      r.request = function (e) {\n        for (var t = [], o = 1; o < arguments.length; o++)\n          t[o - 1] = arguments[o];\n        var i = n.call.apply(n, [r, e].concat(t));\n        s(i, e);\n        return i;\n      };\n      o.request = function (e) {\n        for (var t = [], n = 1; n < arguments.length; n++)\n          t[n - 1] = arguments[n];\n        var r = i.call.apply(i, [o, e].concat(t));\n        s(r, e);\n        return r;\n      };\n      r.get = function (e) {\n        for (var t = [], n = 1; n < arguments.length; n++)\n          t[n - 1] = arguments[n];\n        var o,\n          i = (o = r.request).call.apply(o, [r, e].concat(t));\n        i.end();\n        return i;\n      };\n      o.get = function (e) {\n        for (var t = [], n = 1; n < arguments.length; n++)\n          t[n - 1] = arguments[n];\n        var r,\n          i = (r = o.request).call.apply(r, [o, e].concat(t));\n        i.end();\n        return i;\n      };\n    };\n    e.trackRequest = function (t, n) {\n      if (n.options && n.request && t) {\n        var r,\n          o,\n          p = new c(n.options, n.request),\n          h = l.CorrelationContextManager.getCurrentContext();\n        if (\n          h &&\n          h.operation &&\n          h.operation.traceparent &&\n          d.isValidTraceId(h.operation.traceparent.traceId)\n        ) {\n          h.operation.traceparent.updateSpanId();\n          r = h.operation.traceparent.getBackCompatRequestId();\n        } else {\n          if (u.w3cEnabled) {\n            o = (m = new d()).toString();\n            r = m.getBackCompatRequestId();\n          } else {\n            r =\n              h &&\n              h.operation &&\n              h.operation.parentId + e.requestNumber++ + \".\";\n          }\n        }\n        if (\n          s.canIncludeCorrelationHeader(t, p.getUrl()) &&\n          n.request.getHeader &&\n          n.request.setHeader &&\n          t.config &&\n          t.config.correlationId\n        ) {\n          var f = n.request.getHeader(a.requestContextHeader);\n          try {\n            s.safeIncludeCorrelationHeader(t, n.request, f);\n          } catch (e) {\n            i.warn(\n              \"Request-Context header could not be set. Correlation of requests may be lost\",\n              e\n            );\n          }\n          if (h && h.operation)\n            try {\n              if (\n                (n.request.setHeader(a.requestIdHeader, r),\n                n.request.setHeader(a.parentIdHeader, h.operation.id),\n                n.request.setHeader(a.rootIdHeader, r),\n                o || h.operation.traceparent)\n              )\n                n.request.setHeader(\n                  a.traceparentHeader,\n                  o || h.operation.traceparent.toString()\n                );\n              else if (u.w3cEnabled) {\n                var m = new d().toString();\n                n.request.setHeader(a.traceparentHeader, m);\n              }\n              if (h.operation.tracestate) {\n                var g = h.operation.tracestate.toString();\n                g && n.request.setHeader(a.traceStateHeader, g);\n              }\n              var _ = h.customProperties.serializeToHeader();\n              _ && n.request.setHeader(a.correlationContextHeader, _);\n            } catch (e) {\n              i.warn(\n                \"Correlation headers could not be set. Correlation of requests may be lost.\",\n                e\n              );\n            }\n        }\n        if (n.request.on) {\n          n.request.on(\"response\", function (e) {\n            p.onResponse(e);\n            var o = p.getDependencyTelemetry(n, r);\n            o.contextObjects = o.contextObjects || {};\n            o.contextObjects[\"http.RequestOptions\"] = n.options;\n            o.contextObjects[\"http.ClientRequest\"] = n.request;\n            o.contextObjects[\"http.ClientResponse\"] = e;\n            t.trackDependency(o);\n          });\n          n.request.on(\"error\", function (e) {\n            p.onError(e);\n            var o = p.getDependencyTelemetry(n, r);\n            o.contextObjects = o.contextObjects || {};\n            o.contextObjects[\"http.RequestOptions\"] = n.options;\n            o.contextObjects[\"http.ClientRequest\"] = n.request;\n            o.contextObjects.Error = e;\n            t.trackDependency(o);\n          });\n        }\n      } else\n        i.info(\n          \"AutoCollectHttpDependencies.trackRequest was called with invalid parameters: \",\n          !n.options,\n          !n.request,\n          !t\n        );\n    };\n    e.prototype.dispose = function () {\n      e.INSTANCE = null;\n      this.enable(!1);\n      this._isInitialized = !1;\n    };\n    e.disableCollectionRequestOption = \"disableAppInsightsAutoCollection\";\n    e.requestNumber = 1;\n    e.alreadyAutoCollectedFlag = \"_appInsightsAutoCollected\";\n    return e;\n  })();\nmodule.exports = h;",
  "8771": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.TestNotificationSender =\n  exports.TestUrlOpener =\n  exports.rangeToString =\n  exports.positionToString =\n    undefined;\nconst r = require(1547);\nfunction positionToString(e) {\n  return `${e.line}:${e.character}`;\n}\nexports.positionToString = positionToString;\nexports.rangeToString = function (e) {\n  return `[${positionToString(e.start)}--${positionToString(e.end)}]`;\n};\nexports.TestUrlOpener = class {\n  constructor() {\n    this.openedUrls = [];\n  }\n  open(e) {\n    this.openedUrls.push(e);\n  }\n};\nclass TestNotificationSender extends r.NotificationSender {\n  constructor() {\n    super();\n    this.sentMessages = [];\n  }\n  showWarningMessage(e, ...t) {\n    this.sentMessages.push(e);\n    return t ? Promise.resolve(t[0]) : Promise.resolve(undefined);\n  }\n}\nexports.TestNotificationSender = TestNotificationSender;",
  "8859": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r = require(4953);\nexports.bunyan = {\n  versionSpecifier: \">= 1.0.0 < 2.0.0\",\n  patch: function (e) {\n    var t = e.prototype._emit;\n    e.prototype._emit = function (e, n) {\n      var o = t.apply(this, arguments);\n      if (!n) {\n        var i = o;\n        if (i) {\n          i = t.call(this, e, !0);\n        }\n        r.channel.publish(\"bunyan\", {\n          level: e.level,\n          result: i,\n        });\n      }\n      return o;\n    };\n    return e;\n  },\n};\nexports.enable = function () {\n  r.channel.registerMonkeyPatch(\"bunyan\", exports.bunyan);\n};",
  "8876": "function shouldUseGroup(e, t) {\n  return t.rules.some((t) => shouldUseRule(e, t));\n}\nfunction shouldUseRule(e, t) {\n  var n;\n  return (\n    undefined !== e[t.keyword] ||\n    (null === (n = t.definition.implements) || undefined === n\n      ? undefined\n      : n.some((t) => undefined !== e[t]))\n  );\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.shouldUseRule =\n  exports.shouldUseGroup =\n  exports.schemaHasRulesForType =\n    undefined;\nexports.schemaHasRulesForType = function ({ schema: e, self: t }, r) {\n  const o = t.RULES.types[r];\n  return o && !0 !== o && shouldUseGroup(e, o);\n};\nexports.shouldUseGroup = shouldUseGroup;\nexports.shouldUseRule = shouldUseRule;",
  "8965": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.contextualFilterScore =\n  exports.getLastLineLength =\n  exports.ContextualFilterManager =\n    undefined;\nconst r = require(7744);\nclass ContextualFilterManager {\n  constructor() {\n    this.previousLabel = 0;\n    this.previousLabelTimestamp = Date.now() - 3600;\n    this.probabilityAccept = 0;\n  }\n}\nfunction getLastLineLength(e) {\n  const t = e.split(\"\\n\");\n  return t[t.length - 1].length;\n}\nexports.ContextualFilterManager = ContextualFilterManager;\nexports.getLastLineLength = getLastLineLength;\nexports.contextualFilterScore = function (e, t, n) {\n  const s = e.get(ContextualFilterManager),\n    a = s.previousLabel;\n  let c = 0;\n  if (\n    \"afterCursorWhitespace\" in t.properties &&\n    \"true\" === t.properties.afterCursorWhitespace\n  ) {\n    c = 1;\n  }\n  const l = (Date.now() - s.previousLabelTimestamp) / 1e3,\n    u = Math.log(1 + l);\n  let d = 0,\n    p = 0;\n  const h = n.prefix;\n  if (h) {\n    d = Math.log(1 + getLastLineLength(h));\n    const e = h.slice(-1);\n    if (undefined !== r.contextualFilterCharacterMap[e]) {\n      p = r.contextualFilterCharacterMap[e];\n    }\n  }\n  let f = 0,\n    m = 0;\n  const g = h.trimEnd();\n  if (g) {\n    f = Math.log(1 + getLastLineLength(g));\n    const e = g.slice(-1);\n    if (undefined !== r.contextualFilterCharacterMap[e]) {\n      m = r.contextualFilterCharacterMap[e];\n    }\n  }\n  let _ = 0;\n  if (\"documentLength\" in t.measurements) {\n    const e = t.measurements.documentLength;\n    _ = Math.log(1 + e);\n  }\n  let y = 0;\n  if (\"promptEndPos\" in t.measurements) {\n    const e = t.measurements.promptEndPos;\n    y = Math.log(1 + e);\n  }\n  let v = 0;\n  if (\"promptEndPos\" in t.measurements && \"documentLength\" in t.measurements) {\n    const e = t.measurements.documentLength;\n    v = (t.measurements.promptEndPos + 0.5) / (1 + e);\n  }\n  let b = 0;\n  if (undefined !== r.contextualFilterLanguageMap[t.properties.languageId]) {\n    b = r.contextualFilterLanguageMap[t.properties.languageId];\n  }\n  let w = r.contextualFilterIntercept;\n  w += r.contextualFilterWeights[0] * a;\n  w += r.contextualFilterWeights[1] * c;\n  w += r.contextualFilterWeights[2] * u;\n  w += r.contextualFilterWeights[3] * d;\n  w += r.contextualFilterWeights[4] * f;\n  w += r.contextualFilterWeights[5] * _;\n  w += r.contextualFilterWeights[6] * y;\n  w += r.contextualFilterWeights[7] * v;\n  w += r.contextualFilterWeights[8 + b];\n  w += r.contextualFilterWeights[29 + p];\n  w += r.contextualFilterWeights[125 + m];\n  const x = 1 / (1 + Math.exp(-w));\n  e.get(ContextualFilterManager).probabilityAccept = x;\n  return x;\n};",
  "9012": "var n;\nexports = module.exports = SemVer;\nn =\n  \"object\" == typeof process &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n    ? function () {\n        var e = Array.prototype.slice.call(arguments, 0);\n        e.unshift(\"SEMVER\");\n        console.log.apply(console, e);\n      }\n    : function () {};\nexports.SEMVER_SPEC_VERSION = \"2.0.0\";\nvar r = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  o = (exports.re = []),\n  i = (exports.src = []),\n  s = 0,\n  a = s++;\ni[a] = \"0|[1-9]\\\\d*\";\nvar c = s++;\ni[c] = \"[0-9]+\";\nvar l = s++;\ni[l] = \"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\";\nvar u = s++;\ni[u] = \"(\" + i[a] + \")\\\\.(\" + i[a] + \")\\\\.(\" + i[a] + \")\";\nvar d = s++;\ni[d] = \"(\" + i[c] + \")\\\\.(\" + i[c] + \")\\\\.(\" + i[c] + \")\";\nvar p = s++;\ni[p] = \"(?:\" + i[a] + \"|\" + i[l] + \")\";\nvar h = s++;\ni[h] = \"(?:\" + i[c] + \"|\" + i[l] + \")\";\nvar f = s++;\ni[f] = \"(?:-(\" + i[p] + \"(?:\\\\.\" + i[p] + \")*))\";\nvar m = s++;\ni[m] = \"(?:-?(\" + i[h] + \"(?:\\\\.\" + i[h] + \")*))\";\nvar g = s++;\ni[g] = \"[0-9A-Za-z-]+\";\nvar _ = s++;\ni[_] = \"(?:\\\\+(\" + i[g] + \"(?:\\\\.\" + i[g] + \")*))\";\nvar y = s++,\n  v = \"v?\" + i[u] + i[f] + \"?\" + i[_] + \"?\";\ni[y] = \"^\" + v + \"$\";\nvar b = \"[v=\\\\s]*\" + i[d] + i[m] + \"?\" + i[_] + \"?\",\n  w = s++;\ni[w] = \"^\" + b + \"$\";\nvar x = s++;\ni[x] = \"((?:<|>)?=?)\";\nvar E = s++;\ni[E] = i[c] + \"|x|X|\\\\*\";\nvar C = s++;\ni[C] = i[a] + \"|x|X|\\\\*\";\nvar S = s++;\ni[S] =\n  \"[v=\\\\s]*(\" +\n  i[C] +\n  \")(?:\\\\.(\" +\n  i[C] +\n  \")(?:\\\\.(\" +\n  i[C] +\n  \")(?:\" +\n  i[f] +\n  \")?\" +\n  i[_] +\n  \"?)?)?\";\nvar T = s++;\ni[T] =\n  \"[v=\\\\s]*(\" +\n  i[E] +\n  \")(?:\\\\.(\" +\n  i[E] +\n  \")(?:\\\\.(\" +\n  i[E] +\n  \")(?:\" +\n  i[m] +\n  \")?\" +\n  i[_] +\n  \"?)?)?\";\nvar k = s++;\ni[k] = \"^\" + i[x] + \"\\\\s*\" + i[S] + \"$\";\nvar I = s++;\ni[I] = \"^\" + i[x] + \"\\\\s*\" + i[T] + \"$\";\nvar P = s++;\ni[P] =\n  \"(?:^|[^\\\\d])(\\\\d{1,16})(?:\\\\.(\\\\d{1,16}))?(?:\\\\.(\\\\d{1,16}))?(?:$|[^\\\\d])\";\nvar A = s++;\ni[A] = \"(?:~>?)\";\nvar O = s++;\ni[O] = \"(\\\\s*)\" + i[A] + \"\\\\s+\";\no[O] = new RegExp(i[O], \"g\");\nvar N = s++;\ni[N] = \"^\" + i[A] + i[S] + \"$\";\nvar R = s++;\ni[R] = \"^\" + i[A] + i[T] + \"$\";\nvar M = s++;\ni[M] = \"(?:\\\\^)\";\nvar L = s++;\ni[L] = \"(\\\\s*)\" + i[M] + \"\\\\s+\";\no[L] = new RegExp(i[L], \"g\");\nvar $ = s++;\ni[$] = \"^\" + i[M] + i[S] + \"$\";\nvar D = s++;\ni[D] = \"^\" + i[M] + i[T] + \"$\";\nvar F = s++;\ni[F] = \"^\" + i[x] + \"\\\\s*(\" + b + \")$|^$\";\nvar j = s++;\ni[j] = \"^\" + i[x] + \"\\\\s*(\" + v + \")$|^$\";\nvar q = s++;\ni[q] = \"(\\\\s*)\" + i[x] + \"\\\\s*(\" + b + \"|\" + i[S] + \")\";\no[q] = new RegExp(i[q], \"g\");\nvar B = s++;\ni[B] = \"^\\\\s*(\" + i[S] + \")\\\\s+-\\\\s+(\" + i[S] + \")\\\\s*$\";\nvar U = s++;\ni[U] = \"^\\\\s*(\" + i[T] + \")\\\\s+-\\\\s+(\" + i[T] + \")\\\\s*$\";\nvar H = s++;\ni[H] = \"(<|>)?=?\\\\s*\\\\*\";\nfor (var z = 0; z < 35; z++) {\n  n(z, i[z]);\n  if (o[z]) {\n    o[z] = new RegExp(i[z]);\n  }\n}\nfunction parse(e, t) {\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (e instanceof SemVer) return e;\n  if (\"string\" != typeof e) return null;\n  if (e.length > 256) return null;\n  if (!(t.loose ? o[w] : o[y]).test(e)) return null;\n  try {\n    return new SemVer(e, t);\n  } catch (e) {\n    return null;\n  }\n}\nfunction SemVer(e, t) {\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (e instanceof SemVer) {\n    if (e.loose === t.loose) return e;\n    e = e.version;\n  } else if (\"string\" != typeof e) throw new TypeError(\"Invalid Version: \" + e);\n  if (e.length > 256)\n    throw new TypeError(\"version is longer than 256 characters\");\n  if (!(this instanceof SemVer)) return new SemVer(e, t);\n  n(\"SemVer\", e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  var i = e.trim().match(t.loose ? o[w] : o[y]);\n  if (!i) throw new TypeError(\"Invalid Version: \" + e);\n  this.raw = e;\n  this.major = +i[1];\n  this.minor = +i[2];\n  this.patch = +i[3];\n  if (this.major > r || this.major < 0)\n    throw new TypeError(\"Invalid major version\");\n  if (this.minor > r || this.minor < 0)\n    throw new TypeError(\"Invalid minor version\");\n  if (this.patch > r || this.patch < 0)\n    throw new TypeError(\"Invalid patch version\");\n  if (i[4]) {\n    this.prerelease = i[4].split(\".\").map(function (e) {\n      if (/^[0-9]+$/.test(e)) {\n        var t = +e;\n        if (t >= 0 && t < r) return t;\n      }\n      return e;\n    });\n  } else {\n    this.prerelease = [];\n  }\n  this.build = i[5] ? i[5].split(\".\") : [];\n  this.format();\n}\nexports.parse = parse;\nexports.valid = function (e, t) {\n  var n = parse(e, t);\n  return n ? n.version : null;\n};\nexports.clean = function (e, t) {\n  var n = parse(e.trim().replace(/^[=v]+/, \"\"), t);\n  return n ? n.version : null;\n};\nexports.SemVer = SemVer;\nSemVer.prototype.format = function () {\n  this.version = this.major + \".\" + this.minor + \".\" + this.patch;\n  if (this.prerelease.length) {\n    this.version += \"-\" + this.prerelease.join(\".\");\n  }\n  return this.version;\n};\nSemVer.prototype.toString = function () {\n  return this.version;\n};\nSemVer.prototype.compare = function (e) {\n  n(\"SemVer.compare\", this.version, this.options, e);\n  if (e instanceof SemVer) {\n    e = new SemVer(e, this.options);\n  }\n  return this.compareMain(e) || this.comparePre(e);\n};\nSemVer.prototype.compareMain = function (e) {\n  if (e instanceof SemVer) {\n    e = new SemVer(e, this.options);\n  }\n  return (\n    compareIdentifiers(this.major, e.major) ||\n    compareIdentifiers(this.minor, e.minor) ||\n    compareIdentifiers(this.patch, e.patch)\n  );\n};\nSemVer.prototype.comparePre = function (e) {\n  if (e instanceof SemVer) {\n    e = new SemVer(e, this.options);\n  }\n  if (this.prerelease.length && !e.prerelease.length) return -1;\n  if (!this.prerelease.length && e.prerelease.length) return 1;\n  if (!this.prerelease.length && !e.prerelease.length) return 0;\n  var t = 0;\n  do {\n    var r = this.prerelease[t],\n      o = e.prerelease[t];\n    n(\"prerelease compare\", t, r, o);\n    if (void 0 === r && void 0 === o) return 0;\n    if (undefined === o) return 1;\n    if (undefined === r) return -1;\n    if (r !== o) return compareIdentifiers(r, o);\n  } while (++t);\n};\nSemVer.prototype.inc = function (e, t) {\n  switch (e) {\n    case \"premajor\":\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc(\"pre\", t);\n      break;\n    case \"preminor\":\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc(\"pre\", t);\n      break;\n    case \"prepatch\":\n      this.prerelease.length = 0;\n      this.inc(\"patch\", t);\n      this.inc(\"pre\", t);\n      break;\n    case \"prerelease\":\n      if (0 === this.prerelease.length) {\n        this.inc(\"patch\", t);\n      }\n      this.inc(\"pre\", t);\n      break;\n    case \"major\":\n      if (\n        0 === this.minor &&\n        0 === this.patch &&\n        0 !== this.prerelease.length\n      ) {\n        this.major++;\n      }\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case \"minor\":\n      if (0 === this.patch && 0 !== this.prerelease.length) {\n        this.minor++;\n      }\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case \"patch\":\n      if (0 === this.prerelease.length) {\n        this.patch++;\n      }\n      this.prerelease = [];\n      break;\n    case \"pre\":\n      if (0 === this.prerelease.length) this.prerelease = [0];\n      else {\n        for (var n = this.prerelease.length; --n >= 0; )\n          if (\"number\" == typeof this.prerelease[n]) {\n            this.prerelease[n]++;\n            n = -2;\n          }\n        if (-1 === n) {\n          this.prerelease.push(0);\n        }\n      }\n      if (t) {\n        if (this.prerelease[0] === t) {\n          if (isNaN(this.prerelease[1])) {\n            this.prerelease = [t, 0];\n          }\n        } else {\n          this.prerelease = [t, 0];\n        }\n      }\n      break;\n    default:\n      throw new Error(\"invalid increment argument: \" + e);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\nexports.inc = function (e, t, n, r) {\n  if (\"string\" == typeof n) {\n    r = n;\n    n = undefined;\n  }\n  try {\n    return new SemVer(e, n).inc(t, r).version;\n  } catch (e) {\n    return null;\n  }\n};\nexports.diff = function (e, t) {\n  if (eq(e, t)) return null;\n  var n = parse(e),\n    r = parse(t),\n    o = \"\";\n  if (n.prerelease.length || r.prerelease.length) {\n    o = \"pre\";\n    var i = \"prerelease\";\n  }\n  for (var s in n)\n    if ((\"major\" === s || \"minor\" === s || \"patch\" === s) && n[s] !== r[s])\n      return o + s;\n  return i;\n};\nexports.compareIdentifiers = compareIdentifiers;\nvar W = /^[0-9]+$/;\nfunction compareIdentifiers(e, t) {\n  var n = W.test(e),\n    r = W.test(t);\n  if (n && r) {\n    e = +e;\n    t = +t;\n  }\n  return e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1;\n}\nfunction compare(e, t, n) {\n  return new SemVer(e, n).compare(new SemVer(t, n));\n}\nfunction gt(e, t, n) {\n  return compare(e, t, n) > 0;\n}\nfunction lt(e, t, n) {\n  return compare(e, t, n) < 0;\n}\nfunction eq(e, t, n) {\n  return 0 === compare(e, t, n);\n}\nfunction neq(e, t, n) {\n  return 0 !== compare(e, t, n);\n}\nfunction ee(e, t, n) {\n  return compare(e, t, n) >= 0;\n}\nfunction te(e, t, n) {\n  return compare(e, t, n) <= 0;\n}\nfunction ne(e, t, n, r) {\n  switch (t) {\n    case \"===\":\n      if (\"object\" == typeof e) {\n        e = e.version;\n      }\n      if (\"object\" == typeof n) {\n        n = n.version;\n      }\n      return e === n;\n    case \"!==\":\n      if (\"object\" == typeof e) {\n        e = e.version;\n      }\n      if (\"object\" == typeof n) {\n        n = n.version;\n      }\n      return e !== n;\n    case \"\":\n    case \"=\":\n    case \"==\":\n      return eq(e, n, r);\n    case \"!=\":\n      return neq(e, n, r);\n    case \">\":\n      return gt(e, n, r);\n    case \">=\":\n      return ee(e, n, r);\n    case \"<\":\n      return lt(e, n, r);\n    case \"<=\":\n      return te(e, n, r);\n    default:\n      throw new TypeError(\"Invalid operator: \" + t);\n  }\n}\nfunction re(e, t) {\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (e instanceof re) {\n    if (e.loose === !!t.loose) return e;\n    e = e.value;\n  }\n  if (!(this instanceof re)) return new re(e, t);\n  n(\"comparator\", e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  this.parse(e);\n  if (this.semver === oe) {\n    this.value = \"\";\n  } else {\n    this.value = this.operator + this.semver.version;\n  }\n  n(\"comp\", this);\n}\nexports.rcompareIdentifiers = function (e, t) {\n  return compareIdentifiers(t, e);\n};\nexports.major = function (e, t) {\n  return new SemVer(e, t).major;\n};\nexports.minor = function (e, t) {\n  return new SemVer(e, t).minor;\n};\nexports.patch = function (e, t) {\n  return new SemVer(e, t).patch;\n};\nexports.compare = compare;\nexports.compareLoose = function (e, t) {\n  return compare(e, t, !0);\n};\nexports.rcompare = function (e, t, n) {\n  return compare(t, e, n);\n};\nexports.sort = function (e, n) {\n  return e.sort(function (e, r) {\n    return exports.compare(e, r, n);\n  });\n};\nexports.rsort = function (e, n) {\n  return e.sort(function (e, r) {\n    return exports.rcompare(e, r, n);\n  });\n};\nexports.gt = gt;\nexports.lt = lt;\nexports.eq = eq;\nexports.neq = neq;\nexports.gte = ee;\nexports.lte = te;\nexports.cmp = ne;\nexports.Comparator = re;\nvar oe = {};\nfunction ie(e, t) {\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (e instanceof ie)\n    return e.loose === !!t.loose &&\n      e.includePrerelease === !!t.includePrerelease\n      ? e\n      : new ie(e.raw, t);\n  if (e instanceof re) return new ie(e.value, t);\n  if (!(this instanceof ie)) return new ie(e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  this.includePrerelease = !!t.includePrerelease;\n  this.raw = e;\n  this.set = e\n    .split(/\\s*\\|\\|\\s*/)\n    .map(function (e) {\n      return this.parseRange(e.trim());\n    }, this)\n    .filter(function (e) {\n      return e.length;\n    });\n  if (!this.set.length) throw new TypeError(\"Invalid SemVer Range: \" + e);\n  this.format();\n}\nfunction se(e) {\n  return !e || \"x\" === e.toLowerCase() || \"*\" === e;\n}\nfunction ae(e, t, n, r, o, i, s, a, c, l, u, d, p) {\n  return (\n    (t = se(n)\n      ? \"\"\n      : se(r)\n      ? \">=\" + n + \".0.0\"\n      : se(o)\n      ? \">=\" + n + \".\" + r + \".0\"\n      : \">=\" + t) +\n    \" \" +\n    (a = se(c)\n      ? \"\"\n      : se(l)\n      ? \"<\" + (+c + 1) + \".0.0\"\n      : se(u)\n      ? \"<\" + c + \".\" + (+l + 1) + \".0\"\n      : d\n      ? \"<=\" + c + \".\" + l + \".\" + u + \"-\" + d\n      : \"<=\" + a)\n  ).trim();\n}\nfunction ce(e, t, r) {\n  for (var o = 0; o < e.length; o++) if (!e[o].test(t)) return !1;\n  if (t.prerelease.length && !r.includePrerelease) {\n    for (o = 0; o < e.length; o++) {\n      n(e[o].semver);\n      if (e[o].semver !== oe && e[o].semver.prerelease.length > 0) {\n        var i = e[o].semver;\n        if (i.major === t.major && i.minor === t.minor && i.patch === t.patch)\n          return !0;\n      }\n    }\n    return !1;\n  }\n  return !0;\n}\nfunction le(e, t, n) {\n  try {\n    t = new ie(t, n);\n  } catch (e) {\n    return !1;\n  }\n  return t.test(e);\n}\nfunction ue(e, t, n, r) {\n  var o, i, s, a, c;\n  switch (((e = new SemVer(e, r)), (t = new ie(t, r)), n)) {\n    case \">\":\n      o = gt;\n      i = te;\n      s = lt;\n      a = \">\";\n      c = \">=\";\n      break;\n    case \"<\":\n      o = lt;\n      i = ee;\n      s = gt;\n      a = \"<\";\n      c = \"<=\";\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n  if (le(e, t, r)) return !1;\n  for (var l = 0; l < t.set.length; ++l) {\n    var u = t.set[l],\n      d = null,\n      p = null;\n    u.forEach(function (e) {\n      if (e.semver === oe) {\n        e = new re(\">=0.0.0\");\n      }\n      d = d || e;\n      p = p || e;\n      if (o(e.semver, d.semver, r)) {\n        d = e;\n      } else {\n        if (s(e.semver, p.semver, r)) {\n          p = e;\n        }\n      }\n    });\n    if (d.operator === a || d.operator === c) return !1;\n    if ((!p.operator || p.operator === a) && i(e, p.semver)) return !1;\n    if (p.operator === c && s(e, p.semver)) return !1;\n  }\n  return !0;\n}\nre.prototype.parse = function (e) {\n  var t = this.options.loose ? o[F] : o[j],\n    n = e.match(t);\n  if (!n) throw new TypeError(\"Invalid comparator: \" + e);\n  this.operator = n[1];\n  if (\"=\" === this.operator) {\n    this.operator = \"\";\n  }\n  if (n[2]) {\n    this.semver = new SemVer(n[2], this.options.loose);\n  } else {\n    this.semver = oe;\n  }\n};\nre.prototype.toString = function () {\n  return this.value;\n};\nre.prototype.test = function (e) {\n  n(\"Comparator.test\", e, this.options.loose);\n  return (\n    this.semver === oe ||\n    (\"string\" == typeof e && (e = new SemVer(e, this.options)),\n    ne(e, this.operator, this.semver, this.options))\n  );\n};\nre.prototype.intersects = function (e, t) {\n  if (!(e instanceof re)) throw new TypeError(\"a Comparator is required\");\n  var n;\n  if (t && \"object\" == typeof t) {\n    t = {\n      loose: !!t,\n      includePrerelease: !1,\n    };\n  }\n  if (\"\" === this.operator)\n    return (n = new ie(e.value, t)), le(this.value, n, t);\n  if (\"\" === e.operator) {\n    n = new ie(this.value, t);\n    return le(e.semver, n, t);\n  }\n  var r = !(\n      (\">=\" !== this.operator && \">\" !== this.operator) ||\n      (\">=\" !== e.operator && \">\" !== e.operator)\n    ),\n    o = !(\n      (\"<=\" !== this.operator && \"<\" !== this.operator) ||\n      (\"<=\" !== e.operator && \"<\" !== e.operator)\n    ),\n    i = this.semver.version === e.semver.version,\n    s = !(\n      (\">=\" !== this.operator && \"<=\" !== this.operator) ||\n      (\">=\" !== e.operator && \"<=\" !== e.operator)\n    ),\n    a =\n      ne(this.semver, \"<\", e.semver, t) &&\n      (\">=\" === this.operator || \">\" === this.operator) &&\n      (\"<=\" === e.operator || \"<\" === e.operator),\n    c =\n      ne(this.semver, \">\", e.semver, t) &&\n      (\"<=\" === this.operator || \"<\" === this.operator) &&\n      (\">=\" === e.operator || \">\" === e.operator);\n  return r || o || (i && s) || a || c;\n};\nexports.Range = ie;\nie.prototype.format = function () {\n  this.range = this.set\n    .map(function (e) {\n      return e.join(\" \").trim();\n    })\n    .join(\"||\")\n    .trim();\n  return this.range;\n};\nie.prototype.toString = function () {\n  return this.range;\n};\nie.prototype.parseRange = function (e) {\n  var t = this.options.loose;\n  e = e.trim();\n  var r = t ? o[U] : o[B];\n  e = e.replace(r, ae);\n  n(\"hyphen replace\", e);\n  e = e.replace(o[q], \"$1$2$3\");\n  n(\"comparator trim\", e, o[q]);\n  e = (e = (e = e.replace(o[O], \"$1~\")).replace(o[L], \"$1^\"))\n    .split(/\\s+/)\n    .join(\" \");\n  var i = t ? o[F] : o[j],\n    s = e\n      .split(\" \")\n      .map(function (e) {\n        return (function (e, t) {\n          n(\"comp\", e, t);\n          e = (function (e, t) {\n            return e\n              .trim()\n              .split(/\\s+/)\n              .map(function (e) {\n                return (function (e, t) {\n                  n(\"caret\", e, t);\n                  var r = t.loose ? o[D] : o[$];\n                  return e.replace(r, function (t, r, o, i, s) {\n                    var a;\n                    n(\"caret\", e, t, r, o, i, s);\n                    if (se(r)) {\n                      a = \"\";\n                    } else {\n                      if (se(o)) {\n                        a = \">=\" + r + \".0.0 <\" + (+r + 1) + \".0.0\";\n                      } else {\n                        if (se(i)) {\n                          a =\n                            \"0\" === r\n                              ? \">=\" +\n                                r +\n                                \".\" +\n                                o +\n                                \".0 <\" +\n                                r +\n                                \".\" +\n                                (+o + 1) +\n                                \".0\"\n                              : \">=\" + r + \".\" + o + \".0 <\" + (+r + 1) + \".0.0\";\n                        } else {\n                          if (s) {\n                            n(\"replaceCaret pr\", s);\n                            a =\n                              \"0\" === r\n                                ? \"0\" === o\n                                  ? \">=\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    i +\n                                    \"-\" +\n                                    s +\n                                    \" <\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    (+i + 1)\n                                  : \">=\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    i +\n                                    \"-\" +\n                                    s +\n                                    \" <\" +\n                                    r +\n                                    \".\" +\n                                    (+o + 1) +\n                                    \".0\"\n                                : \">=\" +\n                                  r +\n                                  \".\" +\n                                  o +\n                                  \".\" +\n                                  i +\n                                  \"-\" +\n                                  s +\n                                  \" <\" +\n                                  (+r + 1) +\n                                  \".0.0\";\n                          } else {\n                            n(\"no pr\");\n                            a =\n                              \"0\" === r\n                                ? \"0\" === o\n                                  ? \">=\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    i +\n                                    \" <\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    (+i + 1)\n                                  : \">=\" +\n                                    r +\n                                    \".\" +\n                                    o +\n                                    \".\" +\n                                    i +\n                                    \" <\" +\n                                    r +\n                                    \".\" +\n                                    (+o + 1) +\n                                    \".0\"\n                                : \">=\" +\n                                  r +\n                                  \".\" +\n                                  o +\n                                  \".\" +\n                                  i +\n                                  \" <\" +\n                                  (+r + 1) +\n                                  \".0.0\";\n                          }\n                        }\n                      }\n                    }\n                    n(\"caret return\", a);\n                    return a;\n                  });\n                })(e, t);\n              })\n              .join(\" \");\n          })(e, t);\n          n(\"caret\", e);\n          e = (function (e, t) {\n            return e\n              .trim()\n              .split(/\\s+/)\n              .map(function (e) {\n                return (function (e, t) {\n                  var r = t.loose ? o[R] : o[N];\n                  return e.replace(r, function (t, r, o, i, s) {\n                    var a;\n                    n(\"tilde\", e, t, r, o, i, s);\n                    if (se(r)) {\n                      a = \"\";\n                    } else {\n                      if (se(o)) {\n                        a = \">=\" + r + \".0.0 <\" + (+r + 1) + \".0.0\";\n                      } else {\n                        if (se(i)) {\n                          a =\n                            \">=\" +\n                            r +\n                            \".\" +\n                            o +\n                            \".0 <\" +\n                            r +\n                            \".\" +\n                            (+o + 1) +\n                            \".0\";\n                        } else {\n                          if (s) {\n                            n(\"replaceTilde pr\", s);\n                            a =\n                              \">=\" +\n                              r +\n                              \".\" +\n                              o +\n                              \".\" +\n                              i +\n                              \"-\" +\n                              s +\n                              \" <\" +\n                              r +\n                              \".\" +\n                              (+o + 1) +\n                              \".0\";\n                          } else {\n                            a =\n                              \">=\" +\n                              r +\n                              \".\" +\n                              o +\n                              \".\" +\n                              i +\n                              \" <\" +\n                              r +\n                              \".\" +\n                              (+o + 1) +\n                              \".0\";\n                          }\n                        }\n                      }\n                    }\n                    n(\"tilde return\", a);\n                    return a;\n                  });\n                })(e, t);\n              })\n              .join(\" \");\n          })(e, t);\n          n(\"tildes\", e);\n          e = (function (e, t) {\n            n(\"replaceXRanges\", e, t);\n            return e\n              .split(/\\s+/)\n              .map(function (e) {\n                return (function (e, t) {\n                  e = e.trim();\n                  var r = t.loose ? o[I] : o[k];\n                  return e.replace(r, function (t, r, o, i, s, a) {\n                    n(\"xRange\", e, t, r, o, i, s, a);\n                    var c = se(o),\n                      l = c || se(i),\n                      u = l || se(s);\n                    if (\"=\" === r && u) {\n                      r = \"\";\n                    }\n                    if (c) {\n                      t = \">\" === r || \"<\" === r ? \"<0.0.0\" : \"*\";\n                    } else {\n                      if (r && u) {\n                        if (l) {\n                          i = 0;\n                        }\n                        s = 0;\n                        if (\">\" === r) {\n                          r = \">=\";\n                          if (l) {\n                            o = +o + 1;\n                            i = 0;\n                            s = 0;\n                          } else {\n                            i = +i + 1;\n                            s = 0;\n                          }\n                        } else {\n                          if (\"<=\" === r) {\n                            r = \"<\";\n                            if (l) {\n                              o = +o + 1;\n                            } else {\n                              i = +i + 1;\n                            }\n                          }\n                        }\n                        t = r + o + \".\" + i + \".\" + s;\n                      } else {\n                        if (l) {\n                          t = \">=\" + o + \".0.0 <\" + (+o + 1) + \".0.0\";\n                        } else {\n                          if (u) {\n                            t =\n                              \">=\" +\n                              o +\n                              \".\" +\n                              i +\n                              \".0 <\" +\n                              o +\n                              \".\" +\n                              (+i + 1) +\n                              \".0\";\n                          }\n                        }\n                      }\n                    }\n                    n(\"xRange return\", t);\n                    return t;\n                  });\n                })(e, t);\n              })\n              .join(\" \");\n          })(e, t);\n          n(\"xrange\", e);\n          e = (function (e, t) {\n            n(\"replaceStars\", e, t);\n            return e.trim().replace(o[H], \"\");\n          })(e, t);\n          n(\"stars\", e);\n          return e;\n        })(e, this.options);\n      }, this)\n      .join(\" \")\n      .split(/\\s+/);\n  if (this.options.loose) {\n    s = s.filter(function (e) {\n      return !!e.match(i);\n    });\n  }\n  return s.map(function (e) {\n    return new re(e, this.options);\n  }, this);\n};\nie.prototype.intersects = function (e, t) {\n  if (!(e instanceof ie)) throw new TypeError(\"a Range is required\");\n  return this.set.some(function (n) {\n    return n.every(function (n) {\n      return e.set.some(function (e) {\n        return e.every(function (e) {\n          return n.intersects(e, t);\n        });\n      });\n    });\n  });\n};\nexports.toComparators = function (e, t) {\n  return new ie(e, t).set.map(function (e) {\n    return e\n      .map(function (e) {\n        return e.value;\n      })\n      .join(\" \")\n      .trim()\n      .split(\" \");\n  });\n};\nie.prototype.test = function (e) {\n  if (!e) return !1;\n  if (\"string\" == typeof e) {\n    e = new SemVer(e, this.options);\n  }\n  for (var t = 0; t < this.set.length; t++)\n    if (ce(this.set[t], e, this.options)) return !0;\n  return !1;\n};\nexports.satisfies = le;\nexports.maxSatisfying = function (e, t, n) {\n  var r = null,\n    o = null;\n  try {\n    var i = new ie(t, n);\n  } catch (e) {\n    return null;\n  }\n  e.forEach(function (e) {\n    if (i.test(e)) {\n      if (r && -1 !== o.compare(e)) {\n        o = new SemVer((r = e), n);\n      }\n    }\n  });\n  return r;\n};\nexports.minSatisfying = function (e, t, n) {\n  var r = null,\n    o = null;\n  try {\n    var i = new ie(t, n);\n  } catch (e) {\n    return null;\n  }\n  e.forEach(function (e) {\n    if (i.test(e)) {\n      if (r && 1 !== o.compare(e)) {\n        o = new SemVer((r = e), n);\n      }\n    }\n  });\n  return r;\n};\nexports.minVersion = function (e, t) {\n  e = new ie(e, t);\n  var n = new SemVer(\"0.0.0\");\n  if (e.test(n)) return n;\n  n = new SemVer(\"0.0.0-0\");\n  if (e.test(n)) return n;\n  n = null;\n  for (var r = 0; r < e.set.length; ++r)\n    e.set[r].forEach(function (e) {\n      var t = new SemVer(e.semver.version);\n      switch (e.operator) {\n        case \">\":\n          if (0 === t.prerelease.length) {\n            t.patch++;\n          } else {\n            t.prerelease.push(0);\n          }\n          t.raw = t.format();\n        case \"\":\n        case \">=\":\n          if (n && !gt(n, t)) {\n            n = t;\n          }\n          break;\n        case \"<\":\n        case \"<=\":\n          break;\n        default:\n          throw new Error(\"Unexpected operation: \" + e.operator);\n      }\n    });\n  return n && e.test(n) ? n : null;\n};\nexports.validRange = function (e, t) {\n  try {\n    return new ie(e, t).range || \"*\";\n  } catch (e) {\n    return null;\n  }\n};\nexports.ltr = function (e, t, n) {\n  return ue(e, t, \"<\", n);\n};\nexports.gtr = function (e, t, n) {\n  return ue(e, t, \">\", n);\n};\nexports.outside = ue;\nexports.prerelease = function (e, t) {\n  var n = parse(e, t);\n  return n && n.prerelease.length ? n.prerelease : null;\n};\nexports.intersects = function (e, t, n) {\n  e = new ie(e, n);\n  t = new ie(t, n);\n  return e.intersects(t);\n};\nexports.coerce = function (e) {\n  if (e instanceof SemVer) return e;\n  if (\"string\" != typeof e) return null;\n  var t = e.match(o[P]);\n  return null == t\n    ? null\n    : parse(t[1] + \".\" + (t[2] || \"0\") + \".\" + (t[3] || \"0\"));\n};",
  "9024": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r = require(4953);\nexports.postgresPool1 = {\n  versionSpecifier: \">= 1.0.0 < 3.0.0\",\n  patch: function (e) {\n    var t = e.prototype.connect;\n    e.prototype.connect = function (e) {\n      if (e) {\n        arguments[0] = r.channel.bindToContext(e);\n      }\n      return t.apply(this, arguments);\n    };\n    return e;\n  },\n};\nexports.enable = function () {\n  r.channel.registerMonkeyPatch(\"pg-pool\", exports.postgresPool1);\n};",
  "9030": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.GranularityDirectory = undefined;\nconst r = require(8142),\n  o = require(862),\n  i = r.Filter.CopilotClientTimeBucket;\nexports.GranularityDirectory = class {\n  constructor(e, t) {\n    this.specs = new Map();\n    this.prefix = e;\n    this.clock = t;\n    this.defaultGranularity = o.DEFAULT_GRANULARITY(e);\n  }\n  selectGranularity(e) {\n    for (const [t, n] of this.specs.entries()) if (e.extends(t)) return n;\n    return this.defaultGranularity;\n  }\n  update(e, t, n) {\n    t = t > 1 ? t : NaN;\n    n = n > 0 ? n : NaN;\n    if (isNaN(t) && isNaN(n)) this.specs.delete(e);\n    else {\n      const r = new o.TimeBucketGranularity(this.prefix);\n      isNaN(t) || r.setByCallBuckets(t),\n        isNaN(n) || r.setTimePeriod(3600 * n * 1e3),\n        this.specs.set(e, r);\n    }\n  }\n  extendFilters(e) {\n    const t = this.selectGranularity(e),\n      [n, r] = t.getCurrentAndUpComingValues(this.clock.now());\n    return {\n      newFilterSettings: e.withChange(i, n),\n      otherFilterSettingsToPrefetch: r.map((t) => e.withChange(i, t)),\n    };\n  }\n};",
  "9036": "module.exports = {\n  requestContextHeader: \"request-context\",\n  requestContextSourceKey: \"appId\",\n  requestContextTargetKey: \"appId\",\n  requestIdHeader: \"request-id\",\n  parentIdHeader: \"x-ms-request-id\",\n  rootIdHeader: \"x-ms-request-root-id\",\n  correlationContextHeader: \"correlation-context\",\n  traceparentHeader: \"traceparent\",\n  traceStateHeader: \"tracestate\",\n};",
  "9073": "var r = require(2337);\nmodule.exports = function e(t) {\n  if (Array.isArray(t))\n    return -1 !== t.indexOf(\"ssh\") || -1 !== t.indexOf(\"rsync\");\n  if (\"string\" != typeof t) return !1;\n  var n = r(t);\n  t = t.substring(t.indexOf(\"://\") + 3);\n  if (e(n)) return !0;\n  var o = new RegExp(\".([a-zA-Z\\\\d]+):(\\\\d+)/\");\n  return !t.match(o) && t.indexOf(\"@\") < t.indexOf(\":\");\n};",
  "9090": "var r,\n  o,\n  i = require(6372).wrap,\n  s = [],\n  a = 0,\n  c = !1,\n  l = [];\nfunction u(e, t) {\n  var n = e.length,\n    r = t.length,\n    o = [];\n  if (0 === n && 0 === r) return o;\n  for (var i = 0; i < n; i++) o[i] = e[i];\n  if (0 === r) return o;\n  for (var s = 0; s < r; s++) {\n    var a = !0;\n    for (i = 0; i < n; i++)\n      if (e[i].uid === t[s].uid) {\n        a = !1;\n        break;\n      }\n    if (a) {\n      o.push(t[s]);\n    }\n  }\n  return o;\n}\nif (process._fatalException) {\n  var d,\n    p = !1;\n  r = function (e) {\n    var t = s.length;\n    if (p || 0 === t) return !1;\n    var n = !1;\n    p = !0;\n    for (var r = 0; r < t; ++r) {\n      var o = s[r];\n      if (0 != (8 & o.flags)) {\n        var i = d && d[o.uid];\n        n = o.error(i, e) || n;\n      }\n    }\n    p = !1;\n    if (l.length > 0) {\n      s = l.pop();\n    }\n    d = undefined;\n    return n && !c;\n  };\n  o = function (e, t, n) {\n    var r = [];\n    c = !0;\n    for (var o = 0; o < n; ++o) {\n      var i = t[o];\n      r[i.uid] = i.data;\n      if (0 != (1 & i.flags)) {\n        var a = i.create(i.data);\n        void 0 !== a && (r[i.uid] = a);\n      }\n    }\n    c = !1;\n    return function () {\n      d = r;\n      l.push(s);\n      s = u(t, s);\n      c = !0;\n      for (var o = 0; o < n; ++o)\n        if ((2 & t[o].flags) > 0) {\n          t[o].before(this, r[t[o].uid]);\n        }\n      c = !1;\n      var i = e.apply(this, arguments);\n      for (c = !0, o = 0; o < n; ++o)\n        if ((4 & t[o].flags) > 0) {\n          t[o].after(this, r[t[o].uid]);\n        }\n      c = !1;\n      s = l.pop();\n      d = undefined;\n      return i;\n    };\n  };\n  i(process, \"_fatalException\", function (e) {\n    return function (t) {\n      return r(t) || e(t);\n    };\n  });\n} else {\n  var h = !1;\n  r = function (e) {\n    if (h) throw e;\n    for (var t = !1, n = s.length, r = 0; r < n; ++r) {\n      var o = s[r];\n      if (0 != (8 & o.flags)) {\n        t = o.error(null, e) || t;\n      }\n    }\n    if (!t && c) throw e;\n  };\n  o = function (e, t, n) {\n    var o = [];\n    c = !0;\n    for (var i = 0; i < n; ++i) {\n      var a = t[i];\n      o[a.uid] = a.data;\n      if (0 != (1 & a.flags)) {\n        var d = a.create(a.data);\n        void 0 !== d && (o[a.uid] = d);\n      }\n    }\n    c = !1;\n    return function () {\n      var i,\n        a = !1,\n        d = !1;\n      l.push(s);\n      s = u(t, s);\n      c = !0;\n      for (var p = 0; p < n; ++p)\n        if ((2 & t[p].flags) > 0) {\n          t[p].before(this, o[t[p].uid]);\n        }\n      c = !1;\n      try {\n        i = e.apply(this, arguments);\n      } catch (e) {\n        for (a = !0, p = 0; p < n; ++p)\n          if (0 != (8 & s[p].flags))\n            try {\n              d = s[p].error(o[t[p].uid], e) || d;\n            } catch (e) {\n              throw ((h = !0), e);\n            }\n        if (!d)\n          throw (\n            (process.removeListener(\"uncaughtException\", r),\n            process._originalNextTick(function () {\n              process.addListener(\"uncaughtException\", r);\n            }),\n            e)\n          );\n      } finally {\n        if (!a || d) {\n          for (c = !0, p = 0; p < n; ++p)\n            if ((4 & t[p].flags) > 0) {\n              t[p].after(this, o[t[p].uid]);\n            }\n          c = !1;\n        }\n        s = l.pop();\n      }\n      return i;\n    };\n  };\n  process.addListener(\"uncaughtException\", r);\n}\nfunction f(e, t) {\n  if (\"function\" == typeof e.create) {\n    this.create = e.create;\n    this.flags |= 1;\n  }\n  if (\"function\" == typeof e.before) {\n    this.before = e.before;\n    this.flags |= 2;\n  }\n  if (\"function\" == typeof e.after) {\n    this.after = e.after;\n    this.flags |= 4;\n  }\n  if (\"function\" == typeof e.error) {\n    this.error = e.error;\n    this.flags |= 8;\n  }\n  this.uid = ++a;\n  this.data = undefined === t ? null : t;\n}\nfunction m(e, t) {\n  if (\"object\" != typeof e || !e)\n    throw new TypeError(\"callbacks argument must be an object\");\n  return e instanceof f ? e : new f(e, t);\n}\nf.prototype.create = undefined;\nf.prototype.before = undefined;\nf.prototype.after = undefined;\nf.prototype.error = undefined;\nf.prototype.data = undefined;\nf.prototype.uid = 0;\nf.prototype.flags = 0;\nprocess.createAsyncListener = m;\nprocess.addAsyncListener = function (e, t) {\n  var n;\n  n = e instanceof f ? e : m(e, t);\n  for (var r = !1, o = 0; o < s.length; o++)\n    if (n === s[o]) {\n      r = !0;\n      break;\n    }\n  if (r) {\n    s.push(n);\n  }\n  return n;\n};\nprocess.removeAsyncListener = function (e) {\n  for (var t = 0; t < s.length; t++)\n    if (e === s[t]) {\n      s.splice(t, 1);\n      break;\n    }\n};\nmodule.exports = function (e) {\n  var t = s.length;\n  if (0 === t) return e;\n  for (var n = s.slice(), r = 0; r < t; ++r)\n    if (n[r].flags > 0) return o(e, n, t);\n  return (function (e, t, n) {\n    c = !0;\n    for (var r = 0; r < n; ++r) {\n      var o = t[r];\n      if (o.create) {\n        o.create(o.data);\n      }\n    }\n    c = !1;\n    return function () {\n      l.push(s);\n      s = u(t, s);\n      var n = e.apply(this, arguments);\n      s = l.pop();\n      return n;\n    };\n  })(e, n, t);\n};",
  "9125": "require(4433).h;\nexports.SourceMapConsumer = require(6771).SourceMapConsumer;\nrequire(7085);",
  "9184": "var r = require(\"https\"),\n  o = require(8723),\n  i = require(5282),\n  s = (function () {\n    function e(e) {\n      this._config = e;\n      this._consecutiveErrors = 0;\n    }\n    e.prototype.ping = function (e, t) {\n      this._submitData(e, t, \"ping\");\n    };\n    e.prototype.post = function (e, t) {\n      this._submitData([e], t, \"post\");\n    };\n    e.prototype._submitData = function (t, n, s) {\n      var a,\n        c,\n        l = this,\n        u = JSON.stringify(t),\n        d =\n          (((a = {})[o.disableCollectionRequestOption] = !0),\n          (a.host = this._config.quickPulseHost),\n          (a.method = \"POST\"),\n          (a.path =\n            \"/QuickPulseService.svc/\" +\n            s +\n            \"?ikey=\" +\n            this._config.instrumentationKey),\n          (a.headers =\n            (((c = {\n              Expect: \"100-continue\",\n            })[\"x-ms-qps-transmission-time\"] = 1e4 * Date.now()),\n            (c[\"Content-Type\"] = \"application/json\"),\n            (c[\"Content-Length\"] = Buffer.byteLength(u)),\n            c)),\n          a),\n        p = r.request(d, function (e) {\n          var t = \"true\" === e.headers[\"x-ms-qps-subscribed\"];\n          l._consecutiveErrors = 0;\n          n(t, e);\n        });\n      p.on(\"error\", function (t) {\n        l._consecutiveErrors++;\n        var r =\n          \"Transient error connecting to the Live Metrics endpoint. This packet will not appear in your Live Metrics Stream. Error:\";\n        if (l._consecutiveErrors % e.MAX_QPS_FAILURES_BEFORE_WARN == 0) {\n          r =\n            \"Live Metrics endpoint could not be reached \" +\n            l._consecutiveErrors +\n            \" consecutive times. Most recent error:\";\n          i.warn(e.TAG, r, t);\n        } else {\n          i.info(e.TAG, r, t);\n        }\n        n();\n      });\n      p.write(u);\n      p.end();\n    };\n    e.TAG = \"QuickPulseSender\";\n    e.MAX_QPS_FAILURES_BEFORE_WARN = 25;\n    return e;\n  })();\nmodule.exports = s;",
  "9189": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.Features = exports.Task = undefined;\nconst r = require(3055563),\n  o = require(299),\n  i = require(3076),\n  s = require(1133),\n  a = require(7744),\n  c = require(9657),\n  l = require(219),\n  u = require(9748),\n  d = require(8142),\n  p = require(9030);\nclass h {\n  constructor(e) {\n    this.ctx = e;\n    this.cache = new i.LRUCache(200);\n  }\n  async fetchExpConfig(e) {\n    let t = this.cache.get(e.stringify());\n    if (t) {\n      t = new Task(\n        () =>\n          this.ctx\n            .get(u.ExpConfigMaker)\n            .fetchExperiments(this.ctx, e.toHeaders()),\n        36e5\n      );\n      this.cache.put(e.stringify(), t);\n    }\n    return t.run();\n  }\n  getCachedExpConfig(e) {\n    const t = this.cache.get(e.stringify());\n    return null == t ? undefined : t.value();\n  }\n}\nclass Task {\n  constructor(e, t = 1 / 0) {\n    this.producer = e;\n    this.expirationMs = t;\n  }\n  async run() {\n    if (undefined === this.promise) {\n      this.promise = this.producer();\n      this.storeResult(this.promise).then(() => {\n        if (this.expirationMs < 1 / 0 && undefined !== this.promise) {\n          setTimeout(() => (this.promise = undefined), this.expirationMs);\n        }\n      });\n    }\n    return this.promise;\n  }\n  async storeResult(e) {\n    try {\n      this.result = await e;\n    } finally {\n      if (undefined === this.result) {\n        this.promise = undefined;\n      }\n    }\n  }\n  value() {\n    return this.result;\n  }\n}\nexports.Task = Task;\nclass Features {\n  constructor(e) {\n    this.ctx = e;\n    this.staticFilters = {};\n    this.dynamicFilters = {};\n    this.upcomingDynamicFilters = {};\n    this.assignments = new h(this.ctx);\n    this.granularityDirectory = new p.GranularityDirectory(\n      \"unspecified\",\n      e.get(o.Clock)\n    );\n  }\n  setPrefix(e) {\n    this.granularityDirectory = new p.GranularityDirectory(\n      e,\n      this.ctx.get(o.Clock)\n    );\n  }\n  registerStaticFilters(e) {\n    Object.assign(this.staticFilters, e);\n  }\n  registerDynamicFilter(e, t) {\n    this.dynamicFilters[e] = t;\n  }\n  getDynamicFilterValues() {\n    const e = {};\n    for (const [t, n] of Object.entries(this.dynamicFilters)) e[t] = n();\n    return e;\n  }\n  registerUpcomingDynamicFilter(e, t) {\n    this.upcomingDynamicFilters[e] = t;\n  }\n  async getAssignment(e, t = {}, n) {\n    var r, o;\n    const i = this.makeFilterSettings(t),\n      s = this.granularityDirectory.extendFilters(i),\n      a = await this.getExpConfig(s.newFilterSettings);\n    this.granularityDirectory.update(\n      i,\n      +(null !==\n        (r = a.variables[l.ExpTreatmentVariables.GranularityByCallBuckets]) &&\n      undefined !== r\n        ? r\n        : NaN),\n      +(null !==\n        (o =\n          a.variables[l.ExpTreatmentVariables.GranularityTimePeriodSizeInH]) &&\n      undefined !== o\n        ? o\n        : NaN)\n    );\n    const c = this.granularityDirectory.extendFilters(i),\n      u = c.newFilterSettings,\n      d = await this.getExpConfig(u);\n    let p = new Promise((e) =>\n      setTimeout(e, Features.upcomingDynamicFilterCheckDelayMs)\n    );\n    for (const e of c.otherFilterSettingsToPrefetch)\n      p = p.then(async () => {\n        await new Promise((e) =>\n          setTimeout(e, Features.upcomingDynamicFilterCheckDelayMs)\n        );\n        this.getExpConfig(e);\n      });\n    this.prepareForUpcomingFilters(u);\n    if (n) {\n      n.filtersAndExp = {\n        exp: d,\n        filters: u,\n      };\n    }\n    return d.variables[e];\n  }\n  makeFilterSettings(e) {\n    return new d.FilterSettings({\n      ...this.staticFilters,\n      ...this.getDynamicFilterValues(),\n      ...e,\n    });\n  }\n  async getExpConfig(e) {\n    try {\n      return this.assignments.fetchExpConfig(e);\n    } catch (e) {\n      return l.ExpConfig.createFallbackConfig(\n        this.ctx,\n        `Error fetching ExP config: ${e}`\n      );\n    }\n  }\n  async prepareForUpcomingFilters(e) {\n    if (!(new Date().getMinutes() < 60 - Features.upcomingTimeBucketMinutes))\n      for (const [t, n] of Object.entries(this.upcomingDynamicFilters)) {\n        await new Promise((e) =>\n          setTimeout(e, Features.upcomingDynamicFilterCheckDelayMs)\n        );\n        this.getExpConfig(e.withChange(t, n()));\n      }\n  }\n  stringify() {\n    var e;\n    const t = this.assignments.getCachedExpConfig(new d.FilterSettings({}));\n    return JSON.stringify(\n      null !== (e = null == t ? undefined : t.variables) && undefined !== e\n        ? e\n        : {}\n    );\n  }\n  async customEngine(e, t, n, r, o) {\n    var i;\n    const s = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t,\n      [d.Filter.CopilotDogfood]: n,\n      [d.Filter.CopilotUserKind]: r,\n    };\n    return null !==\n      (i = await this.getAssignment(\n        l.ExpTreatmentVariables.CustomEngine,\n        s,\n        o\n      )) && undefined !== i\n      ? i\n      : \"\";\n  }\n  async beforeRequestWaitMs(e, t, n) {\n    var r;\n    const o = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t,\n    };\n    return null !==\n      (r = await this.getAssignment(\n        l.ExpTreatmentVariables.BeforeRequestWaitMs,\n        o,\n        n\n      )) && undefined !== r\n      ? r\n      : 0;\n  }\n  async multiLogitBias(e, t, n) {\n    var r;\n    const o = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t,\n    };\n    return (\n      null !==\n        (r = await this.getAssignment(\n          l.ExpTreatmentVariables.MultiLogitBias,\n          o,\n          n\n        )) &&\n      undefined !== r &&\n      r\n    );\n  }\n  async debounceMs() {\n    var e;\n    return null !==\n      (e = await this.getAssignment(l.ExpTreatmentVariables.DebounceMs)) &&\n      undefined !== e\n      ? e\n      : 0;\n  }\n  async debouncePredict() {\n    var e;\n    return (\n      null !==\n        (e = await this.getAssignment(\n          l.ExpTreatmentVariables.DebouncePredict\n        )) &&\n      undefined !== e &&\n      e\n    );\n  }\n  async contextualFilterEnable() {\n    var e;\n    return (\n      null ===\n        (e = await this.getAssignment(\n          l.ExpTreatmentVariables.ContextualFilterEnable\n        )) ||\n      undefined === e ||\n      e\n    );\n  }\n  async contextualFilterAcceptThreshold() {\n    var e;\n    return null !==\n      (e = await this.getAssignment(\n        l.ExpTreatmentVariables.ContextualFilterAcceptThreshold\n      )) && undefined !== e\n      ? e\n      : a.contextualFilterAcceptThreshold;\n  }\n  async disableLogProb() {\n    var e;\n    return (\n      null !==\n        (e = await this.getAssignment(\n          l.ExpTreatmentVariables.disableLogProb\n        )) &&\n      undefined !== e &&\n      e\n    );\n  }\n  async overrideBlockMode() {\n    return await this.getAssignment(l.ExpTreatmentVariables.OverrideBlockMode);\n  }\n  async overrideNumGhostCompletions() {\n    return await this.getAssignment(\n      l.ExpTreatmentVariables.OverrideNumGhostCompletions\n    );\n  }\n  async suffixPercent(e, t) {\n    var n;\n    const r = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t,\n    };\n    return s.getConfig(this.ctx, s.ConfigKey.DebugOverrideEngine)\n      ? 0\n      : null !==\n          (n = await this.getAssignment(\n            l.ExpTreatmentVariables.SuffixPercent,\n            r\n          )) && undefined !== n\n      ? n\n      : 0;\n  }\n  async suffixMatchThreshold(e, t) {\n    var n;\n    const r = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t,\n    };\n    return null !==\n      (n = await this.getAssignment(\n        l.ExpTreatmentVariables.SuffixMatchThreshold,\n        r\n      )) && undefined !== n\n      ? n\n      : 0;\n  }\n  async fimSuffixLengthThreshold(e, t) {\n    var n;\n    const r = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t,\n    };\n    return null !==\n      (n = await this.getAssignment(\n        l.ExpTreatmentVariables.FimSuffixLengthThreshold,\n        r\n      )) && undefined !== n\n      ? n\n      : 0;\n  }\n  async suffixStartMode(e, t) {\n    const n = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t,\n    };\n    switch (\n      await this.getAssignment(l.ExpTreatmentVariables.SuffixStartMode, n)\n    ) {\n      default:\n        return r.SuffixStartMode.Cursor;\n      case \"cursortrimstart\":\n        return r.SuffixStartMode.CursorTrimStart;\n      case \"siblingblock\":\n        return r.SuffixStartMode.SiblingBlock;\n      case \"siblingblocktrimstart\":\n        return r.SuffixStartMode.SiblingBlockTrimStart;\n    }\n  }\n  async neighboringTabsOption(e, t) {\n    const n = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t,\n    };\n    switch (\n      await this.getAssignment(l.ExpTreatmentVariables.NeighboringTabsOption, n)\n    ) {\n      case \"none\":\n        return r.NeighboringTabsOption.None;\n      case \"conservative\":\n        return r.NeighboringTabsOption.Conservative;\n      case \"medium\":\n        return r.NeighboringTabsOption.Medium;\n      default:\n        return r.NeighboringTabsOption.Eager;\n      case \"eagerbutlittle\":\n        return r.NeighboringTabsOption.EagerButLittle;\n    }\n  }\n  async repetitionFilterMode() {\n    switch (\n      await this.getAssignment(l.ExpTreatmentVariables.RepetitionFilterMode)\n    ) {\n      case \"proxy\":\n        return c.RepetitionFilterMode.PROXY;\n      case \"both\":\n        return c.RepetitionFilterMode.BOTH;\n      default:\n        return c.RepetitionFilterMode.CLIENT;\n    }\n  }\n  async addExpAndFilterToTelemetry(e) {\n    const t = this.makeFilterSettings({});\n    e.filtersAndExp = {\n      filters: t,\n      exp: await this.getExpConfig(t),\n    };\n  }\n}\nexports.Features = Features;\nFeatures.upcomingDynamicFilterCheckDelayMs = 20;\nFeatures.upcomingTimeBucketMinutes = 5 + Math.floor(11 * Math.random());",
  "9216": "function n(e, r, o, i, s, a) {\n  var c = Math.floor((r - e) / 2) + e,\n    l = s(o, i[c], !0);\n  return 0 === l\n    ? c\n    : l > 0\n    ? r - c > 1\n      ? n(c, r, o, i, s, a)\n      : a == exports.LEAST_UPPER_BOUND\n      ? r < i.length\n        ? r\n        : -1\n      : c\n    : c - e > 1\n    ? n(e, c, o, i, s, a)\n    : a == exports.LEAST_UPPER_BOUND\n    ? c\n    : e < 0\n    ? -1\n    : e;\n}\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\nexports.search = function (e, r, o, i) {\n  if (0 === r.length) return -1;\n  var s = n(-1, r.length, e, r, o, i || exports.GREATEST_LOWER_BOUND);\n  if (s < 0) return -1;\n  for (; s - 1 >= 0 && 0 === o(r[s], r[s - 1], !0); ) --s;\n  return s;\n};",
  "9253": "var r = require(9962),\n  o = require(5158),\n  i = require(3580),\n  s = require(\"url\"),\n  a = (function () {\n    function e(t) {\n      var n = this;\n      this.endpointBase = i.DEFAULT_BREEZE_ENDPOINT;\n      var r = process.env[e.ENV_connectionString],\n        a = o.parse(t),\n        c = o.parse(r),\n        l = !a.instrumentationkey && Object.keys(a).length > 0 ? null : t;\n      this.instrumentationKey =\n        a.instrumentationkey ||\n        l ||\n        c.instrumentationkey ||\n        e._getInstrumentationKey();\n      this.endpointUrl =\n        (a.ingestionendpoint || c.ingestionendpoint || this.endpointBase) +\n        \"/v2/track\";\n      this.maxBatchSize = 250;\n      this.maxBatchIntervalMs = 15e3;\n      this.disableAppInsights = !1;\n      this.samplingPercentage = 100;\n      this.correlationIdRetryIntervalMs = 3e4;\n      this.correlationHeaderExcludedDomains = [\n        \"*.core.windows.net\",\n        \"*.core.chinacloudapi.cn\",\n        \"*.core.cloudapi.de\",\n        \"*.core.usgovcloudapi.net\",\n        \"*.core.microsoft.scloud\",\n        \"*.core.eaglex.ic.gov\",\n      ];\n      this.setCorrelationId = function (e) {\n        return (n.correlationId = e);\n      };\n      this.proxyHttpUrl = process.env[e.ENV_http_proxy] || undefined;\n      this.proxyHttpsUrl = process.env[e.ENV_https_proxy] || undefined;\n      this.httpAgent = undefined;\n      this.httpsAgent = undefined;\n      this.profileQueryEndpoint =\n        a.ingestionendpoint ||\n        c.ingestionendpoint ||\n        process.env[e.ENV_profileQueryEndpoint] ||\n        this.endpointBase;\n      this._quickPulseHost =\n        a.liveendpoint ||\n        c.liveendpoint ||\n        process.env[e.ENV_quickPulseHost] ||\n        i.DEFAULT_LIVEMETRICS_HOST;\n      if (this._quickPulseHost.match(/^https?:\\/\\//)) {\n        this._quickPulseHost = s.parse(this._quickPulseHost).host;\n      }\n    }\n    Object.defineProperty(e.prototype, \"profileQueryEndpoint\", {\n      get: function () {\n        return this._profileQueryEndpoint;\n      },\n      set: function (e) {\n        r.cancelCorrelationIdQuery(this, this.setCorrelationId);\n        this._profileQueryEndpoint = e;\n        this.correlationId = r.correlationIdPrefix;\n        r.queryCorrelationId(this, this.setCorrelationId);\n      },\n      enumerable: !0,\n      configurable: !0,\n    });\n    Object.defineProperty(e.prototype, \"quickPulseHost\", {\n      get: function () {\n        return this._quickPulseHost;\n      },\n      set: function (e) {\n        this._quickPulseHost = e;\n      },\n      enumerable: !0,\n      configurable: !0,\n    });\n    e._getInstrumentationKey = function () {\n      var t =\n        process.env[e.ENV_iKey] ||\n        process.env[e.ENV_azurePrefix + e.ENV_iKey] ||\n        process.env[e.legacy_ENV_iKey] ||\n        process.env[e.ENV_azurePrefix + e.legacy_ENV_iKey];\n      if (!t || \"\" == t)\n        throw new Error(\n          \"Instrumentation key not found, pass the key in the config to this method or set the key in the environment variable APPINSIGHTS_INSTRUMENTATIONKEY before starting the server\"\n        );\n      return t;\n    };\n    e.ENV_azurePrefix = \"APPSETTING_\";\n    e.ENV_iKey = \"APPINSIGHTS_INSTRUMENTATIONKEY\";\n    e.legacy_ENV_iKey = \"APPINSIGHTS_INSTRUMENTATION_KEY\";\n    e.ENV_profileQueryEndpoint = \"APPINSIGHTS_PROFILE_QUERY_ENDPOINT\";\n    e.ENV_quickPulseHost = \"APPINSIGHTS_QUICKPULSE_HOST\";\n    e.ENV_connectionString = \"APPLICATIONINSIGHTS_CONNECTION_STRING\";\n    e.ENV_nativeMetricsDisablers =\n      \"APPLICATION_INSIGHTS_DISABLE_EXTENDED_METRIC\";\n    e.ENV_nativeMetricsDisableAll =\n      \"APPLICATION_INSIGHTS_DISABLE_ALL_EXTENDED_METRICS\";\n    e.ENV_http_proxy = \"http_proxy\";\n    e.ENV_https_proxy = \"https_proxy\";\n    return e;\n  })();\nmodule.exports = a;",
  "9266": "var r = require(3905),\n  o = require(9073);\nmodule.exports = function (e) {\n  var t = r(e);\n  t.token = \"\";\n  if (\"x-oauth-basic\" === t.password) {\n    t.token = t.user;\n  } else {\n    if (\"x-token-auth\" === t.user) {\n      t.token = t.password;\n    }\n  }\n  if (o(t.protocols) || (0 === t.protocols.length && o(e))) {\n    t.protocol = \"ssh\";\n  } else {\n    if (t.protocols.length) {\n      t.protocol = t.protocols[0];\n    } else {\n      t.protocol = \"file\";\n      t.protocols = [\"file\"];\n    }\n  }\n  t.href = t.href.replace(/\\/$/, \"\");\n  return t;\n};",
  "9306": "var n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.DiscrError = undefined;\n(n = exports.DiscrError || (exports.DiscrError = {})).Tag = \"tag\";\nn.Mapping = \"mapping\";",
  "9334": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getGhostText =\n  exports.completionCache =\n  exports.ResultType =\n  exports.ghostTextLogger =\n    undefined;\nconst r = require(3055563),\n  o = require(2277),\n  i = require(3076),\n  s = require(106),\n  a = require(6932),\n  c = require(1133),\n  l = require(9189),\n  u = require(9899),\n  d = require(2279),\n  p = require(3),\n  h = require(4419),\n  f = require(937),\n  m = require(6722),\n  g = require(7727),\n  _ = require(4969),\n  y = require(766),\n  v = require(1006),\n  b = require(1124),\n  w = require(6333),\n  x = require(70),\n  E = require(6403),\n  C = require(8965),\n  S = require(5413),\n  T = require(750);\nvar k;\nlet I, P;\nasync function A(e, n, r, o, i, s, a) {\n  var u, p, m;\n  exports.ghostTextLogger.debug(e, `Getting ${s} from network`);\n  r = r.extendedBy();\n  const g = await (async function (e, t) {\n      const n = await e.get(l.Features).overrideNumGhostCompletions();\n      return n\n        ? t.isCycling\n          ? Math.max(0, 3 - n)\n          : n\n        : c.shouldDoParsingTrimming(t.blockMode) && t.multiline\n        ? c.getConfig(e, c.ConfigKey.InlineSuggestCount)\n        : t.isCycling\n        ? 2\n        : 1;\n    })(e, n),\n    _ = f.getTemperatureForSamples(e, g),\n    y = {\n      stream: !0,\n      n: g,\n      temperature: _,\n      extra: {\n        language: n.languageId,\n        next_indent:\n          null !== (u = n.indentation.next) && undefined !== u ? u : 0,\n        trim_by_indentation: c.shouldDoServerTrimming(n.blockMode),\n      },\n    };\n  if (n.multiline) {\n    y.stop = [\"\\n\"];\n  }\n  if (n.multiline && n.multiLogitBias) {\n    y.logit_bias = {\n      50256: -100,\n    };\n  }\n  const v = Date.now(),\n    b = {\n      endpoint: \"completions\",\n      uiKind: h.CopilotUiKind.GhostText,\n      isCycling: JSON.stringify(n.isCycling),\n      temperature: JSON.stringify(_),\n      n: JSON.stringify(g),\n      stop:\n        null !== (p = JSON.stringify(y.stop)) && undefined !== p ? p : \"unset\",\n      logit_bias: JSON.stringify(\n        null !== (m = y.logit_bias) && undefined !== m ? m : null\n      ),\n    },\n    E = w.telemetrizePromptLength(n.prompt);\n  Object.assign(r.properties, b);\n  Object.assign(r.measurements, E);\n  try {\n    const s = {\n      prompt: n.prompt,\n      languageId: n.languageId,\n      repoInfo: n.repoInfo,\n      ourRequestId: n.ourRequestId,\n      engineUrl: n.engineURL,\n      count: g,\n      uiKind: h.CopilotUiKind.GhostText,\n      postOptions: y,\n    };\n    if (n.delayMs > 0) {\n      await new Promise((e) => setTimeout(e, n.delayMs));\n    }\n    const c = await e\n      .get(h.OpenAIFetcher)\n      .fetchAndStreamCompletions(e, s, r, i, o);\n    return \"failed\" === c.type\n      ? {\n          type: \"failed\",\n          reason: c.reason,\n          telemetryData: T.mkBasicResultTelemetry(r),\n        }\n      : \"canceled\" === c.type\n      ? (exports.ghostTextLogger.debug(\n          e,\n          \"Cancelled after awaiting fetchCompletions\"\n        ),\n        {\n          type: \"canceled\",\n          reason: c.reason,\n          telemetryData: T.mkCanceledResultTelemetry(r),\n        })\n      : a(g, v, c.getProcessingTime(), c.choices);\n  } catch (n) {\n    if (d.isAbortError(n))\n      return {\n        type: \"canceled\",\n        reason: \"network request aborted\",\n        telemetryData: T.mkCanceledResultTelemetry(r, {\n          cancelledNetworkRequest: !0,\n        }),\n      };\n    exports.ghostTextLogger.error(e, `Error on ghost text request ${n}`);\n    if ((0, x.shouldFailForDebugPurposes)(e)) throw n;\n    return {\n      type: \"failed\",\n      reason: \"non-abort error on ghost text request\",\n      telemetryData: T.mkBasicResultTelemetry(r),\n    };\n  }\n}\nfunction O(e, t) {\n  const n = {\n    ...e,\n  };\n  n.completionText = e.completionText.trimEnd();\n  if (t.forceSingleLine) {\n    n.completionText = n.completionText.split(\"\\n\")[0];\n  }\n  return n;\n}\nexports.ghostTextLogger = new u.Logger(u.LogLevel.INFO, \"ghostText\");\n(function (e) {\n  e[(e.Network = 0)] = \"Network\";\n  e[(e.Cache = 1)] = \"Cache\";\n  e[(e.TypingAsSuggested = 2)] = \"TypingAsSuggested\";\n  e[(e.Cycling = 3)] = \"Cycling\";\n})((k = exports.ResultType || (exports.ResultType = {})));\nexports.completionCache = new i.LRUCache(100);\nconst N = new s.Debouncer();\nfunction R(e, t) {\n  I = e;\n  P = t;\n}\nfunction M(e, n, r) {\n  const o = i.keyForPrompt(n.prompt),\n    s = exports.completionCache.get(o);\n  if (s && s.multiline === r.multiline) {\n    exports.completionCache.put(o, {\n      multiline: s.multiline,\n      choices: s.choices.concat(r.choices),\n    });\n  } else {\n    exports.completionCache.put(o, r);\n  }\n  exports.ghostTextLogger.debug(\n    e,\n    `Appended cached ghost text for key: ${o}, multiline: ${r.multiline}, number of suggestions: ${r.choices.length}`\n  );\n}\nfunction L(e, n) {\n  const r = exports.completionCache.get(e);\n  if (r && (!n || r.multiline)) return r.choices;\n}\nfunction $(e, t, n) {\n  if (n.length > 0) {\n    if (t.startsWith(n))\n      return {\n        completionIndex: e,\n        completionText: t,\n        displayText: t.substr(n.length),\n        displayNeedsWsOffset: !1,\n      };\n    {\n      const r = t.substr(0, t.length - t.trimLeft().length);\n      return n.startsWith(r)\n        ? {\n            completionIndex: e,\n            completionText: t,\n            displayText: t.trimLeft(),\n            displayNeedsWsOffset: !0,\n          }\n        : {\n            completionIndex: e,\n            completionText: t,\n            displayText: t,\n            displayNeedsWsOffset: !1,\n          };\n    }\n  }\n  return {\n    completionIndex: e,\n    completionText: t,\n    displayText: t,\n    displayNeedsWsOffset: !1,\n  };\n}\nfunction D(e, n) {\n  const r = n.requestId,\n    o = {\n      choiceIndex: n.choiceIndex.toString(),\n    },\n    i = {\n      numTokens: n.numTokens,\n      compCharLen: n.completionText.length,\n      numLines: n.completionText.split(\"\\n\").length,\n    };\n  if (n.meanLogProb) {\n    i.meanLogProb = n.meanLogProb;\n  }\n  if (n.meanAlternativeLogProb) {\n    i.meanAlternativeLogProb = n.meanAlternativeLogProb;\n  }\n  const s = n.telemetryData.extendedBy(o, i);\n  s.extendWithRequestId(r);\n  s.measurements.confidence = v.ghostTextScoreConfidence(e, s);\n  s.measurements.quantile = v.ghostTextScoreQuantile(e, s);\n  exports.ghostTextLogger.debug(\n    e,\n    `Extended telemetry for ${n.telemetryData.properties.headerRequestId} with retention confidence ${s.measurements.confidence} (expected as good or better than about ${s.measurements.quantile} of all suggestions)`\n  );\n  return s;\n}\nfunction F(e, t, n, r, o) {\n  const i = Date.now() - r,\n    s = i - o,\n    a = n.telemetryData.extendedBy(\n      {},\n      {\n        completionCharLen: n.completionText.length,\n        requestTimeMs: i,\n        processingTimeMs: o,\n        deltaMs: s,\n        meanLogProb: n.meanLogProb || NaN,\n        meanAlternativeLogProb: n.meanAlternativeLogProb || NaN,\n        numTokens: n.numTokens,\n      }\n    );\n  a.extendWithRequestId(n.requestId);\n  w.telemetry(e, `ghostText.${t}`, a);\n}\nexports.getGhostText = async function (e, n, s, u, d, f) {\n  var v, j;\n  const q = await _.extractPrompt(e, n, s);\n  if (\"contextTooShort\" === q.type) {\n    exports.ghostTextLogger.debug(e, \"Breaking, not enough context\");\n    return {\n      type: \"abortedBeforeIssued\",\n      reason: \"Not enough context\",\n    };\n  }\n  if (null == f ? undefined : f.isCancellationRequested) {\n    exports.ghostTextLogger.info(e, \"Cancelled after extractPrompt\");\n    return {\n      type: \"abortedBeforeIssued\",\n      reason: \"Cancelled after extractPrompt\",\n    };\n  }\n  const B = (function (e, t) {\n    const n =\n        ((o = t), 0 != e.lineAt(o).text.substr(o.character).trim().length),\n      r = (function (e, t) {\n        const n = t.lineAt(e).text.substr(e.character).trim();\n        return /^\\s*[)}\\]\"'`]*\\s*[:{;,]?\\s*$/.test(n);\n      })(t, e);\n    var o;\n    if (!n || r) return n && r;\n  })(n, s);\n  if (undefined === B) {\n    exports.ghostTextLogger.debug(e, \"Breaking, invalid middle of the line\");\n    return {\n      type: \"abortedBeforeIssued\",\n      reason: \"Invalid middle of the line\",\n    };\n  }\n  const U = e.get(m.StatusReporter),\n    H = e.get(E.LocationFactory),\n    z = await (async function (e, t, n, o, i, s) {\n      const a = await e.get(c.BlockModeConfig).forLanguage(e, t.languageId);\n      switch (a) {\n        case c.BlockMode.Server:\n          return {\n            blockMode: c.BlockMode.Server,\n            requestMultiline: !0,\n            isCyclingRequest: i,\n            finishedCb: async (e) => {},\n          };\n        case c.BlockMode.Parsing:\n        case c.BlockMode.ParsingAndServer:\n        default: {\n          const c = await (async function (e, t, n, o) {\n            if (t.lineCount >= 8e3)\n              w.telemetry(\n                e,\n                \"ghostText.longFileMultilineSkip\",\n                w.TelemetryData.createAndMarkAsIssued({\n                  languageId: t.languageId,\n                  lineCount: String(t.lineCount),\n                  currentLine: String(n.line),\n                })\n              );\n            else {\n              if (!o && r.isSupportedLanguageId(t.languageId))\n                return await g.isEmptyBlockStart(t, n);\n              if (o && r.isSupportedLanguageId(t.languageId))\n                return (\n                  (await g.isEmptyBlockStart(t, n)) ||\n                  (await g.isEmptyBlockStart(t, t.lineAt(n).range.end))\n                );\n            }\n            return !1;\n          })(e, t, n, s);\n          return c\n            ? {\n                blockMode: a,\n                requestMultiline: !0,\n                isCyclingRequest: !1,\n                finishedCb: async (r) => {\n                  let i;\n                  i =\n                    o.trailingWs.length > 0 &&\n                    !o.prompt.prefix.endsWith(o.trailingWs)\n                      ? e\n                          .get(E.LocationFactory)\n                          .position(\n                            n.line,\n                            Math.max(n.character - o.trailingWs.length, 0)\n                          )\n                      : n;\n                  return g.isBlockBodyFinished(e, t, i, r);\n                },\n              }\n            : {\n                blockMode: a,\n                requestMultiline: !1,\n                isCyclingRequest: i,\n                finishedCb: async (e) => {},\n              };\n        }\n      }\n    })(e, n, s, q, u, B);\n  if (null == f ? undefined : f.isCancellationRequested) {\n    exports.ghostTextLogger.info(e, \"Cancelled after requestMultiline\");\n    return {\n      type: \"abortedBeforeIssued\",\n      reason: \"Cancelled after requestMultiline\",\n    };\n  }\n  const [G] = _.trimLastLine(n.getText(H.range(H.position(0, 0), s)));\n  let V = (function (e, n, r, o) {\n    const s = (function (e, n, r) {\n      if (!I || !P || !n.startsWith(I)) return;\n      const o = L(P, r);\n      if (!o) return;\n      const i = n.substring(I.length);\n      exports.ghostTextLogger.debug(\n        e,\n        `Getting completions for user-typing flow - remaining prefix: ${i}`\n      );\n      const s = [];\n      o.forEach((e) => {\n        const t = O(e, {\n          forceSingleLine: !1,\n        });\n        if (t.completionText.startsWith(i)) {\n          t.completionText = t.completionText.substring(i.length);\n          s.push(t);\n        }\n      });\n      return s;\n    })(e, n, o);\n    if (s && s.length > 0) return [s, k.TypingAsSuggested];\n    const a = (function (e, n, r, o) {\n      const s = i.keyForPrompt(r);\n      exports.ghostTextLogger.debug(\n        e,\n        `Trying to get completions from cache for key: ${s}`\n      );\n      const a = L(s, o);\n      if (a) {\n        exports.ghostTextLogger.debug(\n          e,\n          `Got completions from cache for key: ${s}`\n        );\n        const r = [];\n        a.forEach((e) => {\n          const t = O(e, {\n            forceSingleLine: !o,\n          });\n          r.push(t);\n        });\n        const i = r.filter((e) => e.completionText);\n        if (i.length > 0) {\n          R(n, s);\n        }\n        return i;\n      }\n    })(e, n, r, o);\n    return a && a.length > 0 ? [a, k.Cache] : undefined;\n  })(e, G, q.prompt, z.requestMultiline);\n  const W = o.v4(),\n    K = y.extractRepoInfoInBackground(e, n.fileName),\n    J = await p.getEngineURL(\n      e,\n      y.tryGetGitHubNWO(K),\n      n.languageId,\n      y.getDogFood(K),\n      await y.getUserKind(e),\n      d\n    ),\n    X = await e\n      .get(l.Features)\n      .beforeRequestWaitMs(y.tryGetGitHubNWO(K) || \"\", n.languageId),\n    Q = await e\n      .get(l.Features)\n      .multiLogitBias(y.tryGetGitHubNWO(K) || \"\", n.languageId),\n    Y = {\n      blockMode: z.blockMode,\n      languageId: n.languageId,\n      repoInfo: K,\n      engineURL: J,\n      ourRequestId: W,\n      prefix: G,\n      prompt: q.prompt,\n      multiline: z.requestMultiline,\n      indentation: g.contextIndentation(n, s),\n      isCycling: u,\n      delayMs: X,\n      multiLogitBias: Q,\n    },\n    Z = await e.get(l.Features).debouncePredict(),\n    ee = await e.get(l.Features).contextualFilterEnable(),\n    te = await e.get(l.Features).contextualFilterAcceptThreshold();\n  let ne = !1;\n  if (Z || ee) {\n    ne = !0;\n  }\n  const re = (function (e, t, n, r, o, i, s) {\n    const a = e.get(E.LocationFactory),\n      c = t.lineAt(r.line),\n      l = t.getText(a.range(c.range.start, r)),\n      u = t.getText(a.range(r, c.range.end)),\n      d = {\n        languageId: t.languageId,\n        beforeCursorWhitespace: JSON.stringify(\"\" === l.trim()),\n        afterCursorWhitespace: JSON.stringify(\"\" === u.trim()),\n      },\n      p = {\n        ...w.telemetrizePromptLength(o.prompt),\n        promptEndPos: t.offsetAt(r),\n        documentLength: t.getText().length,\n        delayMs: n.delayMs,\n      },\n      f = i.extendedBy(d, p);\n    f.properties.promptChoices = JSON.stringify(o.promptChoices, (e, t) =>\n      t instanceof Map\n        ? Array.from(t.entries()).reduce(\n            (e, [t, n]) => ({\n              ...e,\n              [t]: n,\n            }),\n            {}\n          )\n        : t\n    );\n    f.properties.promptBackground = JSON.stringify(o.promptBackground, (e, t) =>\n      t instanceof Map ? Array.from(t.values()) : t\n    );\n    f.measurements.promptComputeTimeMs = o.computeTimeMs;\n    if (s) {\n      f.measurements.contextualFilterScore = C.contextualFilterScore(\n        e,\n        f,\n        o.prompt\n      );\n    }\n    const m = n.repoInfo;\n    f.properties.gitRepoInformation =\n      undefined === m\n        ? \"unavailable\"\n        : m === y.ComputationStatus.PENDING\n        ? \"pending\"\n        : \"available\";\n    if (undefined !== m && m !== y.ComputationStatus.PENDING) {\n      f.properties.gitRepoUrl = m.url;\n      f.properties.gitRepoHost = m.hostname;\n      f.properties.gitRepoOwner = m.owner;\n      f.properties.gitRepoName = m.repo;\n      f.properties.gitRepoPath = m.pathname;\n    }\n    f.properties.engineName = h.extractEngineName(e, n.engineURL);\n    f.properties.isMultiline = JSON.stringify(n.multiline);\n    f.properties.blockMode = n.blockMode;\n    f.properties.isCycling = JSON.stringify(n.isCycling);\n    f.properties.headerRequestId = n.ourRequestId;\n    w.telemetry(e, \"ghostText.issued\", f);\n    return f;\n  })(e, n, Y, s, q, d, ne);\n  if (\n    (z.isCyclingRequest &&\n      (null !== (v = null == V ? undefined : V[0].length) && undefined !== v\n        ? v\n        : 0) > 1) ||\n    (!z.isCyclingRequest && undefined !== V)\n  )\n    exports.ghostTextLogger.info(e, \"Found inline suggestions locally\");\n  else {\n    if (null == U) {\n      U.setProgress();\n    }\n    if (z.isCyclingRequest) {\n      const n = await (async function (e, n, r, o, i) {\n        return A(e, n, r, o, i, \"all completions\", async (i, s, a, c) => {\n          const l = [];\n          for await (const n of c) {\n            if (null == o ? void 0 : o.isCancellationRequested)\n              return (\n                exports.ghostTextLogger.debug(\n                  e,\n                  \"Cancelled after awaiting choices iterator\"\n                ),\n                {\n                  type: \"canceled\",\n                  reason: \"after awaiting choices iterator\",\n                  telemetryData: (0, T.mkCanceledResultTelemetry)(r),\n                }\n              );\n            if (n.completionText.trimEnd()) {\n              if (\n                -1 !==\n                l.findIndex(\n                  (e) => e.completionText.trim() === n.completionText.trim()\n                )\n              )\n                continue;\n              l.push(n);\n            }\n          }\n          return (\n            l.length > 0 &&\n              (M(e, n, {\n                multiline: n.multiline,\n                choices: l,\n              }),\n              F(e, \"cyclingPerformance\", l[0], s, a)),\n            {\n              type: \"success\",\n              value: l,\n              telemetryData: (0, T.mkBasicResultTelemetry)(r),\n              telemetryBlob: r,\n            }\n          );\n        });\n      })(e, Y, re, f, z.finishedCb);\n      if (\"success\" === n.type) {\n        const e =\n          null !== (j = null == V ? void 0 : V[0]) && void 0 !== j ? j : [];\n        n.value.forEach((t) => {\n          -1 ===\n            e.findIndex(\n              (e) => e.completionText.trim() === t.completionText.trim()\n            ) && e.push(t);\n        }),\n          (V = [e, k.Cycling]);\n      } else if (void 0 === V) return null == U || U.removeProgress(), n;\n    } else {\n      const n = await (0, S.getDebounceLimit)(e, re);\n      try {\n        await N.debounce(n);\n      } catch {\n        return {\n          type: \"canceled\",\n          reason: \"by debouncer\",\n          telemetryData: (0, T.mkCanceledResultTelemetry)(re),\n        };\n      }\n      if (null == f ? void 0 : f.isCancellationRequested)\n        return (\n          exports.ghostTextLogger.info(e, \"Cancelled during debounce\"),\n          {\n            type: \"canceled\",\n            reason: \"during debounce\",\n            telemetryData: (0, T.mkCanceledResultTelemetry)(re),\n          }\n        );\n      if (\n        ee &&\n        re.measurements.contextualFilterScore &&\n        re.measurements.contextualFilterScore < te / 100\n      )\n        return (\n          exports.ghostTextLogger.info(e, \"Cancelled by contextual filter\"),\n          {\n            type: \"canceled\",\n            reason: \"contextualFilterScore below threshold\",\n            telemetryData: (0, T.mkCanceledResultTelemetry)(re),\n          }\n        );\n      const r = await (async function (e, n, r, o, s) {\n        return A(e, n, r, o, s, \"completions\", async (s, a, c, l) => {\n          const u = l[Symbol.asyncIterator](),\n            d = await u.next();\n          if (d.done)\n            return (\n              exports.ghostTextLogger.debug(e, \"All choices redacted\"),\n              {\n                type: \"empty\",\n                reason: \"all choices redacted\",\n                telemetryData: (0, T.mkBasicResultTelemetry)(r),\n              }\n            );\n          if (null == o ? void 0 : o.isCancellationRequested)\n            return (\n              exports.ghostTextLogger.debug(\n                e,\n                \"Cancelled after awaiting redactedChoices iterator\"\n              ),\n              {\n                type: \"canceled\",\n                reason: \"after awaiting redactedChoices iterator\",\n                telemetryData: (0, T.mkCanceledResultTelemetry)(r),\n              }\n            );\n          const p = d.value;\n          if (void 0 === p)\n            return (\n              exports.ghostTextLogger.debug(\n                e,\n                \"Got undefined choice from redactedChoices iterator\"\n              ),\n              {\n                type: \"empty\",\n                reason: \"got undefined choice from redactedChoices iterator\",\n                telemetryData: (0, T.mkBasicResultTelemetry)(r),\n              }\n            );\n          F(e, \"performance\", p, a, c);\n          const h = s - 1;\n          exports.ghostTextLogger.debug(\n            e,\n            `Awaited first result, id:  ${p.choiceIndex}`\n          ),\n            (function (e, n, r) {\n              const o = (0, i.keyForPrompt)(n.prompt);\n              R(n.prefix, o),\n                exports.completionCache.put(o, r),\n                exports.ghostTextLogger.debug(\n                  e,\n                  `Cached ghost text for key: ${o}, multiline: ${r.multiline}, number of suggestions: ${r.choices.length}`\n                );\n            })(e, n, {\n              multiline: n.multiline,\n              choices: [p],\n            });\n          const f = [];\n          for (let e = 0; e < h; e++) f.push(u.next());\n          const m = Promise.all(f).then((r) => {\n            exports.ghostTextLogger.debug(\n              e,\n              `Awaited remaining results, number of results: ${r.length}`\n            );\n            const o = [];\n            for (const n of r) {\n              const r = n.value;\n              if (\n                void 0 !== r &&\n                (exports.ghostTextLogger.info(\n                  e,\n                  `GhostText later completion: [${r.completionText}]`\n                ),\n                r.completionText.trimEnd())\n              ) {\n                if (\n                  -1 !==\n                  o.findIndex(\n                    (e) => e.completionText.trim() === r.completionText.trim()\n                  )\n                )\n                  continue;\n                if (r.completionText.trim() === p.completionText.trim())\n                  continue;\n                o.push(r);\n              }\n            }\n            o.length > 0 &&\n              M(e, n, {\n                multiline: n.multiline,\n                choices: o,\n              });\n          });\n          return (\n            (0, x.isRunningInTest)(e) && (await m),\n            {\n              type: \"success\",\n              value: O(d.value, {\n                forceSingleLine: !1,\n              }),\n              telemetryData: (0, T.mkBasicResultTelemetry)(r),\n              telemetryBlob: r,\n            }\n          );\n        });\n      })(e, Y, re, f, z.finishedCb);\n      if (\"success\" !== r.type) return null == U || U.removeProgress(), r;\n      V = [[r.value], k.Network];\n    }\n    if (null == U) {\n      U.removeProgress();\n    }\n  }\n  if (undefined === V)\n    return {\n      type: \"failed\",\n      reason: \"internal error: choices should be defined after network call\",\n      telemetryData: T.mkBasicResultTelemetry(re),\n    };\n  const [oe, ie] = V,\n    se = a.asyncIterableMapFilter(a.asyncIterableFromArray(oe), async (r) =>\n      b.postProcessChoice(e, \"ghostText\", n, s, r, B, exports.ghostTextLogger)\n    ),\n    ae = [];\n  for await (const r of se) {\n    const o = B && b.checkSuffix(n, s, r);\n    if (null == f ? undefined : f.isCancellationRequested) {\n      exports.ghostTextLogger.info(\n        e,\n        \"Cancelled after post processing completions\"\n      );\n      return {\n        type: \"canceled\",\n        reason: \"after post processing completions\",\n        telemetryData: T.mkCanceledResultTelemetry(re),\n      };\n    }\n    const i = D(e, r),\n      a = {\n        completion: $(r.choiceIndex, r.completionText, q.trailingWs),\n        telemetry: i,\n        isMiddleOfTheLine: B,\n        coversSuffix: o,\n      };\n    ae.push(a);\n  }\n  return {\n    type: \"success\",\n    value: [ae, ie],\n    telemetryData: T.mkBasicResultTelemetry(re),\n    telemetryBlob: re,\n  };\n};",
  "9351": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(412),\n  o = require(3487),\n  i = require(2141),\n  s = require(6776),\n  a = {\n    keyword: \"additionalProperties\",\n    type: [\"object\"],\n    schemaType: [\"boolean\", \"object\"],\n    allowUndefined: !0,\n    trackErrors: !0,\n    error: {\n      message: \"must NOT have additional properties\",\n      params: ({ params: e }) =>\n        o._`{additionalProperty: ${e.additionalProperty}}`,\n    },\n    code(e) {\n      const {\n        gen: t,\n        schema: n,\n        parentSchema: a,\n        data: c,\n        errsCount: l,\n        it: u,\n      } = e;\n      if (!l) throw new Error(\"ajv implementation error\");\n      const { allErrors: d, opts: p } = u;\n      u.props = !0;\n      if (\"all\" !== p.removeAdditional && (0, s.alwaysValidSchema)(u, n))\n        return;\n      const h = r.allSchemaProperties(a.properties),\n        f = r.allSchemaProperties(a.patternProperties);\n      function m(e) {\n        t.code(o._`delete ${c}[${e}]`);\n      }\n      function g(r) {\n        if (\"all\" === p.removeAdditional || (p.removeAdditional && !1 === n))\n          m(r);\n        else {\n          if (!1 === n) {\n            e.setParams({\n              additionalProperty: r,\n            });\n            e.error();\n            return void (d || t.break());\n          }\n          if (\"object\" == typeof n && !s.alwaysValidSchema(u, n)) {\n            const n = t.name(\"valid\");\n            if (\"failing\" === p.removeAdditional) {\n              _(r, n, !1);\n              t.if(o.not(n), () => {\n                e.reset();\n                m(r);\n              });\n            } else {\n              _(r, n);\n              if (d) {\n                t.if(o.not(n), () => t.break());\n              }\n            }\n          }\n        }\n      }\n      function _(t, n, r) {\n        const o = {\n          keyword: \"additionalProperties\",\n          dataProp: t,\n          dataPropType: s.Type.Str,\n        };\n        if (!1 === r) {\n          Object.assign(o, {\n            compositeRule: !0,\n            createErrors: !1,\n            allErrors: !1,\n          });\n        }\n        e.subschema(o, n);\n      }\n      t.forIn(\"key\", c, (n) => {\n        if (h.length || f.length) {\n          t.if(\n            (function (n) {\n              let i;\n              if (h.length > 8) {\n                const e = s.schemaRefOrVal(u, a.properties, \"properties\");\n                i = r.isOwnProperty(t, e, n);\n              } else\n                i = h.length\n                  ? o.or(...h.map((e) => o._`${n} === ${e}`))\n                  : o.nil;\n              if (f.length) {\n                i = o.or(\n                  i,\n                  ...f.map((t) => o._`${r.usePattern(e, t)}.test(${n})`)\n                );\n              }\n              return o.not(i);\n            })(n),\n            () => g(n)\n          );\n        } else {\n          g(n);\n        }\n      });\n      e.ok(o._`${l} === ${i.default.errors}`);\n    },\n  };\nexports.default = a;",
  "9380": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.setupExperimentationService = exports.logger = undefined;\nconst r = require(\"vscode\"),\n  o = require(1133),\n  i = require(9189),\n  s = require(8142),\n  a = require(9899);\nfunction c(e) {\n  return e.split(\"-\")[0];\n}\nexports.logger = new a.Logger(a.LogLevel.INFO, \"Exp\");\nexports.setupExperimentationService = function (e) {\n  const t = e.get(i.Features);\n  t.setPrefix(r.env.machineId);\n  t.registerStaticFilters(\n    (function (e) {\n      const t = e.get(o.BuildInfo);\n      return {\n        [s.Filter.ApplicationVersion]: c(r.version),\n        [s.Filter.Build]: r.env.appName,\n        [s.Filter.ClientId]: r.env.machineId,\n        [s.Filter.ExtensionName]: t.getName(),\n        [s.Filter.ExtensionVersion]: c(t.getVersion()),\n        [s.Filter.Language]: r.env.language,\n        [s.Filter.TargetPopulation]: s.TargetPopulation.Public,\n      };\n    })(e)\n  );\n  t.registerDynamicFilter(s.Filter.CopilotOverrideEngine, () =>\n    o.getConfig(e, o.ConfigKey.DebugOverrideEngine)\n  );\n};",
  "9382": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r = require(9958),\n  RemoteDependencyDataConstants = (function () {\n    function e() {}\n    e.TYPE_HTTP = \"Http\";\n    e.TYPE_AI = \"Http (tracked component)\";\n    return e;\n  })();\nexports.RemoteDependencyDataConstants = RemoteDependencyDataConstants;\nexports.domainSupportsProperties = function (e) {\n  return (\n    \"properties\" in e ||\n    e instanceof r.EventData ||\n    e instanceof r.ExceptionData ||\n    e instanceof r.MessageData ||\n    e instanceof r.MetricData ||\n    e instanceof r.PageViewData ||\n    e instanceof r.RemoteDependencyData ||\n    e instanceof r.RequestData\n  );\n};",
  "9407": "const { randomBytes: r } = require(\"crypto\"),\n  { Readable: o } = require(\"stream\"),\n  i = (e) =>\n    \"object\" == typeof e &&\n    0 ===\n      [\"arrayBuffer\", \"stream\", \"text\", \"slice\", \"constructor\"]\n        .map((t) => typeof e[t])\n        .filter((e) => \"function\" !== e).length &&\n    \"string\" == typeof e.type &&\n    \"number\" == typeof e.size &&\n    /^(Blob|File)$/.test(e[Symbol.toStringTag]),\n  s = (e) => `--${e}--\\r\\n\\r\\n`,\n  a = (e, t, n) => {\n    let r = \"\";\n    r += `--${e}\\r\\n`;\n    r += `Content-Disposition: form-data; name=\"${t}\"`;\n    if (i(n)) {\n      r += `; filename=\"${n.name}\"\\r\\n`;\n      r += `Content-Type: ${n.type || \"application/octet-stream\"}`;\n    }\n    return `${r}\\r\\n\\r\\n`;\n  };\nmodule.exports = {\n  isFormData: (e) =>\n    null != e &&\n    \"object\" == typeof e &&\n    0 ===\n      [\n        \"append\",\n        \"delete\",\n        \"get\",\n        \"getAll\",\n        \"has\",\n        \"set\",\n        \"keys\",\n        \"values\",\n        \"entries\",\n        \"constructor\",\n      ]\n        .map((t) => typeof e[t])\n        .filter((e) => \"function\" !== e).length &&\n    \"FormData\" === e[Symbol.toStringTag],\n  FormDataSerializer: class {\n    constructor(e) {\n      this.fd = e;\n      this.boundary = r(8).toString(\"hex\");\n    }\n    length() {\n      if (undefined === this._length) {\n        this._length = ((e, t) => {\n          let n = 0;\n          for (const [r, o] of e) {\n            n += Buffer.byteLength(a(t, r, o));\n            n += i(o) ? o.size : Buffer.byteLength(String(o));\n            n += Buffer.byteLength(\"\\r\\n\");\n          }\n          n += Buffer.byteLength(s(t));\n          return n;\n        })(this.fd, this.boundary);\n      }\n      return this._length;\n    }\n    contentType() {\n      return `multipart/form-data; boundary=${this.boundary}`;\n    }\n    stream() {\n      return o.from(\n        (async function* (e, t) {\n          for (const [n, r] of e) {\n            yield a(t, n, r);\n            if (i(r)) {\n              yield* r.stream();\n            } else {\n              yield r;\n            }\n            yield \"\\r\\n\";\n          }\n          yield s(t);\n        })(this.fd, this.boundary)\n      );\n    }\n  },\n};",
  "9408": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.registerDefaultHandlers = undefined;\nconst r = require(2279),\n  o = require(6333);\nexports.registerDefaultHandlers = function (e, t) {\n  process.addListener(\"uncaughtException\", (t) => {\n    console.error(\"uncaughtException\", t);\n    o.telemetryException(e, t, \"uncaughtException\");\n  });\n  let n = !1;\n  process.addListener(\"unhandledRejection\", (i, s) => {\n    if (n) return;\n    n = !0;\n    if (\"vscode\" === t && !i) return;\n    if (\"aborted\" === i.type || r.isAbortError(i)) return;\n    if (\n      \"vscode\" === t &&\n      [\n        \"ENOTFOUND\",\n        \"ECONNREFUSED\",\n        \"ECONNRESET\",\n        \"ETIMEDOUT\",\n        \"ENETDOWN\",\n        \"ENETUNREACH\",\n        \"EADDRNOTAVAIL\",\n      ].includes(i.code)\n    )\n      return;\n    if (\"ENOENT\" == i.code) return;\n    let a = \"\";\n    try {\n      a = `${i.message} (${i.code})`;\n      a = JSON.stringify(i);\n    } catch (e) {\n      a = \"[actual reason JSON was cyclic]\";\n    }\n    if (\"vscode\" === t && \"{}\" === a) {\n      console.error(\"unhandledRejection\", a);\n      o.telemetryError(\n        e,\n        \"unhandledRejection\",\n        o.TelemetryData.createAndMarkAsIssued({\n          origin: \"unhandledRejection\",\n          reason: \"Unhandled rejection logged to restricted telemetry\",\n        }),\n        !1\n      );\n      o.telemetryError(\n        e,\n        \"unhandledRejection\",\n        o.TelemetryData.createAndMarkAsIssued({\n          origin: \"unhandledRejection\",\n          reason: a,\n        }),\n        !0\n      );\n      n = !1;\n    }\n  });\n};",
  "9425": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.VSCodeEditorInfo =\n  exports.makeVscInfo =\n  exports.getExtension =\n  exports.setExtension =\n  exports.VSCodeConfigProvider =\n    undefined;\nconst r = require(\"vscode\"),\n  o = require(1133),\n  i = require(4197),\n  s = require(70),\n  a = require(4147);\nfunction c(e) {\n  return \"string\" == typeof e ? e : JSON.stringify(e);\n}\nclass VSCodeConfigProvider extends o.ConfigProvider {\n  constructor() {\n    super();\n    this.config = r.workspace.getConfiguration(i.CopilotConfigPrefix);\n    r.workspace.onDidChangeConfiguration((e) => {\n      if (e.affectsConfiguration(i.CopilotConfigPrefix)) {\n        this.config = r.workspace.getConfiguration(i.CopilotConfigPrefix);\n      }\n    });\n  }\n  getConfigKeyFromObject(e, t) {\n    const n = this.config[e][t];\n    return undefined === n ? o.getConfigDefaultForObjectKey(e, t) : n;\n  }\n  getConfig(e) {\n    if (Array.isArray(e)) return this.getConfigKeyFromObject(e[0], e[1]);\n    const t = this.config.get(e);\n    if (undefined === t)\n      throw new Error(\n        `Missing config default value: ${i.CopilotConfigPrefix}.${e}`\n      );\n    return t;\n  }\n  isDefaultSettingOverwritten(e) {\n    if (Array.isArray(e)) return undefined !== this.config[e[0]][e[1]];\n    const t = this.config.inspect(e);\n    return (\n      !!t &&\n      !!(\n        t.globalValue ||\n        t.workspaceValue ||\n        t.workspaceFolderValue ||\n        t.defaultLanguageValue ||\n        t.globalLanguageValue ||\n        t.workspaceLanguageValue ||\n        t.workspaceFolderLanguageValue\n      )\n    );\n  }\n  dumpConfig() {\n    const e = {};\n    try {\n      const t = a.contributes.configuration[0].properties;\n      for (const n in t) {\n        const t = n\n          .replace(`${i.CopilotConfigPrefix}.`, \"\")\n          .split(\".\")\n          .reduce((e, t) => e[t], this.config);\n        if (\"object\" == typeof t && null !== t) {\n          Object.keys(t)\n            .filter((e) => \"secret_key\" !== e)\n            .forEach((r) => (e[`${n}.${r}`] = c(t[r])));\n        } else {\n          e[n] = c(t);\n        }\n      }\n    } catch (e) {\n      console.error(`Failed to retrieve configuration properties ${e}`);\n    }\n    return e;\n  }\n  getLanguageConfig(e, t) {\n    const n = this.getConfig(e);\n    if (undefined === t) {\n      const e = r.window.activeTextEditor;\n      t = e && e.document.languageId;\n    }\n    return t && t in n ? n[t] : n[\"*\"];\n  }\n  updateEnabledConfig(e, t, n) {\n    const r = e.get(o.ConfigProvider).getConfig(o.ConfigKey.Enable);\n    r[t] = n;\n    return this.config.update(o.ConfigKey.Enable, r, !0);\n  }\n}\nlet u;\nexports.VSCodeConfigProvider = VSCodeConfigProvider;\nexports.setExtension = function (e) {\n  u = e;\n};\nexports.getExtension = function (e) {\n  if (!u && s.isRunningInTest(e)) {\n    u = r.extensions.all.find((e) => e.id.startsWith(\"GitHub.copilot\"));\n  }\n  if (!u) throw new Error(\"No GitHub.copilot extension found\");\n  return u;\n};\nexports.makeVscInfo = function () {\n  return new o.VscInfo(r.env.sessionId, r.env.machineId, r.version);\n};\nclass VSCodeEditorInfo extends o.EditorAndPluginInfo {\n  getEditorInfo(e) {\n    return {\n      name: \"vscode\",\n      version: r.version,\n    };\n  }\n  getEditorPluginInfo(e) {\n    return {\n      name: \"copilot\",\n      version: o.getVersion(e),\n    };\n  }\n}\nexports.VSCodeEditorInfo = VSCodeEditorInfo;",
  "9428": "function r(e) {\n  for (var n in e)\n    if (exports.hasOwnProperty(n)) {\n      exports[n] = e[n];\n    }\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nr(require(608));\nr(require(4127));",
  "9434": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = require(6776),\n  i = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: !0,\n    error: {\n      message: ({ params: e }) => r.str`must match \"${e.ifClause}\" schema`,\n      params: ({ params: e }) => r._`{failingKeyword: ${e.ifClause}}`,\n    },\n    code(e) {\n      const { gen: t, parentSchema: n, it: i } = e;\n      if (undefined === n.then && undefined === n.else) {\n        o.checkStrictMode(i, '\"if\" without \"then\" and \"else\" is ignored');\n      }\n      const a = s(i, \"then\"),\n        c = s(i, \"else\");\n      if (!a && !c) return;\n      const l = t.let(\"valid\", !0),\n        u = t.name(\"_valid\");\n      (function () {\n        const t = e.subschema(\n          {\n            keyword: \"if\",\n            compositeRule: !0,\n            createErrors: !1,\n            allErrors: !1,\n          },\n          u\n        );\n        e.mergeEvaluated(t);\n      })();\n      e.reset();\n      if (a && c) {\n        const n = t.let(\"ifClause\");\n        e.setParams({\n          ifClause: n,\n        }),\n          t.if(u, d(\"then\", n), d(\"else\", n));\n      } else a ? t.if(u, d(\"then\")) : t.if((0, r.not)(u), d(\"else\"));\n      function d(n, o) {\n        return () => {\n          const i = e.subschema(\n            {\n              keyword: n,\n            },\n            u\n          );\n          t.assign(l, u);\n          e.mergeValidEvaluated(i, l);\n          if (o) {\n            t.assign(o, r._`${n}`);\n          } else {\n            e.setParams({\n              ifClause: n,\n            });\n          }\n        };\n      }\n      e.pass(l, () => e.error(!0));\n    },\n  };\nfunction s(e, t) {\n  const n = e.schema[t];\n  return undefined !== n && !o.alwaysValidSchema(e, n);\n}\nexports.default = i;",
  "9461": "var t = (module.exports = function (e, t, r) {\n  if (\"function\" == typeof t) {\n    r = t;\n    t = {};\n  }\n  n(\n    t,\n    \"function\" == typeof (r = t.cb || r) ? r : r.pre || function () {},\n    r.post || function () {},\n    e,\n    \"\",\n    e\n  );\n});\nfunction n(e, r, o, i, s, a, c, l, u, d) {\n  if (i && \"object\" == typeof i && !Array.isArray(i)) {\n    for (var p in (r(i, s, a, c, l, u, d), i)) {\n      var h = i[p];\n      if (Array.isArray(h)) {\n        if (p in t.arrayKeywords)\n          for (var f = 0; f < h.length; f++)\n            n(e, r, o, h[f], s + \"/\" + p + \"/\" + f, a, s, p, i, f);\n      } else if (p in t.propsKeywords) {\n        if (h && \"object\" == typeof h)\n          for (var m in h)\n            n(\n              e,\n              r,\n              o,\n              h[m],\n              s + \"/\" + p + \"/\" + m.replace(/~/g, \"~0\").replace(/\\//g, \"~1\"),\n              a,\n              s,\n              p,\n              i,\n              m\n            );\n      } else if (p in t.keywords || (e.allKeys && !(p in t.skipKeywords))) {\n        n(e, r, o, h, s + \"/\" + p, a, s, p, i);\n      }\n    }\n    o(i, s, a, c, l, u, d);\n  }\n}\nt.keywords = {\n  additionalItems: !0,\n  items: !0,\n  contains: !0,\n  additionalProperties: !0,\n  propertyNames: !0,\n  not: !0,\n  if: !0,\n  then: !0,\n  else: !0,\n};\nt.arrayKeywords = {\n  items: !0,\n  allOf: !0,\n  anyOf: !0,\n  oneOf: !0,\n};\nt.propsKeywords = {\n  $defs: !0,\n  definitions: !0,\n  properties: !0,\n  patternProperties: !0,\n  dependencies: !0,\n};\nt.skipKeywords = {\n  default: !0,\n  enum: !0,\n  const: !0,\n  required: !0,\n  maximum: !0,\n  minimum: !0,\n  exclusiveMaximum: !0,\n  exclusiveMinimum: !0,\n  multipleOf: !0,\n  maxLength: !0,\n  minLength: !0,\n  pattern: !0,\n  format: !0,\n  maxItems: !0,\n  minItems: !0,\n  uniqueItems: !0,\n  maxProperties: !0,\n  minProperties: !0,\n};",
  "9477": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.initProxyEnvironment = undefined;\nconst r = require(\"net\"),\n  o = require(\"url\"),\n  i = require(\"vscode\");\nexports.initProxyEnvironment = function (e, t) {\n  let n =\n    i.workspace.getConfiguration(\"http\").get(\"proxy\") ||\n    (function (e) {\n      return (\n        e.HTTPS_PROXY || e.https_proxy || e.HTTP_PROXY || e.http_proxy || null\n      );\n    })(t);\n  if (n) {\n    const t = {},\n      s = i.workspace.getConfiguration(\"http\").get(\"proxyAuthorization\"),\n      a = i.workspace.getConfiguration(\"http\").get(\"proxyStrictSSL\", !0);\n    if (s) {\n      t[\"Proxy-Authorization\"] = s;\n    }\n    let c = n;\n    const l = n.split(\":\");\n    if (l.length > 2) {\n      if (n.includes(\"[\")) {\n        const e = n.indexOf(\"[\"),\n          t = n.indexOf(\"]\");\n        c = n.substring(e + 1, t);\n      }\n    } else c = l[0];\n    const u = r.isIP(c);\n    if (4 === u) {\n      n = `https://${n}`;\n    } else {\n      if (6 === u) {\n        if (n.includes(\"[\")) {\n          if (n.startsWith(\"https://\")) {\n            n = `https://${n}`;\n          }\n        } else {\n          n = `https://[${n}]`;\n        }\n      }\n    }\n    const {\n        hostname: d,\n        port: p,\n        username: h,\n        password: f,\n      } = (function (e) {\n        try {\n          return new o.URL(e);\n        } catch (t) {\n          throw new Error(`Invalid proxy URL: '${e}'`);\n        }\n      })(n),\n      m = h && f && `${h}:${f}`;\n    e.proxySettings = {\n      host: d,\n      port: parseInt(p),\n      proxyAuth: m,\n      headers: t,\n      rejectUnauthorized: a,\n    };\n  }\n};",
  "9502": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = [require(9651).default];\nexports.default = r;",
  "9562": "const r = require(9012);\nif (process && r.gte(process.versions.node, \"8.0.0\")) {\n  module.exports = require(3964);\n} else {\n  module.exports = require(4046);\n}",
  "9565": "function t() {}\nmodule.exports = function () {\n  const e = this._hooks,\n    n = this._state,\n    r = global.Promise,\n    o = r.prototype.then;\n  function i(t, n, r, o) {\n    return \"function\" != typeof t\n      ? o\n        ? (function (t) {\n            return function (n) {\n              e.destroy.call(null, t);\n              return n;\n            };\n          })(r)\n        : (function (t) {\n            return function (n) {\n              throw (e.destroy.call(null, t), n);\n            };\n          })(r)\n      : function () {\n          e.pre.call(n, r);\n          try {\n            return t.apply(this, arguments);\n          } finally {\n            e.post.call(n, r, !1);\n            e.destroy.call(null, r);\n          }\n        };\n  }\n  r.prototype.then = function (r, s) {\n    if (!n.enabled) return o.call(this, r, s);\n    const a = new t(),\n      c = --n.counter;\n    e.init.call(a, c, 0, null, null);\n    return o.call(this, i(r, a, c, !0), i(s, a, c, !1));\n  };\n};",
  "9574": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nvar r,\n  o = require(894),\n  i = require(6281),\n  s = require(6639),\n  a = require(4350),\n  c = require(8723),\n  l = require(731),\n  u = require(9962),\n  d = require(5282),\n  p = require(3668),\n  h = require(1629);\nexports.TelemetryClient = require(1259);\nexports.Contracts = require(5290);\n(function (e) {\n  e[(e.AI = 0)] = \"AI\";\n  e[(e.AI_AND_W3C = 1)] = \"AI_AND_W3C\";\n})(\n  (r =\n    exports.DistributedTracingModes || (exports.DistributedTracingModes = {}))\n);\nvar f,\n  m,\n  g,\n  _,\n  y,\n  v,\n  b,\n  w,\n  x,\n  E = !0,\n  C = !1,\n  S = !0,\n  T = !0,\n  k = !0,\n  I = !0,\n  P = !0,\n  A = !0,\n  O = !1,\n  N = !0,\n  R = undefined,\n  M = undefined,\n  L = !1;\nfunction start() {\n  if (exports.defaultClient) {\n    L = !0;\n    g.enable(E, C);\n    _.enable(S);\n    y.enable(T);\n    v.enable(N, m);\n    b.useAutoCorrelation(A, f);\n    b.enable(k);\n    w.enable(I);\n    if (exports.liveMetricsClient && O) {\n      exports.liveMetricsClient.enable(O);\n    }\n  } else {\n    d.warn(\"Start cannot be called before setup\");\n  }\n  return Configuration;\n}\nexports.setup = function (e) {\n  if (exports.defaultClient) {\n    d.info(\"The default client is already setup\");\n  } else {\n    exports.defaultClient = new exports.TelemetryClient(e);\n    g = new i(exports.defaultClient);\n    _ = new s(exports.defaultClient);\n    y = new a(exports.defaultClient);\n    b = new l(exports.defaultClient);\n    w = new c(exports.defaultClient);\n    if (v) {\n      v = new h.AutoCollectNativePerformance(exports.defaultClient);\n    }\n  }\n  if (exports.defaultClient && exports.defaultClient.channel) {\n    exports.defaultClient.channel.setUseDiskRetryCaching(P, R, M);\n  }\n  return Configuration;\n};\nexports.start = start;\nexports.getCorrelationContext = function () {\n  return A ? o.CorrelationContextManager.getCurrentContext() : null;\n};\nexports.wrapWithCorrelationContext = function (e) {\n  return o.CorrelationContextManager.wrapCallback(e);\n};\nvar Configuration = (function () {\n  function e() {}\n  e.setDistributedTracingMode = function (t) {\n    u.w3cEnabled = t === r.AI_AND_W3C;\n    return e;\n  };\n  e.setAutoCollectConsole = function (t, n) {\n    if (undefined === n) {\n      n = !1;\n    }\n    E = t;\n    C = n;\n    if (L) {\n      g.enable(t, n);\n    }\n    return e;\n  };\n  e.setAutoCollectExceptions = function (t) {\n    S = t;\n    if (L) {\n      _.enable(t);\n    }\n    return e;\n  };\n  e.setAutoCollectPerformance = function (t, n) {\n    if (undefined === n) {\n      n = !0;\n    }\n    T = t;\n    var r = h.AutoCollectNativePerformance.parseEnabled(n);\n    N = r.isEnabled;\n    m = r.disabledMetrics;\n    if (L) {\n      y.enable(t);\n      v.enable(r.isEnabled, r.disabledMetrics);\n    }\n    return e;\n  };\n  e.setAutoCollectRequests = function (t) {\n    k = t;\n    if (L) {\n      b.enable(t);\n    }\n    return e;\n  };\n  e.setAutoCollectDependencies = function (t) {\n    I = t;\n    if (L) {\n      w.enable(t);\n    }\n    return e;\n  };\n  e.setAutoDependencyCorrelation = function (t, n) {\n    A = t;\n    f = n;\n    if (L) {\n      b.useAutoCorrelation(t, n);\n    }\n    return e;\n  };\n  e.setUseDiskRetryCaching = function (n, r, o) {\n    P = n;\n    R = r;\n    M = o;\n    if (exports.defaultClient && exports.defaultClient.channel) {\n      exports.defaultClient.channel.setUseDiskRetryCaching(n, r, o);\n    }\n    return e;\n  };\n  e.setInternalLogging = function (t, n) {\n    if (undefined === t) {\n      t = !1;\n    }\n    if (undefined === n) {\n      n = !0;\n    }\n    d.enableDebug = t;\n    d.disableWarnings = !n;\n    return e;\n  };\n  e.setSendLiveMetrics = function (n) {\n    if (undefined === n) {\n      n = !1;\n    }\n    return exports.defaultClient\n      ? (!exports.liveMetricsClient && n\n          ? ((exports.liveMetricsClient = new p(\n              exports.defaultClient.config.instrumentationKey\n            )),\n            (x = new a(exports.liveMetricsClient, 1e3, !0)),\n            exports.liveMetricsClient.addCollector(x),\n            (exports.defaultClient.quickPulseClient =\n              exports.liveMetricsClient))\n          : exports.liveMetricsClient && exports.liveMetricsClient.enable(n),\n        (O = n),\n        e)\n      : (d.warn(\n          \"Live metrics client cannot be setup without the default client\"\n        ),\n        e);\n  };\n  e.start = start;\n  return e;\n})();\nexports.Configuration = Configuration;\nexports.dispose = function () {\n  exports.defaultClient = null;\n  L = !1;\n  if (g) {\n    g.dispose();\n  }\n  if (_) {\n    _.dispose();\n  }\n  if (y) {\n    y.dispose();\n  }\n  if (v) {\n    v.dispose();\n  }\n  if (b) {\n    b.dispose();\n  }\n  if (w) {\n    w.dispose();\n  }\n  if (exports.liveMetricsClient) {\n    exports.liveMetricsClient.enable(!1);\n    O = !1;\n    exports.liveMetricsClient = undefined;\n  }\n};",
  "9575": "const { Readable: r } = require(\"stream\"),\n  o = require(3055404),\n  {\n    types: { isAnyArrayBuffer: i },\n  } = require(\"util\"),\n  s = require(8348),\n  a = require(8104)(\"helix-fetch:core\"),\n  { RequestAbortedError: c } = require(1787),\n  l = require(9803),\n  u = require(7262),\n  d = require(3769),\n  { isPlainObject: p } = require(4544),\n  { isFormData: h, FormDataSerializer: f } = require(9407),\n  { version: m } = require(5258),\n  g = \"h2\",\n  _ = \"h2c\",\n  y = \"http/1.0\",\n  v = \"http/1.1\",\n  b = 100,\n  w = 36e5,\n  x = [g, v, y],\n  E = `helix-fetch/${m}`,\n  C = {\n    method: \"GET\",\n    compress: !0,\n    decode: !0,\n  };\nlet S = 0;\nconst T = d(),\n  k = (e, t) =>\n    new Promise((n, r) => {\n      const { signal: i } = t;\n      let s;\n      const l = () => {\n        i.removeEventListener(\"abort\", l);\n        const e = new c();\n        r(e);\n        if (s) {\n          s.destroy(e);\n        }\n      };\n      if (i) {\n        if (i.aborted) return void r(new c());\n        i.addEventListener(\"abort\", l);\n      }\n      const u = +e.port || 443,\n        d = (t) => {\n          if (i) {\n            i.removeEventListener(\"abort\", l);\n          }\n          if (t instanceof c) {\n            a(`connecting to ${e.hostname}:${u} failed with: ${t.message}`);\n            r(t);\n          }\n        };\n      s = o.connect(u, e.hostname, t);\n      s.once(\"secureConnect\", () => {\n        if (i) {\n          i.removeEventListener(\"abort\", l);\n        }\n        s.off(\"error\", d);\n        S += 1;\n        s.id = S;\n        s.secureConnecting = !1;\n        a(`established TLS connection: #${s.id} (${s.servername})`);\n        n(s);\n      });\n      s.once(\"error\", d);\n    });\nmodule.exports = {\n  request: async (e, t, n) => {\n    const o = new URL(t),\n      s = {\n        ...C,\n        ...(n || {}),\n      };\n    let c;\n    if (\"string\" == typeof s.method) {\n      s.method = s.method.toUpperCase();\n    }\n    s.headers = ((e) => {\n      const t = {};\n      Object.keys(e).forEach((n) => {\n        t[n.toLowerCase()] = e[n];\n      });\n      return t;\n    })(s.headers || {});\n    if (undefined === s.headers.host) {\n      s.headers.host = o.host;\n    }\n    if (e.userAgent && undefined === s.headers[\"user-agent\"]) {\n      s.headers[\"user-agent\"] = e.userAgent;\n    }\n    if (s.body instanceof URLSearchParams)\n      (c = \"application/x-www-form-urlencoded; charset=utf-8\"),\n        (s.body = s.body.toString());\n    else if (h(s.body)) {\n      const e = new f(s.body);\n      (c = e.contentType()),\n        (s.body = e.stream()),\n        void 0 === s.headers[\"transfer-encoding\"] &&\n          void 0 === s.headers[\"content-length\"] &&\n          (s.headers[\"content-length\"] = String(e.length()));\n    } else\n      \"string\" == typeof s.body || s.body instanceof String\n        ? (c = \"text/plain; charset=utf-8\")\n        : p(s.body)\n        ? ((s.body = JSON.stringify(s.body)), (c = \"application/json\"))\n        : i(s.body) && (s.body = Buffer.from(s.body));\n    if (undefined === s.headers[\"content-type\"] && undefined !== c) {\n      s.headers[\"content-type\"] = c;\n    }\n    if (null != s.body) {\n      if (s.body instanceof r) {\n        if (\n          \"string\" == typeof s.body ||\n          s.body instanceof String ||\n          Buffer.isBuffer(s.body)\n        ) {\n          s.body = String(s.body);\n        }\n        if (\n          undefined === s.headers[\"transfer-encoding\"] &&\n          undefined === s.headers[\"content-length\"]\n        ) {\n          s.headers[\"content-length\"] = String(\n            Buffer.isBuffer(s.body)\n              ? s.body.length\n              : Buffer.byteLength(s.body, \"utf-8\")\n          );\n        }\n      }\n    }\n    if (undefined === s.headers.accept) {\n      s.headers.accept = \"*/*\";\n    }\n    if (null == s.body && [\"POST\", \"PUT\"].includes(s.method)) {\n      s.headers[\"content-length\"] = \"0\";\n    }\n    if (s.compress && undefined === s.headers[\"accept-encoding\"]) {\n      s.headers[\"accept-encoding\"] = \"gzip,deflate,br\";\n    }\n    const { signal: d } = s,\n      { protocol: m, socket: b = null } = e.socketFactory\n        ? await (async (e, t, n, r) => {\n            const o = \"https:\" === t.protocol;\n            let i;\n            i = t.port ? t.port : o ? 443 : 80;\n            const s = {\n                ...n,\n                host: t.host,\n                port: i,\n              },\n              a = await e(s);\n            if (o) {\n              const e = {\n                ...s,\n                ALPNProtocols: r,\n              };\n              e.socket = a;\n              const n = await k(t, e);\n              return {\n                protocol: n.alpnProtocol || v,\n                socket: n,\n              };\n            }\n            return {\n              protocol: a.alpnProtocol || v,\n              socket: a,\n            };\n          })(e.socketFactory, o, s, e.alpnProtocols)\n        : await (async (e, t, n) => {\n            const r = `${t.protocol}//${t.host}`;\n            let o = e.alpnCache.get(r);\n            if (o)\n              return {\n                protocol: o,\n              };\n            switch (t.protocol) {\n              case \"http:\":\n                o = v;\n                e.alpnCache.set(r, o);\n                return {\n                  protocol: o,\n                };\n              case \"http2:\":\n                o = _;\n                e.alpnCache.set(r, o);\n                return {\n                  protocol: o,\n                };\n              case \"https:\":\n                break;\n              default:\n                throw new TypeError(`unsupported protocol: ${t.protocol}`);\n            }\n            const {\n                options: { rejectUnauthorized: i, h1: s = {}, h2: a = {} },\n              } = e,\n              c = !(\n                !1 === i ||\n                !1 === s.rejectUnauthorized ||\n                !1 === a.rejectUnauthorized\n              ),\n              l = {\n                servername: t.hostname,\n                ALPNProtocols: e.alpnProtocols,\n                signal: n,\n                rejectUnauthorized: c,\n              },\n              u = await (async (e, t) => {\n                let n = await T.acquire(e.origin);\n                try {\n                  if (n) {\n                    n = await k(e, t);\n                  }\n                  return n;\n                } finally {\n                  T.release(e.origin, n);\n                }\n              })(t, l);\n            o = u.alpnProtocol;\n            if (o) {\n              o = v;\n            }\n            e.alpnCache.set(r, o);\n            return {\n              protocol: o,\n              socket: u,\n            };\n          })(e, o, d);\n    switch ((a(`${o.host} -> ${m}`), m)) {\n      case g:\n        try {\n          return await u.request(\n            e,\n            o,\n            b\n              ? {\n                  ...s,\n                  socket: b,\n                }\n              : s\n          );\n        } catch (t) {\n          const { code: n, message: r } = t;\n          throw (\n            (\"ERR_HTTP2_ERROR\" === n &&\n              \"Protocol error\" === r &&\n              e.alpnCache.delete(`${o.protocol}//${o.host}`),\n            t)\n          );\n        }\n      case _:\n        return u.request(\n          e,\n          new URL(`http://${o.host}${o.pathname}${o.hash}${o.search}`),\n          b\n            ? {\n                ...s,\n                socket: b,\n              }\n            : s\n        );\n      case y:\n      case v:\n        return l.request(\n          e,\n          o,\n          b\n            ? {\n                ...s,\n                socket: b,\n              }\n            : s\n        );\n      default:\n        throw new TypeError(`unsupported protocol: ${m}`);\n    }\n  },\n  setupContext: (e) => {\n    const {\n      options: {\n        alpnProtocols: t = x,\n        alpnCacheTTL: n = w,\n        alpnCacheSize: r = b,\n        userAgent: o = E,\n        socketFactory: i,\n      },\n    } = e;\n    e.alpnProtocols = t;\n    e.alpnCache = new s({\n      max: r,\n      ttl: n,\n    });\n    e.userAgent = o;\n    e.socketFactory = i;\n    l.setupContext(e);\n    u.setupContext(e);\n  },\n  resetContext: async (e) => (\n    e.alpnCache.clear(), Promise.all([l.resetContext(e), u.resetContext(e)])\n  ),\n  RequestAbortedError: c,\n  ALPN_HTTP2: g,\n  ALPN_HTTP2C: _,\n  ALPN_HTTP1_1: v,\n  ALPN_HTTP1_0: y,\n};",
  "9608": "function isVirtual(e) {\n  return \"virtual\" === e.type;\n}\nfunction isTop(e) {\n  return \"top\" === e.type;\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.duplicateTree =\n  exports.cutTreeAfterLine =\n  exports.isTop =\n  exports.isVirtual =\n  exports.isLine =\n  exports.isBlank =\n  exports.topNode =\n  exports.blankNode =\n  exports.lineNode =\n  exports.virtualNode =\n    undefined;\nexports.virtualNode = function (e, t, n) {\n  return {\n    type: \"virtual\",\n    indentation: e,\n    subs: t,\n    label: n,\n  };\n};\nexports.lineNode = function (e, t, n, r, o) {\n  if (\"\" === n)\n    throw new Error(\"Cannot create a line node with an empty source line\");\n  return {\n    type: \"line\",\n    indentation: e,\n    lineNumber: t,\n    sourceLine: n,\n    subs: r,\n    label: o,\n  };\n};\nexports.blankNode = function (e) {\n  return {\n    type: \"blank\",\n    lineNumber: e,\n    subs: [],\n  };\n};\nexports.topNode = function (e) {\n  return {\n    type: \"top\",\n    indentation: -1,\n    subs: null != e ? e : [],\n  };\n};\nexports.isBlank = function (e) {\n  return \"blank\" === e.type;\n};\nexports.isLine = function (e) {\n  return \"line\" === e.type;\n};\nexports.isVirtual = isVirtual;\nexports.isTop = isTop;\nexports.cutTreeAfterLine = function (e, t) {\n  !(function e(o) {\n    if (!isVirtual(o) && !isTop(o) && o.lineNumber === t) {\n      o.subs = [];\n      return !0;\n    }\n    for (let t = 0; t < o.subs.length; t++)\n      if (e(o.subs[t])) {\n        o.subs = o.subs.slice(0, t + 1);\n        return !0;\n      }\n    return !1;\n  })(e);\n};\nexports.duplicateTree = function (e) {\n  return JSON.parse(JSON.stringify(e));\n};",
  "9651": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: !0,\n    error: {\n      message: ({ schemaCode: e }) => r.str`must match format \"${e}\"`,\n      params: ({ schemaCode: e }) => r._`{format: ${e}}`,\n    },\n    code(e, t) {\n      const { gen: n, data: o, $data: i, schema: s, schemaCode: a, it: c } = e,\n        { opts: l, errSchemaPath: u, schemaEnv: d, self: p } = c;\n      if (l.validateFormats) {\n        if (i) {\n          (function () {\n            const i = n.scopeValue(\"formats\", {\n                ref: p.formats,\n                code: l.code.formats,\n              }),\n              s = n.const(\"fDef\", r._`${i}[${a}]`),\n              c = n.let(\"fType\"),\n              u = n.let(\"format\");\n            n.if(\n              r._`typeof ${s} == \"object\" && !(${s} instanceof RegExp)`,\n              () =>\n                n\n                  .assign(c, r._`${s}.type || \"string\"`)\n                  .assign(u, r._`${s}.validate`),\n              () => n.assign(c, r._`\"string\"`).assign(u, s)\n            );\n            e.fail$data(\n              r.or(\n                !1 === l.strictSchema ? r.nil : r._`${a} && !${u}`,\n                (function () {\n                  const e = d.$async\n                      ? r._`(${s}.async ? await ${u}(${o}) : ${u}(${o}))`\n                      : r._`${u}(${o})`,\n                    n = r._`(typeof ${u} == \"function\" ? ${e} : ${u}.test(${o}))`;\n                  return r._`${u} && ${u} !== true && ${c} === ${t} && !${n}`;\n                })()\n              )\n            );\n          })();\n        } else {\n          (function () {\n            const i = p.formats[s];\n            if (!i)\n              return void (function () {\n                if (!1 !== l.strictSchema) throw new Error(e());\n                function e() {\n                  return `unknown format \"${s}\" ignored in schema at path \"${u}\"`;\n                }\n                p.logger.warn(e());\n              })();\n            if (!0 === i) return;\n            const [a, c, h] = (function (e) {\n              const t =\n                  e instanceof RegExp\n                    ? r.regexpCode(e)\n                    : l.code.formats\n                    ? r._`${l.code.formats}${r.getProperty(s)}`\n                    : undefined,\n                o = n.scopeValue(\"formats\", {\n                  key: s,\n                  ref: e,\n                  code: t,\n                });\n              return \"object\" != typeof e || e instanceof RegExp\n                ? [\"string\", e, o]\n                : [e.type || \"string\", e.validate, r._`${o}.validate`];\n            })(i);\n            if (a === t) {\n              e.pass(\n                (function () {\n                  if (\n                    \"object\" == typeof i &&\n                    !(i instanceof RegExp) &&\n                    i.async\n                  ) {\n                    if (!d.$async)\n                      throw new Error(\"async format in sync schema\");\n                    return r._`await ${h}(${o})`;\n                  }\n                  return \"function\" == typeof c\n                    ? r._`${h}(${o})`\n                    : r._`${h}.test(${o})`;\n                })()\n              );\n            }\n          })();\n        }\n      }\n    },\n  };\nexports.default = o;",
  "9657": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.isRepetitive = exports.RepetitionFilterMode = undefined;\nconst n = [\n  {\n    max_token_sequence_length: 1,\n    last_tokens_to_consider: 10,\n  },\n  {\n    max_token_sequence_length: 10,\n    last_tokens_to_consider: 30,\n  },\n  {\n    max_token_sequence_length: 20,\n    last_tokens_to_consider: 45,\n  },\n  {\n    max_token_sequence_length: 30,\n    last_tokens_to_consider: 60,\n  },\n];\nvar r;\nfunction o(e) {\n  const t = (function (e) {\n    const t = Array(e.length).fill(0);\n    t[0] = -1;\n    let n = -1;\n    for (let r = 1; r < e.length; r++) {\n      for (; n >= 0 && e[n + 1] !== e[r]; ) n = t[n];\n      if (e[n + 1] === e[r]) {\n        n++;\n      }\n      t[r] = n;\n    }\n    return t;\n  })(e);\n  for (const r of n)\n    if (\n      !(e.length < r.last_tokens_to_consider) &&\n      r.last_tokens_to_consider - 1 - t[r.last_tokens_to_consider - 1] <=\n        r.max_token_sequence_length\n    )\n      return !0;\n  return !1;\n}\n!(function (e) {\n  e.CLIENT = \"client\";\n  e.PROXY = \"proxy\";\n  e.BOTH = \"both\";\n})((r = exports.RepetitionFilterMode || (exports.RepetitionFilterMode = {})));\nexports.isRepetitive = function (e, t = r.CLIENT) {\n  return (\n    t !== r.PROXY &&\n    (o(e.reverse()) || o(e.reverse().filter((e) => e.trim().length > 0)))\n  );\n};",
  "9697": "var t;\n!(function (e) {\n  e[(e.Verbose = 0)] = \"Verbose\";\n  e[(e.Information = 1)] = \"Information\";\n  e[(e.Warning = 2)] = \"Warning\";\n  e[(e.Error = 3)] = \"Error\";\n  e[(e.Critical = 4)] = \"Critical\";\n})(t || (t = {}));\nmodule.exports = t;",
  "9748": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.ExpConfigNone =\n  exports.ExpConfigFromTAS =\n  exports.ExpConfigMaker =\n    undefined;\nconst r = require(2279),\n  o = require(219);\nclass ExpConfigMaker {}\nexports.ExpConfigMaker = ExpConfigMaker;\nexports.ExpConfigFromTAS = class extends ExpConfigMaker {\n  async fetchExperiments(e, t) {\n    var n;\n    const i = e.get(r.Fetcher);\n    let s;\n    try {\n      s = await i.fetch(\"https://default.exp-tas.com/vscode/ab\", {\n        method: \"GET\",\n        headers: t,\n      });\n    } catch (t) {\n      return o.ExpConfig.createFallbackConfig(\n        e,\n        `Error fetching ExP config: ${t}`\n      );\n    }\n    if (!s.ok)\n      return o.ExpConfig.createFallbackConfig(\n        e,\n        `ExP responded with ${s.status}`\n      );\n    const a = await s.json(),\n      c =\n        null !== (n = a.Configs.find((e) => \"vscode\" === e.Id)) &&\n        undefined !== n\n          ? n\n          : {\n              Id: \"vscode\",\n              Parameters: {},\n            },\n      l = Object.entries(c.Parameters).map(([e, t]) => e + (t ? \"\" : \"cf\"));\n    return new o.ExpConfig(c.Parameters, a.AssignmentContext, l.join(\";\"));\n  }\n};\nexports.ExpConfigNone = class extends ExpConfigMaker {\n  async fetchExperiments(e, t) {\n    return o.ExpConfig.createEmptyConfig();\n  }\n};",
  "9803": "const r = require(\"http\"),\n  o = require(\"https\"),\n  { Readable: i } = require(\"stream\"),\n  s = require(8104)(\"helix-fetch:h1\"),\n  { RequestAbortedError: a } = require(1787),\n  { decodeStream: c } = require(4544);\nmodule.exports = {\n  request: async (e, t, n) => {\n    const { request: l } = \"https:\" === t.protocol ? o : r,\n      u = ((e, t) => {\n        const {\n          h1: n,\n          options: { h1: i, rejectUnauthorized: s },\n        } = e;\n        return \"https:\" === t\n          ? n.httpsAgent\n            ? n.httpsAgent\n            : i || \"boolean\" == typeof s\n            ? ((n.httpsAgent = new o.Agent(\n                \"boolean\" == typeof s\n                  ? {\n                      ...(i || {}),\n                      rejectUnauthorized: s,\n                    }\n                  : i\n              )),\n              n.httpsAgent)\n            : undefined\n          : n.httpAgent\n          ? n.httpAgent\n          : i\n          ? ((n.httpAgent = new r.Agent(i)), n.httpAgent)\n          : undefined;\n      })(e, t.protocol),\n      d = {\n        ...n,\n        agent: u,\n      },\n      { socket: p, body: h } = d;\n    if (p) {\n      delete d.socket;\n      if (p.assigned) {\n        p.assigned = !0;\n        if (u) {\n          d.agent = new Proxy(u, {\n            get: (e, t) =>\n              \"createConnection\" !== t || p.inUse\n                ? e[t]\n                : (e, t) => {\n                    s(`agent reusing socket #${p.id} (${p.servername})`);\n                    p.inUse = !0;\n                    t(null, p);\n                  },\n          });\n        } else {\n          d.createConnection = (e, t) => {\n            s(`reusing socket #${p.id} (${p.servername})`);\n            p.inUse = !0;\n            t(null, p);\n          };\n        }\n      }\n    }\n    return new Promise((e, n) => {\n      let r;\n      s(`${d.method} ${t.href}`);\n      const { signal: o } = d,\n        u = () => {\n          o.removeEventListener(\"abort\", u);\n          if (p && !p.inUse) {\n            s(\n              `discarding redundant socket used for ALPN: #${p.id} ${p.servername}`\n            );\n            p.destroy();\n          }\n          n(new a());\n          if (r) {\n            r.abort();\n          }\n        };\n      if (o) {\n        if (o.aborted) return void n(new a());\n        o.addEventListener(\"abort\", u);\n      }\n      r = l(t, d);\n      r.once(\"response\", (t) => {\n        if (o) {\n          o.removeEventListener(\"abort\", u);\n        }\n        if (p && !p.inUse) {\n          s(\n            `discarding redundant socket used for ALPN: #${p.id} ${p.servername}`\n          );\n          p.destroy();\n        }\n        e(\n          ((e, t, n) => {\n            const {\n                statusCode: r,\n                statusMessage: o,\n                httpVersion: i,\n                httpVersionMajor: s,\n                httpVersionMinor: a,\n                headers: l,\n              } = e,\n              u = t ? c(r, l, e, n) : e;\n            return {\n              statusCode: r,\n              statusText: o,\n              httpVersion: i,\n              httpVersionMajor: s,\n              httpVersionMinor: a,\n              headers: l,\n              readable: u,\n              decoded: !(!t || u === e),\n            };\n          })(t, d.decode, n)\n        );\n      });\n      r.once(\"error\", (e) => {\n        if (o) {\n          o.removeEventListener(\"abort\", u);\n        }\n        if (p && !p.inUse) {\n          s(\n            `discarding redundant socket used for ALPN: #${p.id} ${p.servername}`\n          );\n          p.destroy();\n        }\n        if (r.aborted) {\n          s(`${d.method} ${t.href} failed with: ${e.message}`);\n          r.abort();\n          n(e);\n        }\n      });\n      if (h instanceof i) {\n        h.pipe(r);\n      } else {\n        if (h) {\n          r.write(h);\n        }\n        r.end();\n      }\n    });\n  },\n  setupContext: (e) => {\n    e.h1 = {};\n  },\n  resetContext: async ({ h1: e }) => {\n    if (e.httpAgent) {\n      s(\"resetContext: destroying httpAgent\");\n      e.httpAgent.destroy();\n      delete e.httpAgent;\n    }\n    if (e.httpsAgent) {\n      s(\"resetContext: destroying httpsAgent\");\n      e.httpsAgent.destroy();\n      delete e.httpsAgent;\n    }\n  },\n};",
  "9813": "var r = require(5290),\n  o = require(5740),\n  i = require(894),\n  s = (function () {\n    function e() {}\n    e.createEnvelope = function (t, n, i, s, a) {\n      var c = null;\n      switch (n) {\n        case r.TelemetryType.Trace:\n          c = e.createTraceData(t);\n          break;\n        case r.TelemetryType.Dependency:\n          c = e.createDependencyData(t);\n          break;\n        case r.TelemetryType.Event:\n          c = e.createEventData(t);\n          break;\n        case r.TelemetryType.Exception:\n          c = e.createExceptionData(t);\n          break;\n        case r.TelemetryType.Request:\n          c = e.createRequestData(t);\n          break;\n        case r.TelemetryType.Metric:\n          c = e.createMetricData(t);\n          break;\n        case r.TelemetryType.Availability:\n          c = e.createAvailabilityData(t);\n      }\n      if (i && r.domainSupportsProperties(c.baseData)) {\n        if (c && c.baseData)\n          if (c.baseData.properties) {\n            for (var l in i)\n              if (c.baseData.properties[l]) {\n                c.baseData.properties[l] = i[l];\n              }\n          } else c.baseData.properties = i;\n        c.baseData.properties = o.validateStringMap(c.baseData.properties);\n      }\n      var u = (a && a.instrumentationKey) || \"\",\n        d = new r.Envelope();\n      d.data = c;\n      d.iKey = u;\n      d.name =\n        \"Microsoft.ApplicationInsights.\" +\n        u.replace(/-/g, \"\") +\n        \".\" +\n        c.baseType.substr(0, c.baseType.length - 4);\n      d.tags = this.getTags(s, t.tagOverrides);\n      d.time = new Date().toISOString();\n      d.ver = 1;\n      d.sampleRate = a ? a.samplingPercentage : 100;\n      if (n === r.TelemetryType.Metric) {\n        d.sampleRate = 100;\n      }\n      return d;\n    };\n    e.createTraceData = function (e) {\n      var t = new r.MessageData();\n      t.message = e.message;\n      t.properties = e.properties;\n      if (isNaN(e.severity)) {\n        t.severityLevel = r.SeverityLevel.Information;\n      } else {\n        t.severityLevel = e.severity;\n      }\n      var n = new r.Data();\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Trace);\n      n.baseData = t;\n      return n;\n    };\n    e.createDependencyData = function (e) {\n      var t = new r.RemoteDependencyData();\n      if (\"string\" == typeof e.name) {\n        t.name = e.name.length > 1024 ? e.name.slice(0, 1021) + \"...\" : e.name;\n      }\n      t.data = e.data;\n      t.target = e.target;\n      t.duration = o.msToTimeSpan(e.duration);\n      t.success = e.success;\n      t.type = e.dependencyTypeName;\n      t.properties = e.properties;\n      t.resultCode = e.resultCode ? e.resultCode + \"\" : \"\";\n      if (e.id) {\n        t.id = e.id;\n      } else {\n        t.id = o.w3cTraceId();\n      }\n      var n = new r.Data();\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Dependency);\n      n.baseData = t;\n      return n;\n    };\n    e.createEventData = function (e) {\n      var t = new r.EventData();\n      t.name = e.name;\n      t.properties = e.properties;\n      t.measurements = e.measurements;\n      var n = new r.Data();\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Event);\n      n.baseData = t;\n      return n;\n    };\n    e.createExceptionData = function (e) {\n      var t = new r.ExceptionData();\n      t.properties = e.properties;\n      if (isNaN(e.severity)) {\n        t.severityLevel = r.SeverityLevel.Error;\n      } else {\n        t.severityLevel = e.severity;\n      }\n      t.measurements = e.measurements;\n      t.exceptions = [];\n      var n = e.exception.stack,\n        i = new r.ExceptionDetails();\n      i.message = e.exception.message;\n      i.typeName = e.exception.name;\n      i.parsedStack = this.parseStack(n);\n      i.hasFullStack = o.isArray(i.parsedStack) && i.parsedStack.length > 0;\n      t.exceptions.push(i);\n      var s = new r.Data();\n      s.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Exception);\n      s.baseData = t;\n      return s;\n    };\n    e.createRequestData = function (e) {\n      var t = new r.RequestData();\n      if (e.id) {\n        t.id = e.id;\n      } else {\n        t.id = o.w3cTraceId();\n      }\n      t.name = e.name;\n      t.url = e.url;\n      t.source = e.source;\n      t.duration = o.msToTimeSpan(e.duration);\n      t.responseCode = e.resultCode ? e.resultCode + \"\" : \"\";\n      t.success = e.success;\n      t.properties = e.properties;\n      var n = new r.Data();\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Request);\n      n.baseData = t;\n      return n;\n    };\n    e.createMetricData = function (e) {\n      var t = new r.MetricData();\n      t.metrics = [];\n      var n = new r.DataPoint();\n      n.count = isNaN(e.count) ? 1 : e.count;\n      n.kind = r.DataPointType.Aggregation;\n      n.max = isNaN(e.max) ? e.value : e.max;\n      n.min = isNaN(e.min) ? e.value : e.min;\n      n.name = e.name;\n      n.stdDev = isNaN(e.stdDev) ? 0 : e.stdDev;\n      n.value = e.value;\n      t.metrics.push(n);\n      t.properties = e.properties;\n      var o = new r.Data();\n      o.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Metric);\n      o.baseData = t;\n      return o;\n    };\n    e.createAvailabilityData = function (e) {\n      var t = new r.AvailabilityData();\n      if (e.id) {\n        t.id = e.id;\n      } else {\n        t.id = o.w3cTraceId();\n      }\n      t.name = e.name;\n      t.duration = o.msToTimeSpan(e.duration);\n      t.success = e.success;\n      t.runLocation = e.runLocation;\n      t.message = e.message;\n      t.measurements = e.measurements;\n      t.properties = e.properties;\n      var n = new r.Data();\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Availability);\n      n.baseData = t;\n      return n;\n    };\n    e.getTags = function (e, t) {\n      var n = i.CorrelationContextManager.getCurrentContext(),\n        r = {};\n      if (e && e.tags) for (var o in e.tags) r[o] = e.tags[o];\n      if (t) for (var o in t) r[o] = t[o];\n      if (n) {\n        r[e.keys.operationId] = r[e.keys.operationId] || n.operation.id;\n        r[e.keys.operationName] = r[e.keys.operationName] || n.operation.name;\n        r[e.keys.operationParentId] =\n          r[e.keys.operationParentId] || n.operation.parentId;\n      }\n      return r;\n    };\n    e.parseStack = function (e) {\n      var t = undefined;\n      if (\"string\" == typeof e) {\n        var n = e.split(\"\\n\");\n        t = [];\n        for (var r = 0, o = 0, i = 0; i <= n.length; i++) {\n          var s = n[i];\n          if (a.regex.test(s)) {\n            var c = new a(n[i], r++);\n            o += c.sizeInBytes;\n            t.push(c);\n          }\n        }\n        if (o > 32768)\n          for (var l = 0, u = t.length - 1, d = 0, p = l, h = u; l < u; ) {\n            if ((d += t[l].sizeInBytes + t[u].sizeInBytes) > 32768) {\n              var f = h - p + 1;\n              t.splice(p, f);\n              break;\n            }\n            p = l;\n            h = u;\n            l++;\n            u--;\n          }\n      }\n      return t;\n    };\n    return e;\n  })(),\n  a = (function () {\n    function e(t, n) {\n      this.sizeInBytes = 0;\n      this.level = n;\n      this.method = \"<no_method>\";\n      this.assembly = o.trim(t);\n      var r = t.match(e.regex);\n      if (r && r.length >= 5) {\n        this.method = o.trim(r[2]) || this.method;\n        this.fileName = o.trim(r[4]) || \"<no_filename>\";\n        this.line = parseInt(r[5]) || 0;\n      }\n      this.sizeInBytes += this.method.length;\n      this.sizeInBytes += this.fileName.length;\n      this.sizeInBytes += this.assembly.length;\n      this.sizeInBytes += e.baseSize;\n      this.sizeInBytes += this.level.toString().length;\n      this.sizeInBytes += this.line.toString().length;\n    }\n    e.regex =\n      /^([\\s]+at)?(.*?)(\\@|\\s\\(|\\s)([^\\(\\@\\n]+):([0-9]+):([0-9]+)(\\)?)$/;\n    e.baseSize = 58;\n    return e;\n  })();\nmodule.exports = s;",
  "9822": "const r = process.binding(\"async_wrap\"),\n  o = r.Providers.TIMERWRAP,\n  i = {\n    nextTick: require(3269),\n    promise: require(9565),\n    timers: require(7190),\n  },\n  s = new Set();\nfunction a() {\n  this.enabled = !1;\n  this.counter = 0;\n}\nfunction c() {\n  const e = (this.initFns = []),\n    t = (this.preFns = []),\n    n = (this.postFns = []),\n    r = (this.destroyFns = []);\n  this.init = function (t, n, r, i) {\n    if (n !== o) for (const o of e) o(t, this, n, r, i);\n    else s.add(t);\n  };\n  this.pre = function (e) {\n    if (!s.has(e)) for (const n of t) n(e, this);\n  };\n  this.post = function (e, t) {\n    if (!s.has(e)) for (const r of n) r(e, this, t);\n  };\n  this.destroy = function (e) {\n    if (s.has(e)) s.delete(e);\n    else for (const t of r) t(e);\n  };\n}\nfunction l(e, t) {\n  const n = e.indexOf(t);\n  if (-1 !== n) {\n    e.splice(n, 1);\n  }\n}\nfunction u() {\n  this._state = new a();\n  this._hooks = new c();\n  this.version = require(6157).i8;\n  this.providers = r.Providers;\n  for (const e of Object.keys(i)) i[e].call(this);\n  if (process.env.hasOwnProperty(\"NODE_ASYNC_HOOK_WARNING\")) {\n    console.warn(\"warning: you are using async-hook-jl which is unstable.\");\n  }\n  r.setupHooks({\n    init: this._hooks.init,\n    pre: this._hooks.pre,\n    post: this._hooks.post,\n    destroy: this._hooks.destroy,\n  });\n}\nc.prototype.add = function (e) {\n  if (e.init) {\n    this.initFns.push(e.init);\n  }\n  if (e.pre) {\n    this.preFns.push(e.pre);\n  }\n  if (e.post) {\n    this.postFns.push(e.post);\n  }\n  if (e.destroy) {\n    this.destroyFns.push(e.destroy);\n  }\n};\nc.prototype.remove = function (e) {\n  if (e.init) {\n    l(this.initFns, e.init);\n  }\n  if (e.pre) {\n    l(this.preFns, e.pre);\n  }\n  if (e.post) {\n    l(this.postFns, e.post);\n  }\n  if (e.destroy) {\n    l(this.destroyFns, e.destroy);\n  }\n};\nmodule.exports = u;\nu.prototype.addHooks = function (e) {\n  this._hooks.add(e);\n};\nu.prototype.removeHooks = function (e) {\n  this._hooks.remove(e);\n};\nu.prototype.enable = function () {\n  this._state.enabled = !0;\n  r.enable();\n};\nu.prototype.disable = function () {\n  this._state.enabled = !1;\n  r.disable();\n};",
  "9824": "var r, o, i;\no = (r = require(8249)).lib.Base;\ni = r.enc.Utf8;\nmodule.exports = void (r.algo.HMAC = o.extend({\n  init: function (e, t) {\n    (e = this._hasher = new e.init()), \"string\" == typeof t && (t = i.parse(t));\n    var n = e.blockSize,\n      r = 4 * n;\n    t.sigBytes > r && (t = e.finalize(t)), t.clamp();\n    for (\n      var o = (this._oKey = t.clone()),\n        s = (this._iKey = t.clone()),\n        a = o.words,\n        c = s.words,\n        l = 0;\n      l < n;\n      l++\n    )\n      (a[l] ^= 1549556828), (c[l] ^= 909522486);\n    (o.sigBytes = s.sigBytes = r), this.reset();\n  },\n  reset: function () {\n    var e = this._hasher;\n    e.reset(), e.update(this._iKey);\n  },\n  update: function (e) {\n    return this._hasher.update(e), this;\n  },\n  finalize: function (e) {\n    var t = this._hasher,\n      n = t.finalize(e);\n    return t.reset(), t.finalize(this._oKey.clone().concat(n));\n  },\n}));",
  "9829": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.rebuildTree =\n  exports.foldTree =\n  exports.visitTreeConditionally =\n  exports.visitTree =\n  exports.resetLineNumbers =\n  exports.mapLabels =\n  exports.clearLabelsIf =\n  exports.clearLabels =\n    undefined;\nconst r = require(9608);\nfunction visitTree(e, t, n) {\n  !(function e(r) {\n    if (\"topDown\" === n) {\n      t(r);\n    }\n    r.subs.forEach((t) => {\n      e(t);\n    });\n    if (\"bottomUp\" === n) {\n      t(r);\n    }\n  })(e);\n}\nexports.clearLabels = function (e) {\n  visitTree(\n    e,\n    (e) => {\n      e.label = undefined;\n    },\n    \"bottomUp\"\n  );\n  return e;\n};\nexports.clearLabelsIf = function (e, t) {\n  visitTree(\n    e,\n    (e) => {\n      e.label = e.label ? (t(e.label) ? undefined : e.label) : undefined;\n    },\n    \"bottomUp\"\n  );\n  return e;\n};\nexports.mapLabels = function e(t, n) {\n  switch (t.type) {\n    case \"line\":\n    case \"virtual\":\n      const r = t.subs.map((t) => e(t, n));\n      return {\n        ...t,\n        subs: r,\n        label: t.label ? n(t.label) : undefined,\n      };\n    case \"blank\":\n      return {\n        ...t,\n        label: t.label ? n(t.label) : undefined,\n      };\n    case \"top\":\n      return {\n        ...t,\n        subs: t.subs.map((t) => e(t, n)),\n        label: t.label ? n(t.label) : undefined,\n      };\n  }\n};\nexports.resetLineNumbers = function (e) {\n  let t = 0;\n  visitTree(\n    e,\n    function (e) {\n      if (r.isVirtual(e) || r.isTop(e)) {\n        e.lineNumber = t;\n        t++;\n      }\n    },\n    \"topDown\"\n  );\n};\nexports.visitTree = visitTree;\nexports.visitTreeConditionally = function (e, t, n) {\n  !(function e(r) {\n    if (\"topDown\" === n && !t(r)) return !1;\n    let o = !0;\n    r.subs.forEach((t) => {\n      o = o && e(t);\n    });\n    if (\"bottomUp\" === n) {\n      o = o && t(r);\n    }\n    return o;\n  })(e);\n};\nexports.foldTree = function (e, t, n, r) {\n  let i = t;\n  visitTree(\n    e,\n    function (e) {\n      i = n(e, i);\n    },\n    r\n  );\n  return i;\n};\nexports.rebuildTree = function (e, t, n) {\n  const o = (e) => {\n      if (undefined !== n && n(e)) return e;\n      {\n        const n = e.subs.map(o).filter((e) => undefined !== e);\n        e.subs = n;\n        return t(e);\n      }\n    },\n    i = o(e);\n  return undefined !== i ? i : r.topNode();\n};",
  "9852": "const r = require(\"fs\"),\n  o = require(\"path\"),\n  i = (e, t) => Array.from(Array(t).keys()).slice(e),\n  s = (e) => e.charCodeAt(0),\n  a = new TextDecoder(\"utf-8\"),\n  c = (e) => a.decode(new Uint8Array(e));\nfunction l(e) {\n  const t = new Set();\n  let n = e[0];\n  for (let r = 1; r < e.length; r++) {\n    const o = e[r];\n    t.add([n, o]);\n    n = o;\n  }\n  return t;\n}\nconst u = new TextEncoder(\"utf-8\");\nconst d =\n  /'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+/gu;\nlet p = !1;\nconst h = {};\nlet f,\n  m = {},\n  g = new Map(),\n  _ = new Map();\nconst y = new Map();\nfunction v() {\n  if (p) return;\n  m = JSON.parse(\n    r.readFileSync(o.resolve(__dirname, \"..\", \"dist\", \"tokenizer.json\"))\n  );\n  Object.keys(m).map((e) => {\n    h[m[e]] = e;\n  });\n  const e = r\n      .readFileSync(o.resolve(__dirname, \"..\", \"dist\", \"vocab.bpe\"), \"utf-8\")\n      .split(\"\\n\"),\n    t = e.slice(1, e.length - 1).map((e) =>\n      e.split(/(\\s+)/).filter(function (e) {\n        return e.trim().length > 0;\n      })\n    );\n  f = ((e, t) => {\n    const n = {};\n    e.map((r, o) => {\n      n[e[o]] = t[o];\n    });\n    return n;\n  })(t, i(0, t.length));\n  (function (e) {\n    const t = i(s(\"!\"), s(\"~\") + 1).concat(\n      i(s(\"\"), s(\"\") + 1),\n      i(s(\"\"), s(\"\") + 1)\n    );\n    let n = t.slice(),\n      r = 0;\n    for (let e = 0; e < 256; e++)\n      if (t.includes(e)) {\n        t.push(e);\n        n.push(256 + r);\n        r += 1;\n      }\n    n = n.map((e) => ((e) => String.fromCharCode(e))(e));\n    for (let r = 0; r < t.length; r++) e.set(t[r], n[r]);\n  })(g);\n  g.forEach(function (e, t, n) {\n    _.set(e, t);\n  });\n  p = !0;\n}\nfunction b(e) {\n  if (y.has(e)) return y.get(e);\n  let t = ((r = e), Array.from(u.encode(r))).map((e) => g.get(e)),\n    n = l(t);\n  var r;\n  if (!n) return t.map((e) => m[e]);\n  for (;;) {\n    const e = {};\n    Array.from(n).map((t) => {\n      const n = f[t];\n      e[isNaN(n) ? 1e11 : n] = t;\n    });\n    const r = e[Math.min(...Object.keys(e).map((e) => parseInt(e)))];\n    if (!(r in f)) break;\n    const o = r[0],\n      i = r[1];\n    let s = [],\n      a = 0;\n    for (; a < t.length; ) {\n      const e = t.indexOf(o, a);\n      if (-1 === e) {\n        Array.prototype.push.apply(s, t.slice(a));\n        break;\n      }\n      Array.prototype.push.apply(s, t.slice(a, e));\n      a = e;\n      if (t[a] === o && a < t.length - 1 && t[a + 1] === i) {\n        s.push(o + i);\n        a += 2;\n      } else {\n        s.push(t[a]);\n        a += 1;\n      }\n    }\n    t = s;\n    if (1 === t.length) break;\n    n = l(t);\n  }\n  tokens = t.map((e) => m[e]);\n  y.set(e, tokens);\n  return tokens;\n}\nfunction w(e) {\n  v();\n  let t = [];\n  const n = Array.from(e.matchAll(d)).map((e) => e[0]);\n  for (let e of n) {\n    const n = b(e);\n    Array.prototype.push.apply(t, n);\n  }\n  return t;\n}\nfunction x(e, t) {\n  if (t <= 0) return \"\";\n  let n = Math.min(e.length, 4 * t),\n    r = e.slice(-n),\n    o = w(r);\n  for (; o.length < t + 2 && n < e.length; ) {\n    n = Math.min(e.length, n + 1 * t);\n    r = e.slice(-n);\n    o = w(r);\n  }\n  return o.length < t ? e : ((o = o.slice(-t)), E(o));\n}\nfunction E(e) {\n  v();\n  let t = e.map((e) => h[e]).join(\"\");\n  t = c(t.split(\"\").map((e) => _.get(e)));\n  return t;\n}\nmodule.exports = {\n  prepareTokenizer: v,\n  tokenize: w,\n  tokenize_strings: function (e) {\n    return w(e).map((e) => c(h[e].split(\"\").map((e) => _.get(e))));\n  },\n  tokenLength: function (e) {\n    return w(e).length;\n  },\n  takeLastTokens: x,\n  takeLastLinesTokens: function (e, t) {\n    const n = x(e, t);\n    if (n.length === e.length || \"\\n\" === e[e.length - n.length - 1]) return n;\n    let r = n.indexOf(\"\\n\");\n    return n.substring(r + 1);\n  },\n  takeFirstTokens: function (e, t) {\n    if (t <= 0)\n      return {\n        text: \"\",\n        tokens: [],\n      };\n    let n = Math.min(e.length, 4 * t),\n      r = e.slice(0, n),\n      o = w(r);\n    for (; o.length < t + 2 && n < e.length; ) {\n      n = Math.min(e.length, n + 1 * t);\n      r = e.slice(0, n);\n      o = w(r);\n    }\n    return o.length < t\n      ? {\n          text: e,\n          tokens: o,\n        }\n      : ((o = o.slice(0, t)),\n        {\n          text: E(o),\n          tokens: o,\n        });\n  },\n  detokenize: E,\n};",
  "9864": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nconst r = require(3487),\n  o = require(6776),\n  i = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: !0,\n    error: {\n      message: ({ params: { min: e, max: t } }) =>\n        undefined === t\n          ? r.str`must contain at least ${e} valid item(s)`\n          : r.str`must contain at least ${e} and no more than ${t} valid item(s)`,\n      params: ({ params: { min: e, max: t } }) =>\n        undefined === t\n          ? r._`{minContains: ${e}}`\n          : r._`{minContains: ${e}, maxContains: ${t}}`,\n    },\n    code(e) {\n      const { gen: t, schema: n, parentSchema: i, data: s, it: a } = e;\n      let c, l;\n      const { minContains: u, maxContains: d } = i;\n      if (a.opts.next) {\n        c = undefined === u ? 1 : u;\n        l = d;\n      } else {\n        c = 1;\n      }\n      const p = t.const(\"len\", r._`${s}.length`);\n      e.setParams({\n        min: c,\n        max: l,\n      });\n      if (void 0 === l && 0 === c)\n        return void (0, o.checkStrictMode)(\n          a,\n          '\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored'\n        );\n      if (undefined !== l && c > l) {\n        o.checkStrictMode(a, '\"minContains\" > \"maxContains\" is always invalid');\n        return void e.fail();\n      }\n      if (o.alwaysValidSchema(a, n)) {\n        let t = r._`${p} >= ${c}`;\n        if (undefined !== l) {\n          t = r._`${t} && ${p} <= ${l}`;\n        }\n        return void e.pass(t);\n      }\n      a.items = !0;\n      const h = t.name(\"valid\");\n      if (undefined === l && 1 === c) f(h, () => t.if(h, () => t.break()));\n      else {\n        t.let(h, !1);\n        const e = t.name(\"_valid\"),\n          n = t.let(\"count\", 0);\n        f(e, () =>\n          t.if(e, () =>\n            (function (e) {\n              t.code(r._`${e}++`);\n              if (undefined === l) {\n                t.if(r._`${e} >= ${c}`, () => t.assign(h, !0).break());\n              } else {\n                t.if(r._`${e} > ${l}`, () => t.assign(h, !1).break());\n                if (1 === c) {\n                  t.assign(h, !0);\n                } else {\n                  t.if(r._`${e} >= ${c}`, () => t.assign(h, !0));\n                }\n              }\n            })(n)\n          )\n        );\n      }\n      function f(n, r) {\n        t.forRange(\"i\", 0, p, (t) => {\n          e.subschema(\n            {\n              keyword: \"contains\",\n              dataProp: t,\n              dataPropType: o.Type.Num,\n              compositeRule: !0,\n            },\n            n\n          );\n          r();\n        });\n      }\n      e.result(h, () => e.reset());\n    },\n  };\nexports.default = i;",
  "9867": "var r = require(6372),\n  o = r.wrap,\n  i = r.unwrap,\n  s = \"wrap@before\";\nfunction a(e, t, n) {\n  var r = !!e[t] && e.propertyIsEnumerable(t);\n  Object.defineProperty(e, t, {\n    configurable: !0,\n    enumerable: r,\n    writable: !0,\n    value: n,\n  });\n}\nfunction c(e, t) {\n  var n;\n  n = e._events && e._events[t];\n  if (Array.isArray(n)) {\n    n = n ? [n] : [];\n  }\n  return n;\n}\nfunction l(e, t) {\n  if (e) {\n    var n = e;\n    if (\"function\" == typeof e) n = t(e);\n    else if (Array.isArray(e)) {\n      n = [];\n      for (var r = 0; r < e.length; r++) n[r] = t(e[r]);\n    }\n    return n;\n  }\n}\nmodule.exports = function (e, t, n) {\n  if (!(e && e.on && e.addListener && e.removeListener && e.emit))\n    throw new Error(\"can only wrap real EEs\");\n  if (!t) throw new Error(\"must have function to run on listener addition\");\n  if (!n) throw new Error(\"must have function to wrap listeners when emitting\");\n  function r(e) {\n    return function (t, n) {\n      var i = c(this, t).slice();\n      try {\n        var a = e.call(this, t, n);\n        (function (e, t, n) {\n          var r = c(e, t).filter(function (e) {\n            return -1 === n.indexOf(e);\n          });\n          if (r.length > 0) {\n            (function (e, t) {\n              for (var n = t.length, r = 0; r < n; r++) {\n                var o = t[r],\n                  i = e[s];\n                if (\"function\" == typeof i) i(o);\n                else if (Array.isArray(i))\n                  for (var a = i.length, c = 0; c < a; c++) i[c](o);\n              }\n            })(e, r);\n          }\n        })(this, t, i);\n        return a;\n      } finally {\n        if (this.on.__wrapped) {\n          o(this, \"on\", r);\n        }\n        if (this.addListener.__wrapped) {\n          o(this, \"addListener\", r);\n        }\n      }\n    };\n  }\n  if (e[s]) {\n    if (\"function\" == typeof e[s]) {\n      a(e, s, [e[s], t]);\n    } else {\n      if (Array.isArray(e[s])) {\n        e[s].push(t);\n      }\n    }\n  } else {\n    a(e, s, t);\n  }\n  if (e.__wrapped) {\n    o(e, \"addListener\", r);\n    o(e, \"on\", r);\n    o(e, \"emit\", function (e) {\n      return function (t) {\n        if (!this._events || !this._events[t]) return e.apply(this, arguments);\n        var r = this._events[t];\n        function s(e) {\n          return function () {\n            this._events[t] = r;\n            try {\n              return e.apply(this, arguments);\n            } finally {\n              r = this._events[t];\n              this._events[t] = l(r, n);\n            }\n          };\n        }\n        o(this, \"removeListener\", s);\n        try {\n          this._events[t] = l(r, n);\n          return e.apply(this, arguments);\n        } finally {\n          i(this, \"removeListener\");\n          this._events[t] = r;\n        }\n      };\n    });\n    a(e, \"__unwrap\", function () {\n      i(e, \"addListener\");\n      i(e, \"on\");\n      i(e, \"emit\");\n      delete e[s];\n      delete e.__wrapped;\n    });\n    a(e, \"__wrapped\", !0);\n  }\n};",
  "9871": "module.exports = function () {\n  this.applicationVersion = \"ai.application.ver\";\n  this.deviceId = \"ai.device.id\";\n  this.deviceLocale = \"ai.device.locale\";\n  this.deviceModel = \"ai.device.model\";\n  this.deviceOEMName = \"ai.device.oemName\";\n  this.deviceOSVersion = \"ai.device.osVersion\";\n  this.deviceType = \"ai.device.type\";\n  this.locationIp = \"ai.location.ip\";\n  this.operationId = \"ai.operation.id\";\n  this.operationName = \"ai.operation.name\";\n  this.operationParentId = \"ai.operation.parentId\";\n  this.operationSyntheticSource = \"ai.operation.syntheticSource\";\n  this.operationCorrelationVector = \"ai.operation.correlationVector\";\n  this.sessionId = \"ai.session.id\";\n  this.sessionIsFirst = \"ai.session.isFirst\";\n  this.userAccountId = \"ai.user.accountId\";\n  this.userId = \"ai.user.id\";\n  this.userAuthUserId = \"ai.user.authUserId\";\n  this.cloudRole = \"ai.cloud.role\";\n  this.cloudRoleInstance = \"ai.cloud.roleInstance\";\n  this.internalSdkVersion = \"ai.internal.sdkVersion\";\n  this.internalAgentVersion = \"ai.internal.agentVersion\";\n  this.internalNodeName = \"ai.internal.nodeName\";\n};",
  "9872": "const { validateHeaderName: r, validateHeaderValue: o } = require(\"http\"),\n  { isPlainObject: i } = require(4544),\n  s = Symbol(\"Headers internals\"),\n  a = (e) => {\n    const t = \"string\" != typeof e ? String(e) : e;\n    if (\"function\" == typeof r) r(t);\n    else if (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(t)) {\n      const e = new TypeError(`Header name must be a valid HTTP token [${t}]`);\n      throw (\n        (Object.defineProperty(e, \"code\", {\n          value: \"ERR_INVALID_HTTP_TOKEN\",\n        }),\n        e)\n      );\n    }\n    return t.toLowerCase();\n  },\n  c = (e, t) => {\n    const n = \"string\" != typeof e ? String(e) : e;\n    if (\"function\" == typeof o) o(t, n);\n    else if (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(n)) {\n      const e = new TypeError(`Invalid character in header content [\"${t}\"]`);\n      throw (\n        (Object.defineProperty(e, \"code\", {\n          value: \"ERR_INVALID_CHAR\",\n        }),\n        e)\n      );\n    }\n    return n;\n  };\nclass l {\n  constructor(e = {}) {\n    this[s] = {\n      map: new Map(),\n    };\n    if (e instanceof l)\n      e.forEach((e, t) => {\n        this.append(t, e);\n      });\n    else if (Array.isArray(e))\n      e.forEach(([e, t]) => {\n        this.append(e, t);\n      });\n    else if (i(e)) for (const [t, n] of Object.entries(e)) this.append(t, n);\n  }\n  set(e, t) {\n    this[s].map.set(a(e), c(t, e));\n  }\n  has(e) {\n    return this[s].map.has(a(e));\n  }\n  get(e) {\n    const t = this[s].map.get(a(e));\n    return undefined === t ? null : t;\n  }\n  append(e, t) {\n    const n = a(e),\n      r = c(t, e),\n      o = this[s].map.get(n);\n    this[s].map.set(n, o ? `${o}, ${r}` : r);\n  }\n  delete(e) {\n    this[s].map.delete(a(e));\n  }\n  forEach(e, t) {\n    for (const n of this.keys()) e.call(t, this.get(n), n);\n  }\n  keys() {\n    return Array.from(this[s].map.keys()).sort();\n  }\n  *values() {\n    for (const e of this.keys()) yield this.get(e);\n  }\n  *entries() {\n    for (const e of this.keys()) yield [e, this.get(e)];\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n  plain() {\n    return Object.fromEntries(this[s].map);\n  }\n}\nObject.defineProperties(\n  l.prototype,\n  [\n    \"append\",\n    \"delete\",\n    \"entries\",\n    \"forEach\",\n    \"get\",\n    \"has\",\n    \"keys\",\n    \"set\",\n    \"values\",\n  ].reduce(\n    (e, t) => (\n      (e[t] = {\n        enumerable: !0,\n      }),\n      e\n    ),\n    {}\n  )\n);\nmodule.exports = {\n  Headers: l,\n};",
  "9899": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.logger =\n  exports.toPlainText =\n  exports.Logger =\n  exports.MultiLog =\n  exports.OutputChannelLog =\n  exports.ConsoleLog =\n  exports.LogTarget =\n  exports.verboseLogging =\n  exports.LogVerbose =\n  exports.LogLevel =\n    undefined;\nconst r = require(299),\n  o = require(1133),\n  i = require(6333);\nvar s;\n!(function (e) {\n  e[(e.DEBUG = 0)] = \"DEBUG\";\n  e[(e.INFO = 1)] = \"INFO\";\n  e[(e.WARN = 2)] = \"WARN\";\n  e[(e.ERROR = 3)] = \"ERROR\";\n})((s = exports.LogLevel || (exports.LogLevel = {})));\nclass LogVerbose {\n  constructor(e) {\n    this.logVerbose = e;\n  }\n}\nfunction verboseLogging(e) {\n  return e.get(LogVerbose).logVerbose;\n}\nexports.LogVerbose = LogVerbose;\nexports.verboseLogging = verboseLogging;\nclass LogTarget {\n  shouldLog(e, t) {}\n}\nexports.LogTarget = LogTarget;\nexports.ConsoleLog = class extends LogTarget {\n  constructor(e) {\n    super();\n    this.console = e;\n  }\n  logIt(e, t, n, ...r) {\n    if (verboseLogging(e) || t == s.ERROR) {\n      this.console.error(n, ...r);\n    } else {\n      if (t == s.WARN) {\n        this.console.warn(n, ...r);\n      }\n    }\n  }\n};\nexports.OutputChannelLog = class extends LogTarget {\n  constructor(e) {\n    super();\n    this.output = e;\n  }\n  logIt(e, t, n, ...r) {\n    this.output.appendLine(`${n} ${r.map(toPlainText)}`);\n  }\n};\nexports.MultiLog = class extends LogTarget {\n  constructor(e) {\n    super();\n    this.targets = e;\n  }\n  logIt(e, t, n, ...r) {\n    this.targets.forEach((o) => o.logIt(e, t, n, ...r));\n  }\n};\nclass Logger {\n  constructor(e, t) {\n    this.minLoggedLevel = e;\n    this.context = t;\n  }\n  setLevel(e) {\n    this.minLoggedLevel = e;\n  }\n  stringToLevel(e) {\n    return s[e];\n  }\n  log(e, t, n, ...o) {\n    const a = s[t];\n    if (t == s.ERROR) {\n      i.telemetryError(\n        e,\n        \"log\",\n        i.TelemetryData.createAndMarkAsIssued({\n          context: this.context,\n          level: a,\n          message: o.length > 0 ? JSON.stringify(o) : \"no msg\",\n        }),\n        n\n      );\n    }\n    const c = e.get(LogTarget),\n      u = c.shouldLog(e, t);\n    if (!1 === u) return;\n    if (undefined === u && !this.shouldLog(e, t, this.context)) return;\n    const d = e.get(r.Clock).now().toISOString(),\n      p = `[${a}] [${this.context}] [${d}]`;\n    c.logIt(e, t, p, ...o);\n  }\n  shouldLog(e, t, n) {\n    var r, i;\n    if (verboseLogging(e)) return !0;\n    const s = o.getConfig(e, o.ConfigKey.DebugFilterLogCategories);\n    if (s.length > 0 && !s.includes(n)) return !1;\n    if (o.isProduction(e)) return t >= this.minLoggedLevel;\n    const a = o.getConfig(e, o.ConfigKey.DebugOverrideLogLevels);\n    return (\n      t >=\n      (null !==\n        (i =\n          null !== (r = this.stringToLevel(a[\"*\"])) && undefined !== r\n            ? r\n            : this.stringToLevel(a[this.context])) && undefined !== i\n        ? i\n        : this.minLoggedLevel)\n    );\n  }\n  debug(e, ...t) {\n    this.log(e, s.DEBUG, !1, ...t);\n  }\n  info(e, ...t) {\n    this.log(e, s.INFO, !1, ...t);\n  }\n  warn(e, ...t) {\n    this.log(e, s.WARN, !1, ...t);\n  }\n  error(e, ...t) {\n    this.log(e, s.ERROR, !1, ...t);\n  }\n  secureError(e, t, ...n) {\n    this.log(e, s.ERROR, !1, t);\n    this.log(e, s.ERROR, !0, t, ...n);\n  }\n}\nfunction toPlainText(e) {\n  return \"object\" == typeof e ? JSON.stringify(e) : String(e);\n}\nexports.Logger = Logger;\nexports.toPlainText = toPlainText;\nexports.logger = new Logger(s.INFO, \"default\");",
  "9931": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getNeighborSnippets = exports.neighborOptionToSelection = undefined;\nconst r = require(1788),\n  o = require(569);\nfunction i(e) {\n  return [\n    e.relativePath\n      ? \"Compare this snippet from \" + e.relativePath + \":\"\n      : \"Compare this snippet:\",\n  ].concat(e.snippet.split(\"\\n\"));\n}\nexports.neighborOptionToSelection = {\n  none: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(1),\n    threshold: -1,\n    numberOfSnippets: 0,\n  },\n  conservative: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(10),\n    threshold: 0.3,\n    numberOfSnippets: 1,\n  },\n  medium: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(20),\n    threshold: 0.1,\n    numberOfSnippets: 2,\n  },\n  eager: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(60),\n    threshold: 0,\n    numberOfSnippets: 4,\n  },\n  eagerButLittle: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(10),\n    threshold: 0,\n    numberOfSnippets: 1,\n  },\n};\nexports.getNeighborSnippets = async function (e, n, s, a, c, l, u) {\n  const d = exports.neighborOptionToSelection[s],\n    p = (function (e, n, r, i) {\n      const s = {\n        ...exports.neighborOptionToSelection[n],\n      };\n      if (undefined !== r && undefined !== i) {\n        s.matcherFactory = o.IndentationBasedJaccardMatcher.FACTORY(r, i);\n      }\n      return s.matcherFactory.to(e);\n    })(e, s, a, c);\n  return n\n    .filter((e) => e.source.length < 1e4 && e.source.length > 0)\n    .slice(0, 20)\n    .reduce(\n      (e, t) =>\n        e.concat(\n          p.findMatches(t, l, u).map((e) => ({\n            relativePath: t.relativePath,\n            ...e,\n          }))\n        ),\n      []\n    )\n    .filter((e) => e.score && e.snippet && e.score > d.threshold)\n    .sort((e, t) => e.score - t.score)\n    .slice(-d.numberOfSnippets)\n    .map((t) => ({\n      score: t.score,\n      snippet: i(t)\n        .map((t) => r.comment(t, e.languageId) + \"\\n\")\n        .join(\"\"),\n      startLine: t.startLine,\n      endLine: t.endLine,\n    }));\n};",
  "9940": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getNodeStart =\n  exports.isBlockBodyFinished =\n  exports.isEmptyBlockStart =\n  exports.getBlockParser =\n    undefined;\nconst r = require(464);\nclass o {\n  constructor(e, t, n) {\n    this.languageId = e;\n    this.nodeMatch = t;\n    this.nodeTypesWithBlockOrStmtChild = n;\n  }\n  async getNodeMatchAtPosition(e, t, n) {\n    const o = await r.parseTree(this.languageId, e);\n    try {\n      let e = o.rootNode.descendantForIndex(t);\n      for (; e; ) {\n        const t = this.nodeMatch[e.type];\n        if (t) {\n          if (!this.nodeTypesWithBlockOrStmtChild.has(e.type)) break;\n          const n = this.nodeTypesWithBlockOrStmtChild.get(e.type),\n            r = \"\" == n ? e.namedChildren[0] : e.childForFieldName(n);\n          if ((null == r ? undefined : r.type) == t) break;\n        }\n        e = e.parent;\n      }\n      if (!e) return;\n      return n(e);\n    } finally {\n      o.delete();\n    }\n  }\n  getNextBlockAtPosition(e, t, n) {\n    return this.getNodeMatchAtPosition(e, t, (e) => {\n      let t = e.children\n        .reverse()\n        .find((t) => t.type == this.nodeMatch[e.type]);\n      if (t) {\n        if (\"python\" == this.languageId && t.parent) {\n          const e = \":\" == t.parent.type ? t.parent.parent : t.parent;\n          let n = null == e ? undefined : e.nextSibling;\n          for (; n && \"comment\" == n.type; ) {\n            const r =\n                n.startPosition.row == t.endPosition.row &&\n                n.startPosition.column >= t.endPosition.column,\n              o =\n                n.startPosition.row > e.endPosition.row &&\n                n.startPosition.column > e.startPosition.column;\n            if (!r && !o) break;\n            t = n;\n            n = n.nextSibling;\n          }\n        }\n        if (\n          !(\n            t.endIndex >= t.tree.rootNode.endIndex - 1 &&\n            (t.hasError() || t.parent.hasError())\n          )\n        )\n          return n(t);\n      }\n    });\n  }\n  async isBlockBodyFinished(e, t, n) {\n    const r = (e + t).trimEnd(),\n      o = await this.getNextBlockAtPosition(r, n, (e) => e.endIndex);\n    if (undefined !== o && o < r.length) {\n      const t = o - e.length;\n      return t > 0 ? t : undefined;\n    }\n  }\n  getNodeStart(e, t) {\n    const n = e.trimEnd();\n    return this.getNodeMatchAtPosition(n, t, (e) => e.startIndex);\n  }\n}\nclass i extends o {\n  constructor(e, t, n, r, o) {\n    super(e, r, o);\n    this.blockEmptyMatch = t;\n    this.lineMatch = n;\n  }\n  isBlockStart(e) {\n    return this.lineMatch.test(e.trimStart());\n  }\n  async isBlockBodyEmpty(e, t) {\n    const n = await this.getNextBlockAtPosition(e, t, (n) => {\n      if (n.startIndex < t) {\n        t = n.startIndex;\n      }\n      let r = e.substring(t, n.endIndex).trim();\n      return \"\" == r || r.replace(/\\s/g, \"\") == this.blockEmptyMatch;\n    });\n    return undefined === n || n;\n  }\n  async isEmptyBlockStart(e, t) {\n    t = s(e, t);\n    return (\n      this.isBlockStart(\n        (function (e, t) {\n          const n = e.lastIndexOf(\"\\n\", t - 1);\n          let r = e.indexOf(\"\\n\", t);\n          if (r < 0) {\n            r = e.length;\n          }\n          return e.slice(n + 1, r);\n        })(e, t)\n      ) && this.isBlockBodyEmpty(e, t)\n    );\n  }\n}\nfunction s(e, t) {\n  let n = t;\n  for (; n > 0 && /\\s/.test(e.charAt(n - 1)); ) n--;\n  return n;\n}\nfunction a(e, t) {\n  const n = e.startIndex,\n    r = e.startIndex - e.startPosition.column,\n    o = t.substring(r, n);\n  if (/^\\s*$/.test(o)) return o;\n}\nfunction c(e, t, n) {\n  if (t.startPosition.row <= e.startPosition.row) return !1;\n  const r = a(e, n),\n    o = a(t, n);\n  return undefined !== r && undefined !== o && r.startsWith(o);\n}\nclass l extends o {\n  constructor(e, t, n, r, o, i, s) {\n    super(e, t, n);\n    this.startKeywords = r;\n    this.blockNodeType = o;\n    this.emptyStatementType = i;\n    this.curlyBraceLanguage = s;\n  }\n  isBlockEmpty(e, t) {\n    var n, o;\n    let i = e.text.trim();\n    if (this.curlyBraceLanguage) {\n      if (i.startsWith(\"{\")) {\n        i = i.slice(1);\n      }\n      if (i.endsWith(\"}\")) {\n        i = i.slice(0, -1);\n      }\n      i = i.trim();\n    }\n    return (\n      0 == i.length ||\n      !(\n        \"python\" != this.languageId ||\n        (\"class_definition\" !=\n          (null === (n = e.parent) || undefined === n ? undefined : n.type) &&\n          \"function_definition\" !=\n            (null === (o = e.parent) || undefined === o\n              ? undefined\n              : o.type)) ||\n        1 != e.children.length ||\n        !r.queryPythonIsDocstring(e.parent)\n      )\n    );\n  }\n  async isEmptyBlockStart(e, t) {\n    var n, o, i;\n    if (t > e.length) throw new RangeError(\"Invalid offset\");\n    for (let n = t; n < e.length && \"\\n\" != e.charAt(n); n++)\n      if (/\\S/.test(e.charAt(n))) return !1;\n    t = s(e, t);\n    const a = await r.parseTree(this.languageId, e);\n    try {\n      const r = a.rootNode.descendantForIndex(t - 1);\n      if (null == r) return !1;\n      if (this.curlyBraceLanguage && \"}\" == r.type) return !1;\n      if (\n        (\"javascript\" == this.languageId || \"typescript\" == this.languageId) &&\n        r.parent &&\n        \"object\" == r.parent.type &&\n        \"{\" == r.parent.text.trim()\n      )\n        return !0;\n      if (\"typescript\" == this.languageId) {\n        let n = r;\n        for (; n.parent; ) {\n          if (\"function_signature\" == n.type || \"method_signature\" == n.type) {\n            const o = r.nextSibling;\n            return (\n              !!(o && n.hasError() && c(n, o, e)) ||\n              (!n.children.find((e) => \";\" == e.type) && n.endIndex <= t)\n            );\n          }\n          n = n.parent;\n        }\n      }\n      let s = null,\n        l = null,\n        u = null,\n        d = r;\n      for (; null != d; ) {\n        if (d.type == this.blockNodeType) {\n          l = d;\n          break;\n        }\n        if (this.nodeMatch[d.type]) {\n          u = d;\n          break;\n        }\n        if (\"ERROR\" == d.type) {\n          s = d;\n          break;\n        }\n        d = d.parent;\n      }\n      if (null != l) {\n        if (!l.parent || !this.nodeMatch[l.parent.type]) return !1;\n        if (\"python\" == this.languageId) {\n          const e = l.previousSibling;\n          if (\n            null != e &&\n            e.hasError() &&\n            (e.text.startsWith('\"\"\"') || e.text.startsWith(\"'''\"))\n          )\n            return !0;\n        }\n        return this.isBlockEmpty(l, t);\n      }\n      if (null != s) {\n        if (\n          \"module\" ==\n            (null === (n = s.previousSibling) || undefined === n\n              ? undefined\n              : n.type) ||\n          \"internal_module\" ==\n            (null === (o = s.previousSibling) || undefined === o\n              ? undefined\n              : o.type)\n        )\n          return !0;\n        const e = [...s.children].reverse(),\n          a = e.find((e) => this.startKeywords.includes(e.type));\n        let c = e.find((e) => e.type == this.blockNodeType);\n        if (a) {\n          switch (this.languageId) {\n            case \"python\": {\n              if (\n                \"try\" == a.type &&\n                \"identifier\" == r.type &&\n                r.text.length > 4\n              ) {\n                c =\n                  null === (i = e.find((e) => e.hasError())) || undefined === i\n                    ? undefined\n                    : i.children.find((e) => \"block\" == e.type);\n              }\n              const t = e.find((e) => \":\" == e.type);\n              if (t && a.endIndex <= t.startIndex && t.nextSibling) {\n                if (\"def\" == a.type) {\n                  const e = t.nextSibling;\n                  if ('\"' == e.type || \"'\" == e.type) return !0;\n                  if (\"ERROR\" == e.type && ('\"\"\"' == e.text || \"'''\" == e.text))\n                    return !0;\n                }\n                return !1;\n              }\n              break;\n            }\n            case \"javascript\": {\n              const t = e.find((e) => \"formal_parameters\" == e.type);\n              if (\"class\" == a.type && t) return !0;\n              const n = e.find((e) => \"{\" == e.type);\n              if (n && n.startIndex > a.endIndex && null != n.nextSibling)\n                return !1;\n              if (e.find((e) => \"do\" == e.type) && \"while\" == a.type) return !1;\n              if (\"=>\" == a.type && a.nextSibling && \"{\" != a.nextSibling.type)\n                return !1;\n              break;\n            }\n            case \"typescript\": {\n              const t = e.find((e) => \"{\" == e.type);\n              if (t && t.startIndex > a.endIndex && null != t.nextSibling)\n                return !1;\n              if (e.find((e) => \"do\" == e.type) && \"while\" == a.type) return !1;\n              if (\"=>\" == a.type && a.nextSibling && \"{\" != a.nextSibling.type)\n                return !1;\n              break;\n            }\n          }\n          return !(c && c.startIndex > a.endIndex) || this.isBlockEmpty(c, t);\n        }\n      }\n      if (null != u) {\n        const e = this.nodeMatch[u.type],\n          n = u.children\n            .slice()\n            .reverse()\n            .find((t) => t.type == e);\n        if (n) return this.isBlockEmpty(n, t);\n        if (this.nodeTypesWithBlockOrStmtChild.has(u.type)) {\n          const e = this.nodeTypesWithBlockOrStmtChild.get(u.type),\n            t = \"\" == e ? u.children[0] : u.childForFieldName(e);\n          if (\n            t &&\n            t.type != this.blockNodeType &&\n            t.type != this.emptyStatementType\n          )\n            return !1;\n        }\n        return !0;\n      }\n      return !1;\n    } finally {\n      a.delete();\n    }\n  }\n}\nconst u = {\n  python: new l(\n    \"python\",\n    {\n      class_definition: \"block\",\n      elif_clause: \"block\",\n      else_clause: \"block\",\n      except_clause: \"block\",\n      finally_clause: \"block\",\n      for_statement: \"block\",\n      function_definition: \"block\",\n      if_statement: \"block\",\n      try_statement: \"block\",\n      while_statement: \"block\",\n      with_statement: \"block\",\n    },\n    new Map(),\n    [\n      \"def\",\n      \"class\",\n      \"if\",\n      \"elif\",\n      \"else\",\n      \"for\",\n      \"while\",\n      \"try\",\n      \"except\",\n      \"finally\",\n      \"with\",\n    ],\n    \"block\",\n    null,\n    !1\n  ),\n  javascript: new l(\n    \"javascript\",\n    {\n      arrow_function: \"statement_block\",\n      catch_clause: \"statement_block\",\n      do_statement: \"statement_block\",\n      else_clause: \"statement_block\",\n      finally_clause: \"statement_block\",\n      for_in_statement: \"statement_block\",\n      for_statement: \"statement_block\",\n      function: \"statement_block\",\n      function_declaration: \"statement_block\",\n      generator_function: \"statement_block\",\n      generator_function_declaration: \"statement_block\",\n      if_statement: \"statement_block\",\n      method_definition: \"statement_block\",\n      try_statement: \"statement_block\",\n      while_statement: \"statement_block\",\n      with_statement: \"statement_block\",\n      class: \"class_body\",\n      class_declaration: \"class_body\",\n    },\n    new Map([\n      [\"arrow_function\", \"body\"],\n      [\"do_statement\", \"body\"],\n      [\"else_clause\", \"\"],\n      [\"for_in_statement\", \"body\"],\n      [\"for_statement\", \"body\"],\n      [\"if_statement\", \"consequence\"],\n      [\"while_statement\", \"body\"],\n      [\"with_statement\", \"body\"],\n    ]),\n    [\n      \"=>\",\n      \"try\",\n      \"catch\",\n      \"finally\",\n      \"do\",\n      \"for\",\n      \"if\",\n      \"else\",\n      \"while\",\n      \"with\",\n      \"function\",\n      \"function*\",\n      \"class\",\n    ],\n    \"statement_block\",\n    \"empty_statement\",\n    !0\n  ),\n  typescript: new l(\n    \"typescript\",\n    {\n      ambient_declaration: \"statement_block\",\n      arrow_function: \"statement_block\",\n      catch_clause: \"statement_block\",\n      do_statement: \"statement_block\",\n      else_clause: \"statement_block\",\n      finally_clause: \"statement_block\",\n      for_in_statement: \"statement_block\",\n      for_statement: \"statement_block\",\n      function: \"statement_block\",\n      function_declaration: \"statement_block\",\n      generator_function: \"statement_block\",\n      generator_function_declaration: \"statement_block\",\n      if_statement: \"statement_block\",\n      internal_module: \"statement_block\",\n      method_definition: \"statement_block\",\n      module: \"statement_block\",\n      try_statement: \"statement_block\",\n      while_statement: \"statement_block\",\n      abstract_class_declaration: \"class_body\",\n      class: \"class_body\",\n      class_declaration: \"class_body\",\n    },\n    new Map([\n      [\"arrow_function\", \"body\"],\n      [\"do_statement\", \"body\"],\n      [\"else_clause\", \"\"],\n      [\"for_in_statement\", \"body\"],\n      [\"for_statement\", \"body\"],\n      [\"if_statement\", \"consequence\"],\n      [\"while_statement\", \"body\"],\n      [\"with_statement\", \"body\"],\n    ]),\n    [\n      \"declare\",\n      \"=>\",\n      \"try\",\n      \"catch\",\n      \"finally\",\n      \"do\",\n      \"for\",\n      \"if\",\n      \"else\",\n      \"while\",\n      \"with\",\n      \"function\",\n      \"function*\",\n      \"class\",\n    ],\n    \"statement_block\",\n    \"empty_statement\",\n    !0\n  ),\n  go: new i(\n    \"go\",\n    \"{}\",\n    /\\b(func|if|else|for)\\b/,\n    {\n      communication_case: \"block\",\n      default_case: \"block\",\n      expression_case: \"block\",\n      for_statement: \"block\",\n      func_literal: \"block\",\n      function_declaration: \"block\",\n      if_statement: \"block\",\n      labeled_statement: \"block\",\n      method_declaration: \"block\",\n      type_case: \"block\",\n    },\n    new Map()\n  ),\n  ruby: new i(\n    \"ruby\",\n    \"end\",\n    /\\b(BEGIN|END|case|class|def|do|else|elsif|for|if|module|unless|until|while)\\b|->/,\n    {\n      begin_block: \"}\",\n      block: \"}\",\n      end_block: \"}\",\n      lambda: \"block\",\n      for: \"do\",\n      until: \"do\",\n      while: \"do\",\n      case: \"end\",\n      do: \"end\",\n      if: \"end\",\n      method: \"end\",\n      module: \"end\",\n      unless: \"end\",\n      do_block: \"end\",\n    },\n    new Map()\n  ),\n};\nfunction getBlockParser(e) {\n  return u[r.languageIdToWasmLanguage(e)];\n}\nexports.getBlockParser = getBlockParser;\nexports.isEmptyBlockStart = async function (e, t, n) {\n  return (\n    !!r.isSupportedLanguageId(e) && getBlockParser(e).isEmptyBlockStart(t, n)\n  );\n};\nexports.isBlockBodyFinished = async function (e, t, n, o) {\n  if (r.isSupportedLanguageId(e))\n    return getBlockParser(e).isBlockBodyFinished(t, n, o);\n};\nexports.getNodeStart = async function (e, t, n) {\n  if (r.isSupportedLanguageId(e)) return getBlockParser(e).getNodeStart(t, n);\n};",
  "9958": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.AvailabilityData = require(7220);\nexports.Base = require(4101);\nexports.ContextTagKeys = require(9871);\nexports.Data = require(320);\nexports.DataPoint = require(8602);\nexports.DataPointType = require(495);\nexports.Domain = require(8934);\nexports.Envelope = require(7300);\nexports.EventData = require(4526);\nexports.ExceptionData = require(935);\nexports.ExceptionDetails = require(8082);\nexports.MessageData = require(901);\nexports.MetricData = require(3092);\nexports.PageViewData = require(6279);\nexports.RemoteDependencyData = require(6290);\nexports.RequestData = require(7339);\nexports.SeverityLevel = require(9697);\nexports.StackFrame = require(6376);",
  "9962": "var r = require(5740),\n  o = require(5282),\n  i = (function () {\n    function e() {}\n    e.queryCorrelationId = function (t, n) {\n      var i =\n        t.profileQueryEndpoint +\n        \"/api/profiles/\" +\n        t.instrumentationKey +\n        \"/appId\";\n      if (e.completedLookups.hasOwnProperty(i)) n(e.completedLookups[i]);\n      else if (e.pendingLookups[i]) e.pendingLookups[i].push(n);\n      else {\n        e.pendingLookups[i] = [n];\n        var s = function () {\n          if (e.pendingLookups[i]) {\n            var n = {\n              method: \"GET\",\n              disableAppInsightsAutoCollection: !0,\n            };\n            o.info(e.TAG, n);\n            var a = r.makeRequest(t, i, n, function (n) {\n              if (200 === n.statusCode) {\n                var r = \"\";\n                n.setEncoding(\"utf-8\");\n                n.on(\"data\", function (e) {\n                  r += e;\n                });\n                n.on(\"end\", function () {\n                  o.info(e.TAG, r);\n                  var t = e.correlationIdPrefix + r;\n                  e.completedLookups[i] = t;\n                  if (e.pendingLookups[i]) {\n                    e.pendingLookups[i].forEach(function (e) {\n                      return e(t);\n                    });\n                  }\n                  delete e.pendingLookups[i];\n                });\n              } else if (n.statusCode >= 400 && n.statusCode < 500) {\n                e.completedLookups[i] = undefined;\n                delete e.pendingLookups[i];\n              } else {\n                setTimeout(s, t.correlationIdRetryIntervalMs);\n              }\n            });\n            if (a) {\n              a.on(\"error\", function (t) {\n                o.warn(e.TAG, t);\n              });\n              a.end();\n            }\n          }\n        };\n        setTimeout(s, 0);\n      }\n    };\n    e.cancelCorrelationIdQuery = function (t, n) {\n      var r =\n          t.profileQueryEndpoint +\n          \"/api/profiles/\" +\n          t.instrumentationKey +\n          \"/appId\",\n        o = e.pendingLookups[r];\n      if (o) {\n        e.pendingLookups[r] = o.filter(function (e) {\n          return e != n;\n        });\n        if (0 == e.pendingLookups[r].length) {\n          delete e.pendingLookups[r];\n        }\n      }\n    };\n    e.generateRequestId = function (t) {\n      if (t) {\n        if (\".\" !== (t = \"|\" == t[0] ? t : \"|\" + t)[t.length - 1]) {\n          t += \".\";\n        }\n        var n = (e.currentRootId++).toString(16);\n        return e.appendSuffix(t, n, \"_\");\n      }\n      return e.generateRootId();\n    };\n    e.getRootId = function (e) {\n      var t = e.indexOf(\".\");\n      if (t < 0) {\n        t = e.length;\n      }\n      var n = \"|\" === e[0] ? 1 : 0;\n      return e.substring(n, t);\n    };\n    e.generateRootId = function () {\n      return \"|\" + r.w3cTraceId() + \".\";\n    };\n    e.appendSuffix = function (t, n, o) {\n      if (t.length + n.length < e.requestIdMaxLength) return t + n + o;\n      var i = e.requestIdMaxLength - 9;\n      if (t.length > i)\n        for (; i > 1; --i) {\n          var s = t[i - 1];\n          if (\".\" === s || \"_\" === s) break;\n        }\n      if (i <= 1) return e.generateRootId();\n      for (n = r.randomu32().toString(16); n.length < 8; ) n = \"0\" + n;\n      return t.substring(0, i) + n + \"#\";\n    };\n    e.TAG = \"CorrelationIdManager\";\n    e.correlationIdPrefix = \"cid-v1:\";\n    e.w3cEnabled = !1;\n    e.pendingLookups = {};\n    e.completedLookups = {};\n    e.requestIdMaxLength = 1024;\n    e.currentRootId = r.randomu32();\n    return e;\n  })();\nmodule.exports = i;",
  "9968": "var r;\nr = require(8249);\nrequire(5109);\nr.mode.CTRGladman = (function () {\n  var e = r.lib.BlockCipherMode.extend();\n  function t(e) {\n    if (255 == ((e >> 24) & 255)) {\n      var t = (e >> 16) & 255,\n        n = (e >> 8) & 255,\n        r = 255 & e;\n      if (255 === t) {\n        t = 0;\n        if (255 === n) {\n          n = 0;\n          if (255 === r) {\n            r = 0;\n          } else {\n            ++r;\n          }\n        } else {\n          ++n;\n        }\n      } else {\n        ++t;\n      }\n      e = 0;\n      e += t << 16;\n      e += n << 8;\n      e += r;\n    } else e += 1 << 24;\n    return e;\n  }\n  var n = (e.Encryptor = e.extend({\n    processBlock: function (e, n) {\n      var r = this._cipher,\n        o = r.blockSize,\n        i = this._iv,\n        s = this._counter;\n      if (i) {\n        s = this._counter = i.slice(0);\n        this._iv = undefined;\n      }\n      (function (e) {\n        if (0 === (e[0] = t(e[0]))) {\n          e[1] = t(e[1]);\n        }\n      })(s);\n      var a = s.slice(0);\n      r.encryptBlock(a, 0);\n      for (var c = 0; c < o; c++) e[n + c] ^= a[c];\n    },\n  }));\n  e.Decryptor = n;\n  return e;\n})();\nmodule.exports = r.mode.CTRGladman;",
  "305513": "module.exports = require(\"worker_threads\");",
  "305587": "var r,\n  o,\n  i = undefined !== i ? i : {};\nif (\n  undefined ===\n  (o =\n    \"function\" ==\n    typeof (r = function () {\n      var t,\n        r = {};\n      for (t in i)\n        if (i.hasOwnProperty(t)) {\n          r[t] = i[t];\n        }\n      var o,\n        s,\n        a = [],\n        c = \"./this.program\",\n        l = function (e, t) {\n          throw t;\n        },\n        u = !1,\n        d = !1;\n      u = \"object\" == typeof window;\n      d = \"function\" == typeof importScripts;\n      o =\n        \"object\" == typeof process &&\n        \"object\" == typeof process.versions &&\n        \"string\" == typeof process.versions.node;\n      s = !u && !o && !d;\n      var p,\n        h,\n        f,\n        m,\n        g,\n        _ = \"\";\n      if (o) {\n        _ = d ? require(\"path\").dirname(_) + \"/\" : __dirname + \"/\";\n        p = function (e, t) {\n          if (m) {\n            m = require(\"fs\");\n          }\n          if (g) {\n            g = require(\"path\");\n          }\n          e = g.normalize(e);\n          return m.readFileSync(e, t ? null : \"utf8\");\n        };\n        f = function (e) {\n          var t = p(e, !0);\n          if (t.buffer) {\n            t = new Uint8Array(t);\n          }\n          O(t.buffer);\n          return t;\n        };\n        if (process.argv.length > 1) {\n          c = process.argv[1].replace(/\\\\/g, \"/\");\n        }\n        a = process.argv.slice(2);\n        module.exports = i;\n        l = function (e) {\n          process.exit(e);\n        };\n        i.inspect = function () {\n          return \"[Emscripten Module object]\";\n        };\n      } else {\n        if (s) {\n          if (\"undefined\" != typeof read) {\n            p = function (e) {\n              return read(e);\n            };\n          }\n          f = function (e) {\n            var t;\n            return \"function\" == typeof readbuffer\n              ? new Uint8Array(readbuffer(e))\n              : (O(\"object\" == typeof (t = read(e, \"binary\"))), t);\n          };\n          if (\"undefined\" != typeof scriptArgs) {\n            a = scriptArgs;\n          } else {\n            if (undefined !== arguments) {\n              a = arguments;\n            }\n          }\n          if (\"function\" == typeof quit) {\n            l = function (e) {\n              quit(e);\n            };\n          }\n          if (\"undefined\" != typeof print) {\n            if (\"undefined\" == typeof console) {\n              console = {};\n            }\n            console.log = print;\n            console.warn = console.error =\n              \"undefined\" != typeof printErr ? printErr : print;\n          }\n        } else {\n          if (u || d) {\n            if (d) {\n              _ = self.location.href;\n            } else {\n              if (\"undefined\" != typeof document && document.currentScript) {\n                _ = document.currentScript.src;\n              }\n            }\n            _ =\n              0 !== _.indexOf(\"blob:\")\n                ? _.substr(0, _.lastIndexOf(\"/\") + 1)\n                : \"\";\n            p = function (e) {\n              var t = new XMLHttpRequest();\n              t.open(\"GET\", e, !1);\n              t.send(null);\n              return t.responseText;\n            };\n            if (d) {\n              f = function (e) {\n                var t = new XMLHttpRequest();\n                t.open(\"GET\", e, !1);\n                t.responseType = \"arraybuffer\";\n                t.send(null);\n                return new Uint8Array(t.response);\n              };\n            }\n            h = function (e, t, n) {\n              var r = new XMLHttpRequest();\n              r.open(\"GET\", e, !0);\n              r.responseType = \"arraybuffer\";\n              r.onload = function () {\n                if (200 == r.status || (0 == r.status && r.response)) {\n                  t(r.response);\n                } else {\n                  n();\n                }\n              };\n              r.onerror = n;\n              r.send(null);\n            };\n          }\n        }\n      }\n      if (i.print) {\n        console.log.bind(console);\n      }\n      var y = i.printErr || console.warn.bind(console);\n      for (t in r)\n        if (r.hasOwnProperty(t)) {\n          i[t] = r[t];\n        }\n      r = null;\n      if (i.arguments) {\n        a = i.arguments;\n      }\n      if (i.thisProgram) {\n        c = i.thisProgram;\n      }\n      if (i.quit) {\n        l = i.quit;\n      }\n      var v,\n        b = 16,\n        w = [];\n      function x(e, t) {\n        if (!v) {\n          v = new WeakMap();\n          for (var n = 0; n < J.length; n++) {\n            var r = J.get(n);\n            if (r) {\n              v.set(r, n);\n            }\n          }\n        }\n        if (v.has(e)) return v.get(e);\n        var o = (function () {\n          if (w.length) return w.pop();\n          try {\n            J.grow(1);\n          } catch (e) {\n            if (!(e instanceof RangeError)) throw e;\n            throw \"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.\";\n          }\n          return J.length - 1;\n        })();\n        try {\n          J.set(o, e);\n        } catch (n) {\n          if (!(n instanceof TypeError)) throw n;\n          var i = (function (e, t) {\n            if (\"function\" == typeof WebAssembly.Function) {\n              for (\n                var n = {\n                    i: \"i32\",\n                    j: \"i64\",\n                    f: \"f32\",\n                    d: \"f64\",\n                  },\n                  r = {\n                    parameters: [],\n                    results: \"v\" == t[0] ? [] : [n[t[0]]],\n                  },\n                  o = 1;\n                o < t.length;\n                ++o\n              )\n                r.parameters.push(n[t[o]]);\n              return new WebAssembly.Function(r, e);\n            }\n            var i = [1, 0, 1, 96],\n              s = t.slice(0, 1),\n              a = t.slice(1),\n              c = {\n                i: 127,\n                j: 126,\n                f: 125,\n                d: 124,\n              };\n            for (i.push(a.length), o = 0; o < a.length; ++o) i.push(c[a[o]]);\n            if (\"v\" == s) {\n              i.push(0);\n            } else {\n              i = i.concat([1, c[s]]);\n            }\n            i[1] = i.length - 2;\n            var l = new Uint8Array(\n                [0, 97, 115, 109, 1, 0, 0, 0].concat(\n                  i,\n                  [2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0]\n                )\n              ),\n              u = new WebAssembly.Module(l);\n            return new WebAssembly.Instance(u, {\n              e: {\n                f: e,\n              },\n            }).exports.f;\n          })(e, t);\n          J.set(o, i);\n        }\n        v.set(e, o);\n        return o;\n      }\n      var E,\n        C = function (e) {},\n        S = i.dynamicLibraries || [];\n      if (i.wasmBinary) {\n        E = i.wasmBinary;\n      }\n      var T,\n        k = i.noExitRuntime || !0;\n      function I(e, t, n, r) {\n        switch (\n          (\"*\" === (n = n || \"i8\").charAt(n.length - 1) && (n = \"i32\"), n)\n        ) {\n          case \"i1\":\n          case \"i8\":\n            R[e >> 0] = t;\n            break;\n          case \"i16\":\n            L[e >> 1] = t;\n            break;\n          case \"i32\":\n            $[e >> 2] = t;\n            break;\n          case \"i64\":\n            pe = [\n              t >>> 0,\n              ((de = t),\n              +Math.abs(de) >= 1\n                ? de > 0\n                  ? (0 | Math.min(+Math.floor(de / 4294967296), 4294967295)) >>>\n                    0\n                  : ~~+Math.ceil((de - +(~~de >>> 0)) / 4294967296) >>> 0\n                : 0),\n            ];\n            $[e >> 2] = pe[0];\n            $[(e + 4) >> 2] = pe[1];\n            break;\n          case \"float\":\n            D[e >> 2] = t;\n            break;\n          case \"double\":\n            F[e >> 3] = t;\n            break;\n          default:\n            se(\"invalid type for setValue: \" + n);\n        }\n      }\n      function P(e, t, n) {\n        switch (\n          (\"*\" === (t = t || \"i8\").charAt(t.length - 1) && (t = \"i32\"), t)\n        ) {\n          case \"i1\":\n          case \"i8\":\n            return R[e >> 0];\n          case \"i16\":\n            return L[e >> 1];\n          case \"i32\":\n          case \"i64\":\n            return $[e >> 2];\n          case \"float\":\n            return D[e >> 2];\n          case \"double\":\n            return F[e >> 3];\n          default:\n            se(\"invalid type for getValue: \" + t);\n        }\n        return null;\n      }\n      if (\"object\" != typeof WebAssembly) {\n        se(\"no native wasm support detected\");\n      }\n      var A = !1;\n      function O(e, t) {\n        if (e) {\n          se(\"Assertion failed: \" + t);\n        }\n      }\n      var N,\n        R,\n        M,\n        L,\n        $,\n        D,\n        F,\n        j = 1,\n        q =\n          \"undefined\" != typeof TextDecoder\n            ? new TextDecoder(\"utf8\")\n            : undefined;\n      function B(e, t, n) {\n        for (var r = t + n, o = t; e[o] && !(o >= r); ) ++o;\n        if (o - t > 16 && e.subarray && q) return q.decode(e.subarray(t, o));\n        for (var i = \"\"; t < o; ) {\n          var s = e[t++];\n          if (128 & s) {\n            var a = 63 & e[t++];\n            if (192 != (224 & s)) {\n              var c = 63 & e[t++];\n              if (\n                (s =\n                  224 == (240 & s)\n                    ? ((15 & s) << 12) | (a << 6) | c\n                    : ((7 & s) << 18) | (a << 12) | (c << 6) | (63 & e[t++])) <\n                65536\n              )\n                i += String.fromCharCode(s);\n              else {\n                var l = s - 65536;\n                i += String.fromCharCode(55296 | (l >> 10), 56320 | (1023 & l));\n              }\n            } else i += String.fromCharCode(((31 & s) << 6) | a);\n          } else i += String.fromCharCode(s);\n        }\n        return i;\n      }\n      function U(e, t) {\n        return e ? B(M, e, t) : \"\";\n      }\n      function H(e, t, n, r) {\n        if (!(r > 0)) return 0;\n        for (var o = n, i = n + r - 1, s = 0; s < e.length; ++s) {\n          var a = e.charCodeAt(s);\n          if (a >= 55296 && a <= 57343) {\n            a = (65536 + ((1023 & a) << 10)) | (1023 & e.charCodeAt(++s));\n          }\n          if (a <= 127) {\n            if (n >= i) break;\n            t[n++] = a;\n          } else if (a <= 2047) {\n            if (n + 1 >= i) break;\n            (t[n++] = 192 | (a >> 6)), (t[n++] = 128 | (63 & a));\n          } else if (a <= 65535) {\n            if (n + 2 >= i) break;\n            (t[n++] = 224 | (a >> 12)),\n              (t[n++] = 128 | ((a >> 6) & 63)),\n              (t[n++] = 128 | (63 & a));\n          } else {\n            if (n + 3 >= i) break;\n            (t[n++] = 240 | (a >> 18)),\n              (t[n++] = 128 | ((a >> 12) & 63)),\n              (t[n++] = 128 | ((a >> 6) & 63)),\n              (t[n++] = 128 | (63 & a));\n          }\n        }\n        t[n] = 0;\n        return n - o;\n      }\n      function z(e, t, n) {\n        return H(e, M, t, n);\n      }\n      function G(e) {\n        for (var t = 0, n = 0; n < e.length; ++n) {\n          var r = e.charCodeAt(n);\n          if (r >= 55296 && r <= 57343) {\n            r = (65536 + ((1023 & r) << 10)) | (1023 & e.charCodeAt(++n));\n          }\n          if (r <= 127) {\n            ++t;\n          } else {\n            t += r <= 2047 ? 2 : r <= 65535 ? 3 : 4;\n          }\n        }\n        return t;\n      }\n      function V(e) {\n        var t = G(e) + 1,\n          n = Ve(t);\n        H(e, R, n, t);\n        return n;\n      }\n      function W(e) {\n        N = e;\n        i.HEAP8 = R = new Int8Array(e);\n        i.HEAP16 = L = new Int16Array(e);\n        i.HEAP32 = $ = new Int32Array(e);\n        i.HEAPU8 = M = new Uint8Array(e);\n        i.HEAPU16 = new Uint16Array(e);\n        i.HEAPU32 = new Uint32Array(e);\n        i.HEAPF32 = D = new Float32Array(e);\n        i.HEAPF64 = F = new Float64Array(e);\n      }\n      var K = i.INITIAL_MEMORY || 33554432;\n      if (\n        (T = i.wasmMemory\n          ? i.wasmMemory\n          : new WebAssembly.Memory({\n              initial: K / 65536,\n              maximum: 32768,\n            }))\n      ) {\n        N = T.buffer;\n      }\n      K = N.byteLength;\n      W(N);\n      var J = new WebAssembly.Table({\n          initial: 13,\n          element: \"anyfunc\",\n        }),\n        X = [],\n        Q = [],\n        Y = [],\n        Z = [],\n        ee = !1,\n        te = 0,\n        ne = null,\n        re = null;\n      function oe(e) {\n        te++;\n        if (i.monitorRunDependencies) {\n          i.monitorRunDependencies(te);\n        }\n      }\n      function ie(e) {\n        te--;\n        if (i.monitorRunDependencies) {\n          i.monitorRunDependencies(te);\n        }\n        if (0 == te && (null !== ne && (clearInterval(ne), (ne = null)), re)) {\n          var t = re;\n          (re = null), t();\n        }\n      }\n      function se(e) {\n        throw (\n          (i.onAbort && i.onAbort(e),\n          y((e += \"\")),\n          (A = !0),\n          (e = \"abort(\" + e + \"). Build with -s ASSERTIONS=1 for more info.\"),\n          new WebAssembly.RuntimeError(e))\n        );\n      }\n      i.preloadedImages = {};\n      i.preloadedAudios = {};\n      i.preloadedWasm = {};\n      var ae = \"data:application/octet-stream;base64,\";\n      function ce(e) {\n        return e.startsWith(ae);\n      }\n      function le(e) {\n        return e.startsWith(\"file://\");\n      }\n      var ue,\n        de,\n        pe,\n        he = \"tree-sitter.wasm\";\n      function fe(e) {\n        try {\n          if (e == he && E) return new Uint8Array(E);\n          if (f) return f(e);\n          throw \"both async and sync fetching of the wasm failed\";\n        } catch (e) {\n          se(e);\n        }\n      }\n      if (ce(he)) {\n        ue = he;\n        he = i.locateFile ? i.locateFile(ue, _) : _ + ue;\n      }\n      var me = {},\n        ge = {\n          get: function (e, t) {\n            if (me[t]) {\n              me[t] = new WebAssembly.Global({\n                value: \"i32\",\n                mutable: !0,\n              });\n            }\n            return me[t];\n          },\n        };\n      function _e(e) {\n        for (; e.length > 0; ) {\n          var t = e.shift();\n          if (\"function\" != typeof t) {\n            var n = t.func;\n            if (\"number\" == typeof n) {\n              if (undefined === t.arg) {\n                J.get(n)();\n              } else {\n                J.get(n)(t.arg);\n              }\n            } else {\n              n(undefined === t.arg ? null : t.arg);\n            }\n          } else t(i);\n        }\n      }\n      function ye(e) {\n        var t = 0;\n        function n() {\n          for (var n = 0, r = 1; ; ) {\n            var o = e[t++];\n            n += (127 & o) * r;\n            r *= 128;\n            if (!(128 & o)) break;\n          }\n          return n;\n        }\n        if (e instanceof WebAssembly.Module) {\n          var r = WebAssembly.Module.customSections(e, \"dylink\");\n          O(0 != r.length, \"need dylink section\");\n          e = new Int8Array(r[0]);\n        } else {\n          O(\n            1836278016 ==\n              new Uint32Array(new Uint8Array(e.subarray(0, 24)).buffer)[0],\n            \"need to see wasm magic number\"\n          );\n          O(0 === e[8], \"need the dylink section to be first\");\n          t = 9;\n          n();\n          O(6 === e[t]);\n          O(e[++t] === \"d\".charCodeAt(0));\n          O(e[++t] === \"y\".charCodeAt(0));\n          O(e[++t] === \"l\".charCodeAt(0));\n          O(e[++t] === \"i\".charCodeAt(0));\n          O(e[++t] === \"n\".charCodeAt(0));\n          O(e[++t] === \"k\".charCodeAt(0));\n          t++;\n        }\n        var o = {};\n        o.memorySize = n();\n        o.memoryAlign = n();\n        o.tableSize = n();\n        o.tableAlign = n();\n        var i = n();\n        o.neededDynlibs = [];\n        for (var s = 0; s < i; ++s) {\n          var a = n(),\n            c = e.subarray(t, t + a);\n          t += a;\n          var l = B(c, 0);\n          o.neededDynlibs.push(l);\n        }\n        return o;\n      }\n      var ve = 0;\n      function be() {\n        return k || ve > 0;\n      }\n      var we = {\n        nextHandle: 1,\n        loadedLibs: {},\n        loadedLibNames: {},\n      };\n      function xe(e, t, n) {\n        return e.includes(\"j\")\n          ? (function (e, t, n) {\n              var r = i[\"dynCall_\" + e];\n              return n && n.length\n                ? r.apply(null, [t].concat(n))\n                : r.call(null, t);\n            })(e, t, n)\n          : J.get(t).apply(null, n);\n      }\n      var Ee = 5250832;\n      function Ce(e) {\n        return [\n          \"__cpp_exception\",\n          \"__wasm_apply_data_relocs\",\n          \"__dso_handle\",\n          \"__set_stack_limits\",\n        ].includes(e);\n      }\n      function Se(e, t) {\n        var n = {};\n        for (var r in e) {\n          var o = e[r];\n          if (\"object\" == typeof o) {\n            o = o.value;\n          }\n          if (\"number\" == typeof o) {\n            o += t;\n          }\n          n[r] = o;\n        }\n        (function (e) {\n          for (var t in e)\n            if (!Ce(t)) {\n              var n = !1,\n                r = e[t];\n              if (t.startsWith(\"orig$\")) {\n                t = t.split(\"$\")[1];\n                n = !0;\n              }\n              if (me[t]) {\n                me[t] = new WebAssembly.Global({\n                  value: \"i32\",\n                  mutable: !0,\n                });\n              }\n              if (n || 0 == me[t].value) {\n                if (\"function\" == typeof r) {\n                  me[t].value = x(r);\n                } else {\n                  if (\"number\" == typeof r) {\n                    me[t].value = r;\n                  } else {\n                    y(\"unhandled export type for `\" + t + \"`: \" + typeof r);\n                  }\n                }\n              }\n            }\n        })(n);\n        return n;\n      }\n      function Te(e) {\n        return 0 == e.indexOf(\"dynCall_\") ||\n          [\"stackAlloc\", \"stackSave\", \"stackRestore\"].includes(e)\n          ? e\n          : \"_\" + e;\n      }\n      function ke(e, t) {\n        var n, r;\n        if (t) {\n          n = i.asm[\"orig$\" + e];\n        }\n        if (n) {\n          n = i.asm[e];\n        }\n        if (!n && t) {\n          n = i[\"_orig$\" + e];\n        }\n        if (n) {\n          n = i[Te(e)];\n        }\n        if (!n && e.startsWith(\"invoke_\")) {\n          r = e.split(\"_\")[1];\n          n = function () {\n            var e = ze();\n            try {\n              return xe(\n                r,\n                arguments[0],\n                Array.prototype.slice.call(arguments, 1)\n              );\n            } catch (t) {\n              Ge(e);\n              if (t !== t + 0 && \"longjmp\" !== t) throw t;\n              We(1, 0);\n            }\n          };\n        }\n        return n;\n      }\n      function Ie(e, t) {\n        var n = ye(e);\n        function r() {\n          var r = Math.pow(2, n.memoryAlign);\n          r = Math.max(r, b);\n          var o,\n            i,\n            s,\n            a =\n              ((o = (function (e) {\n                if (ee) return Ue(e);\n                var t = Ee,\n                  n = (t + e + 15) & -16;\n                Ee = n;\n                me.__heap_base.value = n;\n                return t;\n              })(n.memorySize + r)),\n              (i = r) || (i = b),\n              Math.ceil(o / i) * i),\n            c = J.length;\n          J.grow(n.tableSize);\n          for (var l = a; l < a + n.memorySize; l++) R[l] = 0;\n          for (l = c; l < c + n.tableSize; l++) J.set(l, null);\n          var u = new Proxy(Be, {\n              get: function (e, t) {\n                switch (t) {\n                  case \"__memory_base\":\n                    return a;\n                  case \"__table_base\":\n                    return c;\n                }\n                return t in e\n                  ? e[t]\n                  : (e[t] = function () {\n                      if (n) {\n                        n = (function (e) {\n                          var t = ke(e, !1);\n                          if (t) {\n                            t = s[e];\n                          }\n                          return t;\n                        })(t);\n                      }\n                      return n.apply(null, arguments);\n                    });\n                var n;\n              },\n            }),\n            d = {\n              \"GOT.mem\": new Proxy(Be, ge),\n              \"GOT.func\": new Proxy(Be, ge),\n              env: u,\n              wasi_snapshot_preview1: u,\n            };\n          function p(e) {\n            for (var r = 0; r < n.tableSize; r++) {\n              var o = J.get(c + r);\n              if (o) {\n                v.set(o, c + r);\n              }\n            }\n            s = Se(e.exports, a);\n            if (t.allowUndefined) {\n              Oe();\n            }\n            var i = s.__wasm_call_ctors;\n            if (i) {\n              i = s.__post_instantiate;\n            }\n            if (i) {\n              if (ee) {\n                i();\n              } else {\n                Q.push(i);\n              }\n            }\n            return s;\n          }\n          if (t.loadAsync) {\n            if (e instanceof WebAssembly.Module) {\n              var h = new WebAssembly.Instance(e, d);\n              return Promise.resolve(p(h));\n            }\n            return WebAssembly.instantiate(e, d).then(function (e) {\n              return p(e.instance);\n            });\n          }\n          var f =\n            e instanceof WebAssembly.Module ? e : new WebAssembly.Module(e);\n          return p((h = new WebAssembly.Instance(f, d)));\n        }\n        return t.loadAsync\n          ? n.neededDynlibs\n              .reduce(function (e, n) {\n                return e.then(function () {\n                  return Ae(n, t);\n                });\n              }, Promise.resolve())\n              .then(function () {\n                return r();\n              })\n          : (n.neededDynlibs.forEach(function (e) {\n              Ae(e, t);\n            }),\n            r());\n      }\n      function Pe(e, t) {\n        for (var n in e)\n          if (e.hasOwnProperty(n)) {\n            if (Be.hasOwnProperty(n)) {\n              Be[n] = e[n];\n            }\n            var r = Te(n);\n            if (i.hasOwnProperty(r)) {\n              i[r] = e[n];\n            }\n          }\n      }\n      function Ae(e, t) {\n        if (\"__main__\" != e || we.loadedLibNames[e]) {\n          we.loadedLibs[-1] = {\n            refcount: 1 / 0,\n            name: \"__main__\",\n            module: i.asm,\n            global: !0,\n          };\n          we.loadedLibNames.__main__ = -1;\n        }\n        t = t || {\n          global: !0,\n          nodelete: !0,\n        };\n        var n,\n          r = we.loadedLibNames[e];\n        if (r) {\n          n = we.loadedLibs[r];\n          if (t.global && !n.global) {\n            n.global = !0;\n            if (\"loading\" !== n.module) {\n              Pe(n.module);\n            }\n          }\n          if (t.nodelete && n.refcount !== 1 / 0) {\n            n.refcount = 1 / 0;\n          }\n          n.refcount++;\n          return t.loadAsync ? Promise.resolve(r) : r;\n        }\n        function o(e) {\n          if (t.fs) {\n            var n = t.fs.readFile(e, {\n              encoding: \"binary\",\n            });\n            if (n instanceof Uint8Array) {\n              n = new Uint8Array(n);\n            }\n            return t.loadAsync ? Promise.resolve(n) : n;\n          }\n          return t.loadAsync\n            ? ((r = e),\n              fetch(r, {\n                credentials: \"same-origin\",\n              })\n                .then(function (e) {\n                  if (!e.ok) throw \"failed to load binary file at '\" + r + \"'\";\n                  return e.arrayBuffer();\n                })\n                .then(function (e) {\n                  return new Uint8Array(e);\n                }))\n            : f(e);\n          var r;\n        }\n        function s() {\n          if (\n            undefined !== i.preloadedWasm &&\n            undefined !== i.preloadedWasm[e]\n          ) {\n            var n = i.preloadedWasm[e];\n            return t.loadAsync ? Promise.resolve(n) : n;\n          }\n          return t.loadAsync\n            ? o(e).then(function (e) {\n                return Ie(e, t);\n              })\n            : Ie(o(e), t);\n        }\n        function a(e) {\n          if (n.global) {\n            Pe(e);\n          }\n          n.module = e;\n        }\n        r = we.nextHandle++;\n        n = {\n          refcount: t.nodelete ? 1 / 0 : 1,\n          name: e,\n          module: \"loading\",\n          global: t.global,\n        };\n        we.loadedLibNames[e] = r;\n        we.loadedLibs[r] = n;\n        return t.loadAsync\n          ? s().then(function (e) {\n              a(e);\n              return r;\n            })\n          : (a(s()), r);\n      }\n      function Oe() {\n        for (var e in me)\n          if (0 == me[e].value) {\n            var t = ke(e, !0);\n            if (\"function\" == typeof t) {\n              me[e].value = x(t, t.sig);\n            } else {\n              if (\"number\" == typeof t) {\n                me[e].value = t;\n              } else {\n                O(!1, \"bad export type for `\" + e + \"`: \" + typeof t);\n              }\n            }\n          }\n      }\n      i.___heap_base = Ee;\n      var Ne,\n        Re = new WebAssembly.Global(\n          {\n            value: \"i32\",\n            mutable: !0,\n          },\n          5250832\n        );\n      function Me() {\n        se();\n      }\n      i._abort = Me;\n      Me.sig = \"v\";\n      Ne = o\n        ? function () {\n            var e = process.hrtime();\n            return 1e3 * e[0] + e[1] / 1e6;\n          }\n        : \"undefined\" != typeof dateNow\n        ? dateNow\n        : function () {\n            return performance.now();\n          };\n      var Le = !0;\n      function $e(e, t) {\n        var n;\n        if (0 === e) n = Date.now();\n        else {\n          if ((1 !== e && 4 !== e) || !Le) {\n            $[He() >> 2] = 28;\n            return -1;\n          }\n          n = Ne();\n        }\n        $[t >> 2] = (n / 1e3) | 0;\n        $[(t + 4) >> 2] = ((n % 1e3) * 1e3 * 1e3) | 0;\n        return 0;\n      }\n      function De(e) {\n        try {\n          T.grow((e - N.byteLength + 65535) >>> 16);\n          W(T.buffer);\n          return 1;\n        } catch (e) {}\n      }\n      function Fe(e) {\n        Qe(e);\n      }\n      function je(e) {\n        C(e);\n      }\n      $e.sig = \"iii\";\n      Fe.sig = \"vi\";\n      je.sig = \"vi\";\n      var qe,\n        Be = {\n          __heap_base: Ee,\n          __indirect_function_table: J,\n          __memory_base: 1024,\n          __stack_pointer: Re,\n          __table_base: 1,\n          abort: Me,\n          clock_gettime: $e,\n          emscripten_memcpy_big: function (e, t, n) {\n            M.copyWithin(e, t, t + n);\n          },\n          emscripten_resize_heap: function (e) {\n            var t,\n              n = M.length;\n            if ((e >>>= 0) > 2147483648) return !1;\n            for (var r = 1; r <= 4; r *= 2) {\n              var o = n * (1 + 0.2 / r);\n              o = Math.min(o, e + 100663296);\n              if (\n                De(\n                  Math.min(\n                    2147483648,\n                    ((t = Math.max(e, o)) % 65536 > 0 &&\n                      (t += 65536 - (t % 65536)),\n                    t)\n                  )\n                )\n              )\n                return !0;\n            }\n            return !1;\n          },\n          exit: Fe,\n          memory: T,\n          setTempRet0: je,\n          tree_sitter_log_callback: function (e, t) {\n            if (ft) {\n              const n = U(t);\n              ft(n, 0 !== e);\n            }\n          },\n          tree_sitter_parse_callback: function (e, t, n, r, o) {\n            var i = ht(t, {\n              row: n,\n              column: r,\n            });\n            if (\"string\" == typeof i) {\n              I(o, i.length, \"i32\");\n              (function (e, t, n) {\n                if (undefined === n) {\n                  n = 2147483647;\n                }\n                if (n < 2) return 0;\n                for (\n                  var r = (n -= 2) < 2 * e.length ? n / 2 : e.length, o = 0;\n                  o < r;\n                  ++o\n                ) {\n                  var i = e.charCodeAt(o);\n                  L[t >> 1] = i;\n                  t += 2;\n                }\n                L[t >> 1] = 0;\n              })(i, e, 10240);\n            } else {\n              I(o, 0, \"i32\");\n            }\n          },\n        },\n        Ue =\n          ((function () {\n            var e = {\n              env: Be,\n              wasi_snapshot_preview1: Be,\n              \"GOT.mem\": new Proxy(Be, ge),\n              \"GOT.func\": new Proxy(Be, ge),\n            };\n            function t(e, t) {\n              var n = e.exports;\n              n = Se(n, 1024);\n              i.asm = n;\n              var r,\n                o = ye(t);\n              if (o.neededDynlibs) {\n                S = o.neededDynlibs.concat(S);\n              }\n              r = i.asm.__wasm_call_ctors;\n              Q.unshift(r);\n              ie();\n            }\n            function n(e) {\n              t(e.instance, e.module);\n            }\n            function r(t) {\n              return (function () {\n                if (!E && (u || d)) {\n                  if (\"function\" == typeof fetch && !le(he))\n                    return fetch(he, {\n                      credentials: \"same-origin\",\n                    })\n                      .then(function (e) {\n                        if (!e.ok)\n                          throw (\n                            \"failed to load wasm binary file at '\" + he + \"'\"\n                          );\n                        return e.arrayBuffer();\n                      })\n                      .catch(function () {\n                        return fe(he);\n                      });\n                  if (h)\n                    return new Promise(function (e, t) {\n                      h(\n                        he,\n                        function (t) {\n                          e(new Uint8Array(t));\n                        },\n                        t\n                      );\n                    });\n                }\n                return Promise.resolve().then(function () {\n                  return fe(he);\n                });\n              })()\n                .then(function (t) {\n                  return WebAssembly.instantiate(t, e);\n                })\n                .then(t, function (e) {\n                  y(\"failed to asynchronously prepare wasm: \" + e);\n                  se(e);\n                });\n            }\n            oe();\n            if (i.instantiateWasm)\n              try {\n                return i.instantiateWasm(e, t);\n              } catch (e) {\n                return (\n                  y(\"Module.instantiateWasm callback failed with error: \" + e),\n                  !1\n                );\n              }\n            if (\n              E ||\n              \"function\" != typeof WebAssembly.instantiateStreaming ||\n              ce(he) ||\n              le(he) ||\n              \"function\" != typeof fetch\n            ) {\n              r(n);\n            } else {\n              fetch(he, {\n                credentials: \"same-origin\",\n              }).then(function (t) {\n                return WebAssembly.instantiateStreaming(t, e).then(\n                  n,\n                  function (e) {\n                    y(\"wasm streaming compile failed: \" + e);\n                    y(\"falling back to ArrayBuffer instantiation\");\n                    return r(n);\n                  }\n                );\n              });\n            }\n          })(),\n          (i.___wasm_call_ctors = function () {\n            return (i.___wasm_call_ctors = i.asm.__wasm_call_ctors).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._malloc = function () {\n            return (Ue = i._malloc = i.asm.malloc).apply(null, arguments);\n          })),\n        He =\n          ((i._ts_language_symbol_count = function () {\n            return (i._ts_language_symbol_count =\n              i.asm.ts_language_symbol_count).apply(null, arguments);\n          }),\n          (i._ts_language_version = function () {\n            return (i._ts_language_version = i.asm.ts_language_version).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_language_field_count = function () {\n            return (i._ts_language_field_count =\n              i.asm.ts_language_field_count).apply(null, arguments);\n          }),\n          (i._ts_language_symbol_name = function () {\n            return (i._ts_language_symbol_name =\n              i.asm.ts_language_symbol_name).apply(null, arguments);\n          }),\n          (i._ts_language_symbol_for_name = function () {\n            return (i._ts_language_symbol_for_name =\n              i.asm.ts_language_symbol_for_name).apply(null, arguments);\n          }),\n          (i._ts_language_symbol_type = function () {\n            return (i._ts_language_symbol_type =\n              i.asm.ts_language_symbol_type).apply(null, arguments);\n          }),\n          (i._ts_language_field_name_for_id = function () {\n            return (i._ts_language_field_name_for_id =\n              i.asm.ts_language_field_name_for_id).apply(null, arguments);\n          }),\n          (i._memcpy = function () {\n            return (i._memcpy = i.asm.memcpy).apply(null, arguments);\n          }),\n          (i._free = function () {\n            return (i._free = i.asm.free).apply(null, arguments);\n          }),\n          (i._calloc = function () {\n            return (i._calloc = i.asm.calloc).apply(null, arguments);\n          }),\n          (i._ts_parser_delete = function () {\n            return (i._ts_parser_delete = i.asm.ts_parser_delete).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_parser_reset = function () {\n            return (i._ts_parser_reset = i.asm.ts_parser_reset).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_parser_set_language = function () {\n            return (i._ts_parser_set_language =\n              i.asm.ts_parser_set_language).apply(null, arguments);\n          }),\n          (i._ts_parser_timeout_micros = function () {\n            return (i._ts_parser_timeout_micros =\n              i.asm.ts_parser_timeout_micros).apply(null, arguments);\n          }),\n          (i._ts_parser_set_timeout_micros = function () {\n            return (i._ts_parser_set_timeout_micros =\n              i.asm.ts_parser_set_timeout_micros).apply(null, arguments);\n          }),\n          (i._memcmp = function () {\n            return (i._memcmp = i.asm.memcmp).apply(null, arguments);\n          }),\n          (i._ts_query_new = function () {\n            return (i._ts_query_new = i.asm.ts_query_new).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_query_delete = function () {\n            return (i._ts_query_delete = i.asm.ts_query_delete).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._iswspace = function () {\n            return (i._iswspace = i.asm.iswspace).apply(null, arguments);\n          }),\n          (i._iswalnum = function () {\n            return (i._iswalnum = i.asm.iswalnum).apply(null, arguments);\n          }),\n          (i._ts_query_pattern_count = function () {\n            return (i._ts_query_pattern_count =\n              i.asm.ts_query_pattern_count).apply(null, arguments);\n          }),\n          (i._ts_query_capture_count = function () {\n            return (i._ts_query_capture_count =\n              i.asm.ts_query_capture_count).apply(null, arguments);\n          }),\n          (i._ts_query_string_count = function () {\n            return (i._ts_query_string_count =\n              i.asm.ts_query_string_count).apply(null, arguments);\n          }),\n          (i._ts_query_capture_name_for_id = function () {\n            return (i._ts_query_capture_name_for_id =\n              i.asm.ts_query_capture_name_for_id).apply(null, arguments);\n          }),\n          (i._ts_query_string_value_for_id = function () {\n            return (i._ts_query_string_value_for_id =\n              i.asm.ts_query_string_value_for_id).apply(null, arguments);\n          }),\n          (i._ts_query_predicates_for_pattern = function () {\n            return (i._ts_query_predicates_for_pattern =\n              i.asm.ts_query_predicates_for_pattern).apply(null, arguments);\n          }),\n          (i._ts_tree_copy = function () {\n            return (i._ts_tree_copy = i.asm.ts_tree_copy).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_tree_delete = function () {\n            return (i._ts_tree_delete = i.asm.ts_tree_delete).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_init = function () {\n            return (i._ts_init = i.asm.ts_init).apply(null, arguments);\n          }),\n          (i._ts_parser_new_wasm = function () {\n            return (i._ts_parser_new_wasm = i.asm.ts_parser_new_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_parser_enable_logger_wasm = function () {\n            return (i._ts_parser_enable_logger_wasm =\n              i.asm.ts_parser_enable_logger_wasm).apply(null, arguments);\n          }),\n          (i._ts_parser_parse_wasm = function () {\n            return (i._ts_parser_parse_wasm = i.asm.ts_parser_parse_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_language_type_is_named_wasm = function () {\n            return (i._ts_language_type_is_named_wasm =\n              i.asm.ts_language_type_is_named_wasm).apply(null, arguments);\n          }),\n          (i._ts_language_type_is_visible_wasm = function () {\n            return (i._ts_language_type_is_visible_wasm =\n              i.asm.ts_language_type_is_visible_wasm).apply(null, arguments);\n          }),\n          (i._ts_tree_root_node_wasm = function () {\n            return (i._ts_tree_root_node_wasm =\n              i.asm.ts_tree_root_node_wasm).apply(null, arguments);\n          }),\n          (i._ts_tree_edit_wasm = function () {\n            return (i._ts_tree_edit_wasm = i.asm.ts_tree_edit_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_tree_get_changed_ranges_wasm = function () {\n            return (i._ts_tree_get_changed_ranges_wasm =\n              i.asm.ts_tree_get_changed_ranges_wasm).apply(null, arguments);\n          }),\n          (i._ts_tree_cursor_new_wasm = function () {\n            return (i._ts_tree_cursor_new_wasm =\n              i.asm.ts_tree_cursor_new_wasm).apply(null, arguments);\n          }),\n          (i._ts_tree_cursor_delete_wasm = function () {\n            return (i._ts_tree_cursor_delete_wasm =\n              i.asm.ts_tree_cursor_delete_wasm).apply(null, arguments);\n          }),\n          (i._ts_tree_cursor_reset_wasm = function () {\n            return (i._ts_tree_cursor_reset_wasm =\n              i.asm.ts_tree_cursor_reset_wasm).apply(null, arguments);\n          }),\n          (i._ts_tree_cursor_goto_first_child_wasm = function () {\n            return (i._ts_tree_cursor_goto_first_child_wasm =\n              i.asm.ts_tree_cursor_goto_first_child_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_tree_cursor_goto_next_sibling_wasm = function () {\n            return (i._ts_tree_cursor_goto_next_sibling_wasm =\n              i.asm.ts_tree_cursor_goto_next_sibling_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_tree_cursor_goto_parent_wasm = function () {\n            return (i._ts_tree_cursor_goto_parent_wasm =\n              i.asm.ts_tree_cursor_goto_parent_wasm).apply(null, arguments);\n          }),\n          (i._ts_tree_cursor_current_node_type_id_wasm = function () {\n            return (i._ts_tree_cursor_current_node_type_id_wasm =\n              i.asm.ts_tree_cursor_current_node_type_id_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_tree_cursor_current_node_is_named_wasm = function () {\n            return (i._ts_tree_cursor_current_node_is_named_wasm =\n              i.asm.ts_tree_cursor_current_node_is_named_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_tree_cursor_current_node_is_missing_wasm = function () {\n            return (i._ts_tree_cursor_current_node_is_missing_wasm =\n              i.asm.ts_tree_cursor_current_node_is_missing_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_tree_cursor_current_node_id_wasm = function () {\n            return (i._ts_tree_cursor_current_node_id_wasm =\n              i.asm.ts_tree_cursor_current_node_id_wasm).apply(null, arguments);\n          }),\n          (i._ts_tree_cursor_start_position_wasm = function () {\n            return (i._ts_tree_cursor_start_position_wasm =\n              i.asm.ts_tree_cursor_start_position_wasm).apply(null, arguments);\n          }),\n          (i._ts_tree_cursor_end_position_wasm = function () {\n            return (i._ts_tree_cursor_end_position_wasm =\n              i.asm.ts_tree_cursor_end_position_wasm).apply(null, arguments);\n          }),\n          (i._ts_tree_cursor_start_index_wasm = function () {\n            return (i._ts_tree_cursor_start_index_wasm =\n              i.asm.ts_tree_cursor_start_index_wasm).apply(null, arguments);\n          }),\n          (i._ts_tree_cursor_end_index_wasm = function () {\n            return (i._ts_tree_cursor_end_index_wasm =\n              i.asm.ts_tree_cursor_end_index_wasm).apply(null, arguments);\n          }),\n          (i._ts_tree_cursor_current_field_id_wasm = function () {\n            return (i._ts_tree_cursor_current_field_id_wasm =\n              i.asm.ts_tree_cursor_current_field_id_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_tree_cursor_current_node_wasm = function () {\n            return (i._ts_tree_cursor_current_node_wasm =\n              i.asm.ts_tree_cursor_current_node_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_symbol_wasm = function () {\n            return (i._ts_node_symbol_wasm = i.asm.ts_node_symbol_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_node_child_count_wasm = function () {\n            return (i._ts_node_child_count_wasm =\n              i.asm.ts_node_child_count_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_named_child_count_wasm = function () {\n            return (i._ts_node_named_child_count_wasm =\n              i.asm.ts_node_named_child_count_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_child_wasm = function () {\n            return (i._ts_node_child_wasm = i.asm.ts_node_child_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_node_named_child_wasm = function () {\n            return (i._ts_node_named_child_wasm =\n              i.asm.ts_node_named_child_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_child_by_field_id_wasm = function () {\n            return (i._ts_node_child_by_field_id_wasm =\n              i.asm.ts_node_child_by_field_id_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_next_sibling_wasm = function () {\n            return (i._ts_node_next_sibling_wasm =\n              i.asm.ts_node_next_sibling_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_prev_sibling_wasm = function () {\n            return (i._ts_node_prev_sibling_wasm =\n              i.asm.ts_node_prev_sibling_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_next_named_sibling_wasm = function () {\n            return (i._ts_node_next_named_sibling_wasm =\n              i.asm.ts_node_next_named_sibling_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_prev_named_sibling_wasm = function () {\n            return (i._ts_node_prev_named_sibling_wasm =\n              i.asm.ts_node_prev_named_sibling_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_parent_wasm = function () {\n            return (i._ts_node_parent_wasm = i.asm.ts_node_parent_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_node_descendant_for_index_wasm = function () {\n            return (i._ts_node_descendant_for_index_wasm =\n              i.asm.ts_node_descendant_for_index_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_named_descendant_for_index_wasm = function () {\n            return (i._ts_node_named_descendant_for_index_wasm =\n              i.asm.ts_node_named_descendant_for_index_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_node_descendant_for_position_wasm = function () {\n            return (i._ts_node_descendant_for_position_wasm =\n              i.asm.ts_node_descendant_for_position_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_node_named_descendant_for_position_wasm = function () {\n            return (i._ts_node_named_descendant_for_position_wasm =\n              i.asm.ts_node_named_descendant_for_position_wasm).apply(\n              null,\n              arguments\n            );\n          }),\n          (i._ts_node_start_point_wasm = function () {\n            return (i._ts_node_start_point_wasm =\n              i.asm.ts_node_start_point_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_end_point_wasm = function () {\n            return (i._ts_node_end_point_wasm =\n              i.asm.ts_node_end_point_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_start_index_wasm = function () {\n            return (i._ts_node_start_index_wasm =\n              i.asm.ts_node_start_index_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_end_index_wasm = function () {\n            return (i._ts_node_end_index_wasm =\n              i.asm.ts_node_end_index_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_to_string_wasm = function () {\n            return (i._ts_node_to_string_wasm =\n              i.asm.ts_node_to_string_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_children_wasm = function () {\n            return (i._ts_node_children_wasm =\n              i.asm.ts_node_children_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_named_children_wasm = function () {\n            return (i._ts_node_named_children_wasm =\n              i.asm.ts_node_named_children_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_descendants_of_type_wasm = function () {\n            return (i._ts_node_descendants_of_type_wasm =\n              i.asm.ts_node_descendants_of_type_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_is_named_wasm = function () {\n            return (i._ts_node_is_named_wasm =\n              i.asm.ts_node_is_named_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_has_changes_wasm = function () {\n            return (i._ts_node_has_changes_wasm =\n              i.asm.ts_node_has_changes_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_has_error_wasm = function () {\n            return (i._ts_node_has_error_wasm =\n              i.asm.ts_node_has_error_wasm).apply(null, arguments);\n          }),\n          (i._ts_node_is_missing_wasm = function () {\n            return (i._ts_node_is_missing_wasm =\n              i.asm.ts_node_is_missing_wasm).apply(null, arguments);\n          }),\n          (i._ts_query_matches_wasm = function () {\n            return (i._ts_query_matches_wasm =\n              i.asm.ts_query_matches_wasm).apply(null, arguments);\n          }),\n          (i._ts_query_captures_wasm = function () {\n            return (i._ts_query_captures_wasm =\n              i.asm.ts_query_captures_wasm).apply(null, arguments);\n          }),\n          (i._iswalpha = function () {\n            return (i._iswalpha = i.asm.iswalpha).apply(null, arguments);\n          }),\n          (i._iswdigit = function () {\n            return (i._iswdigit = i.asm.iswdigit).apply(null, arguments);\n          }),\n          (i._iswlower = function () {\n            return (i._iswlower = i.asm.iswlower).apply(null, arguments);\n          }),\n          (i._towupper = function () {\n            return (i._towupper = i.asm.towupper).apply(null, arguments);\n          }),\n          (i._memchr = function () {\n            return (i._memchr = i.asm.memchr).apply(null, arguments);\n          }),\n          (i.___errno_location = function () {\n            return (He = i.___errno_location = i.asm.__errno_location).apply(\n              null,\n              arguments\n            );\n          })),\n        ze =\n          ((i._strlen = function () {\n            return (i._strlen = i.asm.strlen).apply(null, arguments);\n          }),\n          (i.stackSave = function () {\n            return (ze = i.stackSave = i.asm.stackSave).apply(null, arguments);\n          })),\n        Ge = (i.stackRestore = function () {\n          return (Ge = i.stackRestore = i.asm.stackRestore).apply(\n            null,\n            arguments\n          );\n        }),\n        Ve = (i.stackAlloc = function () {\n          return (Ve = i.stackAlloc = i.asm.stackAlloc).apply(null, arguments);\n        }),\n        We = (i._setThrew = function () {\n          return (We = i._setThrew = i.asm.setThrew).apply(null, arguments);\n        });\n      function Ke(e) {\n        this.name = \"ExitStatus\";\n        this.message = \"Program terminated with exit(\" + e + \")\";\n        this.status = e;\n      }\n      i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm =\n        function () {\n          return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm =\n            i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm).apply(\n            null,\n            arguments\n          );\n        };\n      i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev =\n        function () {\n          return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev =\n            i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev).apply(\n            null,\n            arguments\n          );\n        };\n      i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm =\n        function () {\n          return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm =\n            i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm).apply(\n            null,\n            arguments\n          );\n        };\n      i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm =\n        function () {\n          return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm =\n            i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm).apply(\n            null,\n            arguments\n          );\n        };\n      i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc =\n        function () {\n          return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc =\n            i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc).apply(\n            null,\n            arguments\n          );\n        };\n      i.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm =\n        function () {\n          return (i.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm =\n            i.asm._ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm).apply(\n            null,\n            arguments\n          );\n        };\n      i.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev =\n        function () {\n          return (i.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev =\n            i.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev).apply(\n            null,\n            arguments\n          );\n        };\n      i.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw =\n        function () {\n          return (i.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw =\n            i.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw).apply(\n            null,\n            arguments\n          );\n        };\n      i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_ =\n        function () {\n          return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_ =\n            i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_).apply(\n            null,\n            arguments\n          );\n        };\n      i.__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv =\n        function () {\n          return (i.__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv =\n            i.asm._ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv).apply(\n            null,\n            arguments\n          );\n        };\n      i.__Znwm = function () {\n        return (i.__Znwm = i.asm._Znwm).apply(null, arguments);\n      };\n      i.__ZdlPv = function () {\n        return (i.__ZdlPv = i.asm._ZdlPv).apply(null, arguments);\n      };\n      i._orig$ts_parser_timeout_micros = function () {\n        return (i._orig$ts_parser_timeout_micros =\n          i.asm.orig$ts_parser_timeout_micros).apply(null, arguments);\n      };\n      i._orig$ts_parser_set_timeout_micros = function () {\n        return (i._orig$ts_parser_set_timeout_micros =\n          i.asm.orig$ts_parser_set_timeout_micros).apply(null, arguments);\n      };\n      i._TRANSFER_BUFFER = 7296;\n      i.___THREW__ = 7932;\n      i.___threwValue = 7936;\n      i.___cxa_new_handler = 7928;\n      i.allocate = function (e, t) {\n        var n;\n        n = t == j ? Ve(e.length) : Ue(e.length);\n        if (e.subarray || e.slice) {\n          M.set(e, n);\n        } else {\n          M.set(new Uint8Array(e), n);\n        }\n        return n;\n      };\n      re = function e() {\n        if (qe) {\n          Xe();\n        }\n        if (qe) {\n          re = e;\n        }\n      };\n      var Je = !1;\n      function Xe(e) {\n        function t() {\n          if (qe) {\n            qe = !0;\n            i.calledRun = !0;\n            if (A) {\n              ee = !0;\n              _e(Q);\n              _e(Y);\n              if (i.onRuntimeInitialized) {\n                i.onRuntimeInitialized();\n              }\n              if (Ye) {\n                (function (e) {\n                  var t = i._main;\n                  if (t) {\n                    var n = (e = e || []).length + 1,\n                      r = Ve(4 * (n + 1));\n                    $[r >> 2] = V(c);\n                    for (var o = 1; o < n; o++) $[(r >> 2) + o] = V(e[o - 1]);\n                    $[(r >> 2) + n] = 0;\n                    try {\n                      Qe(t(n, r), !0);\n                    } catch (e) {\n                      if (e instanceof Ke) return;\n                      if (\"unwind\" == e) return;\n                      var s = e;\n                      if (e && \"object\" == typeof e && e.stack) {\n                        s = [e, e.stack];\n                      }\n                      y(\"exception thrown: \" + s);\n                      l(1, e);\n                    }\n                  }\n                })(e);\n              }\n              (function () {\n                if (i.postRun)\n                  for (\n                    \"function\" == typeof i.postRun && (i.postRun = [i.postRun]);\n                    i.postRun.length;\n\n                  ) {\n                    e = i.postRun.shift();\n                    Z.unshift(e);\n                  }\n                var e;\n                _e(Z);\n              })();\n            }\n          }\n        }\n        e = e || a;\n        if (\n          te > 0 ||\n          (!Je &&\n            ((function () {\n              if (S.length) {\n                if (!f) {\n                  oe();\n                  return void S.reduce(function (e, t) {\n                    return e.then(function () {\n                      return Ae(t, {\n                        loadAsync: !0,\n                        global: !0,\n                        nodelete: !0,\n                        allowUndefined: !0,\n                      });\n                    });\n                  }, Promise.resolve()).then(function () {\n                    ie();\n                    Oe();\n                  });\n                }\n                S.forEach(function (e) {\n                  Ae(e, {\n                    global: !0,\n                    nodelete: !0,\n                    allowUndefined: !0,\n                  });\n                });\n                Oe();\n              } else Oe();\n            })(),\n            (Je = !0),\n            te > 0))\n        ) {\n          (function () {\n            if (i.preRun)\n              for (\n                \"function\" == typeof i.preRun && (i.preRun = [i.preRun]);\n                i.preRun.length;\n\n              ) {\n                e = i.preRun.shift();\n                X.unshift(e);\n              }\n            var e;\n            _e(X);\n          })();\n          if (te > 0) {\n            if (i.setStatus) {\n              i.setStatus(\"Running...\");\n              setTimeout(function () {\n                setTimeout(function () {\n                  i.setStatus(\"\");\n                }, 1);\n                t();\n              }, 1);\n            } else {\n              t();\n            }\n          }\n        }\n      }\n      function Qe(e, t) {\n        if (t && be() && 0 === e) {\n          if (be()) {\n            if (i.onExit) {\n              i.onExit(e);\n            }\n            A = !0;\n          }\n          l(e, new Ke(e));\n        }\n      }\n      i.run = Xe;\n      if (i.preInit)\n        for (\n          \"function\" == typeof i.preInit && (i.preInit = [i.preInit]);\n          i.preInit.length > 0;\n\n        )\n          i.preInit.pop()();\n      var Ye = !0;\n      if (i.noInitialRun) {\n        Ye = !1;\n      }\n      Xe();\n      const Ze = i,\n        et = {},\n        tt = 4,\n        nt = 5 * tt,\n        rt = 2 * tt,\n        ot = 2 * tt + 2 * rt,\n        it = {\n          row: 0,\n          column: 0,\n        },\n        st = /[\\w-.]*/g,\n        at = 1,\n        ct = 2,\n        lt = /^_?tree_sitter_\\w+/;\n      var ut,\n        dt,\n        pt,\n        ht,\n        ft,\n        mt = new Promise((e) => {\n          i.onRuntimeInitialized = e;\n        }).then(() => {\n          pt = Ze._ts_init();\n          ut = P(pt, \"i32\");\n          dt = P(pt + tt, \"i32\");\n        });\n      class gt {\n        static init() {\n          return mt;\n        }\n        constructor() {\n          if (null == pt)\n            throw new Error(\n              \"You must first call Parser.init() and wait for it to resolve.\"\n            );\n          Ze._ts_parser_new_wasm();\n          this[0] = P(pt, \"i32\");\n          this[1] = P(pt + tt, \"i32\");\n        }\n        delete() {\n          Ze._ts_parser_delete(this[0]);\n          Ze._free(this[1]);\n          this[0] = 0;\n          this[1] = 0;\n        }\n        setLanguage(e) {\n          let t;\n          if (e) {\n            if (e.constructor !== bt)\n              throw new Error(\"Argument must be a Language\");\n            {\n              t = e[0];\n              const n = Ze._ts_language_version(t);\n              if (n < dt || ut < n)\n                throw new Error(\n                  `Incompatible language version ${n}. Compatibility range ${dt} through ${ut}.`\n                );\n            }\n          } else {\n            t = 0;\n            e = null;\n          }\n          this.language = e;\n          Ze._ts_parser_set_language(this[0], t);\n          return this;\n        }\n        getLanguage() {\n          return this.language;\n        }\n        parse(e, t, n) {\n          if (\"string\" == typeof e) ht = (t, n, r) => e.slice(t, r);\n          else {\n            if (\"function\" != typeof e)\n              throw new Error(\"Argument must be a string or a function\");\n            ht = e;\n          }\n          if (this.logCallback) {\n            ft = this.logCallback;\n            Ze._ts_parser_enable_logger_wasm(this[0], 1);\n          } else {\n            ft = null;\n            Ze._ts_parser_enable_logger_wasm(this[0], 0);\n          }\n          let r = 0,\n            o = 0;\n          if (n && n.includedRanges) {\n            r = n.includedRanges.length;\n            let e = (o = Ze._calloc(r, ot));\n            for (let t = 0; t < r; t++) {\n              Nt(e, n.includedRanges[t]);\n              e += ot;\n            }\n          }\n          const i = Ze._ts_parser_parse_wasm(\n            this[0],\n            this[1],\n            t ? t[0] : 0,\n            o,\n            r\n          );\n          if (!i) throw ((ht = null), (ft = null), new Error(\"Parsing failed\"));\n          const s = new _t(et, i, this.language, ht);\n          ht = null;\n          ft = null;\n          return s;\n        }\n        reset() {\n          Ze._ts_parser_reset(this[0]);\n        }\n        setTimeoutMicros(e) {\n          Ze._ts_parser_set_timeout_micros(this[0], e);\n        }\n        getTimeoutMicros() {\n          return Ze._ts_parser_timeout_micros(this[0]);\n        }\n        setLogger(e) {\n          if (e) {\n            if (\"function\" != typeof e)\n              throw new Error(\"Logger callback must be a function\");\n          } else e = null;\n          this.logCallback = e;\n          return this;\n        }\n        getLogger() {\n          return this.logCallback;\n        }\n      }\n      class _t {\n        constructor(e, t, n, r) {\n          Ct(e);\n          this[0] = t;\n          this.language = n;\n          this.textCallback = r;\n        }\n        copy() {\n          const e = Ze._ts_tree_copy(this[0]);\n          return new _t(et, e, this.language, this.textCallback);\n        }\n        delete() {\n          Ze._ts_tree_delete(this[0]);\n          this[0] = 0;\n        }\n        edit(e) {\n          !(function (e) {\n            let t = pt;\n            At(t, e.startPosition);\n            At((t += rt), e.oldEndPosition);\n            At((t += rt), e.newEndPosition);\n            I((t += rt), e.startIndex, \"i32\");\n            I((t += tt), e.oldEndIndex, \"i32\");\n            I((t += tt), e.newEndIndex, \"i32\");\n            t += tt;\n          })(e);\n          Ze._ts_tree_edit_wasm(this[0]);\n        }\n        get rootNode() {\n          Ze._ts_tree_root_node_wasm(this[0]);\n          return kt(this);\n        }\n        getLanguage() {\n          return this.language;\n        }\n        walk() {\n          return this.rootNode.walk();\n        }\n        getChangedRanges(e) {\n          if (e.constructor !== _t)\n            throw new TypeError(\"Argument must be a Tree\");\n          Ze._ts_tree_get_changed_ranges_wasm(this[0], e[0]);\n          const t = P(pt, \"i32\"),\n            n = P(pt + tt, \"i32\"),\n            r = new Array(t);\n          if (t > 0) {\n            let e = n;\n            for (let n = 0; n < t; n++) {\n              r[n] = Rt(e);\n              e += ot;\n            }\n            Ze._free(n);\n          }\n          return r;\n        }\n      }\n      class yt {\n        constructor(e, t) {\n          Ct(e);\n          this.tree = t;\n        }\n        get typeId() {\n          Tt(this);\n          return Ze._ts_node_symbol_wasm(this.tree[0]);\n        }\n        get type() {\n          return this.tree.language.types[this.typeId] || \"ERROR\";\n        }\n        get endPosition() {\n          Tt(this);\n          Ze._ts_node_end_point_wasm(this.tree[0]);\n          return Ot(pt);\n        }\n        get endIndex() {\n          Tt(this);\n          return Ze._ts_node_end_index_wasm(this.tree[0]);\n        }\n        get text() {\n          return xt(this.tree, this.startIndex, this.endIndex);\n        }\n        isNamed() {\n          Tt(this);\n          return 1 === Ze._ts_node_is_named_wasm(this.tree[0]);\n        }\n        hasError() {\n          Tt(this);\n          return 1 === Ze._ts_node_has_error_wasm(this.tree[0]);\n        }\n        hasChanges() {\n          Tt(this);\n          return 1 === Ze._ts_node_has_changes_wasm(this.tree[0]);\n        }\n        isMissing() {\n          Tt(this);\n          return 1 === Ze._ts_node_is_missing_wasm(this.tree[0]);\n        }\n        equals(e) {\n          return this.id === e.id;\n        }\n        child(e) {\n          Tt(this);\n          Ze._ts_node_child_wasm(this.tree[0], e);\n          return kt(this.tree);\n        }\n        namedChild(e) {\n          Tt(this);\n          Ze._ts_node_named_child_wasm(this.tree[0], e);\n          return kt(this.tree);\n        }\n        childForFieldId(e) {\n          Tt(this);\n          Ze._ts_node_child_by_field_id_wasm(this.tree[0], e);\n          return kt(this.tree);\n        }\n        childForFieldName(e) {\n          const t = this.tree.language.fields.indexOf(e);\n          if (-1 !== t) return this.childForFieldId(t);\n        }\n        get childCount() {\n          Tt(this);\n          return Ze._ts_node_child_count_wasm(this.tree[0]);\n        }\n        get namedChildCount() {\n          Tt(this);\n          return Ze._ts_node_named_child_count_wasm(this.tree[0]);\n        }\n        get firstChild() {\n          return this.child(0);\n        }\n        get firstNamedChild() {\n          return this.namedChild(0);\n        }\n        get lastChild() {\n          return this.child(this.childCount - 1);\n        }\n        get lastNamedChild() {\n          return this.namedChild(this.namedChildCount - 1);\n        }\n        get children() {\n          if (!this._children) {\n            Tt(this);\n            Ze._ts_node_children_wasm(this.tree[0]);\n            const e = P(pt, \"i32\"),\n              t = P(pt + tt, \"i32\");\n            this._children = new Array(e);\n            if (e > 0) {\n              let n = t;\n              for (let t = 0; t < e; t++)\n                (this._children[t] = kt(this.tree, n)), (n += nt);\n              Ze._free(t);\n            }\n          }\n          return this._children;\n        }\n        get namedChildren() {\n          if (!this._namedChildren) {\n            Tt(this);\n            Ze._ts_node_named_children_wasm(this.tree[0]);\n            const e = P(pt, \"i32\"),\n              t = P(pt + tt, \"i32\");\n            this._namedChildren = new Array(e);\n            if (e > 0) {\n              let n = t;\n              for (let t = 0; t < e; t++)\n                (this._namedChildren[t] = kt(this.tree, n)), (n += nt);\n              Ze._free(t);\n            }\n          }\n          return this._namedChildren;\n        }\n        descendantsOfType(e, t, n) {\n          if (Array.isArray(e)) {\n            e = [e];\n          }\n          if (t) {\n            t = it;\n          }\n          if (n) {\n            n = it;\n          }\n          const r = [],\n            o = this.tree.language.types;\n          for (let t = 0, n = o.length; t < n; t++)\n            if (e.includes(o[t])) {\n              r.push(t);\n            }\n          const i = Ze._malloc(tt * r.length);\n          for (let e = 0, t = r.length; e < t; e++) I(i + e * tt, r[e], \"i32\");\n          Tt(this);\n          Ze._ts_node_descendants_of_type_wasm(\n            this.tree[0],\n            i,\n            r.length,\n            t.row,\n            t.column,\n            n.row,\n            n.column\n          );\n          const s = P(pt, \"i32\"),\n            a = P(pt + tt, \"i32\"),\n            c = new Array(s);\n          if (s > 0) {\n            let e = a;\n            for (let t = 0; t < s; t++) {\n              c[t] = kt(this.tree, e);\n              e += nt;\n            }\n          }\n          Ze._free(a);\n          Ze._free(i);\n          return c;\n        }\n        get nextSibling() {\n          Tt(this);\n          Ze._ts_node_next_sibling_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        get previousSibling() {\n          Tt(this);\n          Ze._ts_node_prev_sibling_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        get nextNamedSibling() {\n          Tt(this);\n          Ze._ts_node_next_named_sibling_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        get previousNamedSibling() {\n          Tt(this);\n          Ze._ts_node_prev_named_sibling_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        get parent() {\n          Tt(this);\n          Ze._ts_node_parent_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        descendantForIndex(e, t = e) {\n          if (\"number\" != typeof e || \"number\" != typeof t)\n            throw new Error(\"Arguments must be numbers\");\n          Tt(this);\n          let n = pt + nt;\n          I(n, e, \"i32\");\n          I(n + tt, t, \"i32\");\n          Ze._ts_node_descendant_for_index_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        namedDescendantForIndex(e, t = e) {\n          if (\"number\" != typeof e || \"number\" != typeof t)\n            throw new Error(\"Arguments must be numbers\");\n          Tt(this);\n          let n = pt + nt;\n          I(n, e, \"i32\");\n          I(n + tt, t, \"i32\");\n          Ze._ts_node_named_descendant_for_index_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        descendantForPosition(e, t = e) {\n          if (!St(e) || !St(t))\n            throw new Error(\"Arguments must be {row, column} objects\");\n          Tt(this);\n          let n = pt + nt;\n          At(n, e);\n          At(n + rt, t);\n          Ze._ts_node_descendant_for_position_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        namedDescendantForPosition(e, t = e) {\n          if (!St(e) || !St(t))\n            throw new Error(\"Arguments must be {row, column} objects\");\n          Tt(this);\n          let n = pt + nt;\n          At(n, e);\n          At(n + rt, t);\n          Ze._ts_node_named_descendant_for_position_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        walk() {\n          Tt(this);\n          Ze._ts_tree_cursor_new_wasm(this.tree[0]);\n          return new vt(et, this.tree);\n        }\n        toString() {\n          Tt(this);\n          const e = Ze._ts_node_to_string_wasm(this.tree[0]),\n            t = (function (e) {\n              for (var t = \"\"; ; ) {\n                var n = M[e++ >> 0];\n                if (!n) return t;\n                t += String.fromCharCode(n);\n              }\n            })(e);\n          Ze._free(e);\n          return t;\n        }\n      }\n      class vt {\n        constructor(e, t) {\n          Ct(e);\n          this.tree = t;\n          Pt(this);\n        }\n        delete() {\n          It(this);\n          Ze._ts_tree_cursor_delete_wasm(this.tree[0]);\n          this[0] = this[1] = this[2] = 0;\n        }\n        reset(e) {\n          Tt(e);\n          It(this, pt + nt);\n          Ze._ts_tree_cursor_reset_wasm(this.tree[0]);\n          Pt(this);\n        }\n        get nodeType() {\n          return this.tree.language.types[this.nodeTypeId] || \"ERROR\";\n        }\n        get nodeTypeId() {\n          It(this);\n          return Ze._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);\n        }\n        get nodeId() {\n          It(this);\n          return Ze._ts_tree_cursor_current_node_id_wasm(this.tree[0]);\n        }\n        get nodeIsNamed() {\n          It(this);\n          return (\n            1 === Ze._ts_tree_cursor_current_node_is_named_wasm(this.tree[0])\n          );\n        }\n        get nodeIsMissing() {\n          It(this);\n          return (\n            1 === Ze._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0])\n          );\n        }\n        get nodeText() {\n          It(this);\n          const e = Ze._ts_tree_cursor_start_index_wasm(this.tree[0]),\n            t = Ze._ts_tree_cursor_end_index_wasm(this.tree[0]);\n          return xt(this.tree, e, t);\n        }\n        get startPosition() {\n          It(this);\n          Ze._ts_tree_cursor_start_position_wasm(this.tree[0]);\n          return Ot(pt);\n        }\n        get endPosition() {\n          It(this);\n          Ze._ts_tree_cursor_end_position_wasm(this.tree[0]);\n          return Ot(pt);\n        }\n        get startIndex() {\n          It(this);\n          return Ze._ts_tree_cursor_start_index_wasm(this.tree[0]);\n        }\n        get endIndex() {\n          It(this);\n          return Ze._ts_tree_cursor_end_index_wasm(this.tree[0]);\n        }\n        currentNode() {\n          It(this);\n          Ze._ts_tree_cursor_current_node_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        currentFieldId() {\n          It(this);\n          return Ze._ts_tree_cursor_current_field_id_wasm(this.tree[0]);\n        }\n        currentFieldName() {\n          return this.tree.language.fields[this.currentFieldId()];\n        }\n        gotoFirstChild() {\n          It(this);\n          const e = Ze._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);\n          Pt(this);\n          return 1 === e;\n        }\n        gotoNextSibling() {\n          It(this);\n          const e = Ze._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);\n          Pt(this);\n          return 1 === e;\n        }\n        gotoParent() {\n          It(this);\n          const e = Ze._ts_tree_cursor_goto_parent_wasm(this.tree[0]);\n          Pt(this);\n          return 1 === e;\n        }\n      }\n      class bt {\n        constructor(e, t) {\n          Ct(e);\n          this[0] = t;\n          this.types = new Array(Ze._ts_language_symbol_count(this[0]));\n          for (let e = 0, t = this.types.length; e < t; e++)\n            if (Ze._ts_language_symbol_type(this[0], e) < 2) {\n              this.types[e] = U(Ze._ts_language_symbol_name(this[0], e));\n            }\n          this.fields = new Array(Ze._ts_language_field_count(this[0]) + 1);\n          for (let e = 0, t = this.fields.length; e < t; e++) {\n            const t = Ze._ts_language_field_name_for_id(this[0], e);\n            this.fields[e] = 0 !== t ? U(t) : null;\n          }\n        }\n        get version() {\n          return Ze._ts_language_version(this[0]);\n        }\n        get fieldCount() {\n          return this.fields.length - 1;\n        }\n        fieldIdForName(e) {\n          const t = this.fields.indexOf(e);\n          return -1 !== t ? t : null;\n        }\n        fieldNameForId(e) {\n          return this.fields[e] || null;\n        }\n        idForNodeType(e, t) {\n          const n = G(e),\n            r = Ze._malloc(n + 1);\n          z(e, r, n + 1);\n          const o = Ze._ts_language_symbol_for_name(this[0], r, n, t);\n          Ze._free(r);\n          return o || null;\n        }\n        get nodeTypeCount() {\n          return Ze._ts_language_symbol_count(this[0]);\n        }\n        nodeTypeForId(e) {\n          const t = Ze._ts_language_symbol_name(this[0], e);\n          return t ? U(t) : null;\n        }\n        nodeTypeIsNamed(e) {\n          return !!Ze._ts_language_type_is_named_wasm(this[0], e);\n        }\n        nodeTypeIsVisible(e) {\n          return !!Ze._ts_language_type_is_visible_wasm(this[0], e);\n        }\n        query(e) {\n          const t = G(e),\n            n = Ze._malloc(t + 1);\n          z(e, n, t + 1);\n          const r = Ze._ts_query_new(this[0], n, t, pt, pt + tt);\n          if (!r) {\n            const t = P(pt + tt, \"i32\"),\n              r = U(n, P(pt, \"i32\")).length,\n              o = e.substr(r, 100).split(\"\\n\")[0];\n            let i,\n              s = o.match(st)[0];\n            switch (t) {\n              case 2:\n                i = new RangeError(`Bad node name '${s}'`);\n                break;\n              case 3:\n                i = new RangeError(`Bad field name '${s}'`);\n                break;\n              case 4:\n                i = new RangeError(`Bad capture name @${s}`);\n                break;\n              case 5:\n                i = new TypeError(\n                  `Bad pattern structure at offset ${r}: '${o}'...`\n                );\n                s = \"\";\n                break;\n              default:\n                i = new SyntaxError(`Bad syntax at offset ${r}: '${o}'...`);\n                s = \"\";\n            }\n            throw ((i.index = r), (i.length = s.length), Ze._free(n), i);\n          }\n          const o = Ze._ts_query_string_count(r),\n            i = Ze._ts_query_capture_count(r),\n            s = Ze._ts_query_pattern_count(r),\n            a = new Array(i),\n            c = new Array(o);\n          for (let e = 0; e < i; e++) {\n            const t = Ze._ts_query_capture_name_for_id(r, e, pt),\n              n = P(pt, \"i32\");\n            a[e] = U(t, n);\n          }\n          for (let e = 0; e < o; e++) {\n            const t = Ze._ts_query_string_value_for_id(r, e, pt),\n              n = P(pt, \"i32\");\n            c[e] = U(t, n);\n          }\n          const l = new Array(s),\n            u = new Array(s),\n            d = new Array(s),\n            p = new Array(s),\n            h = new Array(s);\n          for (let e = 0; e < s; e++) {\n            const t = Ze._ts_query_predicates_for_pattern(r, e, pt),\n              n = P(pt, \"i32\");\n            p[e] = [];\n            h[e] = [];\n            const o = [];\n            let i = t;\n            for (let t = 0; t < n; t++) {\n              const t = P(i, \"i32\"),\n                n = P((i += tt), \"i32\");\n              i += tt;\n              if (t === at)\n                o.push({\n                  type: \"capture\",\n                  name: a[n],\n                });\n              else if (t === ct)\n                o.push({\n                  type: \"string\",\n                  value: c[n],\n                });\n              else if (o.length > 0) {\n                if (\"string\" !== o[0].type)\n                  throw new Error(\"Predicates must begin with a literal value\");\n                const t = o[0].value;\n                let n = !0;\n                switch (t) {\n                  case \"not-eq?\":\n                    n = !1;\n                  case \"eq?\":\n                    if (3 !== o.length)\n                      throw new Error(\n                        \"Wrong number of arguments to `#eq?` predicate. Expected 2, got \" +\n                          (o.length - 1)\n                      );\n                    if (\"capture\" !== o[1].type)\n                      throw new Error(\n                        `First argument of \\`#eq?\\` predicate must be a capture. Got \"${o[1].value}\"`\n                      );\n                    if (\"capture\" === o[2].type) {\n                      const t = o[1].name,\n                        r = o[2].name;\n                      h[e].push(function (e) {\n                        let o, i;\n                        for (const n of e)\n                          n.name === t && (o = n.node),\n                            n.name === r && (i = n.node);\n                        return (o.text === i.text) === n;\n                      });\n                    } else {\n                      const t = o[1].name,\n                        r = o[2].value;\n                      h[e].push(function (e) {\n                        for (const o of e)\n                          if (o.name === t) return (o.node.text === r) === n;\n                        return !1;\n                      });\n                    }\n                    break;\n                  case \"not-match?\":\n                    n = !1;\n                  case \"match?\":\n                    if (3 !== o.length)\n                      throw new Error(\n                        `Wrong number of arguments to \\`#match?\\` predicate. Expected 2, got ${\n                          o.length - 1\n                        }.`\n                      );\n                    if (\"capture\" !== o[1].type)\n                      throw new Error(\n                        `First argument of \\`#match?\\` predicate must be a capture. Got \"${o[1].value}\".`\n                      );\n                    if (\"string\" !== o[2].type)\n                      throw new Error(\n                        `Second argument of \\`#match?\\` predicate must be a string. Got @${o[2].value}.`\n                      );\n                    const r = o[1].name,\n                      i = new RegExp(o[2].value);\n                    h[e].push(function (e) {\n                      for (const t of e)\n                        if (t.name === r) return i.test(t.node.text) === n;\n                      return !1;\n                    });\n                    break;\n                  case \"set!\":\n                    if (o.length < 2 || o.length > 3)\n                      throw new Error(\n                        `Wrong number of arguments to \\`#set!\\` predicate. Expected 1 or 2. Got ${\n                          o.length - 1\n                        }.`\n                      );\n                    if (o.some((e) => \"string\" !== e.type))\n                      throw new Error(\n                        'Arguments to `#set!` predicate must be a strings.\".'\n                      );\n                    l[e] || (l[e] = {}),\n                      (l[e][o[1].value] = o[2] ? o[2].value : null);\n                    break;\n                  case \"is?\":\n                  case \"is-not?\":\n                    if (o.length < 2 || o.length > 3)\n                      throw new Error(\n                        `Wrong number of arguments to \\`#${t}\\` predicate. Expected 1 or 2. Got ${\n                          o.length - 1\n                        }.`\n                      );\n                    if (o.some((e) => \"string\" !== e.type))\n                      throw new Error(\n                        `Arguments to \\`#${t}\\` predicate must be a strings.\".`\n                      );\n                    const s = \"is?\" === t ? u : d;\n                    s[e] || (s[e] = {}),\n                      (s[e][o[1].value] = o[2] ? o[2].value : null);\n                    break;\n                  default:\n                    p[e].push({\n                      operator: t,\n                      operands: o.slice(1),\n                    });\n                }\n                o.length = 0;\n              }\n            }\n            Object.freeze(l[e]);\n            Object.freeze(u[e]);\n            Object.freeze(d[e]);\n          }\n          Ze._free(n);\n          return new wt(\n            et,\n            r,\n            a,\n            h,\n            p,\n            Object.freeze(l),\n            Object.freeze(u),\n            Object.freeze(d)\n          );\n        }\n        static load(e) {\n          let t;\n          if (e instanceof Uint8Array) t = Promise.resolve(e);\n          else {\n            const r = e;\n            if (\n              \"undefined\" != typeof process &&\n              process.versions &&\n              process.versions.node\n            ) {\n              const e = require(\"fs\");\n              t = Promise.resolve(e.readFileSync(r));\n            } else\n              t = fetch(r).then((e) =>\n                e.arrayBuffer().then((t) => {\n                  if (e.ok) return new Uint8Array(t);\n                  {\n                    const n = new TextDecoder(\"utf-8\").decode(t);\n                    throw new Error(\n                      `Language.load failed with status ${e.status}.\\n\\n${n}`\n                    );\n                  }\n                })\n              );\n          }\n          const r = \"function\" == typeof loadSideModule ? loadSideModule : Ie;\n          return t\n            .then((e) =>\n              r(e, {\n                loadAsync: !0,\n              })\n            )\n            .then((e) => {\n              const t = Object.keys(e),\n                n = t.find(\n                  (e) => lt.test(e) && !e.includes(\"external_scanner_\")\n                );\n              if (n) {\n                console.log(\n                  `Couldn't find language function in WASM file. Symbols:\\n${JSON.stringify(\n                    t,\n                    null,\n                    2\n                  )}`\n                );\n              }\n              const r = e[n]();\n              return new bt(et, r);\n            });\n        }\n      }\n      class wt {\n        constructor(e, t, n, r, o, i, s, a) {\n          Ct(e);\n          this[0] = t;\n          this.captureNames = n;\n          this.textPredicates = r;\n          this.predicates = o;\n          this.setProperties = i;\n          this.assertedProperties = s;\n          this.refutedProperties = a;\n          this.exceededMatchLimit = !1;\n        }\n        delete() {\n          Ze._ts_query_delete(this[0]);\n          this[0] = 0;\n        }\n        matches(e, t, n) {\n          if (t) {\n            t = it;\n          }\n          if (n) {\n            n = it;\n          }\n          Tt(e);\n          Ze._ts_query_matches_wasm(\n            this[0],\n            e.tree[0],\n            t.row,\n            t.column,\n            n.row,\n            n.column\n          );\n          const r = P(pt, \"i32\"),\n            o = P(pt + tt, \"i32\"),\n            i = P(pt + 2 * tt, \"i32\"),\n            s = new Array(r);\n          this.exceededMatchLimit = !!i;\n          let a = 0,\n            c = o;\n          for (let t = 0; t < r; t++) {\n            const n = P(c, \"i32\"),\n              r = P((c += tt), \"i32\");\n            c += tt;\n            const o = new Array(r);\n            c = Et(this, e.tree, c, o);\n            if (this.textPredicates[n].every((e) => e(o))) {\n              s[a++] = {\n                pattern: n,\n                captures: o,\n              };\n              const e = this.setProperties[n];\n              e && (s[t].setProperties = e);\n              const r = this.assertedProperties[n];\n              r && (s[t].assertedProperties = r);\n              const i = this.refutedProperties[n];\n              i && (s[t].refutedProperties = i);\n            }\n          }\n          s.length = a;\n          Ze._free(o);\n          return s;\n        }\n        captures(e, t, n) {\n          if (t) {\n            t = it;\n          }\n          if (n) {\n            n = it;\n          }\n          Tt(e);\n          Ze._ts_query_captures_wasm(\n            this[0],\n            e.tree[0],\n            t.row,\n            t.column,\n            n.row,\n            n.column\n          );\n          const r = P(pt, \"i32\"),\n            o = P(pt + tt, \"i32\"),\n            i = P(pt + 2 * tt, \"i32\"),\n            s = [];\n          this.exceededMatchLimit = !!i;\n          const a = [];\n          let c = o;\n          for (let t = 0; t < r; t++) {\n            const t = P(c, \"i32\"),\n              n = P((c += tt), \"i32\"),\n              r = P((c += tt), \"i32\");\n            c += tt;\n            a.length = n;\n            c = Et(this, e.tree, c, a);\n            if (this.textPredicates[t].every((e) => e(a))) {\n              const e = a[r],\n                n = this.setProperties[t];\n              n && (e.setProperties = n);\n              const o = this.assertedProperties[t];\n              o && (e.assertedProperties = o);\n              const i = this.refutedProperties[t];\n              i && (e.refutedProperties = i), s.push(e);\n            }\n          }\n          Ze._free(o);\n          return s;\n        }\n        predicatesForPattern(e) {\n          return this.predicates[e];\n        }\n        didExceedMatchLimit() {\n          return this.exceededMatchLimit;\n        }\n      }\n      function xt(e, t, n) {\n        const r = n - t;\n        let o = e.textCallback(t, null, n);\n        for (t += o.length; t < n; ) {\n          const r = e.textCallback(t, null, n);\n          if (!(r && r.length > 0)) break;\n          t += r.length;\n          o += r;\n        }\n        if (t > n) {\n          o = o.slice(0, r);\n        }\n        return o;\n      }\n      function Et(e, t, n, r) {\n        for (let o = 0, i = r.length; o < i; o++) {\n          const i = P(n, \"i32\"),\n            s = kt(t, (n += tt));\n          n += nt;\n          r[o] = {\n            name: e.captureNames[i],\n            node: s,\n          };\n        }\n        return n;\n      }\n      function Ct(e) {\n        if (e !== et) throw new Error(\"Illegal constructor\");\n      }\n      function St(e) {\n        return e && \"number\" == typeof e.row && \"number\" == typeof e.column;\n      }\n      function Tt(e) {\n        let t = pt;\n        I(t, e.id, \"i32\");\n        I((t += tt), e.startIndex, \"i32\");\n        I((t += tt), e.startPosition.row, \"i32\");\n        I((t += tt), e.startPosition.column, \"i32\");\n        I((t += tt), e[0], \"i32\");\n      }\n      function kt(e, t = pt) {\n        const n = P(t, \"i32\");\n        if (0 === n) return null;\n        const r = P((t += tt), \"i32\"),\n          o = P((t += tt), \"i32\"),\n          i = P((t += tt), \"i32\"),\n          s = P((t += tt), \"i32\"),\n          a = new yt(et, e);\n        a.id = n;\n        a.startIndex = r;\n        a.startPosition = {\n          row: o,\n          column: i,\n        };\n        a[0] = s;\n        return a;\n      }\n      function It(e, t = pt) {\n        I(t + 0 * tt, e[0], \"i32\");\n        I(t + 1 * tt, e[1], \"i32\");\n        I(t + 2 * tt, e[2], \"i32\");\n      }\n      function Pt(e) {\n        e[0] = P(pt + 0 * tt, \"i32\");\n        e[1] = P(pt + 1 * tt, \"i32\");\n        e[2] = P(pt + 2 * tt, \"i32\");\n      }\n      function At(e, t) {\n        I(e, t.row, \"i32\");\n        I(e + tt, t.column, \"i32\");\n      }\n      function Ot(e) {\n        return {\n          row: P(e, \"i32\"),\n          column: P(e + tt, \"i32\"),\n        };\n      }\n      function Nt(e, t) {\n        At(e, t.startPosition);\n        At((e += rt), t.endPosition);\n        I((e += rt), t.startIndex, \"i32\");\n        I((e += tt), t.endIndex, \"i32\");\n        e += tt;\n      }\n      function Rt(e) {\n        const t = {};\n        t.startPosition = Ot(e);\n        e += rt;\n        t.endPosition = Ot(e);\n        e += rt;\n        t.startIndex = P(e, \"i32\");\n        e += tt;\n        t.endIndex = P(e, \"i32\");\n        return t;\n      }\n      gt.Language = bt;\n      gt.Parser = gt;\n      return gt;\n    })\n      ? r.apply(exports, [])\n      : r)\n) {\n  module.exports = o;\n}",
  "305594": "const r = require(\"fs\"),\n  o = require(\"path\"),\n  i = (e, t) => Array.from(Array(t).keys()).slice(e),\n  s = (e) => e.charCodeAt(0),\n  a = new TextDecoder(\"utf-8\"),\n  c = (e) => a.decode(new Uint8Array(e));\nfunction l(e) {\n  const t = new Set();\n  let n = e[0];\n  for (let r = 1; r < e.length; r++) {\n    const o = e[r];\n    t.add([n, o]);\n    n = o;\n  }\n  return t;\n}\nconst u = new TextEncoder(\"utf-8\"),\n  d =\n    /'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+/gu;\nlet p = !1;\nconst h = {};\nlet f,\n  m = {},\n  g = new Map(),\n  _ = new Map();\nconst y = new Map();\nfunction v() {\n  if (p) return;\n  m = JSON.parse(\n    r.readFileSync(o.resolve(__dirname, \"..\", \"dist\", \"tokenizer.json\"))\n  );\n  Object.keys(m).map((e) => {\n    h[m[e]] = e;\n  });\n  const e = r\n      .readFileSync(o.resolve(__dirname, \"..\", \"dist\", \"vocab.bpe\"), \"utf-8\")\n      .split(\"\\n\"),\n    t = e.slice(1, e.length - 1).map((e) =>\n      e.split(/(\\s+)/).filter(function (e) {\n        return e.trim().length > 0;\n      })\n    );\n  f = ((e, t) => {\n    const n = {};\n    e.map((r, o) => {\n      n[e[o]] = t[o];\n    });\n    return n;\n  })(t, i(0, t.length));\n  (function (e) {\n    const t = i(s(\"!\"), s(\"~\") + 1).concat(\n      i(s(\"\"), s(\"\") + 1),\n      i(s(\"\"), s(\"\") + 1)\n    );\n    let n = t.slice(),\n      r = 0;\n    for (let e = 0; e < 256; e++)\n      if (t.includes(e)) {\n        t.push(e);\n        n.push(256 + r);\n        r += 1;\n      }\n    n = n.map((e) => ((e) => String.fromCharCode(e))(e));\n    for (let r = 0; r < t.length; r++) e.set(t[r], n[r]);\n  })(g);\n  g.forEach(function (e, t, n) {\n    _.set(e, t);\n  });\n  p = !0;\n}\nfunction b(e) {\n  if (y.has(e)) return y.get(e);\n  let t = ((r = e), Array.from(u.encode(r))).map((e) => g.get(e)),\n    n = l(t);\n  var r;\n  if (!n) return t.map((e) => m[e]);\n  for (;;) {\n    const e = {};\n    Array.from(n).map((t) => {\n      const n = f[t];\n      e[isNaN(n) ? 1e11 : n] = t;\n    });\n    const r = e[Math.min(...Object.keys(e).map((e) => parseInt(e)))];\n    if (!(r in f)) break;\n    const o = r[0],\n      i = r[1];\n    let s = [],\n      a = 0;\n    for (; a < t.length; ) {\n      const e = t.indexOf(o, a);\n      if (-1 === e) {\n        Array.prototype.push.apply(s, t.slice(a));\n        break;\n      }\n      Array.prototype.push.apply(s, t.slice(a, e));\n      a = e;\n      if (t[a] === o && a < t.length - 1 && t[a + 1] === i) {\n        s.push(o + i);\n        a += 2;\n      } else {\n        s.push(t[a]);\n        a += 1;\n      }\n    }\n    t = s;\n    if (1 === t.length) break;\n    n = l(t);\n  }\n  tokens = t.map((e) => m[e]);\n  y.set(e, tokens);\n  return tokens;\n}\nfunction w(e) {\n  v();\n  let t = [];\n  const n = Array.from(e.matchAll(d)).map((e) => e[0]);\n  for (let e of n) {\n    const n = b(e);\n    Array.prototype.push.apply(t, n);\n  }\n  return t;\n}\nfunction x(e, t) {\n  if (t <= 0) return \"\";\n  let n = Math.min(e.length, 4 * t),\n    r = e.slice(-n),\n    o = w(r);\n  for (; o.length < t + 2 && n < e.length; ) {\n    n = Math.min(e.length, n + 1 * t);\n    r = e.slice(-n);\n    o = w(r);\n  }\n  return o.length < t ? e : ((o = o.slice(-t)), E(o));\n}\nfunction E(e) {\n  v();\n  let t = e.map((e) => h[e]).join(\"\");\n  t = c(t.split(\"\").map((e) => _.get(e)));\n  return t;\n}\nmodule.exports = {\n  prepareTokenizer: v,\n  tokenize: w,\n  tokenize_strings: function (e) {\n    return w(e).map((e) => c(h[e].split(\"\").map((e) => _.get(e))));\n  },\n  tokenLength: function (e) {\n    return w(e).length;\n  },\n  takeLastTokens: x,\n  takeLastLinesTokens: function (e, t) {\n    const n = x(e, t);\n    if (n.length === e.length || \"\\n\" === e[e.length - n.length - 1]) return n;\n    let r = n.indexOf(\"\\n\");\n    return n.substring(r + 1);\n  },\n  takeFirstTokens: function (e, t) {\n    if (t <= 0)\n      return {\n        text: \"\",\n        tokens: [],\n      };\n    let n = Math.min(e.length, 4 * t),\n      r = e.slice(0, n),\n      o = w(r);\n    for (; o.length < t + 2 && n < e.length; ) {\n      n = Math.min(e.length, n + 1 * t);\n      r = e.slice(0, n);\n      o = w(r);\n    }\n    return o.length < t\n      ? {\n          text: e,\n          tokens: o,\n        }\n      : ((o = o.slice(0, t)),\n        {\n          text: E(o),\n          tokens: o,\n        });\n  },\n  detokenize: E,\n};",
  "3055125": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getNeighborSnippets = exports.neighborOptionToSelection = undefined;\nconst r = require(3055417),\n  o = require(3055404);\nfunction i(e) {\n  return [\n    e.relativePath\n      ? \"Compare this snippet from \" + e.relativePath + \":\"\n      : \"Compare this snippet:\",\n  ].concat(e.snippet.split(\"\\n\"));\n}\nexports.neighborOptionToSelection = {\n  none: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(1),\n    threshold: -1,\n    numberOfSnippets: 0,\n  },\n  conservative: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(10),\n    threshold: 0.3,\n    numberOfSnippets: 1,\n  },\n  medium: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(20),\n    threshold: 0.1,\n    numberOfSnippets: 2,\n  },\n  eager: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(60),\n    threshold: 0,\n    numberOfSnippets: 4,\n  },\n  eagerButLittle: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(10),\n    threshold: 0,\n    numberOfSnippets: 1,\n  },\n};\nexports.getNeighborSnippets = async function (e, n, s, a, c, l, u) {\n  const d = exports.neighborOptionToSelection[s],\n    p = (function (e, n, r, i) {\n      const s = {\n        ...exports.neighborOptionToSelection[n],\n      };\n      if (undefined !== r && undefined !== i) {\n        s.matcherFactory = o.IndentationBasedJaccardMatcher.FACTORY(r, i);\n      }\n      return s.matcherFactory.to(e);\n    })(e, s, a, c);\n  return n\n    .filter((e) => e.source.length < 1e4 && e.source.length > 0)\n    .slice(0, 20)\n    .reduce(\n      (e, t) =>\n        e.concat(\n          p.findMatches(t, l, u).map((e) => ({\n            relativePath: t.relativePath,\n            ...e,\n          }))\n        ),\n      []\n    )\n    .filter((e) => e.score && e.snippet && e.score > d.threshold)\n    .sort((e, t) => e.score - t.score)\n    .slice(-d.numberOfSnippets)\n    .map((t) => ({\n      score: t.score,\n      snippet: i(t)\n        .map((t) => r.comment(t, e.languageId) + \"\\n\")\n        .join(\"\"),\n      startLine: t.startLine,\n      endLine: t.endLine,\n    }));\n};",
  "3055179": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.extractLocalImportContext = exports.getDocComment = undefined;\nconst r = require(\"path\"),\n  o = require(3055306);\nfunction i(e, t) {\n  var n;\n  let o =\n    null === (n = t.namedChild(1)) || undefined === n\n      ? undefined\n      : n.text.slice(1, -1);\n  if (!o || !o.startsWith(\".\")) return null;\n  if (\"\" === r.extname(o)) o += \".ts\";\n  else if (\".ts\" !== r.extname(o)) return null;\n  return r.join(r.dirname(e), o);\n}\nfunction s(e) {\n  var t, n, r, o, i;\n  let s = [];\n  if (\n    \"import_clause\" ===\n    (null === (t = e.namedChild(0)) || undefined === t ? undefined : t.type)\n  ) {\n    let t = e.namedChild(0);\n    if (\n      \"named_imports\" ===\n      (null === (n = null == t ? undefined : t.namedChild(0)) || undefined === n\n        ? undefined\n        : n.type)\n    ) {\n      let e = t.namedChild(0);\n      for (let t of null !== (r = null == e ? undefined : e.namedChildren) &&\n      undefined !== r\n        ? r\n        : [])\n        if (\"import_specifier\" === t.type) {\n          const e =\n            null === (o = t.childForFieldName(\"name\")) || undefined === o\n              ? undefined\n              : o.text;\n          if (e) {\n            const n =\n              null === (i = t.childForFieldName(\"alias\")) || undefined === i\n                ? undefined\n                : i.text;\n            s.push({\n              name: e,\n              alias: n,\n            });\n          }\n        }\n    }\n  }\n  return s;\n}\nconst a = new Map();\nfunction c(e, t) {\n  var n, r;\n  let o =\n    null !==\n      (r =\n        null === (n = null == t ? undefined : t.childForFieldName(\"name\")) ||\n        undefined === n\n          ? undefined\n          : n.text) && undefined !== r\n      ? r\n      : \"\";\n  switch (null == t ? undefined : t.type) {\n    case \"ambient_declaration\":\n      return c(e, t.namedChild(0));\n    case \"interface_declaration\":\n    case \"enum_declaration\":\n    case \"type_alias_declaration\":\n      return {\n        name: o,\n        decl: t.text,\n      };\n    case \"function_declaration\":\n    case \"function_signature\":\n      return {\n        name: o,\n        decl: l(e, t),\n      };\n    case \"class_declaration\": {\n      let n = (function (e, t) {\n          let n = t.childForFieldName(\"body\");\n          if (n) return n.namedChildren.map((t) => d(e, t)).filter((e) => e);\n        })(e, t),\n        r = \"\";\n      if (n) {\n        let o = t.childForFieldName(\"body\");\n        r = `declare ${e.substring(t.startIndex, o.startIndex + 1)}`;\n        r += n.map((e) => \"\\n\" + e).join(\"\");\n        r += \"\\n}\";\n      }\n      return {\n        name: o,\n        decl: r,\n      };\n    }\n  }\n  return {\n    name: o,\n    decl: \"\",\n  };\n}\nfunction l(e, t) {\n  var n, r, o;\n  const i =\n    null !==\n      (r =\n        null === (n = t.childForFieldName(\"return_type\")) || undefined === n\n          ? undefined\n          : n.endIndex) && undefined !== r\n      ? r\n      : null === (o = t.childForFieldName(\"parameters\")) || undefined === o\n      ? undefined\n      : o.endIndex;\n  if (undefined !== i) {\n    let n = e.substring(t.startIndex, i) + \";\";\n    return \"function_declaration\" === t.type || \"function_signature\" === t.type\n      ? \"declare \" + n\n      : n;\n  }\n  return \"\";\n}\nfunction getDocComment(e, t) {\n  const n = o.getFirstPrecedingComment(t);\n  return n ? e.substring(n.startIndex, t.startIndex) : \"\";\n}\nfunction d(e, t) {\n  var n, r, i, s, a;\n  if (\n    \"accessibility_modifier\" ===\n      (null === (n = null == t ? undefined : t.firstChild) || undefined === n\n        ? undefined\n        : n.type) &&\n    \"private\" === t.firstChild.text\n  )\n    return \"\";\n  const c = o.getFirstPrecedingComment(t),\n    p =\n      null !==\n        (r = (function (e, t) {\n          let n = t.startIndex - 1;\n          for (; n >= 0 && (\" \" === e[n] || \"\\t\" === e[n]); ) n--;\n          if (n < 0 || \"\\n\" === e[n]) return e.substring(n + 1, t.startIndex);\n        })(e, null != c ? c : t)) && undefined !== r\n        ? r\n        : \"  \",\n    h = getDocComment(e, t);\n  switch (t.type) {\n    case \"ambient_declaration\":\n      const n = t.namedChild(0);\n      return n ? p + h + d(e, n) : \"\";\n    case \"method_definition\":\n    case \"method_signature\":\n      return p + h + l(e, t);\n    case \"public_field_definition\": {\n      let n =\n        null !==\n          (s =\n            null === (i = t.childForFieldName(\"type\")) || undefined === i\n              ? undefined\n              : i.endIndex) && undefined !== s\n          ? s\n          : null === (a = t.childForFieldName(\"name\")) || undefined === a\n          ? undefined\n          : a.endIndex;\n      if (undefined !== n) return p + h + e.substring(t.startIndex, n) + \";\";\n    }\n  }\n  return \"\";\n}\nasync function p(e, t, n) {\n  let r = new Map(),\n    i = -1;\n  try {\n    i = await n.mtime(e);\n  } catch {\n    return r;\n  }\n  let s = a.get(e);\n  if (s && s.mtime === i) return s.exports;\n  if (\"typescript\" === t) {\n    let i = null;\n    try {\n      let s = (await n.readFile(e)).toString();\n      i = await o.parseTree(t, s);\n      for (let e of o.queryExports(t, i.rootNode))\n        for (let t of e.captures) {\n          let e = t.node;\n          if (\"export_statement\" === e.type) {\n            let t = e.childForFieldName(\"declaration\");\n            if (null == t ? undefined : t.hasError()) continue;\n            let { name: n, decl: o } = c(s, t);\n            if (n) {\n              o = getDocComment(s, e) + o;\n              let t = r.get(n);\n              if (t) {\n                t = [];\n                r.set(n, t);\n              }\n              t.push(o);\n            }\n          }\n        }\n    } catch {\n    } finally {\n      if (i) {\n        i.delete();\n      }\n    }\n  }\n  if (a.size > 2e3)\n    for (let e of a.keys()) {\n      a.delete(e);\n      if (r.size <= 1e3) break;\n    }\n  a.set(e, {\n    mtime: i,\n    exports: r,\n  });\n  return r;\n}\nexports.getDocComment = getDocComment;\nconst h = /^\\s*import\\s*(type|)\\s*\\{[^}]*\\}\\s*from\\s*['\"]\\./gm;\nexports.extractLocalImportContext = async function (e, t) {\n  let { source: n, uri: r, languageId: a } = e;\n  return t && \"typescript\" === a\n    ? (async function (e, t, n) {\n        let r = \"typescript\",\n          a = [];\n        const c = (function (e) {\n          let t,\n            n = -1;\n          h.lastIndex = -1;\n          do {\n            t = h.exec(e);\n            if (t) {\n              n = h.lastIndex + t.length;\n            }\n          } while (t);\n          if (-1 === n) return -1;\n          const r = e.indexOf(\"\\n\", n);\n          return -1 !== r ? r : e.length;\n        })(e);\n        if (-1 === c) return a;\n        e = e.substring(0, c);\n        let l = await o.parseTree(r, e);\n        try {\n          for (let e of (function (e) {\n            let t = [];\n            for (let n of e.namedChildren)\n              if (\"import_statement\" === n.type) {\n                t.push(n);\n              }\n            return t;\n          })(l.rootNode)) {\n            let o = i(t, e);\n            if (!o) continue;\n            let c = s(e);\n            if (0 === c.length) continue;\n            let l = await p(o, r, n);\n            for (let e of c)\n              if (l.has(e.name)) {\n                a.push(...l.get(e.name));\n              }\n          }\n        } finally {\n          l.delete();\n        }\n        return a;\n      })(n, r, t)\n    : [];\n};",
  "3055250": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getWindowsDelineations = undefined;\nconst r = require(3055469),\n  o = require(3055617);\nexports.getWindowsDelineations = function (e, t, n, i) {\n  if (e.length < n || 0 == i) return [];\n  const s = [],\n    a = o.clearLabels(r.parseTree(e.join(\"\\n\"), t));\n  o.visitTree(\n    a,\n    (e) => {\n      if (\"blank\" === e.type)\n        return void (e.label = {\n          totalLength: 1,\n          firstLineAfter: e.lineNumber + 1,\n        });\n      let t = \"line\" === e.type ? 1 : 0,\n        r = \"line\" === e.type ? e.lineNumber + 1 : NaN;\n      function o(n) {\n        return -1 == n\n          ? r - t\n          : e.subs[n].label.firstLineAfter - e.subs[n].label.totalLength;\n      }\n      function a(t, n) {\n        return 0 == t ? n + 1 : e.subs[t - 1].label.firstLineAfter;\n      }\n      let c = \"line\" === e.type ? -1 : 0,\n        l = \"line\" === e.type ? 1 : 0,\n        u = 0;\n      for (let d = 0; d < e.subs.length; d++) {\n        for (; c >= 0 && c < e.subs.length && \"blank\" === e.subs[c].type; ) {\n          l -= e.subs[c].label.totalLength;\n          c++;\n        }\n        if (\"blank\" !== e.subs[d].type) {\n          u = d;\n        }\n        r = e.subs[d].label.firstLineAfter;\n        t += e.subs[d].label.totalLength;\n        l += e.subs[d].label.totalLength;\n        if (l > i) {\n          const t = o(c),\n            r = a(d, t),\n            p = u == d ? r : a(u, t);\n          for (n <= r - t && s.push([t, p]); l > i; )\n            (l -=\n              -1 == c\n                ? \"line\" == e.type\n                  ? 1\n                  : 0\n                : e.subs[c].label.totalLength),\n              c++;\n        }\n      }\n      if (c < e.subs.length) {\n        const t = o(c),\n          i = r,\n          a = -1 == c ? i : e.subs[u].label.firstLineAfter;\n        if (n <= i - t) {\n          s.push([t, a]);\n        }\n      }\n      e.label = {\n        totalLength: t,\n        firstLineAfter: r,\n      };\n    },\n    \"bottomUp\"\n  );\n  return s\n    .sort((e, t) => e[0] - t[0] || e[1] - t[1])\n    .filter((e, t, n) => 0 == t || e[0] != n[t - 1][0] || e[1] != n[t - 1][1]);\n};",
  "3055271": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.defaultFileSystem = exports.FileSystem = undefined;\nconst r = require(\"fs\");\nexports.FileSystem = class {};\nexports.defaultFileSystem = {\n  readFile: (e) => r.promises.readFile(e),\n  mtime: async (e) => (await r.promises.stat(e)).mtimeMs,\n  async stat(e) {\n    const t = await r.promises.stat(e);\n    return {\n      ctime: t.ctimeMs,\n      mtime: t.mtimeMs,\n      size: t.size,\n    };\n  },\n};",
  "3055306": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getFunctionPositions =\n  exports.getFirstPrecedingComment =\n  exports.isFunctionDefinition =\n  exports.isFunction =\n  exports.getAncestorWithSiblingFunctions =\n  exports.queryPythonIsDocstring =\n  exports.queryGlobalVars =\n  exports.queryExports =\n  exports.queryImports =\n  exports.queryFunctions =\n  exports.getBlockCloseToken =\n  exports.parsesWithoutError =\n  exports.parseTree =\n  exports.getLanguage =\n  exports.languageIdToWasmLanguage =\n  exports.isSupportedLanguageId =\n  exports.WASMLanguage =\n    undefined;\nconst r = require(\"path\"),\n  o = require(305587),\n  i = require(305587);\nvar s;\n!(function (e) {\n  e.Python = \"python\";\n  e.JavaScript = \"javascript\";\n  e.TypeScript = \"typescript\";\n  e.Go = \"go\";\n  e.Ruby = \"ruby\";\n})((s = exports.WASMLanguage || (exports.WASMLanguage = {})));\nconst a = {\n  python: s.Python,\n  javascript: s.JavaScript,\n  javascriptreact: s.JavaScript,\n  jsx: s.JavaScript,\n  typescript: s.TypeScript,\n  typescriptreact: s.TypeScript,\n  go: s.Go,\n  ruby: s.Ruby,\n};\nfunction languageIdToWasmLanguage(e) {\n  if (!(e in a)) throw new Error(`Unrecognized language: ${e}`);\n  return a[e];\n}\nexports.isSupportedLanguageId = function (e) {\n  return e in a;\n};\nexports.languageIdToWasmLanguage = languageIdToWasmLanguage;\nconst l = {\n    python: [\n      [\n        \"(function_definition body: (block\\n             (expression_statement (string))? @docstring) @body) @function\",\n      ],\n      ['(ERROR (\"def\" (identifier) (parameters))) @function'],\n    ],\n    javascript: [\n      [\n        \"[\\n            (function body: (statement_block) @body)\\n            (function_declaration body: (statement_block) @body)\\n            (generator_function body: (statement_block) @body)\\n            (generator_function_declaration body: (statement_block) @body)\\n            (method_definition body: (statement_block) @body)\\n          ] @function\",\n      ],\n    ],\n    typescript: [\n      [\n        \"[\\n            (function body: (statement_block) @body)\\n            (function_declaration body: (statement_block) @body)\\n            (generator_function body: (statement_block) @body)\\n            (generator_function_declaration body: (statement_block) @body)\\n            (method_definition body: (statement_block) @body)\\n          ] @function\",\n      ],\n    ],\n    go: [\n      [\n        \"[\\n            (function_declaration body: (block) @body)\\n            (method_declaration body: (block) @body)\\n          ] @function\",\n      ],\n    ],\n    ruby: [\n      [\n        '[\\n            (method name: (_) parameters: (method_parameters)? @params [(_)+ \"end\"] @body)\\n            (singleton_method name: (_) parameters: (method_parameters)? @params [(_)+ \"end\"] @body)\\n          ] @function',\n      ],\n    ],\n  },\n  u =\n    '(variable_declarator value: (call_expression function: ((identifier) @req (#eq? @req \"require\"))))',\n  d = `\\n    (lexical_declaration ${u}+)\\n    (variable_declaration ${u}+)\\n`,\n  p = {\n    python: [\n      [\"(module (future_import_statement) @import)\"],\n      [\"(module (import_statement) @import)\"],\n      [\"(module (import_from_statement) @import)\"],\n    ],\n    javascript: [\n      [`(program [ ${d} ] @import)`],\n      [\"(program [ (import_statement) ] @import)\"],\n    ],\n    typescript: [\n      [`(program [ ${d} ] @import)`],\n      [\"(program [ (import_statement) (import_alias) ] @import)\"],\n    ],\n    go: [],\n    ruby: [],\n  },\n  h = {\n    python: [],\n    javascript: [[\"(program (export_statement) @export)\"]],\n    typescript: [[\"(program (export_statement) @export)\"]],\n    go: [],\n    ruby: [],\n  },\n  f = {\n    python: [\n      [\"(module (global_statement) @globalVar)\"],\n      [\"(module (expression_statement) @globalVar)\"],\n    ],\n    javascript: [],\n    typescript: [],\n    go: [],\n    ruby: [],\n  },\n  m = {\n    python: new Set([\"function_definition\"]),\n    javascript: new Set([\n      \"function\",\n      \"function_declaration\",\n      \"generator_function\",\n      \"generator_function_declaration\",\n      \"method_definition\",\n      \"arrow_function\",\n    ]),\n    typescript: new Set([\n      \"function\",\n      \"function_declaration\",\n      \"generator_function\",\n      \"generator_function_declaration\",\n      \"method_definition\",\n      \"arrow_function\",\n    ]),\n    go: new Set([\"function_declaration\", \"method_declaration\"]),\n    ruby: new Set([\"method\", \"singleton_method\"]),\n  },\n  g = {\n    python: (e) => {\n      var t;\n      return (\n        \"module\" === e.type ||\n        (\"block\" === e.type &&\n          \"class_definition\" ===\n            (null === (t = e.parent) || undefined === t ? undefined : t.type))\n      );\n    },\n    javascript: (e) => \"program\" === e.type || \"class_body\" === e.type,\n    typescript: (e) => \"program\" === e.type || \"class_body\" === e.type,\n    go: (e) => \"source_file\" === e.type,\n    ruby: (e) => \"program\" === e.type || \"class\" === e.type,\n  },\n  _ = new Map();\nasync function getLanguage(e) {\n  const t = languageIdToWasmLanguage(e);\n  if (!_.has(t)) {\n    const e = await (async function (e) {\n      await o.init();\n      const t = r.resolve(__dirname, \"..\", \"dist\", `tree-sitter-${e}.wasm`);\n      return i.Language.load(t);\n    })(t);\n    _.set(t, e);\n  }\n  return _.get(t);\n}\nasync function parseTree(e, t) {\n  let n = await getLanguage(e);\n  const r = new o();\n  r.setLanguage(n);\n  const i = r.parse(t);\n  r.delete();\n  return i;\n}\nfunction b(e, t) {\n  const n = [];\n  for (const r of e) {\n    if (!r[1]) {\n      const e = t.tree.getLanguage();\n      r[1] = e.query(r[0]);\n    }\n    n.push(...r[1].matches(t));\n  }\n  return n;\n}\nfunction queryFunctions(e, t) {\n  return b(l[languageIdToWasmLanguage(e)], t);\n}\nexports.getLanguage = getLanguage;\nexports.parseTree = parseTree;\nexports.parsesWithoutError = async function (e, t) {\n  const n = await parseTree(e, t),\n    r = !n.rootNode.hasError();\n  n.delete();\n  return r;\n};\nexports.getBlockCloseToken = function (e) {\n  switch (languageIdToWasmLanguage(e)) {\n    case s.Python:\n      return null;\n    case s.JavaScript:\n    case s.TypeScript:\n    case s.Go:\n      return \"}\";\n    case s.Ruby:\n      return \"end\";\n  }\n};\nexports.queryFunctions = queryFunctions;\nexports.queryImports = function (e, t) {\n  return b(p[languageIdToWasmLanguage(e)], t);\n};\nexports.queryExports = function (e, t) {\n  return b(h[languageIdToWasmLanguage(e)], t);\n};\nexports.queryGlobalVars = function (e, t) {\n  return b(f[languageIdToWasmLanguage(e)], t);\n};\nconst x = [\n  \"[\\n    (class_definition (block (expression_statement (string))))\\n    (function_definition (block (expression_statement (string))))\\n]\",\n];\nfunction isFunction(e, t) {\n  return m[languageIdToWasmLanguage(e)].has(t.type);\n}\nexports.queryPythonIsDocstring = function (e) {\n  return 1 == b([x], e).length;\n};\nexports.getAncestorWithSiblingFunctions = function (e, t) {\n  const n = g[languageIdToWasmLanguage(e)];\n  for (; t.parent; ) {\n    if (n(t.parent)) return t;\n    t = t.parent;\n  }\n  return t.parent ? t : null;\n};\nexports.isFunction = isFunction;\nexports.isFunctionDefinition = function (e, t) {\n  switch (languageIdToWasmLanguage(e)) {\n    case s.Python:\n    case s.Go:\n    case s.Ruby:\n      return isFunction(e, t);\n    case s.JavaScript:\n    case s.TypeScript:\n      if (\n        \"function_declaration\" === t.type ||\n        \"generator_function_declaration\" === t.type ||\n        \"method_definition\" === t.type\n      )\n        return !0;\n      if (\n        \"lexical_declaration\" === t.type ||\n        \"variable_declaration\" === t.type\n      ) {\n        if (t.namedChildCount > 1) return !1;\n        let n = t.namedChild(0);\n        if (null == n) return !1;\n        let r = n.namedChild(1);\n        return null !== r && isFunction(e, r);\n      }\n      if (\"expression_statement\" === t.type) {\n        let n = t.namedChild(0);\n        if (\"assignment_expression\" === (null == n ? undefined : n.type)) {\n          let t = n.namedChild(1);\n          return null !== t && isFunction(e, t);\n        }\n      }\n      return !1;\n  }\n};\nexports.getFirstPrecedingComment = function (e) {\n  var t;\n  let n = e;\n  for (\n    ;\n    \"comment\" ===\n    (null === (t = n.previousSibling) || undefined === t ? undefined : t.type);\n\n  ) {\n    let e = n.previousSibling;\n    if (e.endPosition.row < n.startPosition.row - 1) break;\n    n = e;\n  }\n  return \"comment\" === (null == n ? undefined : n.type) ? n : null;\n};\nexports.getFunctionPositions = async function (e, t) {\n  return queryFunctions(e, (await parseTree(e, t)).rootNode).map((e) => {\n    const t = e.captures.find((e) => \"function\" === e.name).node;\n    return {\n      startIndex: t.startIndex,\n      endIndex: t.endIndex,\n    };\n  });\n};",
  "3055312": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getPrompt =\n  exports.newLineEnded =\n  exports.normalizeLanguageId =\n  exports.PromptOptions =\n  exports.SuffixStartMode =\n  exports.SuffixMatchOption =\n  exports.SuffixOption =\n  exports.LineEndingOptions =\n  exports.LocalImportContextOption =\n  exports.SnippetSelectionOption =\n  exports.NeighboringTabsPositionOption =\n  exports.NeighboringTabsOption =\n  exports.SiblingOption =\n  exports.PathMarkerOption =\n  exports.LanguageMarkerOption =\n  exports.TOKENS_RESERVED_FOR_SUFFIX_ENCODING =\n  exports.MAX_EDIT_DISTANCE_LENGTH =\n  exports.MAX_PROMPT_LENGTH =\n    undefined;\nconst r = require(3055417),\n  o = require(3055179),\n  i = require(3055125),\n  s = require(3055670),\n  a = require(305594),\n  c = require(3055456),\n  l = require(3055395);\nlet u = {\n  text: \"\",\n  tokens: [],\n};\nvar d, p, h, f, m, g, _, y, v, b, w;\nexports.MAX_PROMPT_LENGTH = 1500;\nexports.MAX_EDIT_DISTANCE_LENGTH = 50;\nexports.TOKENS_RESERVED_FOR_SUFFIX_ENCODING = 5;\n(function (e) {\n  e.NoMarker = \"nomarker\";\n  e.Top = \"top\";\n  e.Always = \"always\";\n})((d = exports.LanguageMarkerOption || (exports.LanguageMarkerOption = {})));\n(function (e) {\n  e.NoMarker = \"nomarker\";\n  e.Top = \"top\";\n  e.Always = \"always\";\n})((p = exports.PathMarkerOption || (exports.PathMarkerOption = {})));\n(function (e) {\n  e.NoSiblings = \"nosiblings\";\n  e.SiblingsOverContext = \"siblingabove\";\n  e.ContextOverSiblings = \"contextabove\";\n})((h = exports.SiblingOption || (exports.SiblingOption = {})));\n(function (e) {\n  e.None = \"none\";\n  e.Conservative = \"conservative\";\n  e.Medium = \"medium\";\n  e.Eager = \"eager\";\n  e.EagerButLittle = \"eagerButLittle\";\n})((f = exports.NeighboringTabsOption || (exports.NeighboringTabsOption = {})));\n(function (e) {\n  e.TopOfText = \"top\";\n  e.DirectlyAboveCursor = \"aboveCursor\";\n  e.AfterSiblings = \"afterSiblings\";\n})(\n  (m =\n    exports.NeighboringTabsPositionOption ||\n    (exports.NeighboringTabsPositionOption = {}))\n);\n(function (e) {\n  e.BestMatch = \"bestMatch\";\n  e.TopK = \"topK\";\n})(\n  (g = exports.SnippetSelectionOption || (exports.SnippetSelectionOption = {}))\n);\n(function (e) {\n  e.NoContext = \"nocontext\";\n  e.Declarations = \"declarations\";\n})(\n  (_ =\n    exports.LocalImportContextOption || (exports.LocalImportContextOption = {}))\n);\n(function (e) {\n  e.ConvertToUnix = \"unix\";\n  e.KeepOriginal = \"keep\";\n})((y = exports.LineEndingOptions || (exports.LineEndingOptions = {})));\n(w = exports.SuffixOption || (exports.SuffixOption = {})).None = \"none\";\nw.FifteenPercent = \"fifteenPercent\";\n(function (e) {\n  e.Equal = \"equal\";\n  e.Levenshtein = \"levenshteineditdistance\";\n})((v = exports.SuffixMatchOption || (exports.SuffixMatchOption = {})));\n(function (e) {\n  e.Cursor = \"cursor\";\n  e.CursorTrimStart = \"cursortrimstart\";\n  e.SiblingBlock = \"siblingblock\";\n  e.SiblingBlockTrimStart = \"siblingblocktrimstart\";\n})((b = exports.SuffixStartMode || (exports.SuffixStartMode = {})));\nclass PromptOptions {\n  constructor(e, n) {\n    this.fs = e;\n    this.maxPromptLength = exports.MAX_PROMPT_LENGTH;\n    this.languageMarker = d.Top;\n    this.pathMarker = p.Top;\n    this.includeSiblingFunctions = h.ContextOverSiblings;\n    this.localImportContext = _.Declarations;\n    this.neighboringTabs = f.Eager;\n    this.neighboringTabsPosition = m.TopOfText;\n    this.lineEnding = y.ConvertToUnix;\n    this.suffixPercent = 0;\n    this.suffixStartMode = b.Cursor;\n    this.suffixMatchThreshold = 0;\n    this.suffixMatchCriteria = v.Levenshtein;\n    this.fimSuffixLengthThreshold = 0;\n    if (n) for (const e in n) this[e] = n[e];\n    if (this.suffixPercent < 0 || this.suffixPercent > 100)\n      throw new Error(\n        `suffixPercent must be between 0 and 100, but was ${this.suffixPercent}`\n      );\n    if (this.suffixPercent > 0 && this.includeSiblingFunctions != h.NoSiblings)\n      throw new Error(\n        `Invalid option combination. Cannot set suffixPercent > 0 (${this.suffixPercent}) and includeSiblingFunctions ${this.includeSiblingFunctions}`\n      );\n    if (this.suffixMatchThreshold < 0 || this.suffixMatchThreshold > 100)\n      throw new Error(\n        `suffixMatchThreshold must be at between 0 and 100, but was ${this.suffixMatchThreshold}`\n      );\n    if (this.fimSuffixLengthThreshold < -1)\n      throw new Error(\n        `fimSuffixLengthThreshold must be at least -1, but was ${this.fimSuffixLengthThreshold}`\n      );\n    if (\n      null != this.indentationMinLength &&\n      null != this.indentationMaxLength &&\n      this.indentationMinLength > this.indentationMaxLength\n    )\n      throw new Error(\n        `indentationMinLength must be less than or equal to indentationMaxLength, but was ${this.indentationMinLength} and ${this.indentationMaxLength}`\n      );\n    if (\n      this.snippetSelection === g.TopK &&\n      undefined === this.snippetSelectionK\n    )\n      throw new Error(\"snippetSelectionK must be defined.\");\n    if (\n      this.snippetSelection === g.TopK &&\n      this.snippetSelectionK &&\n      this.snippetSelectionK <= 0\n    )\n      throw new Error(\n        `snippetSelectionK must be greater than 0, but was ${this.snippetSelectionK}`\n      );\n  }\n}\nexports.PromptOptions = PromptOptions;\nconst E = {\n  javascriptreact: \"javascript\",\n  jsx: \"javascript\",\n  typescriptreact: \"typescript\",\n  jade: \"pug\",\n  cshtml: \"razor\",\n};\nfunction normalizeLanguageId(e) {\n  var t;\n  e = e.toLowerCase();\n  return null !== (t = E[e]) && undefined !== t ? t : e;\n}\nfunction newLineEnded(e) {\n  return \"\" == e || e.endsWith(\"\\n\") ? e : e + \"\\n\";\n}\nexports.normalizeLanguageId = normalizeLanguageId;\nexports.newLineEnded = newLineEnded;\nexports.getPrompt = async function (e, n, g = {}, y = []) {\n  var w;\n  const E = new PromptOptions(e, g);\n  let T = !1;\n  const { source: k, offset: I } = n;\n  if (I < 0 || I > k.length) throw new Error(`Offset ${I} is out of range.`);\n  n.languageId = normalizeLanguageId(n.languageId);\n  const P = new c.Priorities(),\n    A = P.justBelow(c.Priorities.TOP),\n    O =\n      E.languageMarker == d.Always\n        ? P.justBelow(c.Priorities.TOP)\n        : P.justBelow(A),\n    N =\n      E.pathMarker == p.Always ? P.justBelow(c.Priorities.TOP) : P.justBelow(A),\n    R =\n      E.includeSiblingFunctions == h.ContextOverSiblings\n        ? P.justBelow(A)\n        : P.justAbove(A),\n    M = P.justBelow(A, R),\n    L = P.justBelow(M),\n    $ = new c.PromptWishlist(E.lineEnding);\n  let D, F;\n  if (E.languageMarker != d.NoMarker) {\n    const e = newLineEnded(r.getLanguageMarker(n));\n    D = $.append(e, c.PromptElementKind.LanguageMarker, O);\n  }\n  if (E.pathMarker != p.NoMarker) {\n    const e = newLineEnded(r.getPathMarker(n));\n    if (e.length > 0) {\n      F = $.append(e, c.PromptElementKind.PathMarker, N);\n    }\n  }\n  if (E.localImportContext != _.NoContext)\n    for (const e of await o.extractLocalImportContext(n, E.fs))\n      $.append(newLineEnded(e), c.PromptElementKind.ImportedFile, M);\n  const j =\n    E.neighboringTabs == f.None || 0 == y.length\n      ? []\n      : await i.getNeighborSnippets(\n          n,\n          y,\n          E.neighboringTabs,\n          E.indentationMinLength,\n          E.indentationMaxLength,\n          E.snippetSelectionOption,\n          E.snippetSelectionK\n        );\n  function q() {\n    j.forEach((e) =>\n      $.append(\n        e.snippet,\n        c.PromptElementKind.SimilarFile,\n        L,\n        a.tokenLength(e.snippet),\n        e.score\n      )\n    );\n  }\n  if (E.neighboringTabsPosition == m.TopOfText) {\n    q();\n  }\n  const B = [];\n  let U;\n  if (E.includeSiblingFunctions == h.NoSiblings) U = k.substring(0, I);\n  else {\n    const {\n      siblings: e,\n      beforeInsertion: t,\n      afterInsertion: r,\n    } = await s.getSiblingFunctions(n);\n    $.appendLineForLine(t, c.PromptElementKind.BeforeCursor, A).forEach((e) =>\n      B.push(e)\n    );\n    let o = R;\n    e.forEach((e) => {\n      $.append(e, c.PromptElementKind.AfterCursor, o);\n      o = P.justBelow(o);\n    });\n    if (E.neighboringTabsPosition == m.AfterSiblings) {\n      q();\n    }\n    U = r;\n  }\n  if (E.neighboringTabsPosition == m.DirectlyAboveCursor) {\n    const e = U.lastIndexOf(\"\\n\") + 1,\n      t = U.substring(0, e),\n      n = U.substring(e);\n    $.appendLineForLine(t, c.PromptElementKind.BeforeCursor, A).forEach((e) =>\n      B.push(e)\n    );\n    q();\n    if (n.length > 0) {\n      B.push($.append(n, c.PromptElementKind.AfterCursor, A));\n      if (B.length > 1) {\n        $.require(B[B.length - 2], B[B.length - 1]);\n      }\n    }\n  } else\n    $.appendLineForLine(U, c.PromptElementKind.BeforeCursor, A).forEach((e) =>\n      B.push(e)\n    );\n  if (d.Top == E.languageMarker && B.length > 0 && undefined !== D) {\n    $.require(D, B[0]);\n  }\n  if (p.Top == E.pathMarker && B.length > 0 && undefined !== F) {\n    if (D) {\n      $.require(F, D);\n    } else {\n      $.require(F, B[0]);\n    }\n  }\n  if (undefined !== D && undefined !== F) {\n    $.exclude(F, D);\n  }\n  let H = k.slice(I);\n  if (0 == E.suffixPercent || H.length <= E.fimSuffixLengthThreshold)\n    return $.fulfill(E.maxPromptLength);\n  {\n    let e = n.offset;\n    if (\n      E.suffixStartMode !== b.Cursor &&\n      E.suffixStartMode !== b.CursorTrimStart\n    ) {\n      e = await s.getSiblingFunctionStart(n);\n    }\n    const r = E.maxPromptLength - exports.TOKENS_RESERVED_FOR_SUFFIX_ENCODING;\n    let o = Math.floor((r * (100 - E.suffixPercent)) / 100),\n      i = $.fulfill(o);\n    const c = r - i.prefixLength;\n    let d = k.slice(e);\n    if (\n      E.suffixStartMode != b.SiblingBlockTrimStart &&\n      E.suffixStartMode != b.CursorTrimStart\n    ) {\n      d = d.trimStart();\n    }\n    const p = a.takeFirstTokens(d, c);\n    if (p.tokens.length <= c - 3) {\n      o = r - p.tokens.length;\n      i = $.fulfill(o);\n    }\n    if (E.suffixMatchCriteria == v.Equal) {\n      if (\n        p.tokens.length === u.tokens.length &&\n        p.tokens.every((e, t) => e === u.tokens[t])\n      ) {\n        T = !0;\n      }\n    } else {\n      if (\n        E.suffixMatchCriteria == v.Levenshtein &&\n        p.tokens.length > 0 &&\n        E.suffixMatchThreshold > 0 &&\n        100 *\n          (null ===\n            (w = l.findEditDistanceScore(\n              p.tokens.slice(0, exports.MAX_EDIT_DISTANCE_LENGTH),\n              u.tokens.slice(0, exports.MAX_EDIT_DISTANCE_LENGTH)\n            )) || undefined === w\n            ? undefined\n            : w.score) <\n          E.suffixMatchThreshold *\n            Math.min(exports.MAX_EDIT_DISTANCE_LENGTH, p.tokens.length)\n      ) {\n        T = !0;\n      }\n    }\n    if (!0 === T && u.tokens.length <= c) {\n      if (u.tokens.length <= c - 3) {\n        o = r - u.tokens.length;\n        i = $.fulfill(o);\n      }\n      i.suffix = u.text;\n      i.suffixLength = u.tokens.length;\n    } else {\n      i.suffix = p.text;\n      i.suffixLength = p.tokens.length;\n      u = p;\n    }\n    return i;\n  }\n};",
  "3055395": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.findEditDistanceScore = undefined;\nconst r = require(305594);\nexports.findEditDistanceScore = function (e, t) {\n  if (\"string\" == typeof e) {\n    e = r.tokenize(e);\n  }\n  if (\"string\" == typeof t) {\n    t = r.tokenize(t);\n  }\n  if (0 === e.length || 0 === t.length)\n    return {\n      score: e.length + t.length,\n    };\n  const n = Array.from({\n    length: e.length,\n  }).map(() =>\n    Array.from({\n      length: t.length,\n    }).map(() => 0)\n  );\n  for (let t = 0; t < e.length; t++) n[t][0] = t;\n  for (let e = 0; e < t.length; e++) n[0][e] = e;\n  for (let r = 0; r < t.length; r++)\n    for (let o = 0; o < e.length; o++)\n      n[o][r] = Math.min(\n        (0 == o ? r : n[o - 1][r]) + 1,\n        (0 == r ? o : n[o][r - 1]) + 1,\n        (0 == o || 0 == r ? Math.max(o, r) : n[o - 1][r - 1]) +\n          (e[o] == t[r] ? 0 : 1)\n      );\n  return {\n    score: n[e.length - 1][t.length - 1],\n  };\n};",
  "3055404": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.computeScore =\n  exports.IndentationBasedJaccardMatcher =\n  exports.FixedWindowSizeJaccardMatcher =\n    undefined;\nconst r = require(3055250),\n  o = require(3055467);\nclass FixedWindowSizeJaccardMatcher extends o.WindowedMatcher {\n  constructor(e, t) {\n    super(e);\n    this.windowLength = t;\n  }\n  id() {\n    return \"fixed:\" + this.windowLength;\n  }\n  getWindowsDelineations(e) {\n    const t = [],\n      n = e.length;\n    for (let e = 0; 0 == e || e < n - this.windowLength; e++) {\n      const r = Math.min(e + this.windowLength, n);\n      t.push([e, r]);\n    }\n    return t;\n  }\n  trimDocument(e) {\n    return e.source\n      .slice(0, e.offset)\n      .split(\"\\n\")\n      .slice(-this.windowLength)\n      .join(\"\\n\");\n  }\n  similarityScore(e, t) {\n    return computeScore(e, t);\n  }\n}\nexports.FixedWindowSizeJaccardMatcher = FixedWindowSizeJaccardMatcher;\nFixedWindowSizeJaccardMatcher.FACTORY = (e) => ({\n  to: (t) => new FixedWindowSizeJaccardMatcher(t, e),\n});\nclass IndentationBasedJaccardMatcher extends o.WindowedMatcher {\n  constructor(e, t, n) {\n    super(e);\n    this.indentationMinLength = t;\n    this.indentationMaxLength = n;\n    this.languageId = e.languageId;\n  }\n  id() {\n    return `indent:${this.indentationMinLength}:${this.indentationMaxLength}:${this.languageId}`;\n  }\n  getWindowsDelineations(e) {\n    return r.getWindowsDelineations(\n      e,\n      this.languageId,\n      this.indentationMinLength,\n      this.indentationMaxLength\n    );\n  }\n  trimDocument(e) {\n    return e.source\n      .slice(0, e.offset)\n      .split(\"\\n\")\n      .slice(-this.indentationMaxLength)\n      .join(\"\\n\");\n  }\n  similarityScore(e, t) {\n    return computeScore(e, t);\n  }\n}\nfunction computeScore(e, t) {\n  const n = new Set();\n  e.forEach((e) => {\n    if (t.has(e)) {\n      n.add(e);\n    }\n  });\n  return n.size / (e.size + t.size - n.size);\n}\nexports.IndentationBasedJaccardMatcher = IndentationBasedJaccardMatcher;\nIndentationBasedJaccardMatcher.FACTORY = (e, t) => ({\n  to: (n) => new IndentationBasedJaccardMatcher(n, e, t),\n});\nexports.computeScore = computeScore;",
  "3055417": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getPathMarker =\n  exports.getLanguageMarker =\n  exports.comment =\n  exports.hasLanguageMarker =\n  exports.languageCommentMarkers =\n    undefined;\nexports.languageCommentMarkers = {\n  abap: {\n    start: '\"',\n    end: \"\",\n  },\n  bat: {\n    start: \"REM\",\n    end: \"\",\n  },\n  bibtex: {\n    start: \"%\",\n    end: \"\",\n  },\n  blade: {\n    start: \"#\",\n    end: \"\",\n  },\n  c: {\n    start: \"//\",\n    end: \"\",\n  },\n  clojure: {\n    start: \";\",\n    end: \"\",\n  },\n  coffeescript: {\n    start: \"//\",\n    end: \"\",\n  },\n  cpp: {\n    start: \"//\",\n    end: \"\",\n  },\n  csharp: {\n    start: \"//\",\n    end: \"\",\n  },\n  css: {\n    start: \"/*\",\n    end: \"*/\",\n  },\n  dart: {\n    start: \"//\",\n    end: \"\",\n  },\n  dockerfile: {\n    start: \"#\",\n    end: \"\",\n  },\n  elixir: {\n    start: \"#\",\n    end: \"\",\n  },\n  erb: {\n    start: \"<%#\",\n    end: \"%>\",\n  },\n  erlang: {\n    start: \"%\",\n    end: \"\",\n  },\n  fsharp: {\n    start: \"//\",\n    end: \"\",\n  },\n  go: {\n    start: \"//\",\n    end: \"\",\n  },\n  groovy: {\n    start: \"//\",\n    end: \"\",\n  },\n  haml: {\n    start: \"-#\",\n    end: \"\",\n  },\n  handlebars: {\n    start: \"{{!\",\n    end: \"}}\",\n  },\n  haskell: {\n    start: \"--\",\n    end: \"\",\n  },\n  html: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\",\n  },\n  ini: {\n    start: \";\",\n    end: \"\",\n  },\n  java: {\n    start: \"//\",\n    end: \"\",\n  },\n  javascript: {\n    start: \"//\",\n    end: \"\",\n  },\n  javascriptreact: {\n    start: \"//\",\n    end: \"\",\n  },\n  jsonc: {\n    start: \"//\",\n    end: \"\",\n  },\n  jsx: {\n    start: \"//\",\n    end: \"\",\n  },\n  julia: {\n    start: \"#\",\n    end: \"\",\n  },\n  kotlin: {\n    start: \"//\",\n    end: \"\",\n  },\n  latex: {\n    start: \"%\",\n    end: \"\",\n  },\n  less: {\n    start: \"//\",\n    end: \"\",\n  },\n  lua: {\n    start: \"--\",\n    end: \"\",\n  },\n  makefile: {\n    start: \"#\",\n    end: \"\",\n  },\n  markdown: {\n    start: \"[]: #\",\n    end: \"\",\n  },\n  \"objective-c\": {\n    start: \"//\",\n    end: \"\",\n  },\n  \"objective-cpp\": {\n    start: \"//\",\n    end: \"\",\n  },\n  perl: {\n    start: \"#\",\n    end: \"\",\n  },\n  php: {\n    start: \"//\",\n    end: \"\",\n  },\n  powershell: {\n    start: \"#\",\n    end: \"\",\n  },\n  pug: {\n    start: \"//\",\n    end: \"\",\n  },\n  python: {\n    start: \"#\",\n    end: \"\",\n  },\n  ql: {\n    start: \"//\",\n    end: \"\",\n  },\n  r: {\n    start: \"#\",\n    end: \"\",\n  },\n  razor: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\",\n  },\n  ruby: {\n    start: \"#\",\n    end: \"\",\n  },\n  rust: {\n    start: \"//\",\n    end: \"\",\n  },\n  sass: {\n    start: \"//\",\n    end: \"\",\n  },\n  scala: {\n    start: \"//\",\n    end: \"\",\n  },\n  scss: {\n    start: \"//\",\n    end: \"\",\n  },\n  shellscript: {\n    start: \"#\",\n    end: \"\",\n  },\n  slim: {\n    start: \"/\",\n    end: \"\",\n  },\n  solidity: {\n    start: \"//\",\n    end: \"\",\n  },\n  sql: {\n    start: \"--\",\n    end: \"\",\n  },\n  stylus: {\n    start: \"//\",\n    end: \"\",\n  },\n  svelte: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\",\n  },\n  swift: {\n    start: \"//\",\n    end: \"\",\n  },\n  terraform: {\n    start: \"#\",\n    end: \"\",\n  },\n  tex: {\n    start: \"%\",\n    end: \"\",\n  },\n  typescript: {\n    start: \"//\",\n    end: \"\",\n  },\n  typescriptreact: {\n    start: \"//\",\n    end: \"\",\n  },\n  vb: {\n    start: \"'\",\n    end: \"\",\n  },\n  verilog: {\n    start: \"//\",\n    end: \"\",\n  },\n  \"vue-html\": {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\",\n  },\n  vue: {\n    start: \"//\",\n    end: \"\",\n  },\n  xml: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\",\n  },\n  xsl: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\",\n  },\n  yaml: {\n    start: \"#\",\n    end: \"\",\n  },\n};\nconst n = [\"php\", \"plaintext\"],\n  r = {\n    html: \"<!DOCTYPE html>\",\n    python: \"#!/usr/bin/env python3\",\n    ruby: \"#!/usr/bin/env ruby\",\n    shellscript: \"#!/bin/sh\",\n    yaml: \"# YAML data\",\n  };\nfunction hasLanguageMarker({ source: e }) {\n  return e.startsWith(\"#!\") || e.startsWith(\"<!DOCTYPE\");\n}\nfunction comment(e, n) {\n  const r = exports.languageCommentMarkers[n];\n  if (r) {\n    const t = \"\" == r.end ? \"\" : \" \" + r.end;\n    return `${r.start} ${e}${t}`;\n  }\n  return \"\";\n}\nexports.hasLanguageMarker = hasLanguageMarker;\nexports.comment = comment;\nexports.getLanguageMarker = function (e) {\n  const { languageId: t } = e;\n  return -1 !== n.indexOf(t) || hasLanguageMarker(e)\n    ? \"\"\n    : t in r\n    ? r[t]\n    : comment(`Language: ${t}`, t);\n};\nexports.getPathMarker = function (e) {\n  return e.relativePath ? comment(`Path: ${e.relativePath}`, e.languageId) : \"\";\n};",
  "3055456": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.Priorities =\n  exports.PromptWishlist =\n  exports.PromptElementRanges =\n  exports.PromptChoices =\n  exports.PromptBackground =\n  exports.PromptElementKind =\n    undefined;\nconst r = require(3055312),\n  o = require(305594);\nvar i;\n!(function (e) {\n  e.BeforeCursor = \"BeforeCursor\";\n  e.AfterCursor = \"AfterCursor\";\n  e.SimilarFile = \"SimilarFile\";\n  e.ImportedFile = \"ImportedFile\";\n  e.LanguageMarker = \"LanguageMarker\";\n  e.PathMarker = \"PathMarker\";\n})((i = exports.PromptElementKind || (exports.PromptElementKind = {})));\nclass PromptBackground {\n  constructor() {\n    this.used = new Map();\n    this.unused = new Map();\n  }\n  markUsed(e) {\n    if (this.IsNeighboringTab(e)) {\n      this.used.set(e.id, this.convert(e));\n    }\n  }\n  undoMarkUsed(e) {\n    if (this.IsNeighboringTab(e)) {\n      this.used.delete(e.id);\n    }\n  }\n  markUnused(e) {\n    if (this.IsNeighboringTab(e)) {\n      this.unused.set(e.id, this.convert(e));\n    }\n  }\n  convert(e) {\n    return {\n      score: e.score.toFixed(4),\n      length: e.text.length,\n    };\n  }\n  IsNeighboringTab(e) {\n    return e.kind == i.SimilarFile;\n  }\n}\nexports.PromptBackground = PromptBackground;\nclass PromptChoices {\n  constructor() {\n    this.used = new Map();\n    this.unused = new Map();\n  }\n  markUsed(e) {\n    this.used.set(e.kind, (this.used.get(e.kind) || 0) + e.tokens);\n  }\n  undoMarkUsed(e) {\n    this.used.set(e.kind, (this.used.get(e.kind) || 0) - e.tokens);\n  }\n  markUnused(e) {\n    this.unused.set(e.kind, (this.used.get(e.kind) || 0) + e.tokens);\n  }\n}\nexports.PromptChoices = PromptChoices;\nclass PromptElementRanges {\n  constructor(e) {\n    this.ranges = new Array();\n    let t,\n      n = 0;\n    for (const { element: r } of e)\n      if (0 !== r.text.length) {\n        if (t === i.BeforeCursor && r.kind === i.BeforeCursor) {\n          this.ranges[this.ranges.length - 1].end += r.text.length;\n        } else {\n          this.ranges.push({\n            kind: r.kind,\n            start: n,\n            end: n + r.text.length,\n          });\n        }\n        t = r.kind;\n        n += r.text.length;\n      }\n  }\n}\nexports.PromptElementRanges = PromptElementRanges;\nexports.PromptWishlist = class {\n  constructor(e) {\n    this.content = [];\n    this.lineEndingOption = e;\n  }\n  getContent() {\n    return [...this.content];\n  }\n  convertLineEndings(e) {\n    if (this.lineEndingOption === r.LineEndingOptions.ConvertToUnix) {\n      e = e.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n    }\n    return e;\n  }\n  append(e, t, n, r = o.tokenLength(e), i = NaN) {\n    e = this.convertLineEndings(e);\n    const s = this.content.length;\n    this.content.push({\n      id: s,\n      text: e,\n      kind: t,\n      priority: n,\n      tokens: r,\n      requires: [],\n      excludes: [],\n      score: i,\n    });\n    return s;\n  }\n  appendLineForLine(e, t, n) {\n    const r = (e = this.convertLineEndings(e)).split(\"\\n\");\n    for (let e = 0; e < r.length - 1; e++) r[e] += \"\\n\";\n    const o = [];\n    r.forEach((e, t) => {\n      if (\"\\n\" === e && o.length > 0 && !o[o.length - 1].endsWith(\"\\n\\n\")) {\n        o[o.length - 1] += \"\\n\";\n      } else {\n        o.push(e);\n      }\n    });\n    const i = [];\n    o.forEach((e, r) => {\n      if (\"\" !== e) {\n        i.push(this.append(e, t, n));\n        if (r > 0) {\n          this.content[this.content.length - 2].requires = [\n            this.content[this.content.length - 1],\n          ];\n        }\n      }\n    });\n    return i;\n  }\n  require(e, t) {\n    const n = this.content.find((t) => t.id === e),\n      r = this.content.find((e) => e.id === t);\n    if (n && r) {\n      n.requires.push(r);\n    }\n  }\n  exclude(e, t) {\n    const n = this.content.find((t) => t.id === e),\n      r = this.content.find((e) => e.id === t);\n    if (n && r) {\n      n.excludes.push(r);\n    }\n  }\n  fulfill(e) {\n    const t = new PromptChoices(),\n      n = new PromptBackground(),\n      r = this.content.map((e, t) => ({\n        element: e,\n        index: t,\n      }));\n    r.sort((e, t) =>\n      e.element.priority === t.element.priority\n        ? t.index - e.index\n        : t.element.priority - e.element.priority\n    );\n    const i = new Set(),\n      l = new Set();\n    let u;\n    const d = [];\n    let p = e;\n    r.forEach((e) => {\n      var r;\n      const o = e.element,\n        s = e.index;\n      if (\n        p >= 0 &&\n        (p > 0 || undefined === u) &&\n        o.requires.every((e) => i.has(e.id)) &&\n        !l.has(o.id)\n      ) {\n        let a = o.tokens;\n        const c =\n          null ===\n            (r = (function (e, t) {\n              let n,\n                r = 1 / 0;\n              for (const o of e)\n                if (o.index > t && o.index < r) {\n                  n = o;\n                  r = o.index;\n                }\n              return n;\n            })(d, s)) || undefined === r\n            ? undefined\n            : r.element;\n        if (o.text.endsWith(\"\\n\\n\") && c && !c.text.match(/^\\s/)) {\n          a++;\n        }\n        if (p >= a) {\n          p -= a;\n          i.add(o.id);\n          o.excludes.forEach((e) => l.add(e.id));\n          t.markUsed(o);\n          n.markUsed(o);\n          d.push(e);\n        } else {\n          u = null != u ? u : e;\n        }\n      } else {\n        t.markUnused(o);\n        n.markUnused(o);\n      }\n    });\n    d.sort((e, t) => e.index - t.index);\n    let h = d.reduce((e, t) => e + t.element.text, \"\"),\n      f = o.tokenLength(h);\n    for (; f > e; ) {\n      d.sort((e, t) =>\n        t.element.priority === e.element.priority\n          ? t.index - e.index\n          : t.element.priority - e.element.priority\n      );\n      const e = d.pop();\n      if (e) {\n        t.undoMarkUsed(e.element);\n        t.markUnused(e.element);\n        n.undoMarkUsed(e.element);\n        n.markUnused(e.element);\n        u = undefined;\n      }\n      d.sort((e, t) => e.index - t.index);\n      h = d.reduce((e, t) => e + t.element.text, \"\");\n      f = o.tokenLength(h);\n    }\n    const m = [...d];\n    if (undefined !== u) {\n      m.push(u);\n      m.sort((e, t) => e.index - t.index);\n      const r = m.reduce((e, t) => e + t.element.text, \"\"),\n        i = o.tokenLength(r);\n      if (i <= e) {\n        t.markUsed(u.element);\n        n.markUsed(u.element);\n        const e = new PromptElementRanges(m);\n        return {\n          prefix: r,\n          suffix: \"\",\n          prefixLength: i,\n          suffixLength: 0,\n          promptChoices: t,\n          promptBackground: n,\n          promptElementRanges: e,\n        };\n      }\n      t.markUnused(u.element);\n      n.markUnused(u.element);\n    }\n    const g = new PromptElementRanges(d);\n    return {\n      prefix: h,\n      suffix: \"\",\n      prefixLength: f,\n      suffixLength: 0,\n      promptChoices: t,\n      promptBackground: n,\n      promptElementRanges: g,\n    };\n  }\n};\nclass Priorities {\n  constructor() {\n    this.registeredPriorities = [0, 1];\n  }\n  register(e) {\n    if (e > Priorities.TOP || e < Priorities.BOTTOM)\n      throw new Error(\"Priority must be between 0 and 1\");\n    this.registeredPriorities.push(e);\n    return e;\n  }\n  justAbove(...e) {\n    const t = Math.max(...e),\n      n = Math.min(...this.registeredPriorities.filter((e) => e > t));\n    return this.register((n + t) / 2);\n  }\n  justBelow(...e) {\n    const t = Math.min(...e),\n      n = Math.max(...this.registeredPriorities.filter((e) => e < t));\n    return this.register((n + t) / 2);\n  }\n  between(e, t) {\n    if (\n      this.registeredPriorities.some((n) => n > e && n < t) ||\n      !this.registeredPriorities.includes(e) ||\n      !this.registeredPriorities.includes(t)\n    )\n      throw new Error(\"Priorities must be adjacent in the list of priorities\");\n    return this.register((e + t) / 2);\n  }\n}\nexports.Priorities = Priorities;\nPriorities.TOP = 1;\nPriorities.BOTTOM = 0;",
  "3055467": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.splitIntoWords =\n  exports.WindowedMatcher =\n  exports.SortOptions =\n    undefined;\nconst r = require(3055312);\nvar o;\n!(function (e) {\n  e.Ascending = \"ascending\";\n  e.Descending = \"descending\";\n  e.None = \"none\";\n})((o = exports.SortOptions || (exports.SortOptions = {})));\nclass i {\n  constructor(e) {\n    var t;\n    this.stopsForLanguage =\n      null !== (t = u.get(e.languageId)) && undefined !== t ? t : l;\n  }\n  tokenize(e) {\n    return new Set(\n      splitIntoWords(e).filter((e) => !this.stopsForLanguage.has(e))\n    );\n  }\n}\nconst s = new (class {\n  constructor(e) {\n    this.keys = [];\n    this.cache = {};\n    this.size = e;\n  }\n  put(e, t) {\n    var n;\n    this.cache[e] = t;\n    if (this.keys.length > this.size) {\n      this.keys.push(e);\n      const t = null !== (n = this.keys.shift()) && void 0 !== n ? n : \"\";\n      delete this.cache[t];\n    }\n  }\n  get(e) {\n    return this.cache[e];\n  }\n})(20);\nfunction splitIntoWords(e) {\n  return e.split(/[^a-zA-Z0-9]/).filter((e) => e.length > 0);\n}\nexports.WindowedMatcher = class {\n  constructor(e) {\n    this.tokenizer = new i(e);\n    this.referenceTokens = this.tokenizer.tokenize(this.trimDocument(e));\n  }\n  sortScoredSnippets(e, t = o.Descending) {\n    return t == o.Ascending\n      ? e.sort((e, t) => (e.score > t.score ? 1 : -1))\n      : t == o.Descending\n      ? e.sort((e, t) => (e.score > t.score ? -1 : 1))\n      : e;\n  }\n  retrieveAllSnippets(e, t = o.Descending) {\n    var n;\n    const r = [];\n    if (0 === e.source.length || 0 === this.referenceTokens.size) return r;\n    const i = e.source.split(\"\\n\"),\n      a = this.id() + \":\" + e.source,\n      c = null !== (n = s.get(a)) && undefined !== n ? n : [],\n      l = 0 == c.length,\n      u = l ? i.map(this.tokenizer.tokenize, this.tokenizer) : [];\n    for (const [e, [t, n]] of this.getWindowsDelineations(i).entries()) {\n      if (l) {\n        const e = new Set();\n        u.slice(t, n).forEach((t) => t.forEach(e.add, e));\n        c.push(e);\n      }\n      const o = c[e],\n        i = this.similarityScore(o, this.referenceTokens);\n      r.push({\n        score: i,\n        startLine: t,\n        endLine: n,\n      });\n    }\n    if (l) {\n      s.put(a, c);\n    }\n    return this.sortScoredSnippets(r, t);\n  }\n  findMatches(e, t = r.SnippetSelectionOption.BestMatch, n) {\n    if (t == r.SnippetSelectionOption.BestMatch) {\n      const t = this.findBestMatch(e);\n      return t ? [t] : [];\n    }\n    return (\n      (t == r.SnippetSelectionOption.TopK && this.findTopKMatches(e, n)) || []\n    );\n  }\n  findBestMatch(e) {\n    if (0 === e.source.length || 0 === this.referenceTokens.size) return;\n    const t = e.source.split(\"\\n\"),\n      n = this.retrieveAllSnippets(e, o.Descending);\n    return 0 !== n.length && 0 !== n[0].score\n      ? {\n          snippet: t.slice(n[0].startLine, n[0].endLine).join(\"\\n\"),\n          ...n[0],\n        }\n      : undefined;\n  }\n  findTopKMatches(e, t = 1) {\n    if (0 === e.source.length || 0 === this.referenceTokens.size || t < 1)\n      return;\n    const n = e.source.split(\"\\n\"),\n      r = this.retrieveAllSnippets(e, o.Descending);\n    if (0 === r.length || 0 === r[0].score) return;\n    const i = [r[0]];\n    for (let e = 1; e < r.length && i.length < t; e++)\n      if (\n        -1 ==\n        i.findIndex(\n          (t) => r[e].startLine < t.endLine && r[e].endLine > t.startLine\n        )\n      ) {\n        i.push(r[e]);\n      }\n    return i.map((e) => ({\n      snippet: n.slice(e.startLine, e.endLine).join(\"\\n\"),\n      ...e,\n    }));\n  }\n};\nexports.splitIntoWords = splitIntoWords;\nconst c = new Set([\n    \"we\",\n    \"our\",\n    \"you\",\n    \"it\",\n    \"its\",\n    \"they\",\n    \"them\",\n    \"their\",\n    \"this\",\n    \"that\",\n    \"these\",\n    \"those\",\n    \"is\",\n    \"are\",\n    \"was\",\n    \"were\",\n    \"be\",\n    \"been\",\n    \"being\",\n    \"have\",\n    \"has\",\n    \"had\",\n    \"having\",\n    \"do\",\n    \"does\",\n    \"did\",\n    \"doing\",\n    \"can\",\n    \"don\",\n    \"t\",\n    \"s\",\n    \"will\",\n    \"would\",\n    \"should\",\n    \"what\",\n    \"which\",\n    \"who\",\n    \"when\",\n    \"where\",\n    \"why\",\n    \"how\",\n    \"a\",\n    \"an\",\n    \"the\",\n    \"and\",\n    \"or\",\n    \"not\",\n    \"no\",\n    \"but\",\n    \"because\",\n    \"as\",\n    \"until\",\n    \"again\",\n    \"further\",\n    \"then\",\n    \"once\",\n    \"here\",\n    \"there\",\n    \"all\",\n    \"any\",\n    \"both\",\n    \"each\",\n    \"few\",\n    \"more\",\n    \"most\",\n    \"other\",\n    \"some\",\n    \"such\",\n    \"above\",\n    \"below\",\n    \"to\",\n    \"during\",\n    \"before\",\n    \"after\",\n    \"of\",\n    \"at\",\n    \"by\",\n    \"about\",\n    \"between\",\n    \"into\",\n    \"through\",\n    \"from\",\n    \"up\",\n    \"down\",\n    \"in\",\n    \"out\",\n    \"on\",\n    \"off\",\n    \"over\",\n    \"under\",\n    \"only\",\n    \"own\",\n    \"same\",\n    \"so\",\n    \"than\",\n    \"too\",\n    \"very\",\n    \"just\",\n    \"now\",\n  ]),\n  l = new Set([\n    \"if\",\n    \"then\",\n    \"else\",\n    \"for\",\n    \"while\",\n    \"with\",\n    \"def\",\n    \"function\",\n    \"return\",\n    \"TODO\",\n    \"import\",\n    \"try\",\n    \"catch\",\n    \"raise\",\n    \"finally\",\n    \"repeat\",\n    \"switch\",\n    \"case\",\n    \"match\",\n    \"assert\",\n    \"continue\",\n    \"break\",\n    \"const\",\n    \"class\",\n    \"enum\",\n    \"struct\",\n    \"static\",\n    \"new\",\n    \"super\",\n    \"this\",\n    \"var\",\n    ...c,\n  ]),\n  u = new Map([]);",
  "3055469": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.parseTree =\n  exports.registerLanguageSpecificParser =\n  exports.flattenVirtual =\n  exports.groupBlocks =\n  exports.combineClosersAndOpeners =\n  exports.buildLabelRules =\n  exports.labelVirtualInherited =\n  exports.labelLines =\n  exports.parseRaw =\n    undefined;\nconst r = require(3055876),\n  o = require(3055617);\nfunction parseRaw(e) {\n  const t = e.split(\"\\n\"),\n    n = t.map((e) => e.match(/^\\s*/)[0].length),\n    o = t.map((e) => e.trimLeft());\n  function i(e) {\n    const [t, i] = s(e + 1, n[e]);\n    return [r.lineNode(n[e], e, o[e], t), i];\n  }\n  function s(e, t) {\n    let s;\n    const a = [];\n    let c,\n      l = e;\n    for (; l < o.length && (\"\" === o[l] || n[l] > t); )\n      if (\"\" === o[l]) {\n        if (undefined === c) {\n          c = l;\n        }\n        l += 1;\n      } else {\n        if (undefined !== c) {\n          for (let e = c; e < l; e++) a.push(r.blankNode(e));\n          c = undefined;\n        }\n        [s, l] = i(l);\n        a.push(s);\n      }\n    if (undefined !== c) {\n      l = c;\n    }\n    return [a, l];\n  }\n  const [a, c] = s(0, -1);\n  let l = c;\n  for (; l < o.length && \"\" === o[l]; ) {\n    a.push(r.blankNode(l));\n    l += 1;\n  }\n  if (l < o.length)\n    throw new Error(\n      `Parsing did not go to end of file. Ended at ${l} out of ${o.length}`\n    );\n  return r.topNode(a);\n}\nfunction labelLines(e, t) {\n  o.visitTree(\n    e,\n    function (e) {\n      if (r.isLine(e)) {\n        const n = t.find((t) => t.matches(e.sourceLine));\n        if (n) {\n          e.label = n.label;\n        }\n      }\n    },\n    \"bottomUp\"\n  );\n}\nfunction buildLabelRules(e) {\n  return Object.keys(e).map((t) => {\n    let n;\n    n = e[t].test ? (n) => e[t].test(n) : e[t];\n    return {\n      matches: n,\n      label: t,\n    };\n  });\n}\nfunction combineClosersAndOpeners(e) {\n  const t = o.rebuildTree(e, function (e) {\n    if (\n      0 === e.subs.length ||\n      -1 ===\n        e.subs.findIndex((e) => \"closer\" === e.label || \"opener\" === e.label)\n    )\n      return e;\n    const t = [];\n    let n;\n    for (let o = 0; o < e.subs.length; o++) {\n      const i = e.subs[o],\n        s = e.subs[o - 1];\n      if (\"opener\" === i.label && undefined !== s && r.isLine(s)) {\n        s.subs.push(i);\n        i.subs.forEach((e) => s.subs.push(e));\n        i.subs = [];\n      } else if (\n        \"closer\" === i.label &&\n        undefined !== n &&\n        (r.isLine(i) || r.isVirtual(i)) &&\n        i.indentation >= n.indentation\n      ) {\n        let e = t.length - 1;\n        for (; e > 0 && r.isBlank(t[e]); ) e -= 1;\n        n.subs.push(...t.splice(e + 1));\n        if (i.subs.length > 0) {\n          const e = n.subs.findIndex((e) => \"newVirtual\" !== e.label),\n            t = n.subs.slice(0, e),\n            o = n.subs.slice(e),\n            s =\n              o.length > 0\n                ? [r.virtualNode(i.indentation, o, \"newVirtual\")]\n                : [];\n          n.subs = [...t, ...s, i];\n        } else n.subs.push(i);\n      } else {\n        t.push(i);\n        if (r.isBlank(i)) {\n          n = i;\n        }\n      }\n    }\n    e.subs = t;\n    return e;\n  });\n  o.clearLabelsIf(e, (e) => \"newVirtual\" === e);\n  return t;\n}\nexports.parseRaw = parseRaw;\nexports.labelLines = labelLines;\nexports.labelVirtualInherited = function (e) {\n  o.visitTree(\n    e,\n    function (e) {\n      if (r.isVirtual(e) && undefined === e.label) {\n        const t = e.subs.filter((e) => !r.isBlank(e));\n        if (1 === t.length) {\n          e.label = t[0].label;\n        }\n      }\n    },\n    \"bottomUp\"\n  );\n};\nexports.buildLabelRules = buildLabelRules;\nexports.combineClosersAndOpeners = combineClosersAndOpeners;\nexports.groupBlocks = function (e, t = r.isBlank, n) {\n  return o.rebuildTree(e, function (e) {\n    if (e.subs.length <= 1) return e;\n    const o = [];\n    let i,\n      s = [],\n      a = !1;\n    function c(e = !1) {\n      if (undefined !== i && (o.length > 0 || !e)) {\n        const e = r.virtualNode(i, s, n);\n        o.push(e);\n      } else s.forEach((e) => o.push(e));\n    }\n    for (let n = 0; n < e.subs.length; n++) {\n      const o = e.subs[n],\n        l = t(o);\n      if (!l && a) {\n        c();\n        s = [];\n      }\n      a = l;\n      s.push(o);\n      if (r.isBlank(o)) {\n        i = null != i ? i : o.indentation;\n      }\n    }\n    c(!0);\n    e.subs = o;\n    return e;\n  });\n};\nexports.flattenVirtual = function (e) {\n  return o.rebuildTree(e, function (e) {\n    return r.isVirtual(e) && undefined === e.label && e.subs.length <= 1\n      ? 0 === e.subs.length\n        ? undefined\n        : e.subs[0]\n      : (1 === e.subs.length &&\n          r.isVirtual(e.subs[0]) &&\n          undefined === e.subs[0].label &&\n          (e.subs = e.subs[0].subs),\n        e);\n  });\n};\nconst l = buildLabelRules({\n    opener: /^[\\[({]/,\n    closer: /^[\\])}]/,\n  }),\n  u = {};\nexports.registerLanguageSpecificParser = function (e, t) {\n  u[e] = t;\n};\nexports.parseTree = function (e, t) {\n  const n = parseRaw(e),\n    r = u[null != t ? t : \"\"];\n  return r ? r(n) : (labelLines(n, l), combineClosersAndOpeners(n));\n};",
  "3055563": "var r =\n    (this && this.__createBinding) ||\n    (Object.create\n      ? function (e, t, n, r) {\n          if (undefined === r) {\n            r = n;\n          }\n          Object.defineProperty(e, r, {\n            enumerable: !0,\n            get: function () {\n              return t[n];\n            },\n          });\n        }\n      : function (e, t, n, r) {\n          if (undefined === r) {\n            r = n;\n          }\n          e[r] = t[n];\n        }),\n  o =\n    (this && this.__exportStar) ||\n    function (e, t) {\n      for (var n in e)\n        if (\"default\" === n || Object.prototype.hasOwnProperty.call(t, n)) {\n          r(t, e, n);\n        }\n    };\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.createWorker =\n  exports.FileSystem =\n  exports.comment =\n  exports.languageCommentMarkers =\n    undefined;\nconst i = require(\"path\"),\n  s = require(\"worker_threads\");\no(require(3055306), exports);\no(require(3055610), exports);\no(require(3055312), exports);\no(require(305594), exports);\nvar a = require(3055417);\nexports.languageCommentMarkers = a.languageCommentMarkers;\nexports.comment = a.comment;\nvar c = require(3055271);\nexports.FileSystem = c.FileSystem;\nexports.createWorker = function () {\n  return new s.Worker(i.resolve(__dirname, \"..\", \"dist\", \"worker.js\"));\n};",
  "3055610": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getNodeStart =\n  exports.isBlockBodyFinished =\n  exports.isEmptyBlockStart =\n  exports.getBlockParser =\n    undefined;\nconst r = require(3055306);\nclass o {\n  constructor(e, t, n) {\n    this.languageId = e;\n    this.nodeMatch = t;\n    this.nodeTypesWithBlockOrStmtChild = n;\n  }\n  async getNodeMatchAtPosition(e, t, n) {\n    const o = await r.parseTree(this.languageId, e);\n    try {\n      let e = o.rootNode.descendantForIndex(t);\n      for (; e; ) {\n        const t = this.nodeMatch[e.type];\n        if (t) {\n          if (!this.nodeTypesWithBlockOrStmtChild.has(e.type)) break;\n          const n = this.nodeTypesWithBlockOrStmtChild.get(e.type),\n            r = \"\" == n ? e.namedChildren[0] : e.childForFieldName(n);\n          if ((null == r ? undefined : r.type) == t) break;\n        }\n        e = e.parent;\n      }\n      if (!e) return;\n      return n(e);\n    } finally {\n      o.delete();\n    }\n  }\n  getNextBlockAtPosition(e, t, n) {\n    return this.getNodeMatchAtPosition(e, t, (e) => {\n      let t = e.children\n        .reverse()\n        .find((t) => t.type == this.nodeMatch[e.type]);\n      if (t) {\n        if (\"python\" == this.languageId && t.parent) {\n          const e = \":\" == t.parent.type ? t.parent.parent : t.parent;\n          let n = null == e ? undefined : e.nextSibling;\n          for (; n && \"comment\" == n.type; ) {\n            const r =\n                n.startPosition.row == t.endPosition.row &&\n                n.startPosition.column >= t.endPosition.column,\n              o =\n                n.startPosition.row > e.endPosition.row &&\n                n.startPosition.column > e.startPosition.column;\n            if (!r && !o) break;\n            t = n;\n            n = n.nextSibling;\n          }\n        }\n        if (\n          !(\n            t.endIndex >= t.tree.rootNode.endIndex - 1 &&\n            (t.hasError() || t.parent.hasError())\n          )\n        )\n          return n(t);\n      }\n    });\n  }\n  async isBlockBodyFinished(e, t, n) {\n    const r = (e + t).trimEnd(),\n      o = await this.getNextBlockAtPosition(r, n, (e) => e.endIndex);\n    if (undefined !== o && o < r.length) {\n      const t = o - e.length;\n      return t > 0 ? t : undefined;\n    }\n  }\n  getNodeStart(e, t) {\n    const n = e.trimEnd();\n    return this.getNodeMatchAtPosition(n, t, (e) => e.startIndex);\n  }\n}\nclass i extends o {\n  constructor(e, t, n, r, o) {\n    super(e, r, o);\n    this.blockEmptyMatch = t;\n    this.lineMatch = n;\n  }\n  isBlockStart(e) {\n    return this.lineMatch.test(e.trimStart());\n  }\n  async isBlockBodyEmpty(e, t) {\n    const n = await this.getNextBlockAtPosition(e, t, (n) => {\n      if (n.startIndex < t) {\n        t = n.startIndex;\n      }\n      let r = e.substring(t, n.endIndex).trim();\n      return \"\" == r || r.replace(/\\s/g, \"\") == this.blockEmptyMatch;\n    });\n    return undefined === n || n;\n  }\n  async isEmptyBlockStart(e, t) {\n    t = s(e, t);\n    return (\n      this.isBlockStart(\n        (function (e, t) {\n          const n = e.lastIndexOf(\"\\n\", t - 1);\n          let r = e.indexOf(\"\\n\", t);\n          if (r < 0) {\n            r = e.length;\n          }\n          return e.slice(n + 1, r);\n        })(e, t)\n      ) && this.isBlockBodyEmpty(e, t)\n    );\n  }\n}\nfunction s(e, t) {\n  let n = t;\n  for (; n > 0 && /\\s/.test(e.charAt(n - 1)); ) n--;\n  return n;\n}\nfunction a(e, t) {\n  const n = e.startIndex,\n    r = e.startIndex - e.startPosition.column,\n    o = t.substring(r, n);\n  if (/^\\s*$/.test(o)) return o;\n}\nfunction c(e, t, n) {\n  if (t.startPosition.row <= e.startPosition.row) return !1;\n  const r = a(e, n),\n    o = a(t, n);\n  return undefined !== r && undefined !== o && r.startsWith(o);\n}\nclass l extends o {\n  constructor(e, t, n, r, o, i, s) {\n    super(e, t, n);\n    this.startKeywords = r;\n    this.blockNodeType = o;\n    this.emptyStatementType = i;\n    this.curlyBraceLanguage = s;\n  }\n  isBlockEmpty(e, t) {\n    var n, o;\n    let i = e.text.trim();\n    if (this.curlyBraceLanguage) {\n      if (i.startsWith(\"{\")) {\n        i = i.slice(1);\n      }\n      if (i.endsWith(\"}\")) {\n        i = i.slice(0, -1);\n      }\n      i = i.trim();\n    }\n    return (\n      0 == i.length ||\n      !(\n        \"python\" != this.languageId ||\n        (\"class_definition\" !=\n          (null === (n = e.parent) || undefined === n ? undefined : n.type) &&\n          \"function_definition\" !=\n            (null === (o = e.parent) || undefined === o\n              ? undefined\n              : o.type)) ||\n        1 != e.children.length ||\n        !r.queryPythonIsDocstring(e.parent)\n      )\n    );\n  }\n  async isEmptyBlockStart(e, t) {\n    var n, o, i;\n    if (t > e.length) throw new RangeError(\"Invalid offset\");\n    for (let n = t; n < e.length && \"\\n\" != e.charAt(n); n++)\n      if (/\\S/.test(e.charAt(n))) return !1;\n    t = s(e, t);\n    const a = await r.parseTree(this.languageId, e);\n    try {\n      const r = a.rootNode.descendantForIndex(t - 1);\n      if (null == r) return !1;\n      if (this.curlyBraceLanguage && \"}\" == r.type) return !1;\n      if (\n        (\"javascript\" == this.languageId || \"typescript\" == this.languageId) &&\n        r.parent &&\n        \"object\" == r.parent.type &&\n        \"{\" == r.parent.text.trim()\n      )\n        return !0;\n      if (\"typescript\" == this.languageId) {\n        let n = r;\n        for (; n.parent; ) {\n          if (\"function_signature\" == n.type || \"method_signature\" == n.type) {\n            const o = r.nextSibling;\n            return (\n              !!(o && n.hasError() && c(n, o, e)) ||\n              (!n.children.find((e) => \";\" == e.type) && n.endIndex <= t)\n            );\n          }\n          n = n.parent;\n        }\n      }\n      let s = null,\n        l = null,\n        u = null,\n        d = r;\n      for (; null != d; ) {\n        if (d.type == this.blockNodeType) {\n          l = d;\n          break;\n        }\n        if (this.nodeMatch[d.type]) {\n          u = d;\n          break;\n        }\n        if (\"ERROR\" == d.type) {\n          s = d;\n          break;\n        }\n        d = d.parent;\n      }\n      if (null != l) {\n        if (!l.parent || !this.nodeMatch[l.parent.type]) return !1;\n        if (\"python\" == this.languageId) {\n          const e = l.previousSibling;\n          if (\n            null != e &&\n            e.hasError() &&\n            (e.text.startsWith('\"\"\"') || e.text.startsWith(\"'''\"))\n          )\n            return !0;\n        }\n        return this.isBlockEmpty(l, t);\n      }\n      if (null != s) {\n        if (\n          \"module\" ==\n            (null === (n = s.previousSibling) || undefined === n\n              ? undefined\n              : n.type) ||\n          \"internal_module\" ==\n            (null === (o = s.previousSibling) || undefined === o\n              ? undefined\n              : o.type)\n        )\n          return !0;\n        const e = [...s.children].reverse(),\n          a = e.find((e) => this.startKeywords.includes(e.type));\n        let c = e.find((e) => e.type == this.blockNodeType);\n        if (a) {\n          switch (this.languageId) {\n            case \"python\": {\n              if (\n                \"try\" == a.type &&\n                \"identifier\" == r.type &&\n                r.text.length > 4\n              ) {\n                c =\n                  null === (i = e.find((e) => e.hasError())) || undefined === i\n                    ? undefined\n                    : i.children.find((e) => \"block\" == e.type);\n              }\n              const t = e.find((e) => \":\" == e.type);\n              if (t && a.endIndex <= t.startIndex && t.nextSibling) {\n                if (\"def\" == a.type) {\n                  const e = t.nextSibling;\n                  if ('\"' == e.type || \"'\" == e.type) return !0;\n                  if (\"ERROR\" == e.type && ('\"\"\"' == e.text || \"'''\" == e.text))\n                    return !0;\n                }\n                return !1;\n              }\n              break;\n            }\n            case \"javascript\": {\n              const t = e.find((e) => \"formal_parameters\" == e.type);\n              if (\"class\" == a.type && t) return !0;\n              const n = e.find((e) => \"{\" == e.type);\n              if (n && n.startIndex > a.endIndex && null != n.nextSibling)\n                return !1;\n              if (e.find((e) => \"do\" == e.type) && \"while\" == a.type) return !1;\n              if (\"=>\" == a.type && a.nextSibling && \"{\" != a.nextSibling.type)\n                return !1;\n              break;\n            }\n            case \"typescript\": {\n              const t = e.find((e) => \"{\" == e.type);\n              if (t && t.startIndex > a.endIndex && null != t.nextSibling)\n                return !1;\n              if (e.find((e) => \"do\" == e.type) && \"while\" == a.type) return !1;\n              if (\"=>\" == a.type && a.nextSibling && \"{\" != a.nextSibling.type)\n                return !1;\n              break;\n            }\n          }\n          return !(c && c.startIndex > a.endIndex) || this.isBlockEmpty(c, t);\n        }\n      }\n      if (null != u) {\n        const e = this.nodeMatch[u.type],\n          n = u.children\n            .slice()\n            .reverse()\n            .find((t) => t.type == e);\n        if (n) return this.isBlockEmpty(n, t);\n        if (this.nodeTypesWithBlockOrStmtChild.has(u.type)) {\n          const e = this.nodeTypesWithBlockOrStmtChild.get(u.type),\n            t = \"\" == e ? u.children[0] : u.childForFieldName(e);\n          if (\n            t &&\n            t.type != this.blockNodeType &&\n            t.type != this.emptyStatementType\n          )\n            return !1;\n        }\n        return !0;\n      }\n      return !1;\n    } finally {\n      a.delete();\n    }\n  }\n}\nconst u = {\n  python: new l(\n    \"python\",\n    {\n      class_definition: \"block\",\n      elif_clause: \"block\",\n      else_clause: \"block\",\n      except_clause: \"block\",\n      finally_clause: \"block\",\n      for_statement: \"block\",\n      function_definition: \"block\",\n      if_statement: \"block\",\n      try_statement: \"block\",\n      while_statement: \"block\",\n      with_statement: \"block\",\n    },\n    new Map(),\n    [\n      \"def\",\n      \"class\",\n      \"if\",\n      \"elif\",\n      \"else\",\n      \"for\",\n      \"while\",\n      \"try\",\n      \"except\",\n      \"finally\",\n      \"with\",\n    ],\n    \"block\",\n    null,\n    !1\n  ),\n  javascript: new l(\n    \"javascript\",\n    {\n      arrow_function: \"statement_block\",\n      catch_clause: \"statement_block\",\n      do_statement: \"statement_block\",\n      else_clause: \"statement_block\",\n      finally_clause: \"statement_block\",\n      for_in_statement: \"statement_block\",\n      for_statement: \"statement_block\",\n      function: \"statement_block\",\n      function_declaration: \"statement_block\",\n      generator_function: \"statement_block\",\n      generator_function_declaration: \"statement_block\",\n      if_statement: \"statement_block\",\n      method_definition: \"statement_block\",\n      try_statement: \"statement_block\",\n      while_statement: \"statement_block\",\n      with_statement: \"statement_block\",\n      class: \"class_body\",\n      class_declaration: \"class_body\",\n    },\n    new Map([\n      [\"arrow_function\", \"body\"],\n      [\"do_statement\", \"body\"],\n      [\"else_clause\", \"\"],\n      [\"for_in_statement\", \"body\"],\n      [\"for_statement\", \"body\"],\n      [\"if_statement\", \"consequence\"],\n      [\"while_statement\", \"body\"],\n      [\"with_statement\", \"body\"],\n    ]),\n    [\n      \"=>\",\n      \"try\",\n      \"catch\",\n      \"finally\",\n      \"do\",\n      \"for\",\n      \"if\",\n      \"else\",\n      \"while\",\n      \"with\",\n      \"function\",\n      \"function*\",\n      \"class\",\n    ],\n    \"statement_block\",\n    \"empty_statement\",\n    !0\n  ),\n  typescript: new l(\n    \"typescript\",\n    {\n      ambient_declaration: \"statement_block\",\n      arrow_function: \"statement_block\",\n      catch_clause: \"statement_block\",\n      do_statement: \"statement_block\",\n      else_clause: \"statement_block\",\n      finally_clause: \"statement_block\",\n      for_in_statement: \"statement_block\",\n      for_statement: \"statement_block\",\n      function: \"statement_block\",\n      function_declaration: \"statement_block\",\n      generator_function: \"statement_block\",\n      generator_function_declaration: \"statement_block\",\n      if_statement: \"statement_block\",\n      internal_module: \"statement_block\",\n      method_definition: \"statement_block\",\n      module: \"statement_block\",\n      try_statement: \"statement_block\",\n      while_statement: \"statement_block\",\n      abstract_class_declaration: \"class_body\",\n      class: \"class_body\",\n      class_declaration: \"class_body\",\n    },\n    new Map([\n      [\"arrow_function\", \"body\"],\n      [\"do_statement\", \"body\"],\n      [\"else_clause\", \"\"],\n      [\"for_in_statement\", \"body\"],\n      [\"for_statement\", \"body\"],\n      [\"if_statement\", \"consequence\"],\n      [\"while_statement\", \"body\"],\n      [\"with_statement\", \"body\"],\n    ]),\n    [\n      \"declare\",\n      \"=>\",\n      \"try\",\n      \"catch\",\n      \"finally\",\n      \"do\",\n      \"for\",\n      \"if\",\n      \"else\",\n      \"while\",\n      \"with\",\n      \"function\",\n      \"function*\",\n      \"class\",\n    ],\n    \"statement_block\",\n    \"empty_statement\",\n    !0\n  ),\n  go: new i(\n    \"go\",\n    \"{}\",\n    /\\b(func|if|else|for)\\b/,\n    {\n      communication_case: \"block\",\n      default_case: \"block\",\n      expression_case: \"block\",\n      for_statement: \"block\",\n      func_literal: \"block\",\n      function_declaration: \"block\",\n      if_statement: \"block\",\n      labeled_statement: \"block\",\n      method_declaration: \"block\",\n      type_case: \"block\",\n    },\n    new Map()\n  ),\n  ruby: new i(\n    \"ruby\",\n    \"end\",\n    /\\b(BEGIN|END|case|class|def|do|else|elsif|for|if|module|unless|until|while)\\b|->/,\n    {\n      begin_block: \"}\",\n      block: \"}\",\n      end_block: \"}\",\n      lambda: \"block\",\n      for: \"do\",\n      until: \"do\",\n      while: \"do\",\n      case: \"end\",\n      do: \"end\",\n      if: \"end\",\n      method: \"end\",\n      module: \"end\",\n      unless: \"end\",\n      do_block: \"end\",\n    },\n    new Map()\n  ),\n};\nfunction getBlockParser(e) {\n  return u[r.languageIdToWasmLanguage(e)];\n}\nexports.getBlockParser = getBlockParser;\nexports.isEmptyBlockStart = async function (e, t, n) {\n  return (\n    !!r.isSupportedLanguageId(e) && getBlockParser(e).isEmptyBlockStart(t, n)\n  );\n};\nexports.isBlockBodyFinished = async function (e, t, n, o) {\n  if (r.isSupportedLanguageId(e))\n    return getBlockParser(e).isBlockBodyFinished(t, n, o);\n};\nexports.getNodeStart = async function (e, t, n) {\n  if (r.isSupportedLanguageId(e)) return getBlockParser(e).getNodeStart(t, n);\n};",
  "3055617": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.rebuildTree =\n  exports.foldTree =\n  exports.visitTreeConditionally =\n  exports.visitTree =\n  exports.resetLineNumbers =\n  exports.mapLabels =\n  exports.clearLabelsIf =\n  exports.clearLabels =\n    undefined;\nconst r = require(3055876);\nfunction visitTree(e, t, n) {\n  !(function e(r) {\n    if (\"topDown\" === n) {\n      t(r);\n    }\n    r.subs.forEach((t) => {\n      e(t);\n    });\n    if (\"bottomUp\" === n) {\n      t(r);\n    }\n  })(e);\n}\nexports.clearLabels = function (e) {\n  visitTree(\n    e,\n    (e) => {\n      e.label = undefined;\n    },\n    \"bottomUp\"\n  );\n  return e;\n};\nexports.clearLabelsIf = function (e, t) {\n  visitTree(\n    e,\n    (e) => {\n      e.label = e.label ? (t(e.label) ? undefined : e.label) : undefined;\n    },\n    \"bottomUp\"\n  );\n  return e;\n};\nexports.mapLabels = function e(t, n) {\n  switch (t.type) {\n    case \"line\":\n    case \"virtual\":\n      const r = t.subs.map((t) => e(t, n));\n      return {\n        ...t,\n        subs: r,\n        label: t.label ? n(t.label) : undefined,\n      };\n    case \"blank\":\n      return {\n        ...t,\n        label: t.label ? n(t.label) : undefined,\n      };\n    case \"top\":\n      return {\n        ...t,\n        subs: t.subs.map((t) => e(t, n)),\n        label: t.label ? n(t.label) : undefined,\n      };\n  }\n};\nexports.resetLineNumbers = function (e) {\n  let t = 0;\n  visitTree(\n    e,\n    function (e) {\n      if (r.isVirtual(e) || r.isTop(e)) {\n        e.lineNumber = t;\n        t++;\n      }\n    },\n    \"topDown\"\n  );\n};\nexports.visitTree = visitTree;\nexports.visitTreeConditionally = function (e, t, n) {\n  !(function e(r) {\n    if (\"topDown\" === n && !t(r)) return !1;\n    let o = !0;\n    r.subs.forEach((t) => {\n      o = o && e(t);\n    });\n    if (\"bottomUp\" === n) {\n      o = o && t(r);\n    }\n    return o;\n  })(e);\n};\nexports.foldTree = function (e, t, n, r) {\n  let i = t;\n  visitTree(\n    e,\n    function (e) {\n      i = n(e, i);\n    },\n    r\n  );\n  return i;\n};\nexports.rebuildTree = function (e, t, n) {\n  const o = (e) => {\n      if (undefined !== n && n(e)) return e;\n      {\n        const n = e.subs.map(o).filter((e) => undefined !== e);\n        e.subs = n;\n        return t(e);\n      }\n    },\n    i = o(e);\n  return undefined !== i ? i : r.topNode();\n};",
  "3055622": "module.exports = require(\"path\");",
  "3055670": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.getSiblingFunctionStart = exports.getSiblingFunctions = undefined;\nconst r = require(3055312),\n  o = require(3055306);\nexports.getSiblingFunctions = async function ({\n  source: e,\n  offset: t,\n  languageId: n,\n}) {\n  var i, s;\n  const a = [];\n  let c = \"\",\n    l = e.substring(0, t);\n  if (o.isSupportedLanguageId(n)) {\n    const u = await o.parseTree(n, e);\n    try {\n      let d = t;\n      for (; d >= 0 && /\\s/.test(e[d]); ) d--;\n      const p = u.rootNode.descendantForIndex(d),\n        h = o.getAncestorWithSiblingFunctions(n, p);\n      if (h) {\n        const u = o.getFirstPrecedingComment(h),\n          d =\n            null !== (i = null == u ? undefined : u.startIndex) &&\n            undefined !== i\n              ? i\n              : h.startIndex;\n        let p,\n          f = 0;\n        for (; \" \" == (p = e[d - f - 1]) || \"\\t\" == p; ) f++;\n        const m = e.substring(d - f, d);\n        for (let i = h.nextSibling; i; i = i.nextSibling)\n          if (o.isFunctionDefinition(n, i)) {\n            const n = o.getFirstPrecedingComment(i),\n              c =\n                null !== (s = null == n ? undefined : n.startIndex) &&\n                undefined !== s\n                  ? s\n                  : i.startIndex;\n            if (c < t) continue;\n            const l = e.substring(c, i.endIndex),\n              u = r.newLineEnded(l) + \"\\n\" + m;\n            a.push(u);\n          }\n        c = e.substring(0, d);\n        l = e.substring(d, t);\n      }\n    } finally {\n      u.delete();\n    }\n  }\n  return {\n    siblings: a,\n    beforeInsertion: c,\n    afterInsertion: l,\n  };\n};\nexports.getSiblingFunctionStart = async function ({\n  source: e,\n  offset: t,\n  languageId: n,\n}) {\n  var r;\n  if (o.isSupportedLanguageId(n)) {\n    const i = await o.parseTree(n, e);\n    try {\n      let s = t;\n      for (; s >= 0 && /\\s/.test(e[s]); ) s--;\n      const a = i.rootNode.descendantForIndex(s),\n        c = o.getAncestorWithSiblingFunctions(n, a);\n      if (c) {\n        for (let e = c.nextSibling; e; e = e.nextSibling)\n          if (o.isFunctionDefinition(n, e)) {\n            const n = o.getFirstPrecedingComment(e),\n              i =\n                null !== (r = null == n ? undefined : n.startIndex) &&\n                undefined !== r\n                  ? r\n                  : e.startIndex;\n            if (i < t) continue;\n            return i;\n          }\n        if (c.endIndex >= t) return c.endIndex;\n      }\n    } finally {\n      i.delete();\n    }\n  }\n  return t;\n};",
  "3055747": "module.exports = require(\"fs\");",
  "3055876": "function isVirtual(e) {\n  return \"virtual\" === e.type;\n}\nfunction isTop(e) {\n  return \"top\" === e.type;\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.duplicateTree =\n  exports.cutTreeAfterLine =\n  exports.isTop =\n  exports.isVirtual =\n  exports.isLine =\n  exports.isBlank =\n  exports.topNode =\n  exports.blankNode =\n  exports.lineNode =\n  exports.virtualNode =\n    undefined;\nexports.virtualNode = function (e, t, n) {\n  return {\n    type: \"virtual\",\n    indentation: e,\n    subs: t,\n    label: n,\n  };\n};\nexports.lineNode = function (e, t, n, r, o) {\n  if (\"\" === n)\n    throw new Error(\"Cannot create a line node with an empty source line\");\n  return {\n    type: \"line\",\n    indentation: e,\n    lineNumber: t,\n    sourceLine: n,\n    subs: r,\n    label: o,\n  };\n};\nexports.blankNode = function (e) {\n  return {\n    type: \"blank\",\n    lineNumber: e,\n    subs: [],\n  };\n};\nexports.topNode = function (e) {\n  return {\n    type: \"top\",\n    indentation: -1,\n    subs: null != e ? e : [],\n  };\n};\nexports.isBlank = function (e) {\n  return \"blank\" === e.type;\n};\nexports.isLine = function (e) {\n  return \"line\" === e.type;\n};\nexports.isVirtual = isVirtual;\nexports.isTop = isTop;\nexports.cutTreeAfterLine = function (e, t) {\n  !(function e(o) {\n    if (!isVirtual(o) && !isTop(o) && o.lineNumber === t) {\n      o.subs = [];\n      return !0;\n    }\n    for (let t = 0; t < o.subs.length; t++)\n      if (e(o.subs[t])) {\n        o.subs = o.subs.slice(0, t + 1);\n        return !0;\n      }\n    return !1;\n  })(e);\n};\nexports.duplicateTree = function (e) {\n  return JSON.parse(JSON.stringify(e));\n};",
  "main": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0,\n});\nexports.deactivate = exports.activate = exports.init = undefined;\nconst t = require(3055563);\nrequire(406);\nconst o = require(\"vscode\"),\n  i = require(362),\n  s = require(299),\n  a = require(1133),\n  c = require(4197),\n  l = require(7870),\n  u = require(9408),\n  d = require(1839),\n  p = require(9189),\n  h = require(9748),\n  f = require(8965),\n  m = require(5413),\n  g = require(9899),\n  _ = require(2279),\n  y = require(1547),\n  v = require(4419),\n  b = require(6722),\n  w = require(2533),\n  x = require(766),\n  E = require(6333),\n  C = require(956),\n  S = require(70),\n  T = require(8771),\n  k = require(6403),\n  I = require(3136),\n  P = require(7057),\n  A = require(3197),\n  O = require(1862),\n  N = require(9425),\n  R = require(3060),\n  M = (require(1929), require(6267)),\n  L = require(2990),\n  $ = require(6857),\n  D = require(9477),\n  F = require(7254),\n  j = require(4428),\n  q = require(8129),\n  B = require(385),\n  U = o.window.createOutputChannel(\"GitHub Copilot\");\nfunction init() {\n  _.init(new a.BuildInfo().getVersion());\n}\nfunction z(e, t, n) {\n  return o.commands.registerCommand(t, async (...r) => {\n    try {\n      return await n(...r);\n    } catch (n) {\n      E.telemetryException(e, n, t);\n    }\n  });\n}\nlet G;\nexports.init = init;\ninit();\nexports.activate = async function (e) {\n  const n = new l.Context();\n  n.set(a.ConfigProvider, new N.VSCodeConfigProvider());\n  n.set(s.Clock, new s.Clock());\n  n.set(a.BuildInfo, new a.BuildInfo());\n  n.set(a.EditorAndPluginInfo, new N.VSCodeEditorInfo());\n  n.set(g.LogVerbose, new g.LogVerbose(!1));\n  n.set(m.GhostTextDebounceManager, new m.GhostTextDebounceManager());\n  n.set(f.ContextualFilterManager, new f.ContextualFilterManager());\n  const r = new g.MultiLog([\n    new g.ConsoleLog(console),\n    new g.OutputChannelLog(U),\n  ]);\n  n.set(g.LogTarget, r);\n  n.set(k.LocationFactory, new q.ExtensionLocationFactory());\n  n.set(I.TextDocumentManager, new B.ExtensionTextDocumentManager());\n  n.set(p.Features, new p.Features(n));\n  const H = new _.HelixFetcher(n);\n  n.set(_.Fetcher, H);\n  D.initProxyEnvironment(H, process.env);\n  n.set(t.FileSystem, $.extensionFileSystem);\n  n.set(y.NotificationSender, new O.ExtensionNotificationSender());\n  n.set(E.TelemetryEndpointUrl, new E.TelemetryEndpointUrl());\n  if (e.extensionMode === o.ExtensionMode.Test) {\n    n.set(i.CopilotTokenManager, C.makeTestingCopilotTokenManager());\n    n.set(a.VscInfo, a.getTestVscInfo());\n    n.set(S.RuntimeMode, S.RuntimeMode.fromEnvironment(!0));\n    n.set(h.ExpConfigMaker, new h.ExpConfigNone());\n    n.set(E.TelemetryReporters, E.setupStandardReporters(n, \"copilot-test\"));\n    n.set(P.UrlOpener, new T.TestUrlOpener());\n  } else {\n    n.set(i.CopilotTokenManager, new O.VSCodeCopilotTokenManager());\n    n.set(a.VscInfo, N.makeVscInfo());\n    n.set(v.OpenAIFetcher, new v.LiveOpenAIFetcher());\n    n.set(a.BlockModeConfig, new a.ConfigBlockModeConfig());\n    n.set(S.RuntimeMode, S.RuntimeMode.fromEnvironment(!1));\n    n.set(h.ExpConfigMaker, new h.ExpConfigFromTAS());\n    n.set(E.TelemetryReporters, j.activate(n, e));\n    n.set(P.UrlOpener, new P.RealUrlOpener());\n  }\n  if (\"GitHub.copilot-nightly\" === e.extension.id) {\n    u.registerDefaultHandlers(n, \"vscode\");\n  }\n  N.setExtension(e.extension);\n  O.setExtensionContext(e);\n  e.globalState.setKeysForSync([O.telemetryAcceptanceKey]);\n  const V = a.getBuildType(n) === a.BuildType.DEV,\n    W = \"GitHub.copilot-nightly\" === e.extension.id;\n  if (W && o.extensions.all.find((e) => \"GitHub.copilot\" === e.id))\n    return void (\n      \"Uninstall\" ===\n        (await o.window.showWarningMessage(\n          \"To use GitHub Copilot Nightly you need to uninstall GitHub Copilot extension\",\n          \"Uninstall\"\n        )) &&\n      (await o.commands.executeCommand(\n        \"workbench.extensions.uninstallExtension\",\n        \"GitHub.copilot\"\n      ))\n    );\n  if (W || V) {\n    o.commands.executeCommand(\"setContext\", \"github.copilot.nightly\", !0);\n  }\n  const K = (function (e, t) {\n    const n = new F.CopilotStatusBar(e);\n    t.subscriptions.push(\n      z(e, R.CMDToggleCopilot, () => {\n        n.toggleStatusBar();\n      })\n    );\n    t.subscriptions.push(\n      z(e, R.CMDShowActivationErrors, () => {\n        n.showActivationErrors(U);\n      })\n    );\n    t.subscriptions.push(n.getStatusBarItem());\n    return n;\n  })(n, e);\n  n.set(b.StatusReporter, K);\n  const J = async () => {\n    try {\n      await n.get(i.CopilotTokenManager).getCopilotToken(n);\n    } catch (e) {\n      const t = e.message || e;\n      E.telemetryError(\n        n,\n        \"activationFailed\",\n        E.TelemetryData.createAndMarkAsIssued({\n          reason: t,\n        })\n      );\n      n.get(E.TelemetryReporters).deactivate();\n      const r = `GitHub Copilot could not connect to server. Extension activation failed: \"${t}\"`;\n      K.setError(r, J);\n      g.logger.error(n, r);\n      return void o.commands.executeCommand(\n        \"setContext\",\n        \"github.copilot.activated\",\n        !1\n      );\n    }\n    K.forceNormal();\n    o.commands.executeCommand(\"setContext\", \"github.copilot.activated\", !0);\n    e.subscriptions.push(\n      z(n, R.CMDOpenPanel, () => {\n        o.commands.executeCommand(\"editor.action.inlineSuggest.hide\");\n        M.commandOpenPanel(n);\n      })\n    );\n    e.subscriptions.push(\n      z(n, R.CMDOpenPanelForRange, (e) => {\n        M.commandOpenPanel(n, e);\n      }),\n      z(n, R.CMDAcceptPanelSolution, async (e, t, n, r, i) => {\n        const s = new o.WorkspaceEdit();\n        s.insert(e, t, n);\n        await o.workspace.applyEdit(s);\n        i();\n        await o.commands.executeCommand(\"workbench.action.closeActiveEditor\");\n        if (\n          r &&\n          o.window.activeTextEditor &&\n          o.window.activeTextEditor.document.uri.toString() === e.toString()\n        ) {\n          const e = t.translate(1).with(void 0, 0),\n            n = new o.Selection(e, e);\n          o.window.activeTextEditor.selection = n;\n        }\n      })\n    );\n    e.subscriptions.push(\n      z(n, R.CMDSendFeedback, () => {\n        o.env.openExternal(\n          o.Uri.parse(\n            \"https://github.com/github/feedback/discussions/categories/copilot\"\n          )\n        );\n      })\n    );\n    const t = new L.CopilotPanel(n);\n    e.subscriptions.push(\n      o.workspace.registerTextDocumentContentProvider(c.CopilotScheme, t),\n      o.languages.registerCodeLensProvider(\n        {\n          scheme: c.CopilotScheme,\n        },\n        t\n      )\n    );\n    try {\n      e.subscriptions.push(...A.registerGhostText(n));\n      const t = o.workspace.getConfiguration(),\n        r = t.inspect(\"editor.inlineSuggest.enabled\");\n      if (undefined === (null == r ? undefined : r.globalValue)) {\n        t.update(\n          \"editor.inlineSuggest.enabled\",\n          !0,\n          o.ConfigurationTarget.Global\n        );\n      }\n    } catch (e) {\n      o.window.showErrorMessage(\n        \"GitHub Copilot requires VS Code 1.57+. Please update your VS Code\"\n      );\n    }\n    e.subscriptions.push(d.registerDocumentTracker(n));\n    e.subscriptions.push(\n      o.window.onDidChangeActiveTextEditor((e) =>\n        e\n          ? e.document.isUntitled ||\n            (\"file\" === e.document.uri.scheme &&\n              x.extractRepoInfoInBackground(n, e.document.fileName))\n          : undefined\n      )\n    );\n    const r = e.extensionMode !== o.ExtensionMode.Development;\n    w.init(n, r, new g.Logger(g.LogLevel.INFO, \"promptlib proxy\"));\n    E.telemetry(n, \"extension.activate\");\n    G = n;\n  };\n  await J();\n};\nexports.deactivate = function () {\n  if (G) {\n    E.telemetry(G, \"extension.deactivate\");\n    G.get(E.TelemetryReporters).deactivate();\n  }\n  w.terminate();\n};"
}