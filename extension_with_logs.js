/*! For license information please see extension.js.LICENSE.txt */
(() => {
    var e = {
            9407: (e, t, r) => {
                "use strict";
                const {
                    randomBytes: n
                } = r(6113), {
                    Readable: o
                } = r(2781), i = e => "object" == typeof e && 0 === ["arrayBuffer", "stream", "text", "slice", "constructor"].map((t => typeof e[t])).filter((e => "function" !== e)).length && "string" == typeof e.type && "number" == typeof e.size && /^(Blob|File)$/.test(e[Symbol.toStringTag]), s = e => `--${e}--\r\n\r\n`, a = (e, t, r) => {
                    let n = "";
                    return n += `--${e}\r\n`, n += `Content-Disposition: form-data; name="${t}"`, i(r) && (n += `; filename="${r.name}"\r\n`, n += `Content-Type: ${r.type||"application/octet-stream"}`), `${n}\r\n\r\n`
                };
                e.exports = {
                    isFormData: e => null != e && "object" == typeof e && 0 === ["append", "delete", "get", "getAll", "has", "set", "keys", "values", "entries", "constructor"].map((t => typeof e[t])).filter((e => "function" !== e)).length && "FormData" === e[Symbol.toStringTag],
                    FormDataSerializer: class {
                        constructor(e) {
                            this.fd = e, this.boundary = n(8).toString("hex")
                        }
                        length() {
                            return void 0 === this._length && (this._length = ((e, t) => {
                                let r = 0;
                                for (const [n, o] of e) r += Buffer.byteLength(a(t, n, o)), r += i(o) ? o.size : Buffer.byteLength(String(o)), r += Buffer.byteLength("\r\n");
                                return r += Buffer.byteLength(s(t)), r
                            })(this.fd, this.boundary)), this._length
                        }
                        contentType() {
                            return `multipart/form-data; boundary=${this.boundary}`
                        }
                        stream() {
                            return o.from(async function*(e, t) {
                                for (const [r, n] of e) yield a(t, r, n), i(n) ? yield* n.stream(): yield n, yield "\r\n";
                                yield s(t)
                            }(this.fd, this.boundary))
                        }
                    }
                }
            },
            4544: (e, t, r) => {
                "use strict";
                const {
                    constants: {
                        MAX_LENGTH: n
                    }
                } = r(4300), {
                    pipeline: o,
                    PassThrough: i
                } = r(2781), {
                    promisify: s
                } = r(3837), {
                    createGunzip: a,
                    createInflate: c,
                    createBrotliDecompress: l,
                    constants: {
                        Z_SYNC_FLUSH: u
                    }
                } = r(9796), d = r(8104)("helix-fetch:utils"), p = s(o), h = (e, t) => {
                    if (Buffer.isBuffer(e)) return e.length;
                    switch (typeof e) {
                        case "string":
                            return 2 * e.length;
                        case "boolean":
                            return 4;
                        case "number":
                            return 8;
                        case "symbol":
                            return Symbol.keyFor(e) ? 2 * Symbol.keyFor(e).length : 2 * (e.toString().length - 8);
                        case "object":
                            return Array.isArray(e) ? f(e, t) : m(e, t);
                        default:
                            return 0
                    }
                }, f = (e, t) => (t.add(e), e.map((e => t.has(e) ? 0 : h(e, t))).reduce(((e, t) => e + t), 0)), m = (e, t) => {
                    if (null == e) return 0;
                    t.add(e);
                    let r = 0;
                    const n = [];
                    for (const t in e) n.push(t);
                    return n.push(...Object.getOwnPropertySymbols(e)), n.forEach((n => {
                        if (r += h(n, t), "object" == typeof e[n] && null !== e[n]) {
                            if (t.has(e[n])) return;
                            t.add(e[n])
                        }
                        r += h(e[n], t)
                    })), r
                };
                e.exports = {
                    decodeStream: (e, t, r, n) => {
                        if (!((e, t) => 204 !== e && 304 !== e && 0 != +t["content-length"] && /^\s*(?:(x-)?deflate|(x-)?gzip|br)\s*$/.test(t["content-encoding"]))(e, t)) return r;
                        const i = e => {
                            e && (d(`encountered error while decoding stream: ${e}`), n(e))
                        };
                        switch (t["content-encoding"].trim()) {
                            case "gzip":
                            case "x-gzip":
                                return o(r, a({
                                    flush: u,
                                    finishFlush: u
                                }), i);
                            case "deflate":
                            case "x-deflate":
                                return o(r, c(), i);
                            case "br":
                                return o(r, l(), i);
                            default:
                                return r
                        }
                    },
                    isPlainObject: e => {
                        if (!e || "object" != typeof e) return !1;
                        if ("[object Object]" !== Object.prototype.toString.call(e)) return !1;
                        if (null === Object.getPrototypeOf(e)) return !0;
                        let t = e;
                        for (; null !== Object.getPrototypeOf(t);) t = Object.getPrototypeOf(t);
                        return Object.getPrototypeOf(e) === t
                    },
                    sizeof: e => h(e, new WeakSet),
                    streamToBuffer: async e => {
                        const t = new i;
                        let r = 0;
                        const o = [];
                        return t.on("data", (e => {
                            if (r + e.length > n) throw new Error("Buffer.constants.MAX_SIZE exceeded");
                            o.push(e), r += e.length
                        })), await p(e, t), Buffer.concat(o, r)
                    }
                }
            },
            1787: e => {
                "use strict";
                class t extends Error {
                    get name() {
                        return this.constructor.name
                    }
                    get[Symbol.toStringTag]() {
                        return this.constructor.name
                    }
                }
                e.exports = {
                    RequestAbortedError: t
                }
            },
            9803: (e, t, r) => {
                "use strict";
                const n = r(3685),
                    o = r(5687),
                    {
                        Readable: i
                    } = r(2781),
                    s = r(8104)("helix-fetch:h1"),
                    {
                        RequestAbortedError: a
                    } = r(1787),
                    {
                        decodeStream: c
                    } = r(4544);
                e.exports = {
                    request: async (e, t, r) => {
                        const {
                            request: l
                        } = "https:" === t.protocol ? o : n, u = ((e, t) => {
                            const {
                                h1: r,
                                options: {
                                    h1: i,
                                    rejectUnauthorized: s
                                }
                            } = e;
                            return "https:" === t ? r.httpsAgent ? r.httpsAgent : i || "boolean" == typeof s ? (r.httpsAgent = new o.Agent("boolean" == typeof s ? { ...i || {},
                                rejectUnauthorized: s
                            } : i), r.httpsAgent) : void 0 : r.httpAgent ? r.httpAgent : i ? (r.httpAgent = new n.Agent(i), r.httpAgent) : void 0
                        })(e, t.protocol), d = { ...r,
                            agent: u
                        }, {
                            socket: p,
                            body: h
                        } = d;
                        return p && (delete d.socket, p.assigned || (p.assigned = !0, u ? d.agent = new Proxy(u, {
                            get: (e, t) => "createConnection" !== t || p.inUse ? e[t] : (e, t) => {
                                s(`agent reusing socket #${p.id} (${p.servername})`), p.inUse = !0, t(null, p)
                            }
                        }) : d.createConnection = (e, t) => {
                            s(`reusing socket #${p.id} (${p.servername})`), p.inUse = !0, t(null, p)
                        })), new Promise(((e, r) => {
                            let n;
                            s(`${d.method} ${t.href}`);
                            const {
                                signal: o
                            } = d, u = () => {
                                o.removeEventListener("abort", u), p && !p.inUse && (s(`discarding redundant socket used for ALPN: #${p.id} ${p.servername}`), p.destroy()), r(new a), n && n.abort()
                            };
                            if (o) {
                                if (o.aborted) return void r(new a);
                                o.addEventListener("abort", u)
                            }
                            n = l(t, d), n.once("response", (t => {
                                o && o.removeEventListener("abort", u), p && !p.inUse && (s(`discarding redundant socket used for ALPN: #${p.id} ${p.servername}`), p.destroy()), e(((e, t) => {
                                    const {
                                        statusCode: r,
                                        statusMessage: n,
                                        httpVersion: o,
                                        httpVersionMajor: i,
                                        httpVersionMinor: s,
                                        headers: a
                                    } = e;
                                    return {
                                        statusCode: r,
                                        statusText: n,
                                        httpVersion: o,
                                        httpVersionMajor: i,
                                        httpVersionMinor: s,
                                        headers: a,
                                        readable: c(r, a, e, t)
                                    }
                                })(t, r))
                            })), n.once("error", (e => {
                                o && o.removeEventListener("abort", u), p && !p.inUse && (s(`discarding redundant socket used for ALPN: #${p.id} ${p.servername}`), p.destroy()), n.aborted || (s(`${d.method} ${t.href} failed with: ${e.message}`), n.abort(), r(e))
                            })), h instanceof i ? h.pipe(n) : (h && n.write(h), n.end())
                        }))
                    },
                    setupContext: e => {
                        e.h1 = {}
                    },
                    resetContext: async ({
                        h1: e
                    }) => {
                        e.httpAgent && (s("resetContext: destroying httpAgent"), e.httpAgent.destroy(), delete e.httpAgent), e.httpsAgent && (s("resetContext: destroying httpsAgent"), e.httpsAgent.destroy(), delete e.httpsAgent)
                    }
                }
            },
            7262: (e, t, r) => {
                "use strict";
                const {
                    connect: n,
                    constants: o
                } = r(1995), {
                    Readable: i
                } = r(2781), s = r(8104)("helix-fetch:h2"), {
                    RequestAbortedError: a
                } = r(1787), {
                    decodeStream: c
                } = r(4544), {
                    NGHTTP2_CANCEL: l
                } = o, u = 3e5, d = 5e3, p = (e, t, r = (() => {})) => {
                    const n = { ...e
                        },
                        o = n[":status"];
                    return delete n[":status"], {
                        statusCode: o,
                        statusText: "",
                        httpVersion: "2.0",
                        httpVersionMajor: 2,
                        httpVersionMinor: 0,
                        headers: n,
                        readable: c(o, e, t, r)
                    }
                };
                e.exports = {
                    request: async (e, t, r) => {
                        const {
                            origin: o,
                            pathname: c,
                            search: h,
                            hash: f
                        } = t, m = `${c}${h}${f}`, {
                            options: {
                                h2: g = {}
                            },
                            h2: {
                                sessionCache: _
                            }
                        } = e, {
                            idleSessionTimeout: y = u,
                            pushPromiseHandler: v,
                            pushHandler: b
                        } = g, w = { ...r
                        }, {
                            method: x,
                            headers: E,
                            socket: C,
                            body: S
                        } = w;
                        return C && delete w.socket, E.host && (E[":authority"] = E.host, delete E.host), new Promise(((r, c) => {
                            let u, h = _[o];
                            if (!h || h.closed || h.destroyed) {
                                const t = !(!1 === e.options.rejectUnauthorized || !1 === g.rejectUnauthorized),
                                    r = { ...g,
                                        rejectUnauthorized: t
                                    };
                                C && !C.inUse && (r.createConnection = () => (s(`reusing socket #${C.id} (${C.servername})`), C.inUse = !0, C));
                                const i = !(!v && !b);
                                h = n(o, { ...r,
                                    settings: {
                                        enablePush: i
                                    }
                                }), h.setMaxListeners(1e3), h.setTimeout(y, (() => {
                                    s(`closing session ${o} after ${y} ms of inactivity`), h.close()
                                })), h.once("connect", (() => {
                                    s(`session ${o} established`), s(`caching session ${o}`), _[o] = h
                                })), h.on("localSettings", (e => {
                                    s(`session ${o} localSettings: ${JSON.stringify(e)}`)
                                })), h.on("remoteSettings", (e => {
                                    s(`session ${o} remoteSettings: ${JSON.stringify(e)}`)
                                })), h.once("close", (() => {
                                    s(`session ${o} closed`), _[o] === h && (s(`discarding cached session ${o}`), delete _[o])
                                })), h.once("error", (e => {
                                    s(`session ${o} encountered error: ${e}`), _[o] === h && (s(`discarding cached session ${o}`), delete _[o])
                                })), h.on("frameError", ((e, t, r) => {
                                    s(`session ${o} encountered frameError: type: ${e}, code: ${t}, id: ${r}`)
                                })), h.once("goaway", ((e, t, r) => {
                                    s(`session ${o} received GOAWAY frame: errorCode: ${e}, lastStreamID: ${t}, opaqueData: ${r?r.toString():void 0}`)
                                })), h.on("stream", ((t, r, n) => {
                                    ((e, t, r, n, o) => {
                                        const {
                                            options: {
                                                h2: {
                                                    pushPromiseHandler: i,
                                                    pushHandler: a,
                                                    pushedStreamIdleTimeout: c = d
                                                }
                                            }
                                        } = e, u = n[":path"], h = `${t}${u}`;
                                        s(`received PUSH_PROMISE: ${h}, stream #${r.id}, headers: ${JSON.stringify(n)}, flags: ${o}`), i && i(h, n, (() => {
                                            r.close(l)
                                        })), r.on("push", ((e, o) => {
                                            s(`received push headers for ${t}${u}, stream #${r.id}, headers: ${JSON.stringify(e)}, flags: ${o}`), r.setTimeout(c, (() => {
                                                s(`closing pushed stream #${r.id} after ${c} ms of inactivity`), r.close(l)
                                            })), a && a(h, n, p(e, r))
                                        })), r.on("aborted", (() => {
                                            s(`pushed stream #${r.id} aborted`)
                                        })), r.on("error", (e => {
                                            s(`pushed stream #${r.id} encountered error: ${e}`)
                                        })), r.on("frameError", ((e, t, n) => {
                                            s(`pushed stream #${r.id} encountered frameError: type: ${e}, code: ${t}, id: ${n}`)
                                        }))
                                    })(e, o, t, r, n)
                                }))
                            } else C && C.id !== h.socket.id && !C.inUse && (s(`discarding redundant socket used for ALPN: #${C.id} ${C.servername}`), C.destroy());
                            s(`${x} ${t.host}${m}`);
                            const {
                                signal: f
                            } = w, T = () => {
                                f.removeEventListener("abort", T), c(new a), u && u.close(l)
                            };
                            if (f) {
                                if (f.aborted) return void c(new a);
                                f.addEventListener("abort", T)
                            }
                            const k = e => {
                                s(`session ${o} encountered error during ${w.method} ${t.href}: ${e}`), c(e)
                            };
                            h.once("error", k), u = h.request({
                                ":method": x,
                                ":path": m,
                                ...E
                            }), u.once("response", (e => {
                                h.off("error", k), f && f.removeEventListener("abort", T), r(p(e, u, c))
                            })), u.once("error", (e => {
                                h.off("error", k), f && f.removeEventListener("abort", T), u.rstCode !== l && (s(`${w.method} ${t.href} failed with: ${e.message}`), u.close(l), c(e))
                            })), u.once("frameError", ((e, r, n) => {
                                h.off("error", k), s(`encountered frameError during ${w.method} ${t.href}: type: ${e}, code: ${r}, id: ${n}`)
                            })), u.on("push", ((e, t) => {
                                s(`received 'push' event: headers: ${JSON.stringify(e)}, flags: ${t}`)
                            })), S instanceof i ? S.pipe(u) : (S && u.write(S), u.end())
                        }))
                    },
                    setupContext: e => {
                        e.h2 = {
                            sessionCache: {}
                        }
                    },
                    resetContext: async ({
                        h2: e
                    }) => Promise.all(Object.values(e.sessionCache).map((e => new Promise((t => {
                        e.on("close", t), s(`resetContext: destroying session (socket #${e.socket&&e.socket.id}, ${e.socket&&e.socket.servername})`), e.destroy()
                    })))))
                }
            },
            3100: (e, t, r) => {
                "use strict";
                const n = r(8104)("helix-fetch:core"),
                    {
                        request: o,
                        setupContext: i,
                        resetContext: s,
                        RequestAbortedError: a,
                        ALPN_HTTP2: c,
                        ALPN_HTTP2C: l,
                        ALPN_HTTP1_1: u,
                        ALPN_HTTP1_0: d
                    } = r(9575);
                class p {
                    constructor(e) {
                        this.options = { ...e || {}
                        }, i(this)
                    }
                    api() {
                        return {
                            request: async (e, t) => this.request(e, t),
                            context: (e = {}) => new p(e).api(),
                            reset: async () => this.reset(),
                            RequestAbortedError: a,
                            ALPN_HTTP2: c,
                            ALPN_HTTP2C: l,
                            ALPN_HTTP1_1: u,
                            ALPN_HTTP1_0: d
                        }
                    }
                    async request(e, t) {
                        return o(this, e, t)
                    }
                    async reset() {
                        return n("resetting context"), s(this)
                    }
                }
                e.exports = (new p).api()
            },
            3769: (e, t, r) => {
                "use strict";
                const {
                    EventEmitter: n
                } = r(2361);
                e.exports = () => {
                    const e = {},
                        t = new n;
                    return t.setMaxListeners(0), {
                        acquire: r => new Promise((n => {
                            if (!e[r]) return e[r] = !0, void n();
                            const o = i => {
                                e[r] || (e[r] = !0, t.removeListener(r, o), n(i))
                            };
                            t.on(r, o)
                        })),
                        release: (r, n) => {
                            Reflect.deleteProperty(e, r), setImmediate((() => t.emit(r, n)))
                        }
                    }
                }
            },
            9575: (e, t, r) => {
                "use strict";
                const {
                    Readable: n
                } = r(2781), o = r(4404), i = r(9593), s = r(8104)("helix-fetch:core"), {
                    RequestAbortedError: a
                } = r(1787), c = r(9803), l = r(7262), u = r(3769), {
                    isPlainObject: d
                } = r(4544), {
                    isFormData: p,
                    FormDataSerializer: h
                } = r(9407), {
                    version: f
                } = r(5258), m = "h2", g = "h2c", _ = "http/1.0", y = "http/1.1", v = 100, b = 36e5, w = [m, y, _], x = `helix-fetch/${f}`, E = {
                    method: "GET",
                    compress: !0
                };
                let C = 0;
                const S = u();
                e.exports = {
                    request: async (e, t, r) => {
                        const i = new URL(t),
                            u = { ...E,
                                ...r || {}
                            };
                        let f;
                        if ("string" == typeof u.method && (u.method = u.method.toUpperCase()), u.headers = (e => {
                                const t = {};
                                return Object.keys(e).forEach((r => {
                                    t[r.toLowerCase()] = e[r]
                                })), t
                            })(u.headers || {}), void 0 === u.headers.host && (u.headers.host = i.host), e.userAgent && void 0 === u.headers["user-agent"] && (u.headers["user-agent"] = e.userAgent), u.body instanceof URLSearchParams) f = "application/x-www-form-urlencoded; charset=utf-8", u.body = u.body.toString();
                        else if (p(u.body)) {
                            const e = new h(u.body);
                            f = e.contentType(), u.body = e.stream(), void 0 === u.headers["transfer-encoding"] && void 0 === u.headers["content-length"] && (u.headers["content-length"] = String(e.length()))
                        } else "string" == typeof u.body || u.body instanceof String ? f = "text/plain; charset=utf-8" : d(u.body) && (u.body = JSON.stringify(u.body), f = "application/json");
                        void 0 === u.headers["content-type"] && void 0 !== f && (u.headers["content-type"] = f), null != u.body && (u.body instanceof n || ("string" == typeof u.body || u.body instanceof String || Buffer.isBuffer(u.body) || (u.body = String(u.body)), void 0 === u.headers["transfer-encoding"] && void 0 === u.headers["content-length"] && (u.headers["content-length"] = String(Buffer.isBuffer(u.body) ? u.body.length : Buffer.byteLength(u.body, "utf-8"))))), void 0 === u.headers.accept && (u.headers.accept = "*/*"), null == u.body && ["POST", "PUT"].includes(u.method) && (u.headers["content-length"] = "0"), u.compress && void 0 === u.headers["accept-encoding"] && (u.headers["accept-encoding"] = "gzip,deflate,br");
                        const {
                            signal: v
                        } = u, {
                            protocol: b,
                            socket: w = null
                        } = await (async (e, t, r) => {
                            const n = `${t.protocol}//${t.host}`;
                            let i = e.alpnCache.get(n);
                            if (i) return {
                                protocol: i
                            };
                            switch (t.protocol) {
                                case "http:":
                                    return i = y, e.alpnCache.set(n, i), {
                                        protocol: i
                                    };
                                case "http2:":
                                    return i = g, e.alpnCache.set(n, i), {
                                        protocol: i
                                    };
                                case "https:":
                                    break;
                                default:
                                    throw new TypeError(`unsupported protocol: ${t.protocol}`)
                            }
                            const {
                                options: {
                                    rejectUnauthorized: c,
                                    h1: l = {},
                                    h2: u = {}
                                }
                            } = e, d = !(!1 === c || !1 === l.rejectUnauthorized || !1 === u.rejectUnauthorized), p = {
                                servername: t.hostname,
                                ALPNProtocols: e.alpnProtocols,
                                signal: r,
                                rejectUnauthorized: d
                            }, h = await (async (e, t) => {
                                let r = await S.acquire(e.origin);
                                try {
                                    return r || (r = await ((e, t) => new Promise(((r, n) => {
                                        const {
                                            signal: i
                                        } = t;
                                        let c;
                                        const l = () => {
                                            i.removeEventListener("abort", l);
                                            const e = new a;
                                            n(e), c && c.destroy(e)
                                        };
                                        if (i) {
                                            if (i.aborted) return void n(new a);
                                            i.addEventListener("abort", l)
                                        }
                                        const u = +e.port || 443,
                                            d = t => {
                                                i && i.removeEventListener("abort", l), t instanceof a || (s(`connecting to ${e.hostname}:${u} failed with: ${t.message}`), n(t))
                                            };
                                        c = o.connect(u, e.hostname, t), c.once("secureConnect", (() => {
                                            i && i.removeEventListener("abort", l), c.off("error", d), C += 1, c.id = C, c.secureConnecting = !1, s(`established TLS connection: #${c.id} (${c.servername})`), r(c)
                                        })), c.once("error", d)
                                    })))(e, t)), r
                                } finally {
                                    S.release(e.origin, r)
                                }
                            })(t, p);
                            return i = h.alpnProtocol, i || (i = y), e.alpnCache.set(n, i), {
                                protocol: i,
                                socket: h
                            }
                        })(e, i, v);
                        switch (s(`${i.host} -> ${b}`), b) {
                            case m:
                                try {
                                    return await l.request(e, i, w ? { ...u,
                                        socket: w
                                    } : u)
                                } catch (t) {
                                    const {
                                        code: r,
                                        message: n
                                    } = t;
                                    throw "ERR_HTTP2_ERROR" === r && "Protocol error" === n && e.alpnCache.del(`${i.protocol}//${i.host}`), t
                                }
                            case g:
                                return l.request(e, new URL(`http://${i.host}${i.pathname}${i.hash}${i.search}`), w ? { ...u,
                                    socket: w
                                } : u);
                            case _:
                            case y:
                                return c.request(e, i, w ? { ...u,
                                    socket: w
                                } : u);
                            default:
                                throw new TypeError(`unsupported protocol: ${b}`)
                        }
                    },
                    setupContext: e => {
                        const {
                            options: {
                                alpnProtocols: t = w,
                                alpnCacheTTL: r = b,
                                alpnCacheSize: n = v,
                                userAgent: o = x
                            }
                        } = e;
                        e.alpnProtocols = t, e.alpnCache = new i({
                            max: n,
                            maxAge: r
                        }), e.userAgent = o, c.setupContext(e), l.setupContext(e)
                    },
                    resetContext: async e => (e.alpnCache.reset(), Promise.all([c.resetContext(e), l.resetContext(e)])),
                    RequestAbortedError: a,
                    ALPN_HTTP2: m,
                    ALPN_HTTP2C: g,
                    ALPN_HTTP1_1: y,
                    ALPN_HTTP1_0: _
                }
            },
            6829: (e, t, r) => {
                "use strict";
                const {
                    EventEmitter: n
                } = r(2361), o = Symbol("AbortSignal internals");
                class i {
                    constructor() {
                        this[o] = {
                            eventEmitter: new n,
                            onabort: null,
                            aborted: !1
                        }
                    }
                    get aborted() {
                        return this[o].aborted
                    }
                    get onabort() {
                        return this[o].onabort
                    }
                    set onabort(e) {
                        this[o].onabort = e
                    }
                    get[Symbol.toStringTag]() {
                        return this.constructor.name
                    }
                    removeEventListener(e, t) {
                        this[o].eventEmitter.removeListener(e, t)
                    }
                    addEventListener(e, t) {
                        this[o].eventEmitter.on(e, t)
                    }
                    dispatchEvent(e) {
                        const t = {
                                type: e,
                                target: this
                            },
                            r = `on${e}`;
                        "function" == typeof this[o][r] && this[r](t), this[o].eventEmitter.emit(e, t)
                    }
                    fire() {
                        this[o].aborted = !0, this.dispatchEvent("abort")
                    }
                }
                Object.defineProperties(i.prototype, {
                    addEventListener: {
                        enumerable: !0
                    },
                    removeEventListener: {
                        enumerable: !0
                    },
                    dispatchEvent: {
                        enumerable: !0
                    },
                    aborted: {
                        enumerable: !0
                    },
                    onabort: {
                        enumerable: !0
                    }
                });
                class s extends i {
                    constructor(e) {
                        if (!Number.isInteger(e)) throw new TypeError("Expected an integer, got " + typeof e);
                        super(), this[o].timerId = setTimeout((() => {
                            this.fire()
                        }), e)
                    }
                    clear() {
                        clearTimeout(this[o].timerId)
                    }
                }
                Object.defineProperties(s.prototype, {
                    clear: {
                        enumerable: !0
                    }
                });
                const a = Symbol("AbortController internals");
                class c {
                    constructor() {
                        this[a] = {
                            signal: new i
                        }
                    }
                    get signal() {
                        return this[a].signal
                    }
                    get[Symbol.toStringTag]() {
                        return this.constructor.name
                    }
                    abort() {
                        this[a].signal.aborted || this[a].signal.fire()
                    }
                }
                Object.defineProperties(c.prototype, {
                    signal: {
                        enumerable: !0
                    },
                    abort: {
                        enumerable: !0
                    }
                }), e.exports = {
                    AbortController: c,
                    AbortSignal: i,
                    TimeoutSignal: s
                }
            },
            5600: (e, t, r) => {
                "use strict";
                const {
                    PassThrough: n,
                    Readable: o
                } = r(2781), {
                    FetchError: i,
                    FetchBaseError: s
                } = r(3683), {
                    streamToBuffer: a
                } = r(4544), c = Buffer.alloc(0), l = Symbol("Body internals"), u = async e => {
                    if (e[l].disturbed) throw new TypeError("Already read");
                    if (e[l].error) throw new TypeError(`Stream had error: ${e[l].error.message}`);
                    e[l].disturbed = !0;
                    const {
                        stream: t
                    } = e[l];
                    return null === t ? c : a(t)
                };
                class d {
                    constructor(e) {
                        let t;
                        t = null == e ? null : e instanceof URLSearchParams ? o.from(e.toString()) : e instanceof o ? e : Buffer.isBuffer(e) || "string" == typeof e || e instanceof String ? o.from(e) : o.from(String(e)), this[l] = {
                            stream: t,
                            disturbed: !1,
                            error: null
                        }, e instanceof o && t.on("error", (e => {
                            const t = e instanceof s ? e : new i(`Invalid response body while trying to fetch ${this.url}: ${e.message}`, "system", e);
                            this[l].error = t
                        }))
                    }
                    get body() {
                        return this[l].stream
                    }
                    get bodyUsed() {
                        return this[l].disturbed
                    }
                    async buffer() {
                        return u(this)
                    }
                    async arrayBuffer() {
                        return (e = await this.buffer()).buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
                        var e
                    }
                    async text() {
                        return (await u(this)).toString()
                    }
                    async json() {
                        return JSON.parse(await this.text())
                    }
                }
                Object.defineProperties(d.prototype, {
                    body: {
                        enumerable: !0
                    },
                    bodyUsed: {
                        enumerable: !0
                    },
                    arrayBuffer: {
                        enumerable: !0
                    },
                    json: {
                        enumerable: !0
                    },
                    text: {
                        enumerable: !0
                    }
                }), e.exports = {
                    Body: d,
                    cloneStream: e => {
                        if (e[l].disturbed) throw new TypeError("Cannot clone: already read");
                        const {
                            stream: t
                        } = e[l];
                        let r = t;
                        if (t instanceof o) {
                            r = new n;
                            const o = new n;
                            t.pipe(r), t.pipe(o), e[l].stream = o
                        }
                        return r
                    },
                    guessContentType: e => null === e ? null : "string" == typeof e ? "text/plain; charset=utf-8" : e instanceof URLSearchParams ? "application/x-www-form-urlencoded; charset=utf-8" : Buffer.isBuffer(e) || e instanceof o ? null : "text/plain; charset=utf-8"
                }
            },
            2500: (e, t, r) => {
                "use strict";
                const {
                    Readable: n
                } = r(2781), {
                    Headers: o
                } = r(9872), {
                    Response: i
                } = r(2981), s = Symbol("CacheableResponse internals");
                class a extends i {
                    constructor(e, t) {
                        super(e, t);
                        const r = new o(t.headers);
                        this[s] = {
                            headers: r,
                            bufferedBody: e
                        }
                    }
                    get headers() {
                        return this[s].headers
                    }
                    set headers(e) {
                        if (!(e instanceof o)) throw new TypeError("instance of Headers expected");
                        this[s].headers = e
                    }
                    get body() {
                        return n.from(this[s].bufferedBody)
                    }
                    get bodyUsed() {
                        return !1
                    }
                    async buffer() {
                        return this[s].bufferedBody
                    }
                    async arrayBuffer() {
                        return (e = this[s].bufferedBody).buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
                        var e
                    }
                    async text() {
                        return this[s].bufferedBody.toString()
                    }
                    async json() {
                        return JSON.parse(await this.text())
                    }
                    clone() {
                        const {
                            url: e,
                            status: t,
                            statusText: r,
                            headers: n,
                            httpVersion: o,
                            counter: i
                        } = this;
                        return new a(this[s].bufferedBody, {
                            url: e,
                            status: t,
                            statusText: r,
                            headers: n,
                            httpVersion: o,
                            counter: i
                        })
                    }
                    get[Symbol.toStringTag]() {
                        return this.constructor.name
                    }
                }
                e.exports = {
                    cacheableResponse: async e => {
                        const t = await e.buffer(),
                            {
                                url: r,
                                status: n,
                                statusText: o,
                                headers: i,
                                httpVersion: s,
                                counter: c
                            } = e;
                        return new a(t, {
                            url: r,
                            status: n,
                            statusText: o,
                            headers: i,
                            httpVersion: s,
                            counter: c
                        })
                    }
                }
            },
            3683: e => {
                "use strict";
                class t extends Error {
                    constructor(e, t) {
                        super(e), this.type = t
                    }
                    get name() {
                        return this.constructor.name
                    }
                    get[Symbol.toStringTag]() {
                        return this.constructor.name
                    }
                }
                e.exports = {
                    FetchBaseError: t,
                    FetchError: class extends t {
                        constructor(e, t, r) {
                            super(e, t), r && (this.code = this.errno = r.code, this.erroredSysCall = r.syscall)
                        }
                    },
                    AbortError: class extends t {
                        constructor(e, t = "aborted") {
                            super(e, t)
                        }
                    }
                }
            },
            9872: (e, t, r) => {
                "use strict";
                const {
                    validateHeaderName: n,
                    validateHeaderValue: o
                } = r(3685), {
                    isPlainObject: i
                } = r(4544), s = Symbol("Headers internals"), a = e => {
                    const t = "string" != typeof e ? String(e) : e;
                    if ("function" == typeof n) n(t);
                    else if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(t)) {
                        const e = new TypeError(`Header name must be a valid HTTP token [${t}]`);
                        throw Object.defineProperty(e, "code", {
                            value: "ERR_INVALID_HTTP_TOKEN"
                        }), e
                    }
                    return t.toLowerCase()
                }, c = e => {
                    const t = "string" != typeof e ? String(e) : e;
                    if ("function" == typeof o) o("dummy", t);
                    else if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(t)) {
                        const e = new TypeError(`Invalid character in header content ["${t}"]`);
                        throw Object.defineProperty(e, "code", {
                            value: "ERR_INVALID_CHAR"
                        }), e
                    }
                    return t
                };
                class l {
                    constructor(e = {}) {
                        if (this[s] = {
                                map: new Map
                            }, e instanceof l) e.forEach(((e, t) => {
                            this.append(t, e)
                        }));
                        else if (Array.isArray(e)) e.forEach((([e, t]) => {
                            this.append(e, t)
                        }));
                        else if (i(e))
                            for (const [t, r] of Object.entries(e)) this.append(t, r)
                    }
                    set(e, t) {
                        this[s].map.set(a(e), c(t))
                    }
                    has(e) {
                        return this[s].map.has(a(e))
                    }
                    get(e) {
                        const t = this[s].map.get(a(e));
                        return void 0 === t ? null : t
                    }
                    append(e, t) {
                        const r = a(e),
                            n = c(t),
                            o = this[s].map.get(r);
                        this[s].map.set(r, o ? `${o}, ${n}` : n)
                    }
                    delete(e) {
                        this[s].map.delete(a(e))
                    }
                    forEach(e, t) {
                        for (const r of this.keys()) e.call(t, this.get(r), r)
                    }
                    keys() {
                        return Array.from(this[s].map.keys()).sort()
                    }* values() {
                        for (const e of this.keys()) yield this.get(e)
                    }* entries() {
                        for (const e of this.keys()) yield [e, this.get(e)]
                    }[Symbol.iterator]() {
                        return this.entries()
                    }
                    get[Symbol.toStringTag]() {
                        return this.constructor.name
                    }
                    plain() {
                        return Object.fromEntries(this[s].map)
                    }
                }
                Object.defineProperties(l.prototype, ["append", "delete", "entries", "forEach", "get", "has", "keys", "set", "values"].reduce(((e, t) => (e[t] = {
                    enumerable: !0
                }, e)), {})), e.exports = {
                    Headers: l
                }
            },
            6143: (e, t, r) => {
                "use strict";
                const {
                    EventEmitter: n
                } = r(2361), {
                    Readable: o
                } = r(2781), i = r(8104)("helix-fetch"), s = r(9593), {
                    Body: a
                } = r(5600), {
                    Headers: c
                } = r(9872), {
                    Request: l
                } = r(8359), {
                    Response: u
                } = r(2981), {
                    FetchBaseError: d,
                    FetchError: p,
                    AbortError: h
                } = r(3683), {
                    AbortController: f,
                    AbortSignal: m,
                    TimeoutSignal: g
                } = r(6829), _ = r(4193), {
                    cacheableResponse: y
                } = r(2500), {
                    sizeof: v
                } = r(4544), {
                    isFormData: b
                } = r(9407), {
                    context: w,
                    RequestAbortedError: x
                } = r(3100), E = ["GET", "HEAD"], C = "push", S = async (e, t, r) => {
                    const {
                        request: n
                    } = e.context, i = t instanceof l && void 0 === r ? t : new l(t, r), {
                        method: s,
                        body: a,
                        signal: d,
                        compress: f,
                        follow: m,
                        redirect: g,
                        init: {
                            body: _
                        }
                    } = i;
                    let y;
                    if (d && d.aborted) {
                        const e = new h("The operation was aborted.");
                        throw i.init.body instanceof o && i.init.body.destroy(e), e
                    }
                    try {
                        y = await n(i.url, { ...r,
                            method: s,
                            headers: i.headers.plain(),
                            body: !_ || _ instanceof o || b(_) ? a : _,
                            compress: f,
                            follow: m,
                            redirect: g,
                            signal: d
                        })
                    } catch (e) {
                        if (_ instanceof o && _.destroy(e), e instanceof TypeError) throw e;
                        if (e instanceof x) throw new h("The operation was aborted.");
                        throw new p(e.message, "system", e)
                    }
                    const v = () => {
                        d.removeEventListener("abort", v);
                        const e = new h("The operation was aborted.");
                        i.init.body instanceof o && i.init.body.destroy(e), y.readable.emit("error", e)
                    };
                    d && d.addEventListener("abort", v);
                    const {
                        statusCode: w,
                        statusText: E,
                        httpVersion: C,
                        headers: T,
                        readable: k
                    } = y;
                    if ([301, 302, 303, 307, 308].includes(w)) {
                        const {
                            location: t
                        } = T, r = null == t ? null : new URL(t, i.url);
                        switch (i.redirect) {
                            case "manual":
                                break;
                            case "error":
                                throw d && d.removeEventListener("abort", v), new p(`uri requested responds with a redirect, redirect mode is set to 'error': ${i.url}`, "no-redirect");
                            case "follow":
                                {
                                    if (null === r) break;
                                    if (i.counter >= i.follow) throw d && d.removeEventListener("abort", v), new p(`maximum redirect reached at: ${i.url}`, "max-redirect");
                                    const t = {
                                        headers: new c(i.headers),
                                        follow: i.follow,
                                        compress: i.compress,
                                        counter: i.counter + 1,
                                        method: i.method,
                                        body: i.body,
                                        signal: i.signal
                                    };
                                    if (303 !== w && i.body && i.init.body instanceof o) throw d && d.removeEventListener("abort", v), new p("Cannot follow redirect with body being a readable stream", "unsupported-redirect");
                                    return 303 !== w && (301 !== w && 302 !== w || "POST" !== i.method) || (t.method = "GET", t.body = void 0, t.headers.delete("content-length")),
                                    d && d.removeEventListener("abort", v),
                                    S(e, new l(r, t))
                                }
                        }
                    }
                    return d && (k.once("end", (() => {
                        d.removeEventListener("abort", v)
                    })), k.once("error", (() => {
                        d.removeEventListener("abort", v)
                    }))), new u(k, {
                        url: i.url,
                        status: w,
                        statusText: E,
                        headers: T,
                        httpVersion: C,
                        counter: i.counter
                    })
                }, T = async (e, t, r) => {
                    if (0 === e.options.maxCacheSize) return r;
                    if (!E.includes(t.method)) return r;
                    const n = new _(t, r, {
                        shared: !1
                    });
                    if (n.storable()) {
                        const o = await y(r);
                        return e.cache.set(t.url, {
                            policy: n,
                            response: o
                        }, n.timeToLive()), o
                    }
                    return r
                }, k = (e, t = {}) => {
                    const r = new URL(e);
                    if ("object" != typeof t || Array.isArray(t)) throw new TypeError("qs: object expected");
                    return Object.entries(t).forEach((([e, t]) => {
                        Array.isArray(t) ? t.forEach((t => r.searchParams.append(e, t))) : r.searchParams.append(e, t)
                    })), r.href
                }, I = e => new g(e);
                class P {
                    constructor(e) {
                        this.options = { ...e
                        };
                        const {
                            maxCacheSize: t
                        } = this.options;
                        let r = "number" == typeof t && t >= 0 ? t : 104857600;
                        0 === r && (r = 1), this.cache = new s({
                            max: r,
                            length: ({
                                response: e
                            }, t) => v(e)
                        }), this.eventEmitter = new n, this.options.h2 = this.options.h2 || {}, void 0 === this.options.h2.enablePush && (this.options.h2.enablePush = !0);
                        const {
                            enablePush: o
                        } = this.options.h2;
                        o && (this.options.h2.pushPromiseHandler = (e, t, r) => {
                            const n = { ...t
                            };
                            Object.keys(n).filter((e => e.startsWith(":"))).forEach((e => delete n[e])), this.pushPromiseHandler(e, n, r)
                        }, this.options.h2.pushHandler = (e, t, r) => {
                            const n = { ...t
                            };
                            Object.keys(n).filter((e => e.startsWith(":"))).forEach((e => delete n[e]));
                            const {
                                statusCode: o,
                                statusText: i,
                                httpVersion: s,
                                headers: a,
                                readable: c
                            } = r;
                            this.pushHandler(e, n, new u(c, {
                                url: e,
                                status: o,
                                statusText: i,
                                headers: a,
                                httpVersion: s
                            }))
                        }), this.context = w(this.options)
                    }
                    api() {
                        return {
                            fetch: async (e, t) => this.fetch(e, t),
                            Body: a,
                            Headers: c,
                            Request: l,
                            Response: u,
                            AbortController: f,
                            AbortSignal: m,
                            FetchBaseError: d,
                            FetchError: p,
                            AbortError: h,
                            context: (e = {}) => new P(e).api(),
                            noCache: (e = {}) => new P({ ...e,
                                maxCacheSize: 0
                            }).api(),
                            h1: (e = {}) => new P({ ...e,
                                alpnProtocols: [this.context.ALPN_HTTP1_1]
                            }).api(),
                            keepAlive: (e = {}) => new P({ ...e,
                                alpnProtocols: [this.context.ALPN_HTTP1_1],
                                h1: {
                                    keepAlive: !0
                                }
                            }).api(),
                            h1NoCache: (e = {}) => new P({ ...e,
                                maxCacheSize: 0,
                                alpnProtocols: [this.context.ALPN_HTTP1_1]
                            }).api(),
                            keepAliveNoCache: (e = {}) => new P({ ...e,
                                maxCacheSize: 0,
                                alpnProtocols: [this.context.ALPN_HTTP1_1],
                                h1: {
                                    keepAlive: !0
                                }
                            }).api(),
                            reset: async () => this.context.reset(),
                            onPush: e => this.onPush(e),
                            offPush: e => this.offPush(e),
                            createUrl: k,
                            timeoutSignal: I,
                            clearCache: () => this.clearCache(),
                            cacheStats: () => this.cacheStats(),
                            ALPN_HTTP2: this.context.ALPN_HTTP2,
                            ALPN_HTTP2C: this.context.ALPN_HTTP2C,
                            ALPN_HTTP1_1: this.context.ALPN_HTTP1_1,
                            ALPN_HTTP1_0: this.context.ALPN_HTTP1_0
                        }
                    }
                    async fetch(e, t) {
                        return (async (e, t, r) => {
                            const n = new l(t, r);
                            if (0 !== e.options.maxCacheSize && E.includes(n.method) && !["no-store", "reload"].includes(n.cache)) {
                                const {
                                    policy: t,
                                    response: r
                                } = e.cache.get(n.url) || {};
                                if (t && t.satisfiesWithoutRevalidation(n)) {
                                    r.headers = new c(t.responseHeaders(r));
                                    const e = r.clone();
                                    return e.fromCache = !0, e
                                }
                            }
                            const o = await S(e, n);
                            return "no-store" !== n.cache ? T(e, n, o) : o
                        })(this, e, t)
                    }
                    onPush(e) {
                        return this.eventEmitter.on(C, e)
                    }
                    offPush(e) {
                        return this.eventEmitter.off(C, e)
                    }
                    clearCache() {
                        this.cache.reset()
                    }
                    cacheStats() {
                        return {
                            size: this.cache.length,
                            count: this.cache.itemCount
                        }
                    }
                    pushPromiseHandler(e, t, r) {
                        i(`received server push promise: ${e}, headers: ${JSON.stringify(t)}`);
                        const n = new l(e, {
                                headers: t
                            }),
                            {
                                policy: o
                            } = this.cache.get(e) || {};
                        o && o.satisfiesWithoutRevalidation(n) && (i(`already cached, reject push promise: ${e}, headers: ${JSON.stringify(t)}`), r())
                    }
                    async pushHandler(e, t, r) {
                        i(`caching resource pushed by server: ${e}, reqHeaders: ${JSON.stringify(t)}, status: ${r.status}, respHeaders: ${JSON.stringify(r.headers)}`);
                        const n = await T(this, new l(e, {
                            headers: t
                        }), r);
                        this.eventEmitter.emit(C, e, n)
                    }
                }
                e.exports = (new P).api()
            },
            4193: (e, t, r) => {
                "use strict";
                const n = r(6214),
                    {
                        Headers: o
                    } = r(9872),
                    i = e => ({
                        url: e.url,
                        method: e.method,
                        headers: e.headers.plain()
                    }),
                    s = e => ({
                        status: e.status,
                        headers: e.headers.plain()
                    });
                e.exports = class {
                    constructor(e, t, r) {
                        this.policy = new n(i(e), s(t), r)
                    }
                    storable() {
                        return this.policy.storable()
                    }
                    satisfiesWithoutRevalidation(e) {
                        return this.policy.satisfiesWithoutRevalidation(i(e))
                    }
                    responseHeaders(e) {
                        return new o(this.policy.responseHeaders(s(e)))
                    }
                    timeToLive() {
                        return this.policy.timeToLive()
                    }
                }
            },
            8359: (e, t, r) => {
                "use strict";
                const {
                    AbortSignal: n
                } = r(6829), {
                    Body: o,
                    cloneStream: i,
                    guessContentType: s
                } = r(5600), {
                    Headers: a
                } = r(9872), {
                    isPlainObject: c
                } = r(4544), {
                    isFormData: l,
                    FormDataSerializer: u
                } = r(9407), d = Symbol("Request internals");
                class p extends o {
                    constructor(e, t = {}) {
                        const r = e instanceof p ? e : null,
                            o = r ? new URL(r.url) : new URL(e);
                        let h = t.method || r && r.method || "GET";
                        if (h = h.toUpperCase(), (null != t.body || r && null !== r.body) && ["GET", "HEAD"].includes(h)) throw new TypeError("Request with GET/HEAD method cannot have body");
                        let f = t.body || (r && r.body ? i(r) : null);
                        const m = new a(t.headers || r && r.headers || {});
                        if (l(f) && !m.has("content-type")) {
                            const e = new u(f);
                            f = e.stream(), m.set("content-type", e.contentType()), m.has("transfer-encoding") || m.has("content-length") || m.set("content-length", e.length())
                        }
                        if (!m.has("content-type"))
                            if (c(f)) f = JSON.stringify(f), m.set("content-type", "application/json");
                            else {
                                const e = s(f);
                                e && m.set("content-type", e)
                            }
                        super(f);
                        let g = r ? r.signal : null;
                        if ("signal" in t && (g = t.signal), g && !(g instanceof n)) throw new TypeError("signal needs to be an instance of AbortSignal");
                        const _ = t.redirect || r && r.redirect || "follow";
                        if (!["follow", "error", "manual"].includes(_)) throw new TypeError(`'${_}' is not a valid redirect option`);
                        const y = t.cache || r && r.cache || "default";
                        if (!["default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"].includes(y)) throw new TypeError(`'${y}' is not a valid cache option`);
                        this[d] = {
                            init: { ...t
                            },
                            method: h,
                            redirect: _,
                            cache: y,
                            headers: m,
                            parsedURL: o,
                            signal: g
                        }, void 0 === t.follow ? r && void 0 !== r.follow ? this.follow = r.follow : this.follow = 20 : this.follow = t.follow, this.counter = t.counter || r && r.counter || 0, void 0 === t.compress ? r && void 0 !== r.compress ? this.compress = r.compress : this.compress = !0 : this.compress = t.compress
                    }
                    get method() {
                        return this[d].method
                    }
                    get url() {
                        return this[d].parsedURL.toString()
                    }
                    get headers() {
                        return this[d].headers
                    }
                    get redirect() {
                        return this[d].redirect
                    }
                    get cache() {
                        return this[d].cache
                    }
                    get signal() {
                        return this[d].signal
                    }
                    clone() {
                        return new p(this)
                    }
                    get init() {
                        return this[d].init
                    }
                    get[Symbol.toStringTag]() {
                        return this.constructor.name
                    }
                }
                Object.defineProperties(p.prototype, {
                    method: {
                        enumerable: !0
                    },
                    url: {
                        enumerable: !0
                    },
                    headers: {
                        enumerable: !0
                    },
                    redirect: {
                        enumerable: !0
                    },
                    cache: {
                        enumerable: !0
                    },
                    clone: {
                        enumerable: !0
                    },
                    signal: {
                        enumerable: !0
                    }
                }), e.exports = {
                    Request: p
                }
            },
            2981: (e, t, r) => {
                "use strict";
                const {
                    Body: n,
                    cloneStream: o,
                    guessContentType: i
                } = r(5600), {
                    Headers: s
                } = r(9872), {
                    isPlainObject: a
                } = r(4544), {
                    isFormData: c,
                    FormDataSerializer: l
                } = r(9407), u = Symbol("Response internals");
                class d extends n {
                    constructor(e = null, t = {}) {
                        const r = new s(t.headers);
                        let n = e;
                        if (c(n) && !r.has("content-type")) {
                            const e = new l(n);
                            n = e.stream(), r.set("content-type", e.contentType()), r.has("transfer-encoding") || r.has("content-length") || r.set("content-length", e.length())
                        }
                        if (null !== n && !r.has("content-type"))
                            if (a(n)) n = JSON.stringify(n), r.set("content-type", "application/json");
                            else {
                                const e = i(n);
                                e && r.set("content-type", e)
                            }
                        super(n), this[u] = {
                            url: t.url,
                            status: t.status || 200,
                            statusText: t.statusText || "",
                            headers: r,
                            httpVersion: t.httpVersion,
                            counter: t.counter
                        }
                    }
                    get url() {
                        return this[u].url || ""
                    }
                    get status() {
                        return this[u].status
                    }
                    get statusText() {
                        return this[u].statusText
                    }
                    get ok() {
                        return this[u].status >= 200 && this[u].status < 300
                    }
                    get redirected() {
                        return this[u].counter > 0
                    }
                    get headers() {
                        return this[u].headers
                    }
                    get httpVersion() {
                        return this[u].httpVersion
                    }
                    static redirect(e, t = 302) {
                        if (![301, 302, 303, 307, 308].includes(t)) throw new RangeError("Invalid status code");
                        return new d(null, {
                            headers: {
                                location: new URL(e).toString()
                            },
                            status: t
                        })
                    }
                    clone() {
                        if (this.bodyUsed) throw new TypeError("Cannot clone: already read");
                        return new d(o(this), { ...this[u]
                        })
                    }
                    get[Symbol.toStringTag]() {
                        return this.constructor.name
                    }
                }
                Object.defineProperties(d.prototype, {
                    url: {
                        enumerable: !0
                    },
                    status: {
                        enumerable: !0
                    },
                    ok: {
                        enumerable: !0
                    },
                    redirected: {
                        enumerable: !0
                    },
                    statusText: {
                        enumerable: !0
                    },
                    headers: {
                        enumerable: !0
                    },
                    clone: {
                        enumerable: !0
                    }
                }), e.exports = {
                    Response: d
                }
            },
            9825: (e, t, r) => {
                "use strict";
                e.exports = r(6143)
            },
            1581: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
                const n = r(7159),
                    o = r(3924),
                    i = r(1240),
                    s = r(98),
                    a = ["/properties"],
                    c = "http://json-schema.org/draft-07/schema";
                class l extends n.default {
                    _addVocabularies() {
                        super._addVocabularies(), o.default.forEach((e => this.addVocabulary(e))), this.opts.discriminator && this.addKeyword(i.default)
                    }
                    _addDefaultMetaSchema() {
                        if (super._addDefaultMetaSchema(), !this.opts.meta) return;
                        const e = this.opts.$data ? this.$dataMetaSchema(s, a) : s;
                        this.addMetaSchema(e, c, !1), this.refs["http://json-schema.org/schema"] = c
                    }
                    defaultMeta() {
                        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(c) ? c : void 0)
                    }
                }
                e.exports = t = l, Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = l;
                var u = r(4815);
                Object.defineProperty(t, "KeywordCxt", {
                    enumerable: !0,
                    get: function() {
                        return u.KeywordCxt
                    }
                });
                var d = r(3487);
                Object.defineProperty(t, "_", {
                    enumerable: !0,
                    get: function() {
                        return d._
                    }
                }), Object.defineProperty(t, "str", {
                    enumerable: !0,
                    get: function() {
                        return d.str
                    }
                }), Object.defineProperty(t, "stringify", {
                    enumerable: !0,
                    get: function() {
                        return d.stringify
                    }
                }), Object.defineProperty(t, "nil", {
                    enumerable: !0,
                    get: function() {
                        return d.nil
                    }
                }), Object.defineProperty(t, "Name", {
                    enumerable: !0,
                    get: function() {
                        return d.Name
                    }
                }), Object.defineProperty(t, "CodeGen", {
                    enumerable: !0,
                    get: function() {
                        return d.CodeGen
                    }
                })
            },
            7023: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.regexpCode = t.getProperty = t.safeStringify = t.stringify = t.strConcat = t.addCodeArg = t.str = t._ = t.nil = t._Code = t.Name = t.IDENTIFIER = t._CodeOrName = void 0;
                class r {}
                t._CodeOrName = r, t.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
                class n extends r {
                    constructor(e) {
                        if (super(), !t.IDENTIFIER.test(e)) throw new Error("CodeGen: name must be a valid identifier");
                        this.str = e
                    }
                    toString() {
                        return this.str
                    }
                    emptyStr() {
                        return !1
                    }
                    get names() {
                        return {
                            [this.str]: 1
                        }
                    }
                }
                t.Name = n;
                class o extends r {
                    constructor(e) {
                        super(), this._items = "string" == typeof e ? [e] : e
                    }
                    toString() {
                        return this.str
                    }
                    emptyStr() {
                        if (this._items.length > 1) return !1;
                        const e = this._items[0];
                        return "" === e || '""' === e
                    }
                    get str() {
                        var e;
                        return null !== (e = this._str) && void 0 !== e ? e : this._str = this._items.reduce(((e, t) => `${e}${t}`), "")
                    }
                    get names() {
                        var e;
                        return null !== (e = this._names) && void 0 !== e ? e : this._names = this._items.reduce(((e, t) => (t instanceof n && (e[t.str] = (e[t.str] || 0) + 1), e)), {})
                    }
                }

                function i(e, ...t) {
                    const r = [e[0]];
                    let n = 0;
                    for (; n < t.length;) c(r, t[n]), r.push(e[++n]);
                    return new o(r)
                }
                t._Code = o, t.nil = new o(""), t._ = i;
                const s = new o("+");

                function a(e, ...t) {
                    const r = [u(e[0])];
                    let n = 0;
                    for (; n < t.length;) r.push(s), c(r, t[n]), r.push(s, u(e[++n]));
                    return function(e) {
                        let t = 1;
                        for (; t < e.length - 1;) {
                            if (e[t] === s) {
                                const r = l(e[t - 1], e[t + 1]);
                                if (void 0 !== r) {
                                    e.splice(t - 1, 3, r);
                                    continue
                                }
                                e[t++] = "+"
                            }
                            t++
                        }
                    }(r), new o(r)
                }

                function c(e, t) {
                    var r;
                    t instanceof o ? e.push(...t._items) : t instanceof n ? e.push(t) : e.push("number" == typeof(r = t) || "boolean" == typeof r || null === r ? r : u(Array.isArray(r) ? r.join(",") : r))
                }

                function l(e, t) {
                    if ('""' === t) return e;
                    if ('""' === e) return t;
                    if ("string" == typeof e) {
                        if (t instanceof n || '"' !== e[e.length - 1]) return;
                        return "string" != typeof t ? `${e.slice(0,-1)}${t}"` : '"' === t[0] ? e.slice(0, -1) + t.slice(1) : void 0
                    }
                    return "string" != typeof t || '"' !== t[0] || e instanceof n ? void 0 : `"${e}${t.slice(1)}`
                }

                function u(e) {
                    return JSON.stringify(e).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029")
                }
                t.str = a, t.addCodeArg = c, t.strConcat = function(e, t) {
                    return t.emptyStr() ? e : e.emptyStr() ? t : a `${e}${t}`
                }, t.stringify = function(e) {
                    return new o(u(e))
                }, t.safeStringify = u, t.getProperty = function(e) {
                    return "string" == typeof e && t.IDENTIFIER.test(e) ? new o(`.${e}`) : i `[${e}]`
                }, t.regexpCode = function(e) {
                    return new o(e.toString())
                }
            },
            3487: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.or = t.and = t.not = t.CodeGen = t.operators = t.varKinds = t.ValueScopeName = t.ValueScope = t.Scope = t.Name = t.regexpCode = t.stringify = t.getProperty = t.nil = t.strConcat = t.str = t._ = void 0;
                const n = r(7023),
                    o = r(8490);
                var i = r(7023);
                Object.defineProperty(t, "_", {
                    enumerable: !0,
                    get: function() {
                        return i._
                    }
                }), Object.defineProperty(t, "str", {
                    enumerable: !0,
                    get: function() {
                        return i.str
                    }
                }), Object.defineProperty(t, "strConcat", {
                    enumerable: !0,
                    get: function() {
                        return i.strConcat
                    }
                }), Object.defineProperty(t, "nil", {
                    enumerable: !0,
                    get: function() {
                        return i.nil
                    }
                }), Object.defineProperty(t, "getProperty", {
                    enumerable: !0,
                    get: function() {
                        return i.getProperty
                    }
                }), Object.defineProperty(t, "stringify", {
                    enumerable: !0,
                    get: function() {
                        return i.stringify
                    }
                }), Object.defineProperty(t, "regexpCode", {
                    enumerable: !0,
                    get: function() {
                        return i.regexpCode
                    }
                }), Object.defineProperty(t, "Name", {
                    enumerable: !0,
                    get: function() {
                        return i.Name
                    }
                });
                var s = r(8490);
                Object.defineProperty(t, "Scope", {
                    enumerable: !0,
                    get: function() {
                        return s.Scope
                    }
                }), Object.defineProperty(t, "ValueScope", {
                    enumerable: !0,
                    get: function() {
                        return s.ValueScope
                    }
                }), Object.defineProperty(t, "ValueScopeName", {
                    enumerable: !0,
                    get: function() {
                        return s.ValueScopeName
                    }
                }), Object.defineProperty(t, "varKinds", {
                    enumerable: !0,
                    get: function() {
                        return s.varKinds
                    }
                }), t.operators = {
                    GT: new n._Code(">"),
                    GTE: new n._Code(">="),
                    LT: new n._Code("<"),
                    LTE: new n._Code("<="),
                    EQ: new n._Code("==="),
                    NEQ: new n._Code("!=="),
                    NOT: new n._Code("!"),
                    OR: new n._Code("||"),
                    AND: new n._Code("&&"),
                    ADD: new n._Code("+")
                };
                class a {
                    optimizeNodes() {
                        return this
                    }
                    optimizeNames(e, t) {
                        return this
                    }
                }
                class c extends a {
                    constructor(e, t, r) {
                        super(), this.varKind = e, this.name = t, this.rhs = r
                    }
                    render({
                        es5: e,
                        _n: t
                    }) {
                        const r = e ? o.varKinds.var : this.varKind,
                            n = void 0 === this.rhs ? "" : ` = ${this.rhs}`;
                        return `${r} ${this.name}${n};` + t
                    }
                    optimizeNames(e, t) {
                        if (e[this.name.str]) return this.rhs && (this.rhs = O(this.rhs, e, t)), this
                    }
                    get names() {
                        return this.rhs instanceof n._CodeOrName ? this.rhs.names : {}
                    }
                }
                class l extends a {
                    constructor(e, t, r) {
                        super(), this.lhs = e, this.rhs = t, this.sideEffects = r
                    }
                    render({
                        _n: e
                    }) {
                        return `${this.lhs} = ${this.rhs};` + e
                    }
                    optimizeNames(e, t) {
                        if (!(this.lhs instanceof n.Name) || e[this.lhs.str] || this.sideEffects) return this.rhs = O(this.rhs, e, t), this
                    }
                    get names() {
                        return A(this.lhs instanceof n.Name ? {} : { ...this.lhs.names
                        }, this.rhs)
                    }
                }
                class u extends l {
                    constructor(e, t, r, n) {
                        super(e, r, n), this.op = t
                    }
                    render({
                        _n: e
                    }) {
                        return `${this.lhs} ${this.op}= ${this.rhs};` + e
                    }
                }
                class d extends a {
                    constructor(e) {
                        super(), this.label = e, this.names = {}
                    }
                    render({
                        _n: e
                    }) {
                        return `${this.label}:` + e
                    }
                }
                class p extends a {
                    constructor(e) {
                        super(), this.label = e, this.names = {}
                    }
                    render({
                        _n: e
                    }) {
                        return `break${this.label?` ${this.label}`:""};` + e
                    }
                }
                class h extends a {
                    constructor(e) {
                        super(), this.error = e
                    }
                    render({
                        _n: e
                    }) {
                        return `throw ${this.error};` + e
                    }
                    get names() {
                        return this.error.names
                    }
                }
                class f extends a {
                    constructor(e) {
                        super(), this.code = e
                    }
                    render({
                        _n: e
                    }) {
                        return `${this.code};` + e
                    }
                    optimizeNodes() {
                        return `${this.code}` ? this : void 0
                    }
                    optimizeNames(e, t) {
                        return this.code = O(this.code, e, t), this
                    }
                    get names() {
                        return this.code instanceof n._CodeOrName ? this.code.names : {}
                    }
                }
                class m extends a {
                    constructor(e = []) {
                        super(), this.nodes = e
                    }
                    render(e) {
                        return this.nodes.reduce(((t, r) => t + r.render(e)), "")
                    }
                    optimizeNodes() {
                        const {
                            nodes: e
                        } = this;
                        let t = e.length;
                        for (; t--;) {
                            const r = e[t].optimizeNodes();
                            Array.isArray(r) ? e.splice(t, 1, ...r) : r ? e[t] = r : e.splice(t, 1)
                        }
                        return e.length > 0 ? this : void 0
                    }
                    optimizeNames(e, t) {
                        const {
                            nodes: r
                        } = this;
                        let n = r.length;
                        for (; n--;) {
                            const o = r[n];
                            o.optimizeNames(e, t) || (N(e, o.names), r.splice(n, 1))
                        }
                        return r.length > 0 ? this : void 0
                    }
                    get names() {
                        return this.nodes.reduce(((e, t) => P(e, t.names)), {})
                    }
                }
                class g extends m {
                    render(e) {
                        return "{" + e._n + super.render(e) + "}" + e._n
                    }
                }
                class _ extends m {}
                class y extends g {}
                y.kind = "else";
                class v extends g {
                    constructor(e, t) {
                        super(t), this.condition = e
                    }
                    render(e) {
                        let t = `if(${this.condition})` + super.render(e);
                        return this.else && (t += "else " + this.else.render(e)), t
                    }
                    optimizeNodes() {
                        super.optimizeNodes();
                        const e = this.condition;
                        if (!0 === e) return this.nodes;
                        let t = this.else;
                        if (t) {
                            const e = t.optimizeNodes();
                            t = this.else = Array.isArray(e) ? new y(e) : e
                        }
                        return t ? !1 === e ? t instanceof v ? t : t.nodes : this.nodes.length ? this : new v(R(e), t instanceof v ? [t] : t.nodes) : !1 !== e && this.nodes.length ? this : void 0
                    }
                    optimizeNames(e, t) {
                        var r;
                        if (this.else = null === (r = this.else) || void 0 === r ? void 0 : r.optimizeNames(e, t), super.optimizeNames(e, t) || this.else) return this.condition = O(this.condition, e, t), this
                    }
                    get names() {
                        const e = super.names;
                        return A(e, this.condition), this.else && P(e, this.else.names), e
                    }
                }
                v.kind = "if";
                class b extends g {}
                b.kind = "for";
                class w extends b {
                    constructor(e) {
                        super(), this.iteration = e
                    }
                    render(e) {
                        return `for(${this.iteration})` + super.render(e)
                    }
                    optimizeNames(e, t) {
                        if (super.optimizeNames(e, t)) return this.iteration = O(this.iteration, e, t), this
                    }
                    get names() {
                        return P(super.names, this.iteration.names)
                    }
                }
                class x extends b {
                    constructor(e, t, r, n) {
                        super(), this.varKind = e, this.name = t, this.from = r, this.to = n
                    }
                    render(e) {
                        const t = e.es5 ? o.varKinds.var : this.varKind,
                            {
                                name: r,
                                from: n,
                                to: i
                            } = this;
                        return `for(${t} ${r}=${n}; ${r}<${i}; ${r}++)` + super.render(e)
                    }
                    get names() {
                        const e = A(super.names, this.from);
                        return A(e, this.to)
                    }
                }
                class E extends b {
                    constructor(e, t, r, n) {
                        super(), this.loop = e, this.varKind = t, this.name = r, this.iterable = n
                    }
                    render(e) {
                        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(e)
                    }
                    optimizeNames(e, t) {
                        if (super.optimizeNames(e, t)) return this.iterable = O(this.iterable, e, t), this
                    }
                    get names() {
                        return P(super.names, this.iterable.names)
                    }
                }
                class C extends g {
                    constructor(e, t, r) {
                        super(), this.name = e, this.args = t, this.async = r
                    }
                    render(e) {
                        return `${this.async?"async ":""}function ${this.name}(${this.args})` + super.render(e)
                    }
                }
                C.kind = "func";
                class S extends m {
                    render(e) {
                        return "return " + super.render(e)
                    }
                }
                S.kind = "return";
                class T extends g {
                    render(e) {
                        let t = "try" + super.render(e);
                        return this.catch && (t += this.catch.render(e)), this.finally && (t += this.finally.render(e)), t
                    }
                    optimizeNodes() {
                        var e, t;
                        return super.optimizeNodes(), null === (e = this.catch) || void 0 === e || e.optimizeNodes(), null === (t = this.finally) || void 0 === t || t.optimizeNodes(), this
                    }
                    optimizeNames(e, t) {
                        var r, n;
                        return super.optimizeNames(e, t), null === (r = this.catch) || void 0 === r || r.optimizeNames(e, t), null === (n = this.finally) || void 0 === n || n.optimizeNames(e, t), this
                    }
                    get names() {
                        const e = super.names;
                        return this.catch && P(e, this.catch.names), this.finally && P(e, this.finally.names), e
                    }
                }
                class k extends g {
                    constructor(e) {
                        super(), this.error = e
                    }
                    render(e) {
                        return `catch(${this.error})` + super.render(e)
                    }
                }
                k.kind = "catch";
                class I extends g {
                    render(e) {
                        return "finally" + super.render(e)
                    }
                }

                function P(e, t) {
                    for (const r in t) e[r] = (e[r] || 0) + (t[r] || 0);
                    return e
                }

                function A(e, t) {
                    return t instanceof n._CodeOrName ? P(e, t.names) : e
                }

                function O(e, t, r) {
                    return e instanceof n.Name ? i(e) : (o = e) instanceof n._Code && o._items.some((e => e instanceof n.Name && 1 === t[e.str] && void 0 !== r[e.str])) ? new n._Code(e._items.reduce(((e, t) => (t instanceof n.Name && (t = i(t)), t instanceof n._Code ? e.push(...t._items) : e.push(t), e)), [])) : e;
                    var o;

                    function i(e) {
                        const n = r[e.str];
                        return void 0 === n || 1 !== t[e.str] ? e : (delete t[e.str], n)
                    }
                }

                function N(e, t) {
                    for (const r in t) e[r] = (e[r] || 0) - (t[r] || 0)
                }

                function R(e) {
                    return "boolean" == typeof e || "number" == typeof e || null === e ? !e : n._ `!${L(e)}`
                }
                I.kind = "finally", t.CodeGen = class {
                    constructor(e, t = {}) {
                        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...t,
                            _n: t.lines ? "\n" : ""
                        }, this._extScope = e, this._scope = new o.Scope({
                            parent: e
                        }), this._nodes = [new _]
                    }
                    toString() {
                        return this._root.render(this.opts)
                    }
                    name(e) {
                        return this._scope.name(e)
                    }
                    scopeName(e) {
                        return this._extScope.name(e)
                    }
                    scopeValue(e, t) {
                        const r = this._extScope.value(e, t);
                        return (this._values[r.prefix] || (this._values[r.prefix] = new Set)).add(r), r
                    }
                    getScopeValue(e, t) {
                        return this._extScope.getValue(e, t)
                    }
                    scopeRefs(e) {
                        return this._extScope.scopeRefs(e, this._values)
                    }
                    scopeCode() {
                        return this._extScope.scopeCode(this._values)
                    }
                    _def(e, t, r, n) {
                        const o = this._scope.toName(t);
                        return void 0 !== r && n && (this._constants[o.str] = r), this._leafNode(new c(e, o, r)), o
                    }
                    const (e, t, r) {
                        return this._def(o.varKinds.const, e, t, r)
                    }
                    let (e, t, r) {
                        return this._def(o.varKinds.let, e, t, r)
                    }
                    var (e, t, r) {
                        return this._def(o.varKinds.var, e, t, r)
                    }
                    assign(e, t, r) {
                        return this._leafNode(new l(e, t, r))
                    }
                    add(e, r) {
                        return this._leafNode(new u(e, t.operators.ADD, r))
                    }
                    code(e) {
                        return "function" == typeof e ? e() : e !== n.nil && this._leafNode(new f(e)), this
                    }
                    object(...e) {
                        const t = ["{"];
                        for (const [r, o] of e) t.length > 1 && t.push(","), t.push(r), (r !== o || this.opts.es5) && (t.push(":"), (0, n.addCodeArg)(t, o));
                        return t.push("}"), new n._Code(t)
                    }
                    if (e, t, r) {
                        if (this._blockNode(new v(e)), t && r) this.code(t).else().code(r).endIf();
                        else if (t) this.code(t).endIf();
                        else if (r) throw new Error('CodeGen: "else" body without "then" body');
                        return this
                    }
                    elseIf(e) {
                        return this._elseNode(new v(e))
                    } else() {
                        return this._elseNode(new y)
                    }
                    endIf() {
                        return this._endBlockNode(v, y)
                    }
                    _for(e, t) {
                        return this._blockNode(e), t && this.code(t).endFor(), this
                    }
                    for (e, t) {
                        return this._for(new w(e), t)
                    }
                    forRange(e, t, r, n, i = (this.opts.es5 ? o.varKinds.var : o.varKinds.let)) {
                        const s = this._scope.toName(e);
                        return this._for(new x(i, s, t, r), (() => n(s)))
                    }
                    forOf(e, t, r, i = o.varKinds.const) {
                        const s = this._scope.toName(e);
                        if (this.opts.es5) {
                            const e = t instanceof n.Name ? t : this.var("_arr", t);
                            return this.forRange("_i", 0, n._ `${e}.length`, (t => {
                                this.var(s, n._ `${e}[${t}]`), r(s)
                            }))
                        }
                        return this._for(new E("of", i, s, t), (() => r(s)))
                    }
                    forIn(e, t, r, i = (this.opts.es5 ? o.varKinds.var : o.varKinds.const)) {
                        if (this.opts.ownProperties) return this.forOf(e, n._ `Object.keys(${t})`, r);
                        const s = this._scope.toName(e);
                        return this._for(new E("in", i, s, t), (() => r(s)))
                    }
                    endFor() {
                        return this._endBlockNode(b)
                    }
                    label(e) {
                        return this._leafNode(new d(e))
                    }
                    break (e) {
                        return this._leafNode(new p(e))
                    }
                    return (e) {
                        const t = new S;
                        if (this._blockNode(t), this.code(e), 1 !== t.nodes.length) throw new Error('CodeGen: "return" should have one node');
                        return this._endBlockNode(S)
                    }
                    try (e, t, r) {
                        if (!t && !r) throw new Error('CodeGen: "try" without "catch" and "finally"');
                        const n = new T;
                        if (this._blockNode(n), this.code(e), t) {
                            const e = this.name("e");
                            this._currNode = n.catch = new k(e), t(e)
                        }
                        return r && (this._currNode = n.finally = new I, this.code(r)), this._endBlockNode(k, I)
                    }
                    throw (e) {
                        return this._leafNode(new h(e))
                    }
                    block(e, t) {
                        return this._blockStarts.push(this._nodes.length), e && this.code(e).endBlock(t), this
                    }
                    endBlock(e) {
                        const t = this._blockStarts.pop();
                        if (void 0 === t) throw new Error("CodeGen: not in self-balancing block");
                        const r = this._nodes.length - t;
                        if (r < 0 || void 0 !== e && r !== e) throw new Error(`CodeGen: wrong number of nodes: ${r} vs ${e} expected`);
                        return this._nodes.length = t, this
                    }
                    func(e, t = n.nil, r, o) {
                        return this._blockNode(new C(e, t, r)), o && this.code(o).endFunc(), this
                    }
                    endFunc() {
                        return this._endBlockNode(C)
                    }
                    optimize(e = 1) {
                        for (; e-- > 0;) this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants)
                    }
                    _leafNode(e) {
                        return this._currNode.nodes.push(e), this
                    }
                    _blockNode(e) {
                        this._currNode.nodes.push(e), this._nodes.push(e)
                    }
                    _endBlockNode(e, t) {
                        const r = this._currNode;
                        if (r instanceof e || t && r instanceof t) return this._nodes.pop(), this;
                        throw new Error(`CodeGen: not in block "${t?`${e.kind}/${t.kind}`:e.kind}"`)
                    }
                    _elseNode(e) {
                        const t = this._currNode;
                        if (!(t instanceof v)) throw new Error('CodeGen: "else" without "if"');
                        return this._currNode = t.else = e, this
                    }
                    get _root() {
                        return this._nodes[0]
                    }
                    get _currNode() {
                        const e = this._nodes;
                        return e[e.length - 1]
                    }
                    set _currNode(e) {
                        const t = this._nodes;
                        t[t.length - 1] = e
                    }
                }, t.not = R;
                const $ = D(t.operators.AND);
                t.and = function(...e) {
                    return e.reduce($)
                };
                const M = D(t.operators.OR);

                function D(e) {
                    return (t, r) => t === n.nil ? r : r === n.nil ? t : n._ `${L(t)} ${e} ${L(r)}`
                }

                function L(e) {
                    return e instanceof n.Name ? e : n._ `(${e})`
                }
                t.or = function(...e) {
                    return e.reduce(M)
                }
            },
            8490: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ValueScope = t.ValueScopeName = t.Scope = t.varKinds = t.UsedValueState = void 0;
                const n = r(7023);
                class o extends Error {
                    constructor(e) {
                        super(`CodeGen: "code" for ${e} not defined`), this.value = e.value
                    }
                }
                var i;
                ! function(e) {
                    e[e.Started = 0] = "Started", e[e.Completed = 1] = "Completed"
                }(i = t.UsedValueState || (t.UsedValueState = {})), t.varKinds = {
                    const: new n.Name("const"),
                    let: new n.Name("let"),
                    var: new n.Name("var")
                };
                class s {
                    constructor({
                        prefixes: e,
                        parent: t
                    } = {}) {
                        this._names = {}, this._prefixes = e, this._parent = t
                    }
                    toName(e) {
                        return e instanceof n.Name ? e : this.name(e)
                    }
                    name(e) {
                        return new n.Name(this._newName(e))
                    }
                    _newName(e) {
                        return `${e}${(this._names[e]||this._nameGroup(e)).index++}`
                    }
                    _nameGroup(e) {
                        var t, r;
                        if ((null === (r = null === (t = this._parent) || void 0 === t ? void 0 : t._prefixes) || void 0 === r ? void 0 : r.has(e)) || this._prefixes && !this._prefixes.has(e)) throw new Error(`CodeGen: prefix "${e}" is not allowed in this scope`);
                        return this._names[e] = {
                            prefix: e,
                            index: 0
                        }
                    }
                }
                t.Scope = s;
                class a extends n.Name {
                    constructor(e, t) {
                        super(t), this.prefix = e
                    }
                    setValue(e, {
                        property: t,
                        itemIndex: r
                    }) {
                        this.value = e, this.scopePath = n._ `.${new n.Name(t)}[${r}]`
                    }
                }
                t.ValueScopeName = a;
                const c = n._ `\n`;
                t.ValueScope = class extends s {
                    constructor(e) {
                        super(e), this._values = {}, this._scope = e.scope, this.opts = { ...e,
                            _n: e.lines ? c : n.nil
                        }
                    }
                    get() {
                        return this._scope
                    }
                    name(e) {
                        return new a(e, this._newName(e))
                    }
                    value(e, t) {
                        var r;
                        if (void 0 === t.ref) throw new Error("CodeGen: ref must be passed in value");
                        const n = this.toName(e),
                            {
                                prefix: o
                            } = n,
                            i = null !== (r = t.key) && void 0 !== r ? r : t.ref;
                        let s = this._values[o];
                        if (s) {
                            const e = s.get(i);
                            if (e) return e
                        } else s = this._values[o] = new Map;
                        s.set(i, n);
                        const a = this._scope[o] || (this._scope[o] = []),
                            c = a.length;
                        return a[c] = t.ref, n.setValue(t, {
                            property: o,
                            itemIndex: c
                        }), n
                    }
                    getValue(e, t) {
                        const r = this._values[e];
                        if (r) return r.get(t)
                    }
                    scopeRefs(e, t = this._values) {
                        return this._reduceValues(t, (t => {
                            if (void 0 === t.scopePath) throw new Error(`CodeGen: name "${t}" has no value`);
                            return n._ `${e}${t.scopePath}`
                        }))
                    }
                    scopeCode(e = this._values, t, r) {
                        return this._reduceValues(e, (e => {
                            if (void 0 === e.value) throw new Error(`CodeGen: name "${e}" has no value`);
                            return e.value.code
                        }), t, r)
                    }
                    _reduceValues(e, r, s = {}, a) {
                        let c = n.nil;
                        for (const l in e) {
                            const u = e[l];
                            if (!u) continue;
                            const d = s[l] = s[l] || new Map;
                            u.forEach((e => {
                                if (d.has(e)) return;
                                d.set(e, i.Started);
                                let s = r(e);
                                if (s) {
                                    const r = this.opts.es5 ? t.varKinds.var : t.varKinds.const;
                                    c = n._ `${c}${r} ${e} = ${s};${this.opts._n}`
                                } else {
                                    if (!(s = null == a ? void 0 : a(e))) throw new o(e);
                                    c = n._ `${c}${s}${this.opts._n}`
                                }
                                d.set(e, i.Completed)
                            }))
                        }
                        return c
                    }
                }
            },
            4181: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.extendErrors = t.resetErrorsCount = t.reportExtraError = t.reportError = t.keyword$DataError = t.keywordError = void 0;
                const n = r(3487),
                    o = r(6776),
                    i = r(2141);

                function s(e, t) {
                    const r = e.const("err", t);
                    e.if(n._ `${i.default.vErrors} === null`, (() => e.assign(i.default.vErrors, n._ `[${r}]`)), n._ `${i.default.vErrors}.push(${r})`), e.code(n._ `${i.default.errors}++`)
                }

                function a(e, t) {
                    const {
                        gen: r,
                        validateName: o,
                        schemaEnv: i
                    } = e;
                    i.$async ? r.throw(n._ `new ${e.ValidationError}(${t})`) : (r.assign(n._ `${o}.errors`, t), r.return(!1))
                }
                t.keywordError = {
                    message: ({
                        keyword: e
                    }) => n.str `must pass "${e}" keyword validation`
                }, t.keyword$DataError = {
                    message: ({
                        keyword: e,
                        schemaType: t
                    }) => t ? n.str `"${e}" keyword must be ${t} ($data)` : n.str `"${e}" keyword is invalid ($data)`
                }, t.reportError = function(e, r = t.keywordError, o, i) {
                    const {
                        it: c
                    } = e, {
                        gen: u,
                        compositeRule: d,
                        allErrors: p
                    } = c, h = l(e, r, o);
                    (null != i ? i : d || p) ? s(u, h): a(c, n._ `[${h}]`)
                }, t.reportExtraError = function(e, r = t.keywordError, n) {
                    const {
                        it: o
                    } = e, {
                        gen: c,
                        compositeRule: u,
                        allErrors: d
                    } = o;
                    s(c, l(e, r, n)), u || d || a(o, i.default.vErrors)
                }, t.resetErrorsCount = function(e, t) {
                    e.assign(i.default.errors, t), e.if(n._ `${i.default.vErrors} !== null`, (() => e.if(t, (() => e.assign(n._ `${i.default.vErrors}.length`, t)), (() => e.assign(i.default.vErrors, null)))))
                }, t.extendErrors = function({
                    gen: e,
                    keyword: t,
                    schemaValue: r,
                    data: o,
                    errsCount: s,
                    it: a
                }) {
                    if (void 0 === s) throw new Error("ajv implementation error");
                    const c = e.name("err");
                    e.forRange("i", s, i.default.errors, (s => {
                        e.const(c, n._ `${i.default.vErrors}[${s}]`), e.if(n._ `${c}.instancePath === undefined`, (() => e.assign(n._ `${c}.instancePath`, (0, n.strConcat)(i.default.instancePath, a.errorPath)))), e.assign(n._ `${c}.schemaPath`, n.str `${a.errSchemaPath}/${t}`), a.opts.verbose && (e.assign(n._ `${c}.schema`, r), e.assign(n._ `${c}.data`, o))
                    }))
                };
                const c = {
                    keyword: new n.Name("keyword"),
                    schemaPath: new n.Name("schemaPath"),
                    params: new n.Name("params"),
                    propertyName: new n.Name("propertyName"),
                    message: new n.Name("message"),
                    schema: new n.Name("schema"),
                    parentSchema: new n.Name("parentSchema")
                };

                function l(e, t, r) {
                    const {
                        createErrors: o
                    } = e.it;
                    return !1 === o ? n._ `{}` : function(e, t, r = {}) {
                        const {
                            gen: o,
                            it: s
                        } = e, a = [u(s, r), d(e, r)];
                        return function(e, {
                            params: t,
                            message: r
                        }, o) {
                            const {
                                keyword: s,
                                data: a,
                                schemaValue: l,
                                it: u
                            } = e, {
                                opts: d,
                                propertyName: p,
                                topSchemaRef: h,
                                schemaPath: f
                            } = u;
                            o.push([c.keyword, s], [c.params, "function" == typeof t ? t(e) : t || n._ `{}`]), d.messages && o.push([c.message, "function" == typeof r ? r(e) : r]), d.verbose && o.push([c.schema, l], [c.parentSchema, n._ `${h}${f}`], [i.default.data, a]), p && o.push([c.propertyName, p])
                        }(e, t, a), o.object(...a)
                    }(e, t, r)
                }

                function u({
                    errorPath: e
                }, {
                    instancePath: t
                }) {
                    const r = t ? n.str `${e}${(0,o.getErrorPath)(t,o.Type.Str)}` : e;
                    return [i.default.instancePath, (0, n.strConcat)(i.default.instancePath, r)]
                }

                function d({
                    keyword: e,
                    it: {
                        errSchemaPath: t
                    }
                }, {
                    schemaPath: r,
                    parentSchema: i
                }) {
                    let s = i ? t : n.str `${t}/${e}`;
                    return r && (s = n.str `${s}${(0,o.getErrorPath)(r,o.Type.Str)}`), [c.schemaPath, s]
                }
            },
            5173: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.resolveSchema = t.getCompilingSchema = t.resolveRef = t.compileSchema = t.SchemaEnv = void 0;
                const n = r(3487),
                    o = r(7426),
                    i = r(2141),
                    s = r(2531),
                    a = r(6776),
                    c = r(4815),
                    l = r(540);
                class u {
                    constructor(e) {
                        var t;
                        let r;
                        this.refs = {}, this.dynamicAnchors = {}, "object" == typeof e.schema && (r = e.schema), this.schema = e.schema, this.schemaId = e.schemaId, this.root = e.root || this, this.baseId = null !== (t = e.baseId) && void 0 !== t ? t : (0, s.normalizeId)(null == r ? void 0 : r[e.schemaId || "$id"]), this.schemaPath = e.schemaPath, this.localRefs = e.localRefs, this.meta = e.meta, this.$async = null == r ? void 0 : r.$async, this.refs = {}
                    }
                }

                function d(e) {
                    const t = h.call(this, e);
                    if (t) return t;
                    const r = (0, s.getFullPath)(e.root.baseId),
                        {
                            es5: a,
                            lines: l
                        } = this.opts.code,
                        {
                            ownProperties: u
                        } = this.opts,
                        d = new n.CodeGen(this.scope, {
                            es5: a,
                            lines: l,
                            ownProperties: u
                        });
                    let p;
                    e.$async && (p = d.scopeValue("Error", {
                        ref: o.default,
                        code: n._ `require("ajv/dist/runtime/validation_error").default`
                    }));
                    const f = d.scopeName("validate");
                    e.validateName = f;
                    const m = {
                        gen: d,
                        allErrors: this.opts.allErrors,
                        data: i.default.data,
                        parentData: i.default.parentData,
                        parentDataProperty: i.default.parentDataProperty,
                        dataNames: [i.default.data],
                        dataPathArr: [n.nil],
                        dataLevel: 0,
                        dataTypes: [],
                        definedProperties: new Set,
                        topSchemaRef: d.scopeValue("schema", !0 === this.opts.code.source ? {
                            ref: e.schema,
                            code: (0, n.stringify)(e.schema)
                        } : {
                            ref: e.schema
                        }),
                        validateName: f,
                        ValidationError: p,
                        schema: e.schema,
                        schemaEnv: e,
                        rootId: r,
                        baseId: e.baseId || r,
                        schemaPath: n.nil,
                        errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
                        errorPath: n._ `""`,
                        opts: this.opts,
                        self: this
                    };
                    let g;
                    try {
                        this._compilations.add(e), (0, c.validateFunctionCode)(m), d.optimize(this.opts.code.optimize);
                        const t = d.toString();
                        g = `${d.scopeRefs(i.default.scope)}return ${t}`, this.opts.code.process && (g = this.opts.code.process(g, e));
                        const r = new Function(`${i.default.self}`, `${i.default.scope}`, g)(this, this.scope.get());
                        if (this.scope.value(f, {
                                ref: r
                            }), r.errors = null, r.schema = e.schema, r.schemaEnv = e, e.$async && (r.$async = !0), !0 === this.opts.code.source && (r.source = {
                                validateName: f,
                                validateCode: t,
                                scopeValues: d._values
                            }), this.opts.unevaluated) {
                            const {
                                props: e,
                                items: t
                            } = m;
                            r.evaluated = {
                                props: e instanceof n.Name ? void 0 : e,
                                items: t instanceof n.Name ? void 0 : t,
                                dynamicProps: e instanceof n.Name,
                                dynamicItems: t instanceof n.Name
                            }, r.source && (r.source.evaluated = (0, n.stringify)(r.evaluated))
                        }
                        return e.validate = r, e
                    } catch (t) {
                        throw delete e.validate, delete e.validateName, g && this.logger.error("Error compiling schema, function code:", g), t
                    } finally {
                        this._compilations.delete(e)
                    }
                }

                function p(e) {
                    return (0, s.inlineRef)(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : d.call(this, e)
                }

                function h(e) {
                    for (const n of this._compilations)
                        if (r = e, (t = n).schema === r.schema && t.root === r.root && t.baseId === r.baseId) return n;
                    var t, r
                }

                function f(e, t) {
                    let r;
                    for (;
                        "string" == typeof(r = this.refs[t]);) t = r;
                    return r || this.schemas[t] || m.call(this, e, t)
                }

                function m(e, t) {
                    const r = l.parse(t),
                        n = (0, s._getFullPath)(r);
                    let o = (0, s.getFullPath)(e.baseId);
                    if (Object.keys(e.schema).length > 0 && n === o) return _.call(this, r, e);
                    const i = (0, s.normalizeId)(n),
                        a = this.refs[i] || this.schemas[i];
                    if ("string" == typeof a) {
                        const t = m.call(this, e, a);
                        if ("object" != typeof(null == t ? void 0 : t.schema)) return;
                        return _.call(this, r, t)
                    }
                    if ("object" == typeof(null == a ? void 0 : a.schema)) {
                        if (a.validate || d.call(this, a), i === (0, s.normalizeId)(t)) {
                            const {
                                schema: t
                            } = a, {
                                schemaId: r
                            } = this.opts, n = t[r];
                            return n && (o = (0, s.resolveUrl)(o, n)), new u({
                                schema: t,
                                schemaId: r,
                                root: e,
                                baseId: o
                            })
                        }
                        return _.call(this, r, a)
                    }
                }
                t.SchemaEnv = u, t.compileSchema = d, t.resolveRef = function(e, t, r) {
                    var n;
                    r = (0, s.resolveUrl)(t, r);
                    const o = e.refs[r];
                    if (o) return o;
                    let i = f.call(this, e, r);
                    if (void 0 === i) {
                        const o = null === (n = e.localRefs) || void 0 === n ? void 0 : n[r],
                            {
                                schemaId: s
                            } = this.opts;
                        o && (i = new u({
                            schema: o,
                            schemaId: s,
                            root: e,
                            baseId: t
                        }))
                    }
                    return void 0 !== i ? e.refs[r] = p.call(this, i) : void 0
                }, t.getCompilingSchema = h, t.resolveSchema = m;
                const g = new Set(["properties", "patternProperties", "enum", "dependencies", "definitions"]);

                function _(e, {
                    baseId: t,
                    schema: r,
                    root: n
                }) {
                    var o;
                    if ("/" !== (null === (o = e.fragment) || void 0 === o ? void 0 : o[0])) return;
                    for (const n of e.fragment.slice(1).split("/")) {
                        if ("boolean" == typeof r) return;
                        const e = r[(0, a.unescapeFragment)(n)];
                        if (void 0 === e) return;
                        const o = "object" == typeof(r = e) && r[this.opts.schemaId];
                        !g.has(n) && o && (t = (0, s.resolveUrl)(t, o))
                    }
                    let i;
                    if ("boolean" != typeof r && r.$ref && !(0, a.schemaHasRulesButRef)(r, this.RULES)) {
                        const e = (0, s.resolveUrl)(t, r.$ref);
                        i = m.call(this, n, e)
                    }
                    const {
                        schemaId: c
                    } = this.opts;
                    return i = i || new u({
                        schema: r,
                        schemaId: c,
                        root: n,
                        baseId: t
                    }), i.schema !== i.root.schema ? i : void 0
                }
            },
            2141: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = {
                        data: new n.Name("data"),
                        valCxt: new n.Name("valCxt"),
                        instancePath: new n.Name("instancePath"),
                        parentData: new n.Name("parentData"),
                        parentDataProperty: new n.Name("parentDataProperty"),
                        rootData: new n.Name("rootData"),
                        dynamicAnchors: new n.Name("dynamicAnchors"),
                        vErrors: new n.Name("vErrors"),
                        errors: new n.Name("errors"),
                        this: new n.Name("this"),
                        self: new n.Name("self"),
                        scope: new n.Name("scope"),
                        json: new n.Name("json"),
                        jsonPos: new n.Name("jsonPos"),
                        jsonLen: new n.Name("jsonLen"),
                        jsonPart: new n.Name("jsonPart")
                    };
                t.default = o
            },
            6646: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(2531);
                class o extends Error {
                    constructor(e, t, r) {
                        super(r || `can't resolve reference ${t} from id ${e}`), this.missingRef = (0, n.resolveUrl)(e, t), this.missingSchema = (0, n.normalizeId)((0, n.getFullPath)(this.missingRef))
                    }
                }
                t.default = o
            },
            2531: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getSchemaRefs = t.resolveUrl = t.normalizeId = t._getFullPath = t.getFullPath = t.inlineRef = void 0;
                const n = r(6776),
                    o = r(4063),
                    i = r(9461),
                    s = r(540),
                    a = new Set(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum", "const"]);
                t.inlineRef = function(e, t = !0) {
                    return "boolean" == typeof e || (!0 === t ? !l(e) : !!t && u(e) <= t)
                };
                const c = new Set(["$ref", "$recursiveRef", "$recursiveAnchor", "$dynamicRef", "$dynamicAnchor"]);

                function l(e) {
                    for (const t in e) {
                        if (c.has(t)) return !0;
                        const r = e[t];
                        if (Array.isArray(r) && r.some(l)) return !0;
                        if ("object" == typeof r && l(r)) return !0
                    }
                    return !1
                }

                function u(e) {
                    let t = 0;
                    for (const r in e) {
                        if ("$ref" === r) return 1 / 0;
                        if (t++, !a.has(r) && ("object" == typeof e[r] && (0, n.eachItem)(e[r], (e => t += u(e))), t === 1 / 0)) return 1 / 0
                    }
                    return t
                }

                function d(e = "", t) {
                    return !1 !== t && (e = f(e)), p(s.parse(e))
                }

                function p(e) {
                    return s.serialize(e).split("#")[0] + "#"
                }
                t.getFullPath = d, t._getFullPath = p;
                const h = /#\/?$/;

                function f(e) {
                    return e ? e.replace(h, "") : ""
                }
                t.normalizeId = f, t.resolveUrl = function(e, t) {
                    return t = f(t), s.resolve(e, t)
                };
                const m = /^[a-z_][-a-z0-9._]*$/i;
                t.getSchemaRefs = function(e, t) {
                    if ("boolean" == typeof e) return {};
                    const {
                        schemaId: r
                    } = this.opts, n = f(e[r] || t), a = {
                        "": n
                    }, c = d(n, !1), l = {}, u = new Set;
                    return i(e, {
                        allKeys: !0
                    }, ((e, t, n, o) => {
                        if (void 0 === o) return;
                        const i = c + t;
                        let d = a[o];

                        function g(t) {
                            if (t = f(d ? s.resolve(d, t) : t), u.has(t)) throw h(t);
                            u.add(t);
                            let r = this.refs[t];
                            return "string" == typeof r && (r = this.refs[r]), "object" == typeof r ? p(e, r.schema, t) : t !== f(i) && ("#" === t[0] ? (p(e, l[t], t), l[t] = e) : this.refs[t] = i), t
                        }

                        function _(e) {
                            if ("string" == typeof e) {
                                if (!m.test(e)) throw new Error(`invalid anchor "${e}"`);
                                g.call(this, `#${e}`)
                            }
                        }
                        "string" == typeof e[r] && (d = g.call(this, e[r])), _.call(this, e.$anchor), _.call(this, e.$dynamicAnchor), a[t] = d
                    })), l;

                    function p(e, t, r) {
                        if (void 0 !== t && !o(e, t)) throw h(r)
                    }

                    function h(e) {
                        return new Error(`reference "${e}" resolves to more than one schema`)
                    }
                }
            },
            3141: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getRules = t.isJSONType = void 0;
                const r = new Set(["string", "number", "integer", "boolean", "null", "object", "array"]);
                t.isJSONType = function(e) {
                    return "string" == typeof e && r.has(e)
                }, t.getRules = function() {
                    const e = {
                        number: {
                            type: "number",
                            rules: []
                        },
                        string: {
                            type: "string",
                            rules: []
                        },
                        array: {
                            type: "array",
                            rules: []
                        },
                        object: {
                            type: "object",
                            rules: []
                        }
                    };
                    return {
                        types: { ...e,
                            integer: !0,
                            boolean: !0,
                            null: !0
                        },
                        rules: [{
                            rules: []
                        }, e.number, e.string, e.array, e.object],
                        post: {
                            rules: []
                        },
                        all: {},
                        keywords: {}
                    }
                }
            },
            6776: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.checkStrictMode = t.getErrorPath = t.Type = t.useFunc = t.setEvaluated = t.evaluatedPropsToName = t.mergeEvaluated = t.eachItem = t.unescapeJsonPointer = t.escapeJsonPointer = t.escapeFragment = t.unescapeFragment = t.schemaRefOrVal = t.schemaHasRulesButRef = t.schemaHasRules = t.checkUnknownRules = t.alwaysValidSchema = t.toHash = void 0;
                const n = r(3487),
                    o = r(7023);

                function i(e, t = e.schema) {
                    const {
                        opts: r,
                        self: n
                    } = e;
                    if (!r.strictSchema) return;
                    if ("boolean" == typeof t) return;
                    const o = n.RULES.keywords;
                    for (const r in t) o[r] || f(e, `unknown keyword: "${r}"`)
                }

                function s(e, t) {
                    if ("boolean" == typeof e) return !e;
                    for (const r in e)
                        if (t[r]) return !0;
                    return !1
                }

                function a(e) {
                    return "number" == typeof e ? `${e}` : e.replace(/~/g, "~0").replace(/\//g, "~1")
                }

                function c(e) {
                    return e.replace(/~1/g, "/").replace(/~0/g, "~")
                }

                function l({
                    mergeNames: e,
                    mergeToName: t,
                    mergeValues: r,
                    resultToName: o
                }) {
                    return (i, s, a, c) => {
                        const l = void 0 === a ? s : a instanceof n.Name ? (s instanceof n.Name ? e(i, s, a) : t(i, s, a), a) : s instanceof n.Name ? (t(i, a, s), s) : r(s, a);
                        return c !== n.Name || l instanceof n.Name ? l : o(i, l)
                    }
                }

                function u(e, t) {
                    if (!0 === t) return e.var("props", !0);
                    const r = e.var("props", n._ `{}`);
                    return void 0 !== t && d(e, r, t), r
                }

                function d(e, t, r) {
                    Object.keys(r).forEach((r => e.assign(n._ `${t}${(0,n.getProperty)(r)}`, !0)))
                }
                t.toHash = function(e) {
                    const t = {};
                    for (const r of e) t[r] = !0;
                    return t
                }, t.alwaysValidSchema = function(e, t) {
                    return "boolean" == typeof t ? t : 0 === Object.keys(t).length || (i(e, t), !s(t, e.self.RULES.all))
                }, t.checkUnknownRules = i, t.schemaHasRules = s, t.schemaHasRulesButRef = function(e, t) {
                    if ("boolean" == typeof e) return !e;
                    for (const r in e)
                        if ("$ref" !== r && t.all[r]) return !0;
                    return !1
                }, t.schemaRefOrVal = function({
                    topSchemaRef: e,
                    schemaPath: t
                }, r, o, i) {
                    if (!i) {
                        if ("number" == typeof r || "boolean" == typeof r) return r;
                        if ("string" == typeof r) return n._ `${r}`
                    }
                    return n._ `${e}${t}${(0,n.getProperty)(o)}`
                }, t.unescapeFragment = function(e) {
                    return c(decodeURIComponent(e))
                }, t.escapeFragment = function(e) {
                    return encodeURIComponent(a(e))
                }, t.escapeJsonPointer = a, t.unescapeJsonPointer = c, t.eachItem = function(e, t) {
                    if (Array.isArray(e))
                        for (const r of e) t(r);
                    else t(e)
                }, t.mergeEvaluated = {
                    props: l({
                        mergeNames: (e, t, r) => e.if(n._ `${r} !== true && ${t} !== undefined`, (() => {
                            e.if(n._ `${t} === true`, (() => e.assign(r, !0)), (() => e.assign(r, n._ `${r} || {}`).code(n._ `Object.assign(${r}, ${t})`)))
                        })),
                        mergeToName: (e, t, r) => e.if(n._ `${r} !== true`, (() => {
                            !0 === t ? e.assign(r, !0) : (e.assign(r, n._ `${r} || {}`), d(e, r, t))
                        })),
                        mergeValues: (e, t) => !0 === e || { ...e,
                            ...t
                        },
                        resultToName: u
                    }),
                    items: l({
                        mergeNames: (e, t, r) => e.if(n._ `${r} !== true && ${t} !== undefined`, (() => e.assign(r, n._ `${t} === true ? true : ${r} > ${t} ? ${r} : ${t}`))),
                        mergeToName: (e, t, r) => e.if(n._ `${r} !== true`, (() => e.assign(r, !0 === t || n._ `${r} > ${t} ? ${r} : ${t}`))),
                        mergeValues: (e, t) => !0 === e || Math.max(e, t),
                        resultToName: (e, t) => e.var("items", t)
                    })
                }, t.evaluatedPropsToName = u, t.setEvaluated = d;
                const p = {};
                var h;

                function f(e, t, r = e.opts.strictSchema) {
                    if (r) {
                        if (t = `strict mode: ${t}`, !0 === r) throw new Error(t);
                        e.self.logger.warn(t)
                    }
                }
                t.useFunc = function(e, t) {
                        return e.scopeValue("func", {
                            ref: t,
                            code: p[t.code] || (p[t.code] = new o._Code(t.code))
                        })
                    },
                    function(e) {
                        e[e.Num = 0] = "Num", e[e.Str = 1] = "Str"
                    }(h = t.Type || (t.Type = {})), t.getErrorPath = function(e, t, r) {
                        if (e instanceof n.Name) {
                            const o = t === h.Num;
                            return r ? o ? n._ `"[" + ${e} + "]"` : n._ `"['" + ${e} + "']"` : o ? n._ `"/" + ${e}` : n._ `"/" + ${e}.replace(/~/g, "~0").replace(/\\//g, "~1")`
                        }
                        return r ? (0, n.getProperty)(e).toString() : "/" + a(e)
                    }, t.checkStrictMode = f
            },
            8876: (e, t) => {
                "use strict";

                function r(e, t) {
                    return t.rules.some((t => n(e, t)))
                }

                function n(e, t) {
                    var r;
                    return void 0 !== e[t.keyword] || (null === (r = t.definition.implements) || void 0 === r ? void 0 : r.some((t => void 0 !== e[t])))
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.shouldUseRule = t.shouldUseGroup = t.schemaHasRulesForType = void 0, t.schemaHasRulesForType = function({
                    schema: e,
                    self: t
                }, n) {
                    const o = t.RULES.types[n];
                    return o && !0 !== o && r(e, o)
                }, t.shouldUseGroup = r, t.shouldUseRule = n
            },
            5667: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.boolOrEmptySchema = t.topBoolOrEmptySchema = void 0;
                const n = r(4181),
                    o = r(3487),
                    i = r(2141),
                    s = {
                        message: "boolean schema is false"
                    };

                function a(e, t) {
                    const {
                        gen: r,
                        data: o
                    } = e, i = {
                        gen: r,
                        keyword: "false schema",
                        data: o,
                        schema: !1,
                        schemaCode: !1,
                        schemaValue: !1,
                        params: {},
                        it: e
                    };
                    (0, n.reportError)(i, s, void 0, t)
                }
                t.topBoolOrEmptySchema = function(e) {
                    const {
                        gen: t,
                        schema: r,
                        validateName: n
                    } = e;
                    !1 === r ? a(e, !1) : "object" == typeof r && !0 === r.$async ? t.return(i.default.data) : (t.assign(o._ `${n}.errors`, null), t.return(!0))
                }, t.boolOrEmptySchema = function(e, t) {
                    const {
                        gen: r,
                        schema: n
                    } = e;
                    !1 === n ? (r.var(t, !1), a(e)) : r.var(t, !0)
                }
            },
            453: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.reportTypeError = t.checkDataTypes = t.checkDataType = t.coerceAndCheckDataType = t.getJSONTypes = t.getSchemaTypes = t.DataType = void 0;
                const n = r(3141),
                    o = r(8876),
                    i = r(4181),
                    s = r(3487),
                    a = r(6776);
                var c;

                function l(e) {
                    const t = Array.isArray(e) ? e : e ? [e] : [];
                    if (t.every(n.isJSONType)) return t;
                    throw new Error("type must be JSONType or JSONType[]: " + t.join(","))
                }! function(e) {
                    e[e.Correct = 0] = "Correct", e[e.Wrong = 1] = "Wrong"
                }(c = t.DataType || (t.DataType = {})), t.getSchemaTypes = function(e) {
                    const t = l(e.type);
                    if (t.includes("null")) {
                        if (!1 === e.nullable) throw new Error("type: null contradicts nullable: false")
                    } else {
                        if (!t.length && void 0 !== e.nullable) throw new Error('"nullable" cannot be used without "type"');
                        !0 === e.nullable && t.push("null")
                    }
                    return t
                }, t.getJSONTypes = l, t.coerceAndCheckDataType = function(e, t) {
                    const {
                        gen: r,
                        data: n,
                        opts: i
                    } = e, a = function(e, t) {
                        return t ? e.filter((e => u.has(e) || "array" === t && "array" === e)) : []
                    }(t, i.coerceTypes), l = t.length > 0 && !(0 === a.length && 1 === t.length && (0, o.schemaHasRulesForType)(e, t[0]));
                    if (l) {
                        const o = p(t, n, i.strictNumbers, c.Wrong);
                        r.if(o, (() => {
                            a.length ? function(e, t, r) {
                                const {
                                    gen: n,
                                    data: o,
                                    opts: i
                                } = e, a = n.let("dataType", s._ `typeof ${o}`), c = n.let("coerced", s._ `undefined`);
                                "array" === i.coerceTypes && n.if(s._ `${a} == 'object' && Array.isArray(${o}) && ${o}.length == 1`, (() => n.assign(o, s._ `${o}[0]`).assign(a, s._ `typeof ${o}`).if(p(t, o, i.strictNumbers), (() => n.assign(c, o))))), n.if(s._ `${c} !== undefined`);
                                for (const e of r)(u.has(e) || "array" === e && "array" === i.coerceTypes) && l(e);

                                function l(e) {
                                    switch (e) {
                                        case "string":
                                            return void n.elseIf(s._ `${a} == "number" || ${a} == "boolean"`).assign(c, s._ `"" + ${o}`).elseIf(s._ `${o} === null`).assign(c, s._ `""`);
                                        case "number":
                                            return void n.elseIf(s._ `${a} == "boolean" || ${o} === null
              || (${a} == "string" && ${o} && ${o} == +${o})`).assign(c, s._ `+${o}`);
                                        case "integer":
                                            return void n.elseIf(s._ `${a} === "boolean" || ${o} === null
              || (${a} === "string" && ${o} && ${o} == +${o} && !(${o} % 1))`).assign(c, s._ `+${o}`);
                                        case "boolean":
                                            return void n.elseIf(s._ `${o} === "false" || ${o} === 0 || ${o} === null`).assign(c, !1).elseIf(s._ `${o} === "true" || ${o} === 1`).assign(c, !0);
                                        case "null":
                                            return n.elseIf(s._ `${o} === "" || ${o} === 0 || ${o} === false`), void n.assign(c, null);
                                        case "array":
                                            n.elseIf(s._ `${a} === "string" || ${a} === "number"
              || ${a} === "boolean" || ${o} === null`).assign(c, s._ `[${o}]`)
                                    }
                                }
                                n.else(), f(e), n.endIf(), n.if(s._ `${c} !== undefined`, (() => {
                                    n.assign(o, c),
                                        function({
                                            gen: e,
                                            parentData: t,
                                            parentDataProperty: r
                                        }, n) {
                                            e.if(s._ `${t} !== undefined`, (() => e.assign(s._ `${t}[${r}]`, n)))
                                        }(e, c)
                                }))
                            }(e, t, a) : f(e)
                        }))
                    }
                    return l
                };
                const u = new Set(["string", "number", "integer", "boolean", "null"]);

                function d(e, t, r, n = c.Correct) {
                    const o = n === c.Correct ? s.operators.EQ : s.operators.NEQ;
                    let i;
                    switch (e) {
                        case "null":
                            return s._ `${t} ${o} null`;
                        case "array":
                            i = s._ `Array.isArray(${t})`;
                            break;
                        case "object":
                            i = s._ `${t} && typeof ${t} == "object" && !Array.isArray(${t})`;
                            break;
                        case "integer":
                            i = a(s._ `!(${t} % 1) && !isNaN(${t})`);
                            break;
                        case "number":
                            i = a();
                            break;
                        default:
                            return s._ `typeof ${t} ${o} ${e}`
                    }
                    return n === c.Correct ? i : (0, s.not)(i);

                    function a(e = s.nil) {
                        return (0, s.and)(s._ `typeof ${t} == "number"`, e, r ? s._ `isFinite(${t})` : s.nil)
                    }
                }

                function p(e, t, r, n) {
                    if (1 === e.length) return d(e[0], t, r, n);
                    let o;
                    const i = (0, a.toHash)(e);
                    if (i.array && i.object) {
                        const e = s._ `typeof ${t} != "object"`;
                        o = i.null ? e : s._ `!${t} || ${e}`, delete i.null, delete i.array, delete i.object
                    } else o = s.nil;
                    i.number && delete i.integer;
                    for (const e in i) o = (0, s.and)(o, d(e, t, r, n));
                    return o
                }
                t.checkDataType = d, t.checkDataTypes = p;
                const h = {
                    message: ({
                        schema: e
                    }) => `must be ${e}`,
                    params: ({
                        schema: e,
                        schemaValue: t
                    }) => "string" == typeof e ? s._ `{type: ${e}}` : s._ `{type: ${t}}`
                };

                function f(e) {
                    const t = function(e) {
                        const {
                            gen: t,
                            data: r,
                            schema: n
                        } = e, o = (0, a.schemaRefOrVal)(e, n, "type");
                        return {
                            gen: t,
                            keyword: "type",
                            data: r,
                            schema: n.type,
                            schemaCode: o,
                            schemaValue: o,
                            parentSchema: n,
                            params: {},
                            it: e
                        }
                    }(e);
                    (0, i.reportError)(t, h)
                }
                t.reportTypeError = f
            },
            313: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.assignDefaults = void 0;
                const n = r(3487),
                    o = r(6776);

                function i(e, t, r) {
                    const {
                        gen: i,
                        compositeRule: s,
                        data: a,
                        opts: c
                    } = e;
                    if (void 0 === r) return;
                    const l = n._ `${a}${(0,n.getProperty)(t)}`;
                    if (s) return void(0, o.checkStrictMode)(e, `default is ignored for: ${l}`);
                    let u = n._ `${l} === undefined`;
                    "empty" === c.useDefaults && (u = n._ `${u} || ${l} === null || ${l} === ""`), i.if(u, n._ `${l} = ${(0,n.stringify)(r)}`)
                }
                t.assignDefaults = function(e, t) {
                    const {
                        properties: r,
                        items: n
                    } = e.schema;
                    if ("object" === t && r)
                        for (const t in r) i(e, t, r[t].default);
                    else "array" === t && Array.isArray(n) && n.forEach(((t, r) => i(e, r, t.default)))
                }
            },
            4815: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getData = t.KeywordCxt = t.validateFunctionCode = void 0;
                const n = r(5667),
                    o = r(453),
                    i = r(8876),
                    s = r(453),
                    a = r(313),
                    c = r(5005),
                    l = r(3099),
                    u = r(3487),
                    d = r(2141),
                    p = r(2531),
                    h = r(6776),
                    f = r(4181);

                function m({
                    gen: e,
                    validateName: t,
                    schema: r,
                    schemaEnv: n,
                    opts: o
                }, i) {
                    o.code.es5 ? e.func(t, u._ `${d.default.data}, ${d.default.valCxt}`, n.$async, (() => {
                        e.code(u._ `"use strict"; ${g(r,o)}`),
                            function(e, t) {
                                e.if(d.default.valCxt, (() => {
                                    e.var(d.default.instancePath, u._ `${d.default.valCxt}.${d.default.instancePath}`), e.var(d.default.parentData, u._ `${d.default.valCxt}.${d.default.parentData}`), e.var(d.default.parentDataProperty, u._ `${d.default.valCxt}.${d.default.parentDataProperty}`), e.var(d.default.rootData, u._ `${d.default.valCxt}.${d.default.rootData}`), t.dynamicRef && e.var(d.default.dynamicAnchors, u._ `${d.default.valCxt}.${d.default.dynamicAnchors}`)
                                }), (() => {
                                    e.var(d.default.instancePath, u._ `""`), e.var(d.default.parentData, u._ `undefined`), e.var(d.default.parentDataProperty, u._ `undefined`), e.var(d.default.rootData, d.default.data), t.dynamicRef && e.var(d.default.dynamicAnchors, u._ `{}`)
                                }))
                            }(e, o), e.code(i)
                    })) : e.func(t, u._ `${d.default.data}, ${function(e){return u._`{${d.default.instancePath}="", ${d.default.parentData}, ${d.default.parentDataProperty}, ${d.default.rootData}=${d.default.data}${e.dynamicRef?u._`, ${d.default.dynamicAnchors}={}`:u.nil}}={}`}(o)}`, n.$async, (() => e.code(g(r, o)).code(i)))
                }

                function g(e, t) {
                    const r = "object" == typeof e && e[t.schemaId];
                    return r && (t.code.source || t.code.process) ? u._ `/*# sourceURL=${r} */` : u.nil
                }

                function _({
                    schema: e,
                    self: t
                }) {
                    if ("boolean" == typeof e) return !e;
                    for (const r in e)
                        if (t.RULES.all[r]) return !0;
                    return !1
                }

                function y(e) {
                    return "boolean" != typeof e.schema
                }

                function v(e) {
                    (0, h.checkUnknownRules)(e),
                    function(e) {
                        const {
                            schema: t,
                            errSchemaPath: r,
                            opts: n,
                            self: o
                        } = e;
                        t.$ref && n.ignoreKeywordsWithRef && (0, h.schemaHasRulesButRef)(t, o.RULES) && o.logger.warn(`$ref: keywords ignored in schema at path "${r}"`)
                    }(e)
                }

                function b(e, t) {
                    if (e.opts.jtd) return x(e, [], !1, t);
                    const r = (0, o.getSchemaTypes)(e.schema);
                    x(e, r, !(0, o.coerceAndCheckDataType)(e, r), t)
                }

                function w({
                    gen: e,
                    schemaEnv: t,
                    schema: r,
                    errSchemaPath: n,
                    opts: o
                }) {
                    const i = r.$comment;
                    if (!0 === o.$comment) e.code(u._ `${d.default.self}.logger.log(${i})`);
                    else if ("function" == typeof o.$comment) {
                        const r = u.str `${n}/$comment`,
                            o = e.scopeValue("root", {
                                ref: t.root
                            });
                        e.code(u._ `${d.default.self}.opts.$comment(${i}, ${r}, ${o}.schema)`)
                    }
                }

                function x(e, t, r, n) {
                    const {
                        gen: o,
                        schema: a,
                        data: c,
                        allErrors: l,
                        opts: p,
                        self: f
                    } = e, {
                        RULES: m
                    } = f;

                    function g(h) {
                        (0, i.shouldUseGroup)(a, h) && (h.type ? (o.if((0, s.checkDataType)(h.type, c, p.strictNumbers)), E(e, h), 1 === t.length && t[0] === h.type && r && (o.else(), (0, s.reportTypeError)(e)), o.endIf()) : E(e, h), l || o.if(u._ `${d.default.errors} === ${n||0}`))
                    }!a.$ref || !p.ignoreKeywordsWithRef && (0, h.schemaHasRulesButRef)(a, m) ? (p.jtd || function(e, t) {
                        !e.schemaEnv.meta && e.opts.strictTypes && (function(e, t) {
                            t.length && (e.dataTypes.length ? (t.forEach((t => {
                                C(e.dataTypes, t) || S(e, `type "${t}" not allowed by context "${e.dataTypes.join(",")}"`)
                            })), e.dataTypes = e.dataTypes.filter((e => C(t, e)))) : e.dataTypes = t)
                        }(e, t), e.opts.allowUnionTypes || function(e, t) {
                            t.length > 1 && (2 !== t.length || !t.includes("null")) && S(e, "use allowUnionTypes to allow union type keyword")
                        }(e, t), function(e, t) {
                            const r = e.self.RULES.all;
                            for (const n in r) {
                                const o = r[n];
                                if ("object" == typeof o && (0, i.shouldUseRule)(e.schema, o)) {
                                    const {
                                        type: r
                                    } = o.definition;
                                    r.length && !r.some((e => {
                                        return n = e, (r = t).includes(n) || "number" === n && r.includes("integer");
                                        var r, n
                                    })) && S(e, `missing type "${r.join(",")}" for keyword "${n}"`)
                                }
                            }
                        }(e, e.dataTypes))
                    }(e, t), o.block((() => {
                        for (const e of m.rules) g(e);
                        g(m.post)
                    }))) : o.block((() => k(e, "$ref", m.all.$ref.definition)))
                }

                function E(e, t) {
                    const {
                        gen: r,
                        schema: n,
                        opts: {
                            useDefaults: o
                        }
                    } = e;
                    o && (0, a.assignDefaults)(e, t.type), r.block((() => {
                        for (const r of t.rules)(0, i.shouldUseRule)(n, r) && k(e, r.keyword, r.definition, t.type)
                    }))
                }

                function C(e, t) {
                    return e.includes(t) || "integer" === t && e.includes("number")
                }

                function S(e, t) {
                    t += ` at "${e.schemaEnv.baseId+e.errSchemaPath}" (strictTypes)`, (0, h.checkStrictMode)(e, t, e.opts.strictTypes)
                }
                t.validateFunctionCode = function(e) {
                    y(e) && (v(e), _(e)) ? function(e) {
                        const {
                            schema: t,
                            opts: r,
                            gen: n
                        } = e;
                        m(e, (() => {
                            r.$comment && t.$comment && w(e),
                                function(e) {
                                    const {
                                        schema: t,
                                        opts: r
                                    } = e;
                                    void 0 !== t.default && r.useDefaults && r.strictSchema && (0, h.checkStrictMode)(e, "default is ignored in the schema root")
                                }(e), n.let(d.default.vErrors, null), n.let(d.default.errors, 0), r.unevaluated && function(e) {
                                    const {
                                        gen: t,
                                        validateName: r
                                    } = e;
                                    e.evaluated = t.const("evaluated", u._ `${r}.evaluated`), t.if(u._ `${e.evaluated}.dynamicProps`, (() => t.assign(u._ `${e.evaluated}.props`, u._ `undefined`))), t.if(u._ `${e.evaluated}.dynamicItems`, (() => t.assign(u._ `${e.evaluated}.items`, u._ `undefined`)))
                                }(e), b(e),
                                function(e) {
                                    const {
                                        gen: t,
                                        schemaEnv: r,
                                        validateName: n,
                                        ValidationError: o,
                                        opts: i
                                    } = e;
                                    r.$async ? t.if(u._ `${d.default.errors} === 0`, (() => t.return(d.default.data)), (() => t.throw(u._ `new ${o}(${d.default.vErrors})`))) : (t.assign(u._ `${n}.errors`, d.default.vErrors), i.unevaluated && function({
                                        gen: e,
                                        evaluated: t,
                                        props: r,
                                        items: n
                                    }) {
                                        r instanceof u.Name && e.assign(u._ `${t}.props`, r), n instanceof u.Name && e.assign(u._ `${t}.items`, n)
                                    }(e), t.return(u._ `${d.default.errors} === 0`))
                                }(e)
                        }))
                    }(e) : m(e, (() => (0, n.topBoolOrEmptySchema)(e)))
                };
                class T {
                    constructor(e, t, r) {
                        if ((0, c.validateKeywordUsage)(e, t, r), this.gen = e.gen, this.allErrors = e.allErrors, this.keyword = r, this.data = e.data, this.schema = e.schema[r], this.$data = t.$data && e.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, h.schemaRefOrVal)(e, this.schema, r, this.$data), this.schemaType = t.schemaType, this.parentSchema = e.schema, this.params = {}, this.it = e, this.def = t, this.$data) this.schemaCode = e.gen.const("vSchema", A(this.$data, e));
                        else if (this.schemaCode = this.schemaValue, !(0, c.validSchemaType)(this.schema, t.schemaType, t.allowUndefined)) throw new Error(`${r} value must be ${JSON.stringify(t.schemaType)}`);
                        ("code" in t ? t.trackErrors : !1 !== t.errors) && (this.errsCount = e.gen.const("_errs", d.default.errors))
                    }
                    result(e, t, r) {
                        this.failResult((0, u.not)(e), t, r)
                    }
                    failResult(e, t, r) {
                        this.gen.if(e), r ? r() : this.error(), t ? (this.gen.else(), t(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else()
                    }
                    pass(e, t) {
                        this.failResult((0, u.not)(e), void 0, t)
                    }
                    fail(e) {
                        if (void 0 === e) return this.error(), void(this.allErrors || this.gen.if(!1));
                        this.gen.if(e), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else()
                    }
                    fail$data(e) {
                        if (!this.$data) return this.fail(e);
                        const {
                            schemaCode: t
                        } = this;
                        this.fail(u._ `${t} !== undefined && (${(0,u.or)(this.invalid$data(),e)})`)
                    }
                    error(e, t, r) {
                        if (t) return this.setParams(t), this._error(e, r), void this.setParams({});
                        this._error(e, r)
                    }
                    _error(e, t) {
                        (e ? f.reportExtraError : f.reportError)(this, this.def.error, t)
                    }
                    $dataError() {
                        (0, f.reportError)(this, this.def.$dataError || f.keyword$DataError)
                    }
                    reset() {
                        if (void 0 === this.errsCount) throw new Error('add "trackErrors" to keyword definition');
                        (0, f.resetErrorsCount)(this.gen, this.errsCount)
                    }
                    ok(e) {
                        this.allErrors || this.gen.if(e)
                    }
                    setParams(e, t) {
                        t ? Object.assign(this.params, e) : this.params = e
                    }
                    block$data(e, t, r = u.nil) {
                        this.gen.block((() => {
                            this.check$data(e, r), t()
                        }))
                    }
                    check$data(e = u.nil, t = u.nil) {
                        if (!this.$data) return;
                        const {
                            gen: r,
                            schemaCode: n,
                            schemaType: o,
                            def: i
                        } = this;
                        r.if((0, u.or)(u._ `${n} === undefined`, t)), e !== u.nil && r.assign(e, !0), (o.length || i.validateSchema) && (r.elseIf(this.invalid$data()), this.$dataError(), e !== u.nil && r.assign(e, !1)), r.else()
                    }
                    invalid$data() {
                        const {
                            gen: e,
                            schemaCode: t,
                            schemaType: r,
                            def: n,
                            it: o
                        } = this;
                        return (0, u.or)(function() {
                            if (r.length) {
                                if (!(t instanceof u.Name)) throw new Error("ajv implementation error");
                                const e = Array.isArray(r) ? r : [r];
                                return u._ `${(0,s.checkDataTypes)(e,t,o.opts.strictNumbers,s.DataType.Wrong)}`
                            }
                            return u.nil
                        }(), function() {
                            if (n.validateSchema) {
                                const r = e.scopeValue("validate$data", {
                                    ref: n.validateSchema
                                });
                                return u._ `!${r}(${t})`
                            }
                            return u.nil
                        }())
                    }
                    subschema(e, t) {
                        const r = (0, l.getSubschema)(this.it, e);
                        (0, l.extendSubschemaData)(r, this.it, e), (0, l.extendSubschemaMode)(r, e);
                        const o = { ...this.it,
                            ...r,
                            items: void 0,
                            props: void 0
                        };
                        return function(e, t) {
                            y(e) && (v(e), _(e)) ? function(e, t) {
                                const {
                                    schema: r,
                                    gen: n,
                                    opts: o
                                } = e;
                                o.$comment && r.$comment && w(e),
                                    function(e) {
                                        const t = e.schema[e.opts.schemaId];
                                        t && (e.baseId = (0, p.resolveUrl)(e.baseId, t))
                                    }(e),
                                    function(e) {
                                        if (e.schema.$async && !e.schemaEnv.$async) throw new Error("async schema in sync schema")
                                    }(e);
                                const i = n.const("_errs", d.default.errors);
                                b(e, i), n.var(t, u._ `${i} === ${d.default.errors}`)
                            }(e, t) : (0, n.boolOrEmptySchema)(e, t)
                        }(o, t), o
                    }
                    mergeEvaluated(e, t) {
                        const {
                            it: r,
                            gen: n
                        } = this;
                        r.opts.unevaluated && (!0 !== r.props && void 0 !== e.props && (r.props = h.mergeEvaluated.props(n, e.props, r.props, t)), !0 !== r.items && void 0 !== e.items && (r.items = h.mergeEvaluated.items(n, e.items, r.items, t)))
                    }
                    mergeValidEvaluated(e, t) {
                        const {
                            it: r,
                            gen: n
                        } = this;
                        if (r.opts.unevaluated && (!0 !== r.props || !0 !== r.items)) return n.if(t, (() => this.mergeEvaluated(e, u.Name))), !0
                    }
                }

                function k(e, t, r, n) {
                    const o = new T(e, r, t);
                    "code" in r ? r.code(o, n) : o.$data && r.validate ? (0, c.funcKeywordCode)(o, r) : "macro" in r ? (0, c.macroKeywordCode)(o, r) : (r.compile || r.validate) && (0, c.funcKeywordCode)(o, r)
                }
                t.KeywordCxt = T;
                const I = /^\/(?:[^~]|~0|~1)*$/,
                    P = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;

                function A(e, {
                    dataLevel: t,
                    dataNames: r,
                    dataPathArr: n
                }) {
                    let o, i;
                    if ("" === e) return d.default.rootData;
                    if ("/" === e[0]) {
                        if (!I.test(e)) throw new Error(`Invalid JSON-pointer: ${e}`);
                        o = e, i = d.default.rootData
                    } else {
                        const s = P.exec(e);
                        if (!s) throw new Error(`Invalid JSON-pointer: ${e}`);
                        const a = +s[1];
                        if (o = s[2], "#" === o) {
                            if (a >= t) throw new Error(c("property/index", a));
                            return n[t - a]
                        }
                        if (a > t) throw new Error(c("data", a));
                        if (i = r[t - a], !o) return i
                    }
                    let s = i;
                    const a = o.split("/");
                    for (const e of a) e && (i = u._ `${i}${(0,u.getProperty)((0,h.unescapeJsonPointer)(e))}`, s = u._ `${s} && ${i}`);
                    return s;

                    function c(e, r) {
                        return `Cannot access ${e} ${r} levels up, current level is ${t}`
                    }
                }
                t.getData = A
            },
            5005: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.validateKeywordUsage = t.validSchemaType = t.funcKeywordCode = t.macroKeywordCode = void 0;
                const n = r(3487),
                    o = r(2141),
                    i = r(412),
                    s = r(4181);

                function a(e) {
                    const {
                        gen: t,
                        data: r,
                        it: o
                    } = e;
                    t.if(o.parentData, (() => t.assign(r, n._ `${o.parentData}[${o.parentDataProperty}]`)))
                }

                function c(e, t, r) {
                    if (void 0 === r) throw new Error(`keyword "${t}" failed to compile`);
                    return e.scopeValue("keyword", "function" == typeof r ? {
                        ref: r
                    } : {
                        ref: r,
                        code: (0, n.stringify)(r)
                    })
                }
                t.macroKeywordCode = function(e, t) {
                    const {
                        gen: r,
                        keyword: o,
                        schema: i,
                        parentSchema: s,
                        it: a
                    } = e, l = t.macro.call(a.self, i, s, a), u = c(r, o, l);
                    !1 !== a.opts.validateSchema && a.self.validateSchema(l, !0);
                    const d = r.name("valid");
                    e.subschema({
                        schema: l,
                        schemaPath: n.nil,
                        errSchemaPath: `${a.errSchemaPath}/${o}`,
                        topSchemaRef: u,
                        compositeRule: !0
                    }, d), e.pass(d, (() => e.error(!0)))
                }, t.funcKeywordCode = function(e, t) {
                    var r;
                    const {
                        gen: l,
                        keyword: u,
                        schema: d,
                        parentSchema: p,
                        $data: h,
                        it: f
                    } = e;
                    ! function({
                        schemaEnv: e
                    }, t) {
                        if (t.async && !e.$async) throw new Error("async keyword in sync schema")
                    }(f, t);
                    const m = !h && t.compile ? t.compile.call(f.self, d, p, f) : t.validate,
                        g = c(l, u, m),
                        _ = l.let("valid");

                    function y(r = (t.async ? n._ `await ` : n.nil)) {
                        const s = f.opts.passContext ? o.default.this : o.default.self,
                            a = !("compile" in t && !h || !1 === t.schema);
                        l.assign(_, n._ `${r}${(0,i.callValidateCode)(e,g,s,a)}`, t.modifying)
                    }

                    function v(e) {
                        var r;
                        l.if((0, n.not)(null !== (r = t.valid) && void 0 !== r ? r : _), e)
                    }
                    e.block$data(_, (function() {
                        if (!1 === t.errors) y(), t.modifying && a(e), v((() => e.error()));
                        else {
                            const r = t.async ? function() {
                                const e = l.let("ruleErrs", null);
                                return l.try((() => y(n._ `await `)), (t => l.assign(_, !1).if(n._ `${t} instanceof ${f.ValidationError}`, (() => l.assign(e, n._ `${t}.errors`)), (() => l.throw(t))))), e
                            }() : function() {
                                const e = n._ `${g}.errors`;
                                return l.assign(e, null), y(n.nil), e
                            }();
                            t.modifying && a(e), v((() => function(e, t) {
                                const {
                                    gen: r
                                } = e;
                                r.if(n._ `Array.isArray(${t})`, (() => {
                                    r.assign(o.default.vErrors, n._ `${o.default.vErrors} === null ? ${t} : ${o.default.vErrors}.concat(${t})`).assign(o.default.errors, n._ `${o.default.vErrors}.length`), (0, s.extendErrors)(e)
                                }), (() => e.error()))
                            }(e, r)))
                        }
                    })), e.ok(null !== (r = t.valid) && void 0 !== r ? r : _)
                }, t.validSchemaType = function(e, t, r = !1) {
                    return !t.length || t.some((t => "array" === t ? Array.isArray(e) : "object" === t ? e && "object" == typeof e && !Array.isArray(e) : typeof e == t || r && void 0 === e))
                }, t.validateKeywordUsage = function({
                    schema: e,
                    opts: t,
                    self: r,
                    errSchemaPath: n
                }, o, i) {
                    if (Array.isArray(o.keyword) ? !o.keyword.includes(i) : o.keyword !== i) throw new Error("ajv implementation error");
                    const s = o.dependencies;
                    if (null == s ? void 0 : s.some((t => !Object.prototype.hasOwnProperty.call(e, t)))) throw new Error(`parent schema must have dependencies of ${i}: ${s.join(",")}`);
                    if (o.validateSchema && !o.validateSchema(e[i])) {
                        const e = `keyword "${i}" value is invalid at path "${n}": ` + r.errorsText(o.validateSchema.errors);
                        if ("log" !== t.validateSchema) throw new Error(e);
                        r.logger.error(e)
                    }
                }
            },
            3099: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.extendSubschemaMode = t.extendSubschemaData = t.getSubschema = void 0;
                const n = r(3487),
                    o = r(6776);
                t.getSubschema = function(e, {
                    keyword: t,
                    schemaProp: r,
                    schema: i,
                    schemaPath: s,
                    errSchemaPath: a,
                    topSchemaRef: c
                }) {
                    if (void 0 !== t && void 0 !== i) throw new Error('both "keyword" and "schema" passed, only one allowed');
                    if (void 0 !== t) {
                        const i = e.schema[t];
                        return void 0 === r ? {
                            schema: i,
                            schemaPath: n._ `${e.schemaPath}${(0,n.getProperty)(t)}`,
                            errSchemaPath: `${e.errSchemaPath}/${t}`
                        } : {
                            schema: i[r],
                            schemaPath: n._ `${e.schemaPath}${(0,n.getProperty)(t)}${(0,n.getProperty)(r)}`,
                            errSchemaPath: `${e.errSchemaPath}/${t}/${(0,o.escapeFragment)(r)}`
                        }
                    }
                    if (void 0 !== i) {
                        if (void 0 === s || void 0 === a || void 0 === c) throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
                        return {
                            schema: i,
                            schemaPath: s,
                            topSchemaRef: c,
                            errSchemaPath: a
                        }
                    }
                    throw new Error('either "keyword" or "schema" must be passed')
                }, t.extendSubschemaData = function(e, t, {
                    dataProp: r,
                    dataPropType: i,
                    data: s,
                    dataTypes: a,
                    propertyName: c
                }) {
                    if (void 0 !== s && void 0 !== r) throw new Error('both "data" and "dataProp" passed, only one allowed');
                    const {
                        gen: l
                    } = t;
                    if (void 0 !== r) {
                        const {
                            errorPath: s,
                            dataPathArr: a,
                            opts: c
                        } = t;
                        u(l.let("data", n._ `${t.data}${(0,n.getProperty)(r)}`, !0)), e.errorPath = n.str `${s}${(0,o.getErrorPath)(r,i,c.jsPropertySyntax)}`, e.parentDataProperty = n._ `${r}`, e.dataPathArr = [...a, e.parentDataProperty]
                    }

                    function u(r) {
                        e.data = r, e.dataLevel = t.dataLevel + 1, e.dataTypes = [], t.definedProperties = new Set, e.parentData = t.data, e.dataNames = [...t.dataNames, r]
                    }
                    void 0 !== s && (u(s instanceof n.Name ? s : l.let("data", s, !0)), void 0 !== c && (e.propertyName = c)), a && (e.dataTypes = a)
                }, t.extendSubschemaMode = function(e, {
                    jtdDiscriminator: t,
                    jtdMetadata: r,
                    compositeRule: n,
                    createErrors: o,
                    allErrors: i
                }) {
                    void 0 !== n && (e.compositeRule = n), void 0 !== o && (e.createErrors = o), void 0 !== i && (e.allErrors = i), e.jtdDiscriminator = t, e.jtdMetadata = r
                }
            },
            7159: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
                var n = r(4815);
                Object.defineProperty(t, "KeywordCxt", {
                    enumerable: !0,
                    get: function() {
                        return n.KeywordCxt
                    }
                });
                var o = r(3487);
                Object.defineProperty(t, "_", {
                    enumerable: !0,
                    get: function() {
                        return o._
                    }
                }), Object.defineProperty(t, "str", {
                    enumerable: !0,
                    get: function() {
                        return o.str
                    }
                }), Object.defineProperty(t, "stringify", {
                    enumerable: !0,
                    get: function() {
                        return o.stringify
                    }
                }), Object.defineProperty(t, "nil", {
                    enumerable: !0,
                    get: function() {
                        return o.nil
                    }
                }), Object.defineProperty(t, "Name", {
                    enumerable: !0,
                    get: function() {
                        return o.Name
                    }
                }), Object.defineProperty(t, "CodeGen", {
                    enumerable: !0,
                    get: function() {
                        return o.CodeGen
                    }
                });
                const i = r(7426),
                    s = r(6646),
                    a = r(3141),
                    c = r(5173),
                    l = r(3487),
                    u = r(2531),
                    d = r(453),
                    p = r(6776),
                    h = r(4775),
                    f = ["removeAdditional", "useDefaults", "coerceTypes"],
                    m = new Set(["validate", "serialize", "parse", "wrapper", "root", "schema", "keyword", "pattern", "formats", "validate$data", "func", "obj", "Error"]),
                    g = {
                        errorDataPath: "",
                        format: "`validateFormats: false` can be used instead.",
                        nullable: '"nullable" keyword is supported by default.',
                        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
                        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
                        missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
                        processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
                        sourceCode: "Use option `code: {source: true}`",
                        strictDefaults: "It is default now, see option `strict`.",
                        strictKeywords: "It is default now, see option `strict`.",
                        uniqueItems: '"uniqueItems" keyword is always validated.',
                        unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
                        cache: "Map is used as cache, schema object as key.",
                        serialize: "Map is used as cache, schema object as key.",
                        ajvErrors: "It is default now."
                    },
                    _ = {
                        ignoreKeywordsWithRef: "",
                        jsPropertySyntax: "",
                        unicode: '"minLength"/"maxLength" account for unicode characters by default.'
                    };

                function y(e) {
                    var t, r, n, o, i, s, a, c, l, u, d, p, h, f, m, g, _, y, v, b, w, x;
                    const E = e.strict,
                        C = null === (t = e.code) || void 0 === t ? void 0 : t.optimize,
                        S = !0 === C || void 0 === C ? 1 : C || 0;
                    return {
                        strictSchema: null === (n = null !== (r = e.strictSchema) && void 0 !== r ? r : E) || void 0 === n || n,
                        strictNumbers: null === (i = null !== (o = e.strictNumbers) && void 0 !== o ? o : E) || void 0 === i || i,
                        strictTypes: null !== (a = null !== (s = e.strictTypes) && void 0 !== s ? s : E) && void 0 !== a ? a : "log",
                        strictTuples: null !== (l = null !== (c = e.strictTuples) && void 0 !== c ? c : E) && void 0 !== l ? l : "log",
                        strictRequired: null !== (d = null !== (u = e.strictRequired) && void 0 !== u ? u : E) && void 0 !== d && d,
                        code: e.code ? { ...e.code,
                            optimize: S
                        } : {
                            optimize: S
                        },
                        loopRequired: null !== (p = e.loopRequired) && void 0 !== p ? p : 200,
                        loopEnum: null !== (h = e.loopEnum) && void 0 !== h ? h : 200,
                        meta: null === (f = e.meta) || void 0 === f || f,
                        messages: null === (m = e.messages) || void 0 === m || m,
                        inlineRefs: null === (g = e.inlineRefs) || void 0 === g || g,
                        schemaId: null !== (_ = e.schemaId) && void 0 !== _ ? _ : "$id",
                        addUsedSchema: null === (y = e.addUsedSchema) || void 0 === y || y,
                        validateSchema: null === (v = e.validateSchema) || void 0 === v || v,
                        validateFormats: null === (b = e.validateFormats) || void 0 === b || b,
                        unicodeRegExp: null === (w = e.unicodeRegExp) || void 0 === w || w,
                        int32range: null === (x = e.int32range) || void 0 === x || x
                    }
                }
                class v {
                    constructor(e = {}) {
                        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = new Set, this._loading = {}, this._cache = new Map, e = this.opts = { ...e,
                            ...y(e)
                        };
                        const {
                            es5: t,
                            lines: r
                        } = this.opts.code;
                        this.scope = new l.ValueScope({
                            scope: {},
                            prefixes: m,
                            es5: t,
                            lines: r
                        }), this.logger = function(e) {
                            if (!1 === e) return T;
                            if (void 0 === e) return console;
                            if (e.log && e.warn && e.error) return e;
                            throw new Error("logger must implement log, warn and error methods")
                        }(e.logger);
                        const n = e.validateFormats;
                        e.validateFormats = !1, this.RULES = (0, a.getRules)(), b.call(this, g, e, "NOT SUPPORTED"), b.call(this, _, e, "DEPRECATED", "warn"), this._metaOpts = S.call(this), e.formats && E.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), e.keywords && C.call(this, e.keywords), "object" == typeof e.meta && this.addMetaSchema(e.meta), x.call(this), e.validateFormats = n
                    }
                    _addVocabularies() {
                        this.addKeyword("$async")
                    }
                    _addDefaultMetaSchema() {
                        const {
                            $data: e,
                            meta: t,
                            schemaId: r
                        } = this.opts;
                        let n = h;
                        "id" === r && (n = { ...h
                        }, n.id = n.$id, delete n.$id), t && e && this.addMetaSchema(n, n[r], !1)
                    }
                    defaultMeta() {
                        const {
                            meta: e,
                            schemaId: t
                        } = this.opts;
                        return this.opts.defaultMeta = "object" == typeof e ? e[t] || e : void 0
                    }
                    validate(e, t) {
                        let r;
                        if ("string" == typeof e) {
                            if (r = this.getSchema(e), !r) throw new Error(`no schema with key or ref "${e}"`)
                        } else r = this.compile(e);
                        const n = r(t);
                        return "$async" in r || (this.errors = r.errors), n
                    }
                    compile(e, t) {
                        const r = this._addSchema(e, t);
                        return r.validate || this._compileSchemaEnv(r)
                    }
                    compileAsync(e, t) {
                        if ("function" != typeof this.opts.loadSchema) throw new Error("options.loadSchema should be a function");
                        const {
                            loadSchema: r
                        } = this.opts;
                        return n.call(this, e, t);
                        async function n(e, t) {
                            await o.call(this, e.$schema);
                            const r = this._addSchema(e, t);
                            return r.validate || i.call(this, r)
                        }
                        async function o(e) {
                            e && !this.getSchema(e) && await n.call(this, {
                                $ref: e
                            }, !0)
                        }
                        async function i(e) {
                            try {
                                return this._compileSchemaEnv(e)
                            } catch (t) {
                                if (!(t instanceof s.default)) throw t;
                                return a.call(this, t), await c.call(this, t.missingSchema), i.call(this, e)
                            }
                        }

                        function a({
                            missingSchema: e,
                            missingRef: t
                        }) {
                            if (this.refs[e]) throw new Error(`AnySchema ${e} is loaded but ${t} cannot be resolved`)
                        }
                        async function c(e) {
                            const r = await l.call(this, e);
                            this.refs[e] || await o.call(this, r.$schema), this.refs[e] || this.addSchema(r, e, t)
                        }
                        async function l(e) {
                            const t = this._loading[e];
                            if (t) return t;
                            try {
                                return await (this._loading[e] = r(e))
                            } finally {
                                delete this._loading[e]
                            }
                        }
                    }
                    addSchema(e, t, r, n = this.opts.validateSchema) {
                        if (Array.isArray(e)) {
                            for (const t of e) this.addSchema(t, void 0, r, n);
                            return this
                        }
                        let o;
                        if ("object" == typeof e) {
                            const {
                                schemaId: t
                            } = this.opts;
                            if (o = e[t], void 0 !== o && "string" != typeof o) throw new Error(`schema ${t} must be string`)
                        }
                        return t = (0, u.normalizeId)(t || o), this._checkUnique(t), this.schemas[t] = this._addSchema(e, r, t, n, !0), this
                    }
                    addMetaSchema(e, t, r = this.opts.validateSchema) {
                        return this.addSchema(e, t, !0, r), this
                    }
                    validateSchema(e, t) {
                        if ("boolean" == typeof e) return !0;
                        let r;
                        if (r = e.$schema, void 0 !== r && "string" != typeof r) throw new Error("$schema must be a string");
                        if (r = r || this.opts.defaultMeta || this.defaultMeta(), !r) return this.logger.warn("meta-schema not available"), this.errors = null, !0;
                        const n = this.validate(r, e);
                        if (!n && t) {
                            const e = "schema is invalid: " + this.errorsText();
                            if ("log" !== this.opts.validateSchema) throw new Error(e);
                            this.logger.error(e)
                        }
                        return n
                    }
                    getSchema(e) {
                        let t;
                        for (;
                            "string" == typeof(t = w.call(this, e));) e = t;
                        if (void 0 === t) {
                            const {
                                schemaId: r
                            } = this.opts, n = new c.SchemaEnv({
                                schema: {},
                                schemaId: r
                            });
                            if (t = c.resolveSchema.call(this, n, e), !t) return;
                            this.refs[e] = t
                        }
                        return t.validate || this._compileSchemaEnv(t)
                    }
                    removeSchema(e) {
                        if (e instanceof RegExp) return this._removeAllSchemas(this.schemas, e), this._removeAllSchemas(this.refs, e), this;
                        switch (typeof e) {
                            case "undefined":
                                return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
                            case "string":
                                {
                                    const t = w.call(this, e);
                                    return "object" == typeof t && this._cache.delete(t.schema),
                                    delete this.schemas[e],
                                    delete this.refs[e],
                                    this
                                }
                            case "object":
                                {
                                    const t = e;this._cache.delete(t);
                                    let r = e[this.opts.schemaId];
                                    return r && (r = (0, u.normalizeId)(r), delete this.schemas[r], delete this.refs[r]),
                                    this
                                }
                            default:
                                throw new Error("ajv.removeSchema: invalid parameter")
                        }
                    }
                    addVocabulary(e) {
                        for (const t of e) this.addKeyword(t);
                        return this
                    }
                    addKeyword(e, t) {
                        let r;
                        if ("string" == typeof e) r = e, "object" == typeof t && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), t.keyword = r);
                        else {
                            if ("object" != typeof e || void 0 !== t) throw new Error("invalid addKeywords parameters");
                            if (r = (t = e).keyword, Array.isArray(r) && !r.length) throw new Error("addKeywords: keyword must be string or non-empty array")
                        }
                        if (I.call(this, r, t), !t) return (0, p.eachItem)(r, (e => P.call(this, e))), this;
                        O.call(this, t);
                        const n = { ...t,
                            type: (0, d.getJSONTypes)(t.type),
                            schemaType: (0, d.getJSONTypes)(t.schemaType)
                        };
                        return (0, p.eachItem)(r, 0 === n.type.length ? e => P.call(this, e, n) : e => n.type.forEach((t => P.call(this, e, n, t)))), this
                    }
                    getKeyword(e) {
                        const t = this.RULES.all[e];
                        return "object" == typeof t ? t.definition : !!t
                    }
                    removeKeyword(e) {
                        const {
                            RULES: t
                        } = this;
                        delete t.keywords[e], delete t.all[e];
                        for (const r of t.rules) {
                            const t = r.rules.findIndex((t => t.keyword === e));
                            t >= 0 && r.rules.splice(t, 1)
                        }
                        return this
                    }
                    addFormat(e, t) {
                        return "string" == typeof t && (t = new RegExp(t)), this.formats[e] = t, this
                    }
                    errorsText(e = this.errors, {
                        separator: t = ", ",
                        dataVar: r = "data"
                    } = {}) {
                        return e && 0 !== e.length ? e.map((e => `${r}${e.instancePath} ${e.message}`)).reduce(((e, r) => e + t + r)) : "No errors"
                    }
                    $dataMetaSchema(e, t) {
                        const r = this.RULES.all;
                        e = JSON.parse(JSON.stringify(e));
                        for (const n of t) {
                            const t = n.split("/").slice(1);
                            let o = e;
                            for (const e of t) o = o[e];
                            for (const e in r) {
                                const t = r[e];
                                if ("object" != typeof t) continue;
                                const {
                                    $data: n
                                } = t.definition, i = o[e];
                                n && i && (o[e] = R(i))
                            }
                        }
                        return e
                    }
                    _removeAllSchemas(e, t) {
                        for (const r in e) {
                            const n = e[r];
                            t && !t.test(r) || ("string" == typeof n ? delete e[r] : n && !n.meta && (this._cache.delete(n.schema), delete e[r]))
                        }
                    }
                    _addSchema(e, t, r, n = this.opts.validateSchema, o = this.opts.addUsedSchema) {
                        let i;
                        const {
                            schemaId: s
                        } = this.opts;
                        if ("object" == typeof e) i = e[s];
                        else {
                            if (this.opts.jtd) throw new Error("schema must be object");
                            if ("boolean" != typeof e) throw new Error("schema must be object or boolean")
                        }
                        let a = this._cache.get(e);
                        if (void 0 !== a) return a;
                        r = (0, u.normalizeId)(i || r);
                        const l = u.getSchemaRefs.call(this, e, r);
                        return a = new c.SchemaEnv({
                            schema: e,
                            schemaId: s,
                            meta: t,
                            baseId: r,
                            localRefs: l
                        }), this._cache.set(a.schema, a), o && !r.startsWith("#") && (r && this._checkUnique(r), this.refs[r] = a), n && this.validateSchema(e, !0), a
                    }
                    _checkUnique(e) {
                        if (this.schemas[e] || this.refs[e]) throw new Error(`schema with key or id "${e}" already exists`)
                    }
                    _compileSchemaEnv(e) {
                        if (e.meta ? this._compileMetaSchema(e) : c.compileSchema.call(this, e), !e.validate) throw new Error("ajv implementation error");
                        return e.validate
                    }
                    _compileMetaSchema(e) {
                        const t = this.opts;
                        this.opts = this._metaOpts;
                        try {
                            c.compileSchema.call(this, e)
                        } finally {
                            this.opts = t
                        }
                    }
                }

                function b(e, t, r, n = "error") {
                    for (const o in e) {
                        const i = o;
                        i in t && this.logger[n](`${r}: option ${o}. ${e[i]}`)
                    }
                }

                function w(e) {
                    return e = (0, u.normalizeId)(e), this.schemas[e] || this.refs[e]
                }

                function x() {
                    const e = this.opts.schemas;
                    if (e)
                        if (Array.isArray(e)) this.addSchema(e);
                        else
                            for (const t in e) this.addSchema(e[t], t)
                }

                function E() {
                    for (const e in this.opts.formats) {
                        const t = this.opts.formats[e];
                        t && this.addFormat(e, t)
                    }
                }

                function C(e) {
                    if (Array.isArray(e)) this.addVocabulary(e);
                    else {
                        this.logger.warn("keywords option as map is deprecated, pass array");
                        for (const t in e) {
                            const r = e[t];
                            r.keyword || (r.keyword = t), this.addKeyword(r)
                        }
                    }
                }

                function S() {
                    const e = { ...this.opts
                    };
                    for (const t of f) delete e[t];
                    return e
                }
                t.default = v, v.ValidationError = i.default, v.MissingRefError = s.default;
                const T = {
                        log() {},
                        warn() {},
                        error() {}
                    },
                    k = /^[a-z_$][a-z0-9_$:-]*$/i;

                function I(e, t) {
                    const {
                        RULES: r
                    } = this;
                    if ((0, p.eachItem)(e, (e => {
                            if (r.keywords[e]) throw new Error(`Keyword ${e} is already defined`);
                            if (!k.test(e)) throw new Error(`Keyword ${e} has invalid name`)
                        })), t && t.$data && !("code" in t) && !("validate" in t)) throw new Error('$data keyword must have "code" or "validate" function')
                }

                function P(e, t, r) {
                    var n;
                    const o = null == t ? void 0 : t.post;
                    if (r && o) throw new Error('keyword with "post" flag cannot have "type"');
                    const {
                        RULES: i
                    } = this;
                    let s = o ? i.post : i.rules.find((({
                        type: e
                    }) => e === r));
                    if (s || (s = {
                            type: r,
                            rules: []
                        }, i.rules.push(s)), i.keywords[e] = !0, !t) return;
                    const a = {
                        keyword: e,
                        definition: { ...t,
                            type: (0, d.getJSONTypes)(t.type),
                            schemaType: (0, d.getJSONTypes)(t.schemaType)
                        }
                    };
                    t.before ? A.call(this, s, a, t.before) : s.rules.push(a), i.all[e] = a, null === (n = t.implements) || void 0 === n || n.forEach((e => this.addKeyword(e)))
                }

                function A(e, t, r) {
                    const n = e.rules.findIndex((e => e.keyword === r));
                    n >= 0 ? e.rules.splice(n, 0, t) : (e.rules.push(t), this.logger.warn(`rule ${r} is not defined`))
                }

                function O(e) {
                    let {
                        metaSchema: t
                    } = e;
                    void 0 !== t && (e.$data && this.opts.$data && (t = R(t)), e.validateSchema = this.compile(t, !0))
                }
                const N = {
                    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
                };

                function R(e) {
                    return {
                        anyOf: [e, N]
                    }
                }
            },
            3510: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(4063);
                n.code = 'require("ajv/dist/runtime/equal").default', t.default = n
            },
            4499: (e, t) => {
                "use strict";

                function r(e) {
                    const t = e.length;
                    let r, n = 0,
                        o = 0;
                    for (; o < t;) n++, r = e.charCodeAt(o++), r >= 55296 && r <= 56319 && o < t && (r = e.charCodeAt(o), 56320 == (64512 & r) && o++);
                    return n
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = r, r.code = 'require("ajv/dist/runtime/ucs2length").default'
            },
            7426: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                class r extends Error {
                    constructor(e) {
                        super("validation failed"), this.errors = e, this.ajv = this.validation = !0
                    }
                }
                t.default = r
            },
            4783: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.validateAdditionalItems = void 0;
                const n = r(3487),
                    o = r(6776),
                    i = {
                        keyword: "additionalItems",
                        type: "array",
                        schemaType: ["boolean", "object"],
                        before: "uniqueItems",
                        error: {
                            message: ({
                                params: {
                                    len: e
                                }
                            }) => n.str `must NOT have more than ${e} items`,
                            params: ({
                                params: {
                                    len: e
                                }
                            }) => n._ `{limit: ${e}}`
                        },
                        code(e) {
                            const {
                                parentSchema: t,
                                it: r
                            } = e, {
                                items: n
                            } = t;
                            Array.isArray(n) ? s(e, n) : (0, o.checkStrictMode)(r, '"additionalItems" is ignored when "items" is not an array of schemas')
                        }
                    };

                function s(e, t) {
                    const {
                        gen: r,
                        schema: i,
                        data: s,
                        keyword: a,
                        it: c
                    } = e;
                    c.items = !0;
                    const l = r.const("len", n._ `${s}.length`);
                    if (!1 === i) e.setParams({
                        len: t.length
                    }), e.pass(n._ `${l} <= ${t.length}`);
                    else if ("object" == typeof i && !(0, o.alwaysValidSchema)(c, i)) {
                        const i = r.var("valid", n._ `${l} <= ${t.length}`);
                        r.if((0, n.not)(i), (() => function(i) {
                            r.forRange("i", t.length, l, (t => {
                                e.subschema({
                                    keyword: a,
                                    dataProp: t,
                                    dataPropType: o.Type.Num
                                }, i), c.allErrors || r.if((0, n.not)(i), (() => r.break()))
                            }))
                        }(i))), e.ok(i)
                    }
                }
                t.validateAdditionalItems = s, t.default = i
            },
            9351: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(412),
                    o = r(3487),
                    i = r(2141),
                    s = r(6776),
                    a = {
                        keyword: "additionalProperties",
                        type: ["object"],
                        schemaType: ["boolean", "object"],
                        allowUndefined: !0,
                        trackErrors: !0,
                        error: {
                            message: "must NOT have additional properties",
                            params: ({
                                params: e
                            }) => o._ `{additionalProperty: ${e.additionalProperty}}`
                        },
                        code(e) {
                            const {
                                gen: t,
                                schema: r,
                                parentSchema: a,
                                data: c,
                                errsCount: l,
                                it: u
                            } = e;
                            if (!l) throw new Error("ajv implementation error");
                            const {
                                allErrors: d,
                                opts: p
                            } = u;
                            if (u.props = !0, "all" !== p.removeAdditional && (0, s.alwaysValidSchema)(u, r)) return;
                            const h = (0, n.allSchemaProperties)(a.properties),
                                f = (0, n.allSchemaProperties)(a.patternProperties);

                            function m(e) {
                                t.code(o._ `delete ${c}[${e}]`)
                            }

                            function g(n) {
                                if ("all" === p.removeAdditional || p.removeAdditional && !1 === r) m(n);
                                else {
                                    if (!1 === r) return e.setParams({
                                        additionalProperty: n
                                    }), e.error(), void(d || t.break());
                                    if ("object" == typeof r && !(0, s.alwaysValidSchema)(u, r)) {
                                        const r = t.name("valid");
                                        "failing" === p.removeAdditional ? (_(n, r, !1), t.if((0, o.not)(r), (() => {
                                            e.reset(), m(n)
                                        }))) : (_(n, r), d || t.if((0, o.not)(r), (() => t.break())))
                                    }
                                }
                            }

                            function _(t, r, n) {
                                const o = {
                                    keyword: "additionalProperties",
                                    dataProp: t,
                                    dataPropType: s.Type.Str
                                };
                                !1 === n && Object.assign(o, {
                                    compositeRule: !0,
                                    createErrors: !1,
                                    allErrors: !1
                                }), e.subschema(o, r)
                            }
                            t.forIn("key", c, (r => {
                                h.length || f.length ? t.if(function(r) {
                                    let i;
                                    if (h.length > 8) {
                                        const e = (0, s.schemaRefOrVal)(u, a.properties, "properties");
                                        i = (0, n.isOwnProperty)(t, e, r)
                                    } else i = h.length ? (0, o.or)(...h.map((e => o._ `${r} === ${e}`))) : o.nil;
                                    return f.length && (i = (0, o.or)(i, ...f.map((t => o._ `${(0,n.usePattern)(e,t)}.test(${r})`)))), (0, o.not)(i)
                                }(r), (() => g(r))) : g(r)
                            })), e.ok(o._ `${l} === ${i.default.errors}`)
                        }
                    };
                t.default = a
            },
            1125: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(6776),
                    o = {
                        keyword: "allOf",
                        schemaType: "array",
                        code(e) {
                            const {
                                gen: t,
                                schema: r,
                                it: o
                            } = e;
                            if (!Array.isArray(r)) throw new Error("ajv implementation error");
                            const i = t.name("valid");
                            r.forEach(((t, r) => {
                                if ((0, n.alwaysValidSchema)(o, t)) return;
                                const s = e.subschema({
                                    keyword: "allOf",
                                    schemaProp: r
                                }, i);
                                e.ok(i), e.mergeEvaluated(s)
                            }))
                        }
                    };
                t.default = o
            },
            19: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = {
                    keyword: "anyOf",
                    schemaType: "array",
                    trackErrors: !0,
                    code: r(412).validateUnion,
                    error: {
                        message: "must match a schema in anyOf"
                    }
                };
                t.default = n
            },
            9864: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = r(6776),
                    i = {
                        keyword: "contains",
                        type: "array",
                        schemaType: ["object", "boolean"],
                        before: "uniqueItems",
                        trackErrors: !0,
                        error: {
                            message: ({
                                params: {
                                    min: e,
                                    max: t
                                }
                            }) => void 0 === t ? n.str `must contain at least ${e} valid item(s)` : n.str `must contain at least ${e} and no more than ${t} valid item(s)`,
                            params: ({
                                params: {
                                    min: e,
                                    max: t
                                }
                            }) => void 0 === t ? n._ `{minContains: ${e}}` : n._ `{minContains: ${e}, maxContains: ${t}}`
                        },
                        code(e) {
                            const {
                                gen: t,
                                schema: r,
                                parentSchema: i,
                                data: s,
                                it: a
                            } = e;
                            let c, l;
                            const {
                                minContains: u,
                                maxContains: d
                            } = i;
                            a.opts.next ? (c = void 0 === u ? 1 : u, l = d) : c = 1;
                            const p = t.const("len", n._ `${s}.length`);
                            if (e.setParams({
                                    min: c,
                                    max: l
                                }), void 0 === l && 0 === c) return void(0, o.checkStrictMode)(a, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
                            if (void 0 !== l && c > l) return (0, o.checkStrictMode)(a, '"minContains" > "maxContains" is always invalid'), void e.fail();
                            if ((0, o.alwaysValidSchema)(a, r)) {
                                let t = n._ `${p} >= ${c}`;
                                return void 0 !== l && (t = n._ `${t} && ${p} <= ${l}`), void e.pass(t)
                            }
                            a.items = !0;
                            const h = t.name("valid");
                            if (void 0 === l && 1 === c) f(h, (() => t.if(h, (() => t.break()))));
                            else {
                                t.let(h, !1);
                                const e = t.name("_valid"),
                                    r = t.let("count", 0);
                                f(e, (() => t.if(e, (() => function(e) {
                                    t.code(n._ `${e}++`), void 0 === l ? t.if(n._ `${e} >= ${c}`, (() => t.assign(h, !0).break())) : (t.if(n._ `${e} > ${l}`, (() => t.assign(h, !1).break())), 1 === c ? t.assign(h, !0) : t.if(n._ `${e} >= ${c}`, (() => t.assign(h, !0))))
                                }(r)))))
                            }

                            function f(r, n) {
                                t.forRange("i", 0, p, (t => {
                                    e.subschema({
                                        keyword: "contains",
                                        dataProp: t,
                                        dataPropType: o.Type.Num,
                                        compositeRule: !0
                                    }, r), n()
                                }))
                            }
                            e.result(h, (() => e.reset()))
                        }
                    };
                t.default = i
            },
            7772: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.validateSchemaDeps = t.validatePropertyDeps = t.error = void 0;
                const n = r(3487),
                    o = r(6776),
                    i = r(412);
                t.error = {
                    message: ({
                        params: {
                            property: e,
                            depsCount: t,
                            deps: r
                        }
                    }) => {
                        const o = 1 === t ? "property" : "properties";
                        return n.str `must have ${o} ${r} when property ${e} is present`
                    },
                    params: ({
                        params: {
                            property: e,
                            depsCount: t,
                            deps: r,
                            missingProperty: o
                        }
                    }) => n._ `{property: ${e},
    missingProperty: ${o},
    depsCount: ${t},
    deps: ${r}}`
                };
                const s = {
                    keyword: "dependencies",
                    type: "object",
                    schemaType: "object",
                    error: t.error,
                    code(e) {
                        const [t, r] = function({
                            schema: e
                        }) {
                            const t = {},
                                r = {};
                            for (const n in e) "__proto__" !== n && ((Array.isArray(e[n]) ? t : r)[n] = e[n]);
                            return [t, r]
                        }(e);
                        a(e, t), c(e, r)
                    }
                };

                function a(e, t = e.schema) {
                    const {
                        gen: r,
                        data: o,
                        it: s
                    } = e;
                    if (0 === Object.keys(t).length) return;
                    const a = r.let("missing");
                    for (const c in t) {
                        const l = t[c];
                        if (0 === l.length) continue;
                        const u = (0, i.propertyInData)(r, o, c, s.opts.ownProperties);
                        e.setParams({
                            property: c,
                            depsCount: l.length,
                            deps: l.join(", ")
                        }), s.allErrors ? r.if(u, (() => {
                            for (const t of l)(0, i.checkReportMissingProp)(e, t)
                        })) : (r.if(n._ `${u} && (${(0,i.checkMissingProp)(e,l,a)})`), (0, i.reportMissingProp)(e, a), r.else())
                    }
                }

                function c(e, t = e.schema) {
                    const {
                        gen: r,
                        data: n,
                        keyword: s,
                        it: a
                    } = e, c = r.name("valid");
                    for (const l in t)(0, o.alwaysValidSchema)(a, t[l]) || (r.if((0, i.propertyInData)(r, n, l, a.opts.ownProperties), (() => {
                        const t = e.subschema({
                            keyword: s,
                            schemaProp: l
                        }, c);
                        e.mergeValidEvaluated(t, c)
                    }), (() => r.var(c, !0))), e.ok(c))
                }
                t.validatePropertyDeps = a, t.validateSchemaDeps = c, t.default = s
            },
            9434: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = r(6776),
                    i = {
                        keyword: "if",
                        schemaType: ["object", "boolean"],
                        trackErrors: !0,
                        error: {
                            message: ({
                                params: e
                            }) => n.str `must match "${e.ifClause}" schema`,
                            params: ({
                                params: e
                            }) => n._ `{failingKeyword: ${e.ifClause}}`
                        },
                        code(e) {
                            const {
                                gen: t,
                                parentSchema: r,
                                it: i
                            } = e;
                            void 0 === r.then && void 0 === r.else && (0, o.checkStrictMode)(i, '"if" without "then" and "else" is ignored');
                            const a = s(i, "then"),
                                c = s(i, "else");
                            if (!a && !c) return;
                            const l = t.let("valid", !0),
                                u = t.name("_valid");
                            if (function() {
                                    const t = e.subschema({
                                        keyword: "if",
                                        compositeRule: !0,
                                        createErrors: !1,
                                        allErrors: !1
                                    }, u);
                                    e.mergeEvaluated(t)
                                }(), e.reset(), a && c) {
                                const r = t.let("ifClause");
                                e.setParams({
                                    ifClause: r
                                }), t.if(u, d("then", r), d("else", r))
                            } else a ? t.if(u, d("then")) : t.if((0, n.not)(u), d("else"));

                            function d(r, o) {
                                return () => {
                                    const i = e.subschema({
                                        keyword: r
                                    }, u);
                                    t.assign(l, u), e.mergeValidEvaluated(i, l), o ? t.assign(o, n._ `${r}`) : e.setParams({
                                        ifClause: r
                                    })
                                }
                            }
                            e.pass(l, (() => e.error(!0)))
                        }
                    };

                function s(e, t) {
                    const r = e.schema[t];
                    return void 0 !== r && !(0, o.alwaysValidSchema)(e, r)
                }
                t.default = i
            },
            8200: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(4783),
                    o = r(2924),
                    i = r(4665),
                    s = r(1119),
                    a = r(9864),
                    c = r(7772),
                    l = r(3708),
                    u = r(9351),
                    d = r(6239),
                    p = r(2296),
                    h = r(5697),
                    f = r(19),
                    m = r(4200),
                    g = r(1125),
                    _ = r(9434),
                    y = r(6552);
                t.default = function(e = !1) {
                    const t = [h.default, f.default, m.default, g.default, _.default, y.default, l.default, u.default, c.default, d.default, p.default];
                    return e ? t.push(o.default, s.default) : t.push(n.default, i.default), t.push(a.default), t
                }
            },
            4665: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.validateTuple = void 0;
                const n = r(3487),
                    o = r(6776),
                    i = r(412),
                    s = {
                        keyword: "items",
                        type: "array",
                        schemaType: ["object", "array", "boolean"],
                        before: "uniqueItems",
                        code(e) {
                            const {
                                schema: t,
                                it: r
                            } = e;
                            if (Array.isArray(t)) return a(e, "additionalItems", t);
                            r.items = !0, (0, o.alwaysValidSchema)(r, t) || e.ok((0, i.validateArray)(e))
                        }
                    };

                function a(e, t, r = e.schema) {
                    const {
                        gen: i,
                        parentSchema: s,
                        data: a,
                        keyword: c,
                        it: l
                    } = e;
                    ! function(e) {
                        const {
                            opts: n,
                            errSchemaPath: i
                        } = l, s = r.length, a = s === e.minItems && (s === e.maxItems || !1 === e[t]);
                        if (n.strictTuples && !a) {
                            const e = `"${c}" is ${s}-tuple, but minItems or maxItems/${t} are not specified or different at path "${i}"`;
                            (0, o.checkStrictMode)(l, e, n.strictTuples)
                        }
                    }(s), l.opts.unevaluated && r.length && !0 !== l.items && (l.items = o.mergeEvaluated.items(i, r.length, l.items));
                    const u = i.name("valid"),
                        d = i.const("len", n._ `${a}.length`);
                    r.forEach(((t, r) => {
                        (0, o.alwaysValidSchema)(l, t) || (i.if(n._ `${d} > ${r}`, (() => e.subschema({
                            keyword: c,
                            schemaProp: r,
                            dataProp: r
                        }, u))), e.ok(u))
                    }))
                }
                t.validateTuple = a, t.default = s
            },
            1119: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = r(6776),
                    i = r(412),
                    s = r(4783),
                    a = {
                        keyword: "items",
                        type: "array",
                        schemaType: ["object", "boolean"],
                        before: "uniqueItems",
                        error: {
                            message: ({
                                params: {
                                    len: e
                                }
                            }) => n.str `must NOT have more than ${e} items`,
                            params: ({
                                params: {
                                    len: e
                                }
                            }) => n._ `{limit: ${e}}`
                        },
                        code(e) {
                            const {
                                schema: t,
                                parentSchema: r,
                                it: n
                            } = e, {
                                prefixItems: a
                            } = r;
                            n.items = !0, (0, o.alwaysValidSchema)(n, t) || (a ? (0, s.validateAdditionalItems)(e, a) : e.ok((0, i.validateArray)(e)))
                        }
                    };
                t.default = a
            },
            5697: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(6776),
                    o = {
                        keyword: "not",
                        schemaType: ["object", "boolean"],
                        trackErrors: !0,
                        code(e) {
                            const {
                                gen: t,
                                schema: r,
                                it: o
                            } = e;
                            if ((0, n.alwaysValidSchema)(o, r)) return void e.fail();
                            const i = t.name("valid");
                            e.subschema({
                                keyword: "not",
                                compositeRule: !0,
                                createErrors: !1,
                                allErrors: !1
                            }, i), e.failResult(i, (() => e.reset()), (() => e.error()))
                        },
                        error: {
                            message: "must NOT be valid"
                        }
                    };
                t.default = o
            },
            4200: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = r(6776),
                    i = {
                        keyword: "oneOf",
                        schemaType: "array",
                        trackErrors: !0,
                        error: {
                            message: "must match exactly one schema in oneOf",
                            params: ({
                                params: e
                            }) => n._ `{passingSchemas: ${e.passing}}`
                        },
                        code(e) {
                            const {
                                gen: t,
                                schema: r,
                                parentSchema: i,
                                it: s
                            } = e;
                            if (!Array.isArray(r)) throw new Error("ajv implementation error");
                            if (s.opts.discriminator && i.discriminator) return;
                            const a = r,
                                c = t.let("valid", !1),
                                l = t.let("passing", null),
                                u = t.name("_valid");
                            e.setParams({
                                passing: l
                            }), t.block((function() {
                                a.forEach(((r, i) => {
                                    let a;
                                    (0, o.alwaysValidSchema)(s, r) ? t.var(u, !0): a = e.subschema({
                                        keyword: "oneOf",
                                        schemaProp: i,
                                        compositeRule: !0
                                    }, u), i > 0 && t.if(n._ `${u} && ${c}`).assign(c, !1).assign(l, n._ `[${l}, ${i}]`).else(), t.if(u, (() => {
                                        t.assign(c, !0), t.assign(l, i), a && e.mergeEvaluated(a, n.Name)
                                    }))
                                }))
                            })), e.result(c, (() => e.reset()), (() => e.error(!0)))
                        }
                    };
                t.default = i
            },
            2296: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(412),
                    o = r(3487),
                    i = r(6776),
                    s = r(6776),
                    a = {
                        keyword: "patternProperties",
                        type: "object",
                        schemaType: "object",
                        code(e) {
                            const {
                                gen: t,
                                schema: r,
                                data: a,
                                parentSchema: c,
                                it: l
                            } = e, {
                                opts: u
                            } = l, d = (0, n.allSchemaProperties)(r), p = d.filter((e => (0, i.alwaysValidSchema)(l, r[e])));
                            if (0 === d.length || p.length === d.length && (!l.opts.unevaluated || !0 === l.props)) return;
                            const h = u.strictSchema && !u.allowMatchingProperties && c.properties,
                                f = t.name("valid");
                            !0 === l.props || l.props instanceof o.Name || (l.props = (0, s.evaluatedPropsToName)(t, l.props));
                            const {
                                props: m
                            } = l;

                            function g(e) {
                                for (const t in h) new RegExp(e).test(t) && (0, i.checkStrictMode)(l, `property ${t} matches pattern ${e} (use allowMatchingProperties)`)
                            }

                            function _(r) {
                                t.forIn("key", a, (i => {
                                    t.if(o._ `${(0,n.usePattern)(e,r)}.test(${i})`, (() => {
                                        const n = p.includes(r);
                                        n || e.subschema({
                                            keyword: "patternProperties",
                                            schemaProp: r,
                                            dataProp: i,
                                            dataPropType: s.Type.Str
                                        }, f), l.opts.unevaluated && !0 !== m ? t.assign(o._ `${m}[${i}]`, !0) : n || l.allErrors || t.if((0, o.not)(f), (() => t.break()))
                                    }))
                                }))
                            }! function() {
                                for (const e of d) h && g(e), l.allErrors ? _(e) : (t.var(f, !0), _(e), t.if(f))
                            }()
                        }
                    };
                t.default = a
            },
            2924: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(4665),
                    o = {
                        keyword: "prefixItems",
                        type: "array",
                        schemaType: ["array"],
                        before: "uniqueItems",
                        code: e => (0, n.validateTuple)(e, "items")
                    };
                t.default = o
            },
            6239: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(4815),
                    o = r(412),
                    i = r(6776),
                    s = r(9351),
                    a = {
                        keyword: "properties",
                        type: "object",
                        schemaType: "object",
                        code(e) {
                            const {
                                gen: t,
                                schema: r,
                                parentSchema: a,
                                data: c,
                                it: l
                            } = e;
                            "all" === l.opts.removeAdditional && void 0 === a.additionalProperties && s.default.code(new n.KeywordCxt(l, s.default, "additionalProperties"));
                            const u = (0, o.allSchemaProperties)(r);
                            for (const e of u) l.definedProperties.add(e);
                            l.opts.unevaluated && u.length && !0 !== l.props && (l.props = i.mergeEvaluated.props(t, (0, i.toHash)(u), l.props));
                            const d = u.filter((e => !(0, i.alwaysValidSchema)(l, r[e])));
                            if (0 === d.length) return;
                            const p = t.name("valid");
                            for (const r of d) h(r) ? f(r) : (t.if((0, o.propertyInData)(t, c, r, l.opts.ownProperties)), f(r), l.allErrors || t.else().var(p, !0), t.endIf()), e.it.definedProperties.add(r), e.ok(p);

                            function h(e) {
                                return l.opts.useDefaults && !l.compositeRule && void 0 !== r[e].default
                            }

                            function f(t) {
                                e.subschema({
                                    keyword: "properties",
                                    schemaProp: t,
                                    dataProp: t
                                }, p)
                            }
                        }
                    };
                t.default = a
            },
            3708: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = r(6776),
                    i = {
                        keyword: "propertyNames",
                        type: "object",
                        schemaType: ["object", "boolean"],
                        error: {
                            message: "property name must be valid",
                            params: ({
                                params: e
                            }) => n._ `{propertyName: ${e.propertyName}}`
                        },
                        code(e) {
                            const {
                                gen: t,
                                schema: r,
                                data: i,
                                it: s
                            } = e;
                            if ((0, o.alwaysValidSchema)(s, r)) return;
                            const a = t.name("valid");
                            t.forIn("key", i, (r => {
                                e.setParams({
                                    propertyName: r
                                }), e.subschema({
                                    keyword: "propertyNames",
                                    data: r,
                                    dataTypes: ["string"],
                                    propertyName: r,
                                    compositeRule: !0
                                }, a), t.if((0, n.not)(a), (() => {
                                    e.error(!0), s.allErrors || t.break()
                                }))
                            })), e.ok(a)
                        }
                    };
                t.default = i
            },
            6552: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(6776),
                    o = {
                        keyword: ["then", "else"],
                        schemaType: ["object", "boolean"],
                        code({
                            keyword: e,
                            parentSchema: t,
                            it: r
                        }) {
                            void 0 === t.if && (0, n.checkStrictMode)(r, `"${e}" without "if" is ignored`)
                        }
                    };
                t.default = o
            },
            412: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.validateUnion = t.validateArray = t.usePattern = t.callValidateCode = t.schemaProperties = t.allSchemaProperties = t.noPropertyInData = t.propertyInData = t.isOwnProperty = t.hasPropFunc = t.reportMissingProp = t.checkMissingProp = t.checkReportMissingProp = void 0;
                const n = r(3487),
                    o = r(6776),
                    i = r(2141);

                function s(e) {
                    return e.scopeValue("func", {
                        ref: Object.prototype.hasOwnProperty,
                        code: n._ `Object.prototype.hasOwnProperty`
                    })
                }

                function a(e, t, r) {
                    return n._ `${s(e)}.call(${t}, ${r})`
                }

                function c(e, t, r, o) {
                    const i = n._ `${t}${(0,n.getProperty)(r)} === undefined`;
                    return o ? (0, n.or)(i, (0, n.not)(a(e, t, r))) : i
                }

                function l(e) {
                    return e ? Object.keys(e).filter((e => "__proto__" !== e)) : []
                }
                t.checkReportMissingProp = function(e, t) {
                    const {
                        gen: r,
                        data: o,
                        it: i
                    } = e;
                    r.if(c(r, o, t, i.opts.ownProperties), (() => {
                        e.setParams({
                            missingProperty: n._ `${t}`
                        }, !0), e.error()
                    }))
                }, t.checkMissingProp = function({
                    gen: e,
                    data: t,
                    it: {
                        opts: r
                    }
                }, o, i) {
                    return (0, n.or)(...o.map((o => (0, n.and)(c(e, t, o, r.ownProperties), n._ `${i} = ${o}`))))
                }, t.reportMissingProp = function(e, t) {
                    e.setParams({
                        missingProperty: t
                    }, !0), e.error()
                }, t.hasPropFunc = s, t.isOwnProperty = a, t.propertyInData = function(e, t, r, o) {
                    const i = n._ `${t}${(0,n.getProperty)(r)} !== undefined`;
                    return o ? n._ `${i} && ${a(e,t,r)}` : i
                }, t.noPropertyInData = c, t.allSchemaProperties = l, t.schemaProperties = function(e, t) {
                    return l(t).filter((r => !(0, o.alwaysValidSchema)(e, t[r])))
                }, t.callValidateCode = function({
                    schemaCode: e,
                    data: t,
                    it: {
                        gen: r,
                        topSchemaRef: o,
                        schemaPath: s,
                        errorPath: a
                    },
                    it: c
                }, l, u, d) {
                    const p = d ? n._ `${e}, ${t}, ${o}${s}` : t,
                        h = [
                            [i.default.instancePath, (0, n.strConcat)(i.default.instancePath, a)],
                            [i.default.parentData, c.parentData],
                            [i.default.parentDataProperty, c.parentDataProperty],
                            [i.default.rootData, i.default.rootData]
                        ];
                    c.opts.dynamicRef && h.push([i.default.dynamicAnchors, i.default.dynamicAnchors]);
                    const f = n._ `${p}, ${r.object(...h)}`;
                    return u !== n.nil ? n._ `${l}.call(${u}, ${f})` : n._ `${l}(${f})`
                }, t.usePattern = function({
                    gen: e,
                    it: {
                        opts: t
                    }
                }, r) {
                    const o = t.unicodeRegExp ? "u" : "";
                    return e.scopeValue("pattern", {
                        key: r,
                        ref: new RegExp(r, o),
                        code: n._ `new RegExp(${r}, ${o})`
                    })
                }, t.validateArray = function(e) {
                    const {
                        gen: t,
                        data: r,
                        keyword: i,
                        it: s
                    } = e, a = t.name("valid");
                    if (s.allErrors) {
                        const e = t.let("valid", !0);
                        return c((() => t.assign(e, !1))), e
                    }
                    return t.var(a, !0), c((() => t.break())), a;

                    function c(s) {
                        const c = t.const("len", n._ `${r}.length`);
                        t.forRange("i", 0, c, (r => {
                            e.subschema({
                                keyword: i,
                                dataProp: r,
                                dataPropType: o.Type.Num
                            }, a), t.if((0, n.not)(a), s)
                        }))
                    }
                }, t.validateUnion = function(e) {
                    const {
                        gen: t,
                        schema: r,
                        keyword: i,
                        it: s
                    } = e;
                    if (!Array.isArray(r)) throw new Error("ajv implementation error");
                    if (r.some((e => (0, o.alwaysValidSchema)(s, e))) && !s.opts.unevaluated) return;
                    const a = t.let("valid", !1),
                        c = t.name("_valid");
                    t.block((() => r.forEach(((r, o) => {
                        const s = e.subschema({
                            keyword: i,
                            schemaProp: o,
                            compositeRule: !0
                        }, c);
                        t.assign(a, n._ `${a} || ${c}`), e.mergeValidEvaluated(s, c) || t.if((0, n.not)(a))
                    })))), e.result(a, (() => e.reset()), (() => e.error(!0)))
                }
            },
            8386: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const r = {
                    keyword: "id",
                    code() {
                        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID')
                    }
                };
                t.default = r
            },
            5684: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(8386),
                    o = r(8280),
                    i = ["$schema", "$id", "$defs", "$vocabulary", {
                        keyword: "$comment"
                    }, "definitions", n.default, o.default];
                t.default = i
            },
            8280: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.callRef = t.getValidate = void 0;
                const n = r(6646),
                    o = r(412),
                    i = r(3487),
                    s = r(2141),
                    a = r(5173),
                    c = r(6776),
                    l = {
                        keyword: "$ref",
                        schemaType: "string",
                        code(e) {
                            const {
                                gen: t,
                                schema: r,
                                it: o
                            } = e, {
                                baseId: s,
                                schemaEnv: c,
                                validateName: l,
                                opts: p,
                                self: h
                            } = o, {
                                root: f
                            } = c;
                            if (("#" === r || "#/" === r) && s === f.baseId) return function() {
                                if (c === f) return d(e, l, c, c.$async);
                                const r = t.scopeValue("root", {
                                    ref: f
                                });
                                return d(e, i._ `${r}.validate`, f, f.$async)
                            }();
                            const m = a.resolveRef.call(h, f, s, r);
                            if (void 0 === m) throw new n.default(s, r);
                            return m instanceof a.SchemaEnv ? function(t) {
                                const r = u(e, t);
                                d(e, r, t, t.$async)
                            }(m) : function(n) {
                                const o = t.scopeValue("schema", !0 === p.code.source ? {
                                        ref: n,
                                        code: (0, i.stringify)(n)
                                    } : {
                                        ref: n
                                    }),
                                    s = t.name("valid"),
                                    a = e.subschema({
                                        schema: n,
                                        dataTypes: [],
                                        schemaPath: i.nil,
                                        topSchemaRef: o,
                                        errSchemaPath: r
                                    }, s);
                                e.mergeEvaluated(a), e.ok(s)
                            }(m)
                        }
                    };

                function u(e, t) {
                    const {
                        gen: r
                    } = e;
                    return t.validate ? r.scopeValue("validate", {
                        ref: t.validate
                    }) : i._ `${r.scopeValue("wrapper",{ref:t})}.validate`
                }

                function d(e, t, r, n) {
                    const {
                        gen: a,
                        it: l
                    } = e, {
                        allErrors: u,
                        schemaEnv: d,
                        opts: p
                    } = l, h = p.passContext ? s.default.this : i.nil;

                    function f(e) {
                        const t = i._ `${e}.errors`;
                        a.assign(s.default.vErrors, i._ `${s.default.vErrors} === null ? ${t} : ${s.default.vErrors}.concat(${t})`), a.assign(s.default.errors, i._ `${s.default.vErrors}.length`)
                    }

                    function m(e) {
                        var t;
                        if (!l.opts.unevaluated) return;
                        const n = null === (t = null == r ? void 0 : r.validate) || void 0 === t ? void 0 : t.evaluated;
                        if (!0 !== l.props)
                            if (n && !n.dynamicProps) void 0 !== n.props && (l.props = c.mergeEvaluated.props(a, n.props, l.props));
                            else {
                                const t = a.var("props", i._ `${e}.evaluated.props`);
                                l.props = c.mergeEvaluated.props(a, t, l.props, i.Name)
                            }
                        if (!0 !== l.items)
                            if (n && !n.dynamicItems) void 0 !== n.items && (l.items = c.mergeEvaluated.items(a, n.items, l.items));
                            else {
                                const t = a.var("items", i._ `${e}.evaluated.items`);
                                l.items = c.mergeEvaluated.items(a, t, l.items, i.Name)
                            }
                    }
                    n ? function() {
                        if (!d.$async) throw new Error("async schema referenced by sync schema");
                        const r = a.let("valid");
                        a.try((() => {
                            a.code(i._ `await ${(0,o.callValidateCode)(e,t,h)}`), m(t), u || a.assign(r, !0)
                        }), (e => {
                            a.if(i._ `!(${e} instanceof ${l.ValidationError})`, (() => a.throw(e))), f(e), u || a.assign(r, !1)
                        })), e.ok(r)
                    }() : e.result((0, o.callValidateCode)(e, t, h), (() => m(t)), (() => f(t)))
                }
                t.getValidate = u, t.callRef = d, t.default = l
            },
            1240: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = r(9306),
                    i = {
                        keyword: "discriminator",
                        type: "object",
                        schemaType: "object",
                        error: {
                            message: ({
                                params: {
                                    discrError: e,
                                    tagName: t
                                }
                            }) => e === o.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in oneOf`,
                            params: ({
                                params: {
                                    discrError: e,
                                    tag: t,
                                    tagName: r
                                }
                            }) => n._ `{error: ${e}, tag: ${r}, tagValue: ${t}}`
                        },
                        code(e) {
                            const {
                                gen: t,
                                data: r,
                                schema: i,
                                parentSchema: s,
                                it: a
                            } = e, {
                                oneOf: c
                            } = s;
                            if (!a.opts.discriminator) throw new Error("discriminator: requires discriminator option");
                            const l = i.propertyName;
                            if ("string" != typeof l) throw new Error("discriminator: requires propertyName");
                            if (i.mapping) throw new Error("discriminator: mapping is not supported");
                            if (!c) throw new Error("discriminator: requires oneOf keyword");
                            const u = t.let("valid", !1),
                                d = t.const("tag", n._ `${r}${(0,n.getProperty)(l)}`);

                            function p(r) {
                                const o = t.name("valid"),
                                    i = e.subschema({
                                        keyword: "oneOf",
                                        schemaProp: r
                                    }, o);
                                return e.mergeEvaluated(i, n.Name), o
                            }
                            t.if(n._ `typeof ${d} == "string"`, (() => function() {
                                const r = function() {
                                    var e;
                                    const t = {},
                                        r = o(s);
                                    let n = !0;
                                    for (let t = 0; t < c.length; t++) {
                                        const s = c[t],
                                            a = null === (e = s.properties) || void 0 === e ? void 0 : e[l];
                                        if ("object" != typeof a) throw new Error(`discriminator: oneOf schemas must have "properties/${l}"`);
                                        n = n && (r || o(s)), i(a, t)
                                    }
                                    if (!n) throw new Error(`discriminator: "${l}" must be required`);
                                    return t;

                                    function o({
                                        required: e
                                    }) {
                                        return Array.isArray(e) && e.includes(l)
                                    }

                                    function i(e, t) {
                                        if (e.const) a(e.const, t);
                                        else {
                                            if (!e.enum) throw new Error(`discriminator: "properties/${l}" must have "const" or "enum"`);
                                            for (const r of e.enum) a(r, t)
                                        }
                                    }

                                    function a(e, r) {
                                        if ("string" != typeof e || e in t) throw new Error(`discriminator: "${l}" values must be unique strings`);
                                        t[e] = r
                                    }
                                }();
                                t.if(!1);
                                for (const e in r) t.elseIf(n._ `${d} === ${e}`), t.assign(u, p(r[e]));
                                t.else(), e.error(!1, {
                                    discrError: o.DiscrError.Mapping,
                                    tag: d,
                                    tagName: l
                                }), t.endIf()
                            }()), (() => e.error(!1, {
                                discrError: o.DiscrError.Tag,
                                tag: d,
                                tagName: l
                            }))), e.ok(u)
                        }
                    };
                t.default = i
            },
            9306: (e, t) => {
                "use strict";
                var r;
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.DiscrError = void 0, (r = t.DiscrError || (t.DiscrError = {})).Tag = "tag", r.Mapping = "mapping"
            },
            3924: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(5684),
                    o = r(2649),
                    i = r(8200),
                    s = r(9502),
                    a = r(6167),
                    c = [n.default, o.default, (0, i.default)(), s.default, a.metadataVocabulary, a.contentVocabulary];
                t.default = c
            },
            9651: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = {
                        keyword: "format",
                        type: ["number", "string"],
                        schemaType: "string",
                        $data: !0,
                        error: {
                            message: ({
                                schemaCode: e
                            }) => n.str `must match format "${e}"`,
                            params: ({
                                schemaCode: e
                            }) => n._ `{format: ${e}}`
                        },
                        code(e, t) {
                            const {
                                gen: r,
                                data: o,
                                $data: i,
                                schema: s,
                                schemaCode: a,
                                it: c
                            } = e, {
                                opts: l,
                                errSchemaPath: u,
                                schemaEnv: d,
                                self: p
                            } = c;
                            l.validateFormats && (i ? function() {
                                const i = r.scopeValue("formats", {
                                        ref: p.formats,
                                        code: l.code.formats
                                    }),
                                    s = r.const("fDef", n._ `${i}[${a}]`),
                                    c = r.let("fType"),
                                    u = r.let("format");
                                r.if(n._ `typeof ${s} == "object" && !(${s} instanceof RegExp)`, (() => r.assign(c, n._ `${s}.type || "string"`).assign(u, n._ `${s}.validate`)), (() => r.assign(c, n._ `"string"`).assign(u, s))), e.fail$data((0, n.or)(!1 === l.strictSchema ? n.nil : n._ `${a} && !${u}`, function() {
                                    const e = d.$async ? n._ `(${s}.async ? await ${u}(${o}) : ${u}(${o}))` : n._ `${u}(${o})`,
                                        r = n._ `(typeof ${u} == "function" ? ${e} : ${u}.test(${o}))`;
                                    return n._ `${u} && ${u} !== true && ${c} === ${t} && !${r}`
                                }()))
                            }() : function() {
                                const i = p.formats[s];
                                if (!i) return void
                                function() {
                                    if (!1 !== l.strictSchema) throw new Error(e());

                                    function e() {
                                        return `unknown format "${s}" ignored in schema at path "${u}"`
                                    }
                                    p.logger.warn(e())
                                }();
                                if (!0 === i) return;
                                const [a, c, h] = function(e) {
                                    const t = e instanceof RegExp ? (0, n.regexpCode)(e) : l.code.formats ? n._ `${l.code.formats}${(0,n.getProperty)(s)}` : void 0,
                                        o = r.scopeValue("formats", {
                                            key: s,
                                            ref: e,
                                            code: t
                                        });
                                    return "object" != typeof e || e instanceof RegExp ? ["string", e, o] : [e.type || "string", e.validate, n._ `${o}.validate`]
                                }(i);
                                a === t && e.pass(function() {
                                    if ("object" == typeof i && !(i instanceof RegExp) && i.async) {
                                        if (!d.$async) throw new Error("async format in sync schema");
                                        return n._ `await ${h}(${o})`
                                    }
                                    return "function" == typeof c ? n._ `${h}(${o})` : n._ `${h}.test(${o})`
                                }())
                            }())
                        }
                    };
                t.default = o
            },
            9502: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = [r(9651).default];
                t.default = n
            },
            6167: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.contentVocabulary = t.metadataVocabulary = void 0, t.metadataVocabulary = ["title", "description", "default", "deprecated", "readOnly", "writeOnly", "examples"], t.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"]
            },
            4693: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = r(6776),
                    i = r(3510),
                    s = {
                        keyword: "const",
                        $data: !0,
                        error: {
                            message: "must be equal to constant",
                            params: ({
                                schemaCode: e
                            }) => n._ `{allowedValue: ${e}}`
                        },
                        code(e) {
                            const {
                                gen: t,
                                data: r,
                                $data: s,
                                schemaCode: a,
                                schema: c
                            } = e;
                            s || c && "object" == typeof c ? e.fail$data(n._ `!${(0,o.useFunc)(t,i.default)}(${r}, ${a})`) : e.fail(n._ `${c} !== ${r}`)
                        }
                    };
                t.default = s
            },
            966: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = r(6776),
                    i = r(3510),
                    s = {
                        keyword: "enum",
                        schemaType: "array",
                        $data: !0,
                        error: {
                            message: "must be equal to one of the allowed values",
                            params: ({
                                schemaCode: e
                            }) => n._ `{allowedValues: ${e}}`
                        },
                        code(e) {
                            const {
                                gen: t,
                                data: r,
                                $data: s,
                                schema: a,
                                schemaCode: c,
                                it: l
                            } = e;
                            if (!s && 0 === a.length) throw new Error("enum must have non-empty array");
                            const u = a.length >= l.opts.loopEnum,
                                d = (0, o.useFunc)(t, i.default);
                            let p;
                            if (u || s) p = t.let("valid"), e.block$data(p, (function() {
                                t.assign(p, !1), t.forOf("v", c, (e => t.if(n._ `${d}(${r}, ${e})`, (() => t.assign(p, !0).break()))))
                            }));
                            else {
                                if (!Array.isArray(a)) throw new Error("ajv implementation error");
                                const e = t.const("vSchema", c);
                                p = (0, n.or)(...a.map(((t, o) => function(e, t) {
                                    const o = a[t];
                                    return "object" == typeof o && null !== o ? n._ `${d}(${r}, ${e}[${t}])` : n._ `${r} === ${o}`
                                }(e, o))))
                            }
                            e.pass(p)
                        }
                    };
                t.default = s
            },
            2649: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3983),
                    o = r(430),
                    i = r(3229),
                    s = r(4336),
                    a = r(498),
                    c = r(3301),
                    l = r(1687),
                    u = r(2958),
                    d = r(4693),
                    p = r(966),
                    h = [n.default, o.default, i.default, s.default, a.default, c.default, l.default, u.default, {
                        keyword: "type",
                        schemaType: ["string", "array"]
                    }, {
                        keyword: "nullable",
                        schemaType: "boolean"
                    }, d.default, p.default];
                t.default = h
            },
            1687: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = {
                        keyword: ["maxItems", "minItems"],
                        type: "array",
                        schemaType: "number",
                        $data: !0,
                        error: {
                            message({
                                keyword: e,
                                schemaCode: t
                            }) {
                                const r = "maxItems" === e ? "more" : "fewer";
                                return n.str `must NOT have ${r} than ${t} items`
                            },
                            params: ({
                                schemaCode: e
                            }) => n._ `{limit: ${e}}`
                        },
                        code(e) {
                            const {
                                keyword: t,
                                data: r,
                                schemaCode: o
                            } = e, i = "maxItems" === t ? n.operators.GT : n.operators.LT;
                            e.fail$data(n._ `${r}.length ${i} ${o}`)
                        }
                    };
                t.default = o
            },
            3229: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = r(6776),
                    i = r(4499),
                    s = {
                        keyword: ["maxLength", "minLength"],
                        type: "string",
                        schemaType: "number",
                        $data: !0,
                        error: {
                            message({
                                keyword: e,
                                schemaCode: t
                            }) {
                                const r = "maxLength" === e ? "more" : "fewer";
                                return n.str `must NOT have ${r} than ${t} characters`
                            },
                            params: ({
                                schemaCode: e
                            }) => n._ `{limit: ${e}}`
                        },
                        code(e) {
                            const {
                                keyword: t,
                                data: r,
                                schemaCode: s,
                                it: a
                            } = e, c = "maxLength" === t ? n.operators.GT : n.operators.LT, l = !1 === a.opts.unicode ? n._ `${r}.length` : n._ `${(0,o.useFunc)(e.gen,i.default)}(${r})`;
                            e.fail$data(n._ `${l} ${c} ${s}`)
                        }
                    };
                t.default = s
            },
            3983: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = n.operators,
                    i = {
                        maximum: {
                            okStr: "<=",
                            ok: o.LTE,
                            fail: o.GT
                        },
                        minimum: {
                            okStr: ">=",
                            ok: o.GTE,
                            fail: o.LT
                        },
                        exclusiveMaximum: {
                            okStr: "<",
                            ok: o.LT,
                            fail: o.GTE
                        },
                        exclusiveMinimum: {
                            okStr: ">",
                            ok: o.GT,
                            fail: o.LTE
                        }
                    },
                    s = {
                        message: ({
                            keyword: e,
                            schemaCode: t
                        }) => n.str `must be ${i[e].okStr} ${t}`,
                        params: ({
                            keyword: e,
                            schemaCode: t
                        }) => n._ `{comparison: ${i[e].okStr}, limit: ${t}}`
                    },
                    a = {
                        keyword: Object.keys(i),
                        type: "number",
                        schemaType: "number",
                        $data: !0,
                        error: s,
                        code(e) {
                            const {
                                keyword: t,
                                data: r,
                                schemaCode: o
                            } = e;
                            e.fail$data(n._ `${r} ${i[t].fail} ${o} || isNaN(${r})`)
                        }
                    };
                t.default = a
            },
            498: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = {
                        keyword: ["maxProperties", "minProperties"],
                        type: "object",
                        schemaType: "number",
                        $data: !0,
                        error: {
                            message({
                                keyword: e,
                                schemaCode: t
                            }) {
                                const r = "maxProperties" === e ? "more" : "fewer";
                                return n.str `must NOT have ${r} than ${t} items`
                            },
                            params: ({
                                schemaCode: e
                            }) => n._ `{limit: ${e}}`
                        },
                        code(e) {
                            const {
                                keyword: t,
                                data: r,
                                schemaCode: o
                            } = e, i = "maxProperties" === t ? n.operators.GT : n.operators.LT;
                            e.fail$data(n._ `Object.keys(${r}).length ${i} ${o}`)
                        }
                    };
                t.default = o
            },
            430: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(3487),
                    o = {
                        keyword: "multipleOf",
                        type: "number",
                        schemaType: "number",
                        $data: !0,
                        error: {
                            message: ({
                                schemaCode: e
                            }) => n.str `must be multiple of ${e}`,
                            params: ({
                                schemaCode: e
                            }) => n._ `{multipleOf: ${e}}`
                        },
                        code(e) {
                            const {
                                gen: t,
                                data: r,
                                schemaCode: o,
                                it: i
                            } = e, s = i.opts.multipleOfPrecision, a = t.let("res"), c = s ? n._ `Math.abs(Math.round(${a}) - ${a}) > 1e-${s}` : n._ `${a} !== parseInt(${a})`;
                            e.fail$data(n._ `(${o} === 0 || (${a} = ${r}/${o}, ${c}))`)
                        }
                    };
                t.default = o
            },
            4336: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(412),
                    o = r(3487),
                    i = {
                        keyword: "pattern",
                        type: "string",
                        schemaType: "string",
                        $data: !0,
                        error: {
                            message: ({
                                schemaCode: e
                            }) => o.str `must match pattern "${e}"`,
                            params: ({
                                schemaCode: e
                            }) => o._ `{pattern: ${e}}`
                        },
                        code(e) {
                            const {
                                data: t,
                                $data: r,
                                schema: i,
                                schemaCode: s,
                                it: a
                            } = e, c = a.opts.unicodeRegExp ? "u" : "", l = r ? o._ `(new RegExp(${s}, ${c}))` : (0, n.usePattern)(e, i);
                            e.fail$data(o._ `!${l}.test(${t})`)
                        }
                    };
                t.default = i
            },
            3301: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(412),
                    o = r(3487),
                    i = r(6776),
                    s = {
                        keyword: "required",
                        type: "object",
                        schemaType: "array",
                        $data: !0,
                        error: {
                            message: ({
                                params: {
                                    missingProperty: e
                                }
                            }) => o.str `must have required property '${e}'`,
                            params: ({
                                params: {
                                    missingProperty: e
                                }
                            }) => o._ `{missingProperty: ${e}}`
                        },
                        code(e) {
                            const {
                                gen: t,
                                schema: r,
                                schemaCode: s,
                                data: a,
                                $data: c,
                                it: l
                            } = e, {
                                opts: u
                            } = l;
                            if (!c && 0 === r.length) return;
                            const d = r.length >= u.loopRequired;
                            if (l.allErrors ? function() {
                                    if (d || c) e.block$data(o.nil, p);
                                    else
                                        for (const t of r)(0, n.checkReportMissingProp)(e, t)
                                }() : function() {
                                    const i = t.let("missing");
                                    if (d || c) {
                                        const r = t.let("valid", !0);
                                        e.block$data(r, (() => function(r, i) {
                                            e.setParams({
                                                missingProperty: r
                                            }), t.forOf(r, s, (() => {
                                                t.assign(i, (0, n.propertyInData)(t, a, r, u.ownProperties)), t.if((0, o.not)(i), (() => {
                                                    e.error(), t.break()
                                                }))
                                            }), o.nil)
                                        }(i, r))), e.ok(r)
                                    } else t.if((0, n.checkMissingProp)(e, r, i)), (0, n.reportMissingProp)(e, i), t.else()
                                }(), u.strictRequired) {
                                const t = e.parentSchema.properties,
                                    {
                                        definedProperties: n
                                    } = e.it;
                                for (const e of r)
                                    if (void 0 === (null == t ? void 0 : t[e]) && !n.has(e)) {
                                        const t = `required property "${e}" is not defined at "${l.schemaEnv.baseId+l.errSchemaPath}" (strictRequired)`;
                                        (0, i.checkStrictMode)(l, t, l.opts.strictRequired)
                                    }
                            }

                            function p() {
                                t.forOf("prop", s, (r => {
                                    e.setParams({
                                        missingProperty: r
                                    }), t.if((0, n.noPropertyInData)(t, a, r, u.ownProperties), (() => e.error()))
                                }))
                            }
                        }
                    };
                t.default = s
            },
            2958: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const n = r(453),
                    o = r(3487),
                    i = r(6776),
                    s = r(3510),
                    a = {
                        keyword: "uniqueItems",
                        type: "array",
                        schemaType: "boolean",
                        $data: !0,
                        error: {
                            message: ({
                                params: {
                                    i: e,
                                    j: t
                                }
                            }) => o.str `must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
                            params: ({
                                params: {
                                    i: e,
                                    j: t
                                }
                            }) => o._ `{i: ${e}, j: ${t}}`
                        },
                        code(e) {
                            const {
                                gen: t,
                                data: r,
                                $data: a,
                                schema: c,
                                parentSchema: l,
                                schemaCode: u,
                                it: d
                            } = e;
                            if (!a && !c) return;
                            const p = t.let("valid"),
                                h = l.items ? (0, n.getSchemaTypes)(l.items) : [];

                            function f(i, s) {
                                const a = t.name("item"),
                                    c = (0, n.checkDataTypes)(h, a, d.opts.strictNumbers, n.DataType.Wrong),
                                    l = t.const("indices", o._ `{}`);
                                t.for(o._ `;${i}--;`, (() => {
                                    t.let(a, o._ `${r}[${i}]`), t.if(c, o._ `continue`), h.length > 1 && t.if(o._ `typeof ${a} == "string"`, o._ `${a} += "_"`), t.if(o._ `typeof ${l}[${a}] == "number"`, (() => {
                                        t.assign(s, o._ `${l}[${a}]`), e.error(), t.assign(p, !1).break()
                                    })).code(o._ `${l}[${a}] = ${i}`)
                                }))
                            }

                            function m(n, a) {
                                const c = (0, i.useFunc)(t, s.default),
                                    l = t.name("outer");
                                t.label(l).for(o._ `;${n}--;`, (() => t.for(o._ `${a} = ${n}; ${a}--;`, (() => t.if(o._ `${c}(${r}[${n}], ${r}[${a}])`, (() => {
                                    e.error(), t.assign(p, !1).break(l)
                                }))))))
                            }
                            e.block$data(p, (function() {
                                const n = t.let("i", o._ `${r}.length`),
                                    i = t.let("j");
                                e.setParams({
                                    i: n,
                                    j: i
                                }), t.assign(p, !0), t.if(o._ `${n} > 1`, (() => (h.length > 0 && !h.some((e => "object" === e || "array" === e)) ? f : m)(n, i)))
                            }), o._ `${u} === false`), e.ok(p)
                        }
                    };
                t.default = a
            },
            6281: (e, t, r) => {
                "use strict";
                var n = r(7396),
                    o = function() {
                        function e(t) {
                            if (e.INSTANCE) throw new Error("Console logging adapter tracking should be configured from the applicationInsights object");
                            this._client = t, e.INSTANCE = this
                        }
                        return e.prototype.enable = function(e, t) {
                            n.IsInitialized && (r(4309).wp(e && t, this._client), r(5823).wp(e, this._client), r(454).wp(e, this._client))
                        }, e.prototype.isInitialized = function() {
                            return this._isInitialized
                        }, e.prototype.dispose = function() {
                            e.INSTANCE = null, this.enable(!1, !1)
                        }, e._methodNames = ["debug", "info", "log", "warn", "error"], e
                    }();
                e.exports = o
            },
            894: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(5282),
                    o = r(7396),
                    i = function() {
                        function e() {}
                        return e.getCurrentContext = function() {
                            if (!e.enabled) return null;
                            var t = e.session.get(e.CONTEXT_NAME);
                            return void 0 === t ? null : t
                        }, e.generateContextObject = function(e, t, r, n, o, i) {
                            return t = t || e, this.enabled ? {
                                operation: {
                                    name: r,
                                    id: e,
                                    parentId: t,
                                    traceparent: o,
                                    tracestate: i
                                },
                                customProperties: new s(n)
                            } : null
                        }, e.runWithContext = function(t, r) {
                            return e.enabled ? e.session.bind(r, ((n = {})[e.CONTEXT_NAME] = t, n))() : r();
                            var n
                        }, e.wrapEmitter = function(t) {
                            e.enabled && e.session.bindEmitter(t)
                        }, e.wrapCallback = function(t) {
                            return e.enabled ? e.session.bind(t) : t
                        }, e.enable = function(t) {
                            this.enabled || (this.isNodeVersionCompatible() ? (e.hasEverEnabled || (this.forceClsHooked = t, this.hasEverEnabled = !0, void 0 === this.cls && (!0 === e.forceClsHooked || void 0 === e.forceClsHooked && e.shouldUseClsHooked() ? this.cls = r(9562) : this.cls = r(3057)), e.session = this.cls.createNamespace("AI-CLS-Session"), o.registerContextPreservation((function(t) {
                                return e.session.bind(t)
                            }))), this.enabled = !0) : this.enabled = !1)
                        }, e.disable = function() {
                            this.enabled = !1
                        }, e.reset = function() {
                            e.hasEverEnabled && (e.session = null, e.session = this.cls.createNamespace("AI-CLS-Session"))
                        }, e.isNodeVersionCompatible = function() {
                            var e = process.versions.node.split(".");
                            return parseInt(e[0]) > 3 || parseInt(e[0]) > 2 && parseInt(e[1]) > 2
                        }, e.shouldUseClsHooked = function() {
                            var e = process.versions.node.split(".");
                            return parseInt(e[0]) > 8 || parseInt(e[0]) >= 8 && parseInt(e[1]) >= 2
                        }, e.canUseClsHooked = function() {
                            var e = process.versions.node.split("."),
                                t = parseInt(e[0]) > 8 || parseInt(e[0]) >= 8 && parseInt(e[1]) >= 0,
                                r = parseInt(e[0]) < 8 || parseInt(e[0]) <= 8 && parseInt(e[1]) < 2,
                                n = parseInt(e[0]) > 4 || parseInt(e[0]) >= 4 && parseInt(e[1]) >= 7;
                            return !(t && r) && n
                        }, e.enabled = !1, e.hasEverEnabled = !1, e.forceClsHooked = void 0, e.CONTEXT_NAME = "ApplicationInsights-Context", e
                    }();
                t.CorrelationContextManager = i;
                var s = function() {
                    function e(e) {
                        this.props = [], this.addHeaderData(e)
                    }
                    return e.prototype.addHeaderData = function(e) {
                        var t = e ? e.split(", ") : [];
                        this.props = t.map((function(e) {
                            var t = e.split("=");
                            return {
                                key: t[0],
                                value: t[1]
                            }
                        })).concat(this.props)
                    }, e.prototype.serializeToHeader = function() {
                        return this.props.map((function(e) {
                            return e.key + "=" + e.value
                        })).join(", ")
                    }, e.prototype.getProperty = function(e) {
                        for (var t = 0; t < this.props.length; ++t) {
                            var r = this.props[t];
                            if (r.key === e) return r.value
                        }
                    }, e.prototype.setProperty = function(t, r) {
                        if (e.bannedCharacters.test(t) || e.bannedCharacters.test(r)) n.warn("Correlation context property keys and values must not contain ',' or '='. setProperty was called with key: " + t + " and value: " + r);
                        else {
                            for (var o = 0; o < this.props.length; ++o) {
                                var i = this.props[o];
                                if (i.key === t) return void(i.value = r)
                            }
                            this.props.push({
                                key: t,
                                value: r
                            })
                        }
                    }, e.bannedCharacters = /[,=]/, e
                }()
            },
            6639: e => {
                "use strict";
                var t = function() {
                    function e(t) {
                        if (e.INSTANCE) throw new Error("Exception tracking should be configured from the applicationInsights object");
                        e.INSTANCE = this, this._client = t;
                        var r = process.versions.node.split(".");
                        e._canUseUncaughtExceptionMonitor = parseInt(r[0]) > 13 || 13 === parseInt(r[0]) && parseInt(r[1]) >= 7
                    }
                    return e.prototype.isInitialized = function() {
                        return this._isInitialized
                    }, e.prototype.enable = function(t) {
                        var r = this;
                        if (t) {
                            if (this._isInitialized = !0, !this._exceptionListenerHandle) {
                                var n = function(t, n, o) {
                                    void 0 === o && (o = new Error(e._FALLBACK_ERROR_MESSAGE)), r._client.trackException({
                                        exception: o
                                    }), r._client.flush({
                                        isAppCrashing: !0
                                    }), t && n && 1 === process.listeners(n).length && (console.error(o), process.exit(1))
                                };
                                e._canUseUncaughtExceptionMonitor ? (this._exceptionListenerHandle = n.bind(this, !1), process.on(e.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle)) : (this._exceptionListenerHandle = n.bind(this, !0, e.UNCAUGHT_EXCEPTION_HANDLER_NAME), this._rejectionListenerHandle = n.bind(this, !1), process.on(e.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle), process.on(e.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle))
                            }
                        } else this._exceptionListenerHandle && (e._canUseUncaughtExceptionMonitor ? process.removeListener(e.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle) : (process.removeListener(e.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle), process.removeListener(e.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle)), this._exceptionListenerHandle = void 0, this._rejectionListenerHandle = void 0, delete this._exceptionListenerHandle, delete this._rejectionListenerHandle)
                    }, e.prototype.dispose = function() {
                        e.INSTANCE = null, this.enable(!1), this._isInitialized = !1
                    }, e.INSTANCE = null, e.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME = "uncaughtExceptionMonitor", e.UNCAUGHT_EXCEPTION_HANDLER_NAME = "uncaughtException", e.UNHANDLED_REJECTION_HANDLER_NAME = "unhandledRejection", e._RETHROW_EXIT_MESSAGE = "Application Insights Rethrow Exception Handler", e._FALLBACK_ERROR_MESSAGE = "A promise was rejected without providing an error. Application Insights generated this error stack for you.", e._canUseUncaughtExceptionMonitor = !1, e
                }();
                e.exports = t
            },
            8723: (e, t, r) => {
                "use strict";
                var n = r(3685),
                    o = r(5687),
                    i = r(5282),
                    s = r(5740),
                    a = r(9036),
                    c = r(8339),
                    l = r(894),
                    u = r(9962),
                    d = r(8090),
                    p = r(7396),
                    h = function() {
                        function e(t) {
                            if (e.INSTANCE) throw new Error("Client request tracking should be configured from the applicationInsights object");
                            e.INSTANCE = this, this._client = t
                        }
                        return e.prototype.enable = function(e) {
                            this._isEnabled = e, this._isEnabled && !this._isInitialized && this._initialize(), p.IsInitialized && (r(7886).wp(e, this._client), r(4777).wp(e, this._client), r(5071).wp(e, this._client), r(1227).wp(e, this._client))
                        }, e.prototype.isInitialized = function() {
                            return this._isInitialized
                        }, e.prototype._initialize = function() {
                            var t = this;
                            this._isInitialized = !0, n.get;
                            var r = n.request,
                                i = o.request,
                                s = function(r, n) {
                                    var o = !n[e.disableCollectionRequestOption] && !r[e.alreadyAutoCollectedFlag];
                                    r[e.alreadyAutoCollectedFlag] = !0, r && n && o && (l.CorrelationContextManager.wrapEmitter(r), e.trackRequest(t._client, {
                                        options: n,
                                        request: r
                                    }))
                                };
                            n.request = function(e) {
                                for (var t = [], o = 1; o < arguments.length; o++) t[o - 1] = arguments[o];
                                var i = r.call.apply(r, [n, e].concat(t));
                                return s(i, e), i
                            }, o.request = function(e) {
                                for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
                                var n = i.call.apply(i, [o, e].concat(t));
                                return s(n, e), n
                            }, n.get = function(e) {
                                for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
                                var o, i = (o = n.request).call.apply(o, [n, e].concat(t));
                                return i.end(), i
                            }, o.get = function(e) {
                                for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
                                var n, i = (n = o.request).call.apply(n, [o, e].concat(t));
                                return i.end(), i
                            }
                        }, e.trackRequest = function(t, r) {
                            if (r.options && r.request && t) {
                                var n, o, p = new c(r.options, r.request),
                                    h = l.CorrelationContextManager.getCurrentContext();
                                if (h && h.operation && h.operation.traceparent && d.isValidTraceId(h.operation.traceparent.traceId) ? (h.operation.traceparent.updateSpanId(), n = h.operation.traceparent.getBackCompatRequestId()) : u.w3cEnabled ? (o = (m = new d).toString(), n = m.getBackCompatRequestId()) : n = h && h.operation && h.operation.parentId + e.requestNumber++ + ".", s.canIncludeCorrelationHeader(t, p.getUrl()) && r.request.getHeader && r.request.setHeader && t.config && t.config.correlationId) {
                                    var f = r.request.getHeader(a.requestContextHeader);
                                    try {
                                        s.safeIncludeCorrelationHeader(t, r.request, f)
                                    } catch (e) {
                                        i.warn("Request-Context header could not be set. Correlation of requests may be lost", e)
                                    }
                                    if (h && h.operation) try {
                                        if (r.request.setHeader(a.requestIdHeader, n), r.request.setHeader(a.parentIdHeader, h.operation.id), r.request.setHeader(a.rootIdHeader, n), o || h.operation.traceparent) r.request.setHeader(a.traceparentHeader, o || h.operation.traceparent.toString());
                                        else if (u.w3cEnabled) {
                                            var m = (new d).toString();
                                            r.request.setHeader(a.traceparentHeader, m)
                                        }
                                        if (h.operation.tracestate) {
                                            var g = h.operation.tracestate.toString();
                                            g && r.request.setHeader(a.traceStateHeader, g)
                                        }
                                        var _ = h.customProperties.serializeToHeader();
                                        _ && r.request.setHeader(a.correlationContextHeader, _)
                                    } catch (e) {
                                        i.warn("Correlation headers could not be set. Correlation of requests may be lost.", e)
                                    }
                                }
                                r.request.on && (r.request.on("response", (function(e) {
                                    p.onResponse(e);
                                    var o = p.getDependencyTelemetry(r, n);
                                    o.contextObjects = o.contextObjects || {}, o.contextObjects["http.RequestOptions"] = r.options, o.contextObjects["http.ClientRequest"] = r.request, o.contextObjects["http.ClientResponse"] = e, t.trackDependency(o)
                                })), r.request.on("error", (function(e) {
                                    p.onError(e);
                                    var o = p.getDependencyTelemetry(r, n);
                                    o.contextObjects = o.contextObjects || {}, o.contextObjects["http.RequestOptions"] = r.options, o.contextObjects["http.ClientRequest"] = r.request, o.contextObjects.Error = e, t.trackDependency(o)
                                })))
                            } else i.info("AutoCollectHttpDependencies.trackRequest was called with invalid parameters: ", !r.options, !r.request, !t)
                        }, e.prototype.dispose = function() {
                            e.INSTANCE = null, this.enable(!1), this._isInitialized = !1
                        }, e.disableCollectionRequestOption = "disableAppInsightsAutoCollection", e.requestNumber = 1, e.alreadyAutoCollectedFlag = "_appInsightsAutoCollected", e
                    }();
                e.exports = h
            },
            8339: function(e, t, r) {
                "use strict";
                var n, o = this && this.__extends || (n = Object.setPrototypeOf || {
                            __proto__: []
                        }
                        instanceof Array && function(e, t) {
                            e.__proto__ = t
                        } || function(e, t) {
                            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                        },
                        function(e, t) {
                            function r() {
                                this.constructor = e
                            }
                            n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                        }),
                    i = r(7310),
                    s = r(5290),
                    a = r(5740),
                    c = r(9036),
                    l = r(3054),
                    u = r(9962),
                    d = function(e) {
                        function t(r, n) {
                            var o = e.call(this) || this;
                            return n && n.method && r && (o.method = n.method, o.url = t._getUrlFromRequestOptions(r, n), o.startTime = +new Date), o
                        }
                        return o(t, e), t.prototype.onError = function(e) {
                            this._setStatus(void 0, e)
                        }, t.prototype.onResponse = function(e) {
                            this._setStatus(e.statusCode, void 0), this.correlationId = a.getCorrelationContextTarget(e, c.requestContextTargetKey)
                        }, t.prototype.getDependencyTelemetry = function(e, t) {
                            var r = i.parse(this.url);
                            r.search = void 0, r.hash = void 0;
                            var n = this.method.toUpperCase() + " " + r.pathname,
                                o = s.RemoteDependencyDataConstants.TYPE_HTTP,
                                a = r.hostname;
                            this.correlationId ? (o = s.RemoteDependencyDataConstants.TYPE_AI, this.correlationId !== u.correlationIdPrefix && (a = r.hostname + " | " + this.correlationId)) : o = s.RemoteDependencyDataConstants.TYPE_HTTP, r.port && (a += ":" + r.port);
                            var c = {
                                id: t,
                                name: n,
                                data: this.url,
                                duration: this.duration,
                                success: this._isSuccess(),
                                resultCode: this.statusCode ? this.statusCode.toString() : null,
                                properties: this.properties || {},
                                dependencyTypeName: o,
                                target: a
                            };
                            if (e) {
                                for (var l in e) c[l] || (c[l] = e[l]);
                                if (e.properties)
                                    for (var l in e.properties) c.properties[l] = e.properties[l]
                            }
                            return c
                        }, t._getUrlFromRequestOptions = function(e, t) {
                            if ("string" == typeof e) e = i.parse(e);
                            else {
                                var r = e;
                                e = {}, r && Object.keys(r).forEach((function(t) {
                                    e[t] = r[t]
                                }))
                            }
                            if (e.path) {
                                var n = i.parse(e.path);
                                e.pathname = n.pathname, e.search = n.search
                            }
                            return e.host && e.port && !i.parse("http://" + e.host).port && e.port && (e.hostname = e.host, delete e.host), e.protocol = e.protocol || t.agent && t.agent.protocol || void 0, e.hostname = e.hostname || "localhost", i.format(e)
                        }, t
                    }(l);
                e.exports = d
            },
            6694: function(e, t, r) {
                "use strict";
                var n, o = this && this.__extends || (n = Object.setPrototypeOf || {
                            __proto__: []
                        }
                        instanceof Array && function(e, t) {
                            e.__proto__ = t
                        } || function(e, t) {
                            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                        },
                        function(e, t) {
                            function r() {
                                this.constructor = e
                            }
                            n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                        }),
                    i = r(7310),
                    s = r(5290),
                    a = r(5740),
                    c = r(9036),
                    l = r(3054),
                    u = r(9962),
                    d = r(1974),
                    p = r(8090),
                    h = function(e) {
                        function t(t, r) {
                            var n = e.call(this) || this;
                            return t && (n.method = t.method, n.url = n._getAbsoluteUrl(t), n.startTime = +new Date, n.socketRemoteAddress = t.socket && t.socket.remoteAddress, n.parseHeaders(t, r), t.connection && (n.connectionRemoteAddress = t.connection.remoteAddress, n.legacySocketRemoteAddress = t.connection.socket && t.connection.socket.remoteAddress)), n
                        }
                        return o(t, e), t.prototype.onError = function(e, t) {
                            this._setStatus(void 0, e), t && (this.duration = t)
                        }, t.prototype.onResponse = function(e, t) {
                            this._setStatus(e.statusCode, void 0), t && (this.duration = t)
                        }, t.prototype.getRequestTelemetry = function(e) {
                            var t = {
                                id: this.requestId,
                                name: this.method + " " + i.parse(this.url).pathname,
                                url: this.url,
                                source: this.sourceCorrelationId,
                                duration: this.duration,
                                resultCode: this.statusCode ? this.statusCode.toString() : null,
                                success: this._isSuccess(),
                                properties: this.properties
                            };
                            if (e) {
                                for (var r in e) t[r] || (t[r] = e[r]);
                                if (e.properties)
                                    for (var r in e.properties) t.properties[r] = e.properties[r]
                            }
                            return t
                        }, t.prototype.getRequestTags = function(e) {
                            var r = {};
                            for (var n in e) r[n] = e[n];
                            return r[t.keys.locationIp] = e[t.keys.locationIp] || this._getIp(), r[t.keys.sessionId] = e[t.keys.sessionId] || this._getId("ai_session"), r[t.keys.userId] = e[t.keys.userId] || this._getId("ai_user"), r[t.keys.userAuthUserId] = e[t.keys.userAuthUserId] || this._getId("ai_authUser"), r[t.keys.operationName] = this.getOperationName(e), r[t.keys.operationParentId] = this.getOperationParentId(e), r[t.keys.operationId] = this.getOperationId(e), r
                        }, t.prototype.getOperationId = function(e) {
                            return e[t.keys.operationId] || this.operationId
                        }, t.prototype.getOperationParentId = function(e) {
                            return e[t.keys.operationParentId] || this.parentId || this.getOperationId(e)
                        }, t.prototype.getOperationName = function(e) {
                            return e[t.keys.operationName] || this.method + " " + i.parse(this.url).pathname
                        }, t.prototype.getRequestId = function() {
                            return this.requestId
                        }, t.prototype.getCorrelationContextHeader = function() {
                            return this.correlationContextHeader
                        }, t.prototype.getTraceparent = function() {
                            return this.traceparent
                        }, t.prototype.getTracestate = function() {
                            return this.tracestate
                        }, t.prototype.getLegacyRootId = function() {
                            return this.legacyRootId
                        }, t.prototype._getAbsoluteUrl = function(e) {
                            if (!e.headers) return e.url;
                            var t = e.connection ? e.connection.encrypted : null,
                                r = i.parse(e.url),
                                n = r.pathname,
                                o = r.search;
                            return i.format({
                                protocol: t ? "https" : "http",
                                host: e.headers.host,
                                pathname: n,
                                search: o
                            })
                        }, t.prototype._getIp = function() {
                            var e = /[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/,
                                t = function(t) {
                                    var r = e.exec(t);
                                    if (r) return r[0]
                                },
                                r = t(this.rawHeaders["x-forwarded-for"]) || t(this.rawHeaders["x-client-ip"]) || t(this.rawHeaders["x-real-ip"]) || t(this.connectionRemoteAddress) || t(this.socketRemoteAddress) || t(this.legacySocketRemoteAddress);
                            return !r && this.connectionRemoteAddress && this.connectionRemoteAddress.substr && "::" === this.connectionRemoteAddress.substr(0, 2) && (r = "127.0.0.1"), r
                        }, t.prototype._getId = function(e) {
                            var r = this.rawHeaders && this.rawHeaders.cookie && "string" == typeof this.rawHeaders.cookie && this.rawHeaders.cookie || "";
                            return t.parseId(a.getCookie(e, r))
                        }, t.prototype.setBackCompatFromThisTraceContext = function() {
                            this.operationId = this.traceparent.traceId, this.traceparent.legacyRootId && (this.legacyRootId = this.traceparent.legacyRootId), this.parentId = this.traceparent.parentId, this.traceparent.updateSpanId(), this.requestId = this.traceparent.getBackCompatRequestId()
                        }, t.prototype.parseHeaders = function(e, t) {
                            if (this.rawHeaders = e.headers || e.rawHeaders, this.userAgent = e.headers && e.headers["user-agent"], this.sourceCorrelationId = a.getCorrelationContextTarget(e, c.requestContextSourceKey), e.headers) {
                                var r = e.headers[c.traceStateHeader],
                                    n = e.headers[c.traceparentHeader],
                                    o = e.headers[c.requestIdHeader],
                                    i = e.headers[c.parentIdHeader],
                                    s = e.headers[c.rootIdHeader];
                                this.correlationContextHeader = e.headers[c.correlationContextHeader], u.w3cEnabled && (n || r) ? (this.traceparent = new p(n), this.tracestate = n && r && new d(r), this.setBackCompatFromThisTraceContext()) : o ? u.w3cEnabled ? (this.traceparent = new p(null, o), this.setBackCompatFromThisTraceContext()) : (this.parentId = o, this.requestId = u.generateRequestId(this.parentId), this.operationId = u.getRootId(this.requestId)) : u.w3cEnabled ? (this.traceparent = new p, this.traceparent.parentId = i, this.traceparent.legacyRootId = s || i, this.setBackCompatFromThisTraceContext()) : (this.parentId = i, this.requestId = u.generateRequestId(s || this.parentId), this.correlationContextHeader = null, this.operationId = u.getRootId(this.requestId)), t && (this.requestId = t, this.operationId = u.getRootId(this.requestId))
                            }
                        }, t.parseId = function(e) {
                            var t = e.split("|");
                            return t.length > 0 ? t[0] : ""
                        }, t.keys = new s.ContextTagKeys, t
                    }(l);
                e.exports = h
            },
            731: (e, t, r) => {
                "use strict";
                var n = r(3685),
                    o = r(5687),
                    i = r(5282),
                    s = r(5740),
                    a = r(9036),
                    c = r(6694),
                    l = r(894),
                    u = r(4350),
                    d = function() {
                        function e(t) {
                            if (e.INSTANCE) throw new Error("Server request tracking should be configured from the applicationInsights object");
                            e.INSTANCE = this, this._client = t
                        }
                        return e.prototype.enable = function(e) {
                            this._isEnabled = e, (this._isAutoCorrelating || this._isEnabled || u.isEnabled()) && !this._isInitialized && (this.useAutoCorrelation(this._isAutoCorrelating), this._initialize())
                        }, e.prototype.useAutoCorrelation = function(e, t) {
                            e && !this._isAutoCorrelating ? l.CorrelationContextManager.enable(t) : !e && this._isAutoCorrelating && l.CorrelationContextManager.disable(), this._isAutoCorrelating = e
                        }, e.prototype.isInitialized = function() {
                            return this._isInitialized
                        }, e.prototype.isAutoCorrelating = function() {
                            return this._isAutoCorrelating
                        }, e.prototype._generateCorrelationContext = function(e) {
                            if (this._isAutoCorrelating) return l.CorrelationContextManager.generateContextObject(e.getOperationId(this._client.context.tags), e.getRequestId(), e.getOperationName(this._client.context.tags), e.getCorrelationContextHeader(), e.getTraceparent(), e.getTracestate())
                        }, e.prototype._initialize = function() {
                            var t = this;
                            this._isInitialized = !0;
                            var r = function(r) {
                                    if (r) {
                                        if ("function" != typeof r) throw new Error("onRequest handler must be a function");
                                        return function(n, o) {
                                            l.CorrelationContextManager.wrapEmitter(n), l.CorrelationContextManager.wrapEmitter(o);
                                            var i = n && !n[e.alreadyAutoCollectedFlag];
                                            if (n && i) {
                                                var s = new c(n),
                                                    a = t._generateCorrelationContext(s);
                                                l.CorrelationContextManager.runWithContext(a, (function() {
                                                    t._isEnabled && (n[e.alreadyAutoCollectedFlag] = !0, e.trackRequest(t._client, {
                                                        request: n,
                                                        response: o
                                                    }, s)), "function" == typeof r && r(n, o)
                                                }))
                                            } else "function" == typeof r && r(n, o)
                                        }
                                    }
                                },
                                i = function(e) {
                                    var t = e.addListener.bind(e);
                                    e.addListener = function(e, n) {
                                        switch (e) {
                                            case "request":
                                            case "checkContinue":
                                                return t(e, r(n));
                                            default:
                                                return t(e, n)
                                        }
                                    }, e.on = e.addListener
                                },
                                s = n.createServer;
                            n.createServer = function(e) {
                                var t = s(r(e));
                                return i(t), t
                            };
                            var a = o.createServer;
                            o.createServer = function(e, t) {
                                var n = a(e, r(t));
                                return i(n), n
                            }
                        }, e.trackRequestSync = function(t, r) {
                            if (r.request && r.response && t) {
                                e.addResponseCorrelationIdHeader(t, r.response);
                                var n = l.CorrelationContextManager.getCurrentContext(),
                                    o = new c(r.request, n && n.operation.parentId);
                                n && (n.operation.id = o.getOperationId(t.context.tags) || n.operation.id, n.operation.name = o.getOperationName(t.context.tags) || n.operation.name, n.operation.parentId = o.getRequestId() || n.operation.parentId, n.customProperties.addHeaderData(o.getCorrelationContextHeader())), e.endRequest(t, o, r, r.duration, r.error)
                            } else i.info("AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: ", !r.request, !r.response, !t)
                        }, e.trackRequest = function(t, r, n) {
                            if (r.request && r.response && t) {
                                var o = l.CorrelationContextManager.getCurrentContext(),
                                    a = n || new c(r.request, o && o.operation.parentId);
                                s.canIncludeCorrelationHeader(t, a.getUrl()) && e.addResponseCorrelationIdHeader(t, r.response), o && !n && (o.operation.id = a.getOperationId(t.context.tags) || o.operation.id, o.operation.name = a.getOperationName(t.context.tags) || o.operation.name, o.operation.parentId = a.getOperationParentId(t.context.tags) || o.operation.parentId, o.customProperties.addHeaderData(a.getCorrelationContextHeader())), r.response.once && r.response.once("finish", (function() {
                                    e.endRequest(t, a, r, null, null)
                                })), r.request.on && r.request.on("error", (function(n) {
                                    e.endRequest(t, a, r, null, n)
                                }))
                            } else i.info("AutoCollectHttpRequests.trackRequest was called with invalid parameters: ", !r.request, !r.response, !t)
                        }, e.addResponseCorrelationIdHeader = function(e, t) {
                            if (e.config && e.config.correlationId && t.getHeader && t.setHeader && !t.headersSent) {
                                var r = t.getHeader(a.requestContextHeader);
                                s.safeIncludeCorrelationHeader(e, t, r)
                            }
                        }, e.endRequest = function(e, t, r, n, o) {
                            o ? t.onError(o, n) : t.onResponse(r.response, n);
                            var i = t.getRequestTelemetry(r);
                            if (i.tagOverrides = t.getRequestTags(e.context.tags), r.tagOverrides)
                                for (var s in r.tagOverrides) i.tagOverrides[s] = r.tagOverrides[s];
                            var a = t.getLegacyRootId();
                            a && (i.properties.ai_legacyRootId = a), i.contextObjects = i.contextObjects || {}, i.contextObjects["http.ServerRequest"] = r.request, i.contextObjects["http.ServerResponse"] = r.response, e.trackRequest(i)
                        }, e.prototype.dispose = function() {
                            e.INSTANCE = null, this.enable(!1), this._isInitialized = !1, l.CorrelationContextManager.disable(), this._isAutoCorrelating = !1
                        }, e.alreadyAutoCollectedFlag = "_appInsightsAutoCollected", e
                    }();
                e.exports = d
            },
            1629: function(e, t, r) {
                "use strict";
                var n = this && this.__assign || Object.assign || function(e) {
                    for (var t, r = 1, n = arguments.length; r < n; r++)
                        for (var o in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
                    return e
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var o = r(9253),
                    i = r(4470),
                    s = r(5282),
                    a = function() {
                        function e(t) {
                            this._disabledMetrics = {}, e.INSTANCE && e.INSTANCE.dispose(), e.INSTANCE = this, this._client = t
                        }
                        return e.isNodeVersionCompatible = function() {
                            var e = process.versions.node.split(".");
                            return parseInt(e[0]) >= 6
                        }, e.prototype.enable = function(t, n, o) {
                            var i = this;
                            if (void 0 === n && (n = {}), void 0 === o && (o = 6e4), e.isNodeVersionCompatible()) {
                                if (null == e._metricsAvailable && t && !this._isInitialized) try {
                                    var a = r(9166);
                                    e._emitter = new a, e._metricsAvailable = !0, s.info("Native metrics module successfully loaded!")
                                } catch (t) {
                                    return void(e._metricsAvailable = !1)
                                }
                                this._isEnabled = t, this._disabledMetrics = n, this._isEnabled && !this._isInitialized && (this._isInitialized = !0), this._isEnabled && e._emitter ? (e._emitter.enable(!0, o), this._handle = setInterval((function() {
                                    return i._trackNativeMetrics()
                                }), o), this._handle.unref()) : e._emitter && (e._emitter.enable(!1), this._handle && (clearInterval(this._handle), this._handle = void 0))
                            }
                        }, e.prototype.dispose = function() {
                            this.enable(!1)
                        }, e.parseEnabled = function(e) {
                            var t = process.env[o.ENV_nativeMetricsDisableAll],
                                r = process.env[o.ENV_nativeMetricsDisablers];
                            if (t) return {
                                isEnabled: !1,
                                disabledMetrics: {}
                            };
                            if (r) {
                                var i = r.split(","),
                                    s = {};
                                if (i.length > 0)
                                    for (var a = 0, c = i; a < c.length; a++) s[c[a]] = !0;
                                return "object" == typeof e ? {
                                    isEnabled: !0,
                                    disabledMetrics: n({}, e, s)
                                } : {
                                    isEnabled: e,
                                    disabledMetrics: s
                                }
                            }
                            return "boolean" == typeof e ? {
                                isEnabled: e,
                                disabledMetrics: {}
                            } : {
                                isEnabled: !0,
                                disabledMetrics: e
                            }
                        }, e.prototype._trackNativeMetrics = function() {
                            var e = !0;
                            "object" != typeof this._isEnabled && (e = this._isEnabled), e && (this._trackGarbageCollection(), this._trackEventLoop(), this._trackHeapUsage())
                        }, e.prototype._trackGarbageCollection = function() {
                            if (!this._disabledMetrics.gc) {
                                var t, r = e._emitter.getGCData();
                                for (var n in r) {
                                    var o = r[n].metrics,
                                        s = n + " Garbage Collection Duration",
                                        a = Math.sqrt(o.sumSquares / o.count - Math.pow(o.total / o.count, 2)) || 0;
                                    this._client.trackMetric({
                                        name: s,
                                        value: o.total,
                                        count: o.count,
                                        max: o.max,
                                        min: o.min,
                                        stdDev: a,
                                        tagOverrides: (t = {}, t[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + i.sdkVersion, t)
                                    })
                                }
                            }
                        }, e.prototype._trackEventLoop = function() {
                            if (!this._disabledMetrics.loop) {
                                var t = e._emitter.getLoopData().loopUsage;
                                if (0 != t.count) {
                                    var r, n = Math.sqrt(t.sumSquares / t.count - Math.pow(t.total / t.count, 2)) || 0;
                                    this._client.trackMetric({
                                        name: "Event Loop CPU Time",
                                        value: t.total,
                                        count: t.count,
                                        min: t.min,
                                        max: t.max,
                                        stdDev: n,
                                        tagOverrides: (r = {}, r[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + i.sdkVersion, r)
                                    })
                                }
                            }
                        }, e.prototype._trackHeapUsage = function() {
                            if (!this._disabledMetrics.heap) {
                                var e, t, r, n = process.memoryUsage(),
                                    o = n.heapUsed,
                                    s = n.heapTotal,
                                    a = n.rss;
                                this._client.trackMetric({
                                    name: "Memory Usage (Heap)",
                                    value: o,
                                    count: 1,
                                    tagOverrides: (e = {}, e[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + i.sdkVersion, e)
                                }), this._client.trackMetric({
                                    name: "Memory Total (Heap)",
                                    value: s,
                                    count: 1,
                                    tagOverrides: (t = {}, t[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + i.sdkVersion, t)
                                }), this._client.trackMetric({
                                    name: "Memory Usage (Non-Heap)",
                                    value: a - s,
                                    count: 1,
                                    tagOverrides: (r = {}, r[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + i.sdkVersion, r)
                                })
                            }
                        }, e
                    }();
                t.AutoCollectNativePerformance = a
            },
            4350: (e, t, r) => {
                "use strict";
                var n = r(2037),
                    o = r(3580),
                    i = function() {
                        function e(t, r, n) {
                            void 0 === r && (r = 6e4), void 0 === n && (n = !1), this._lastIntervalRequestExecutionTime = 0, this._lastIntervalDependencyExecutionTime = 0, e.INSTANCE || (e.INSTANCE = this), this._isInitialized = !1, this._client = t, this._collectionInterval = r, this._enableLiveMetricsCounters = n
                        }
                        return e.prototype.enable = function(t, r) {
                            var o = this;
                            this._isEnabled = t, this._isEnabled && !this._isInitialized && (this._isInitialized = !0), t ? this._handle || (this._lastCpus = n.cpus(), this._lastRequests = {
                                totalRequestCount: e._totalRequestCount,
                                totalFailedRequestCount: e._totalFailedRequestCount,
                                time: +new Date
                            }, this._lastDependencies = {
                                totalDependencyCount: e._totalDependencyCount,
                                totalFailedDependencyCount: e._totalFailedDependencyCount,
                                time: +new Date
                            }, this._lastExceptions = {
                                totalExceptionCount: e._totalExceptionCount,
                                time: +new Date
                            }, "function" == typeof process.cpuUsage && (this._lastAppCpuUsage = process.cpuUsage()), this._lastHrtime = process.hrtime(), this._collectionInterval = r || this._collectionInterval, this._handle = setInterval((function() {
                                return o.trackPerformance()
                            }), this._collectionInterval), this._handle.unref()) : this._handle && (clearInterval(this._handle), this._handle = void 0)
                        }, e.countRequest = function(t, r) {
                            var n;
                            if (e.isEnabled()) {
                                if ("string" == typeof t) n = +new Date("1970-01-01T" + t + "Z");
                                else {
                                    if ("number" != typeof t) return;
                                    n = t
                                }
                                e._intervalRequestExecutionTime += n, !1 === r && e._totalFailedRequestCount++, e._totalRequestCount++
                            }
                        }, e.countException = function() {
                            e._totalExceptionCount++
                        }, e.countDependency = function(t, r) {
                            var n;
                            if (e.isEnabled()) {
                                if ("string" == typeof t) n = +new Date("1970-01-01T" + t + "Z");
                                else {
                                    if ("number" != typeof t) return;
                                    n = t
                                }
                                e._intervalDependencyExecutionTime += n, !1 === r && e._totalFailedDependencyCount++, e._totalDependencyCount++
                            }
                        }, e.prototype.isInitialized = function() {
                            return this._isInitialized
                        }, e.isEnabled = function() {
                            return e.INSTANCE && e.INSTANCE._isEnabled
                        }, e.prototype.trackPerformance = function() {
                            this._trackCpu(), this._trackMemory(), this._trackNetwork(), this._trackDependencyRate(), this._trackExceptionRate()
                        }, e.prototype._trackCpu = function() {
                            var e = n.cpus();
                            if (e && e.length && this._lastCpus && e.length === this._lastCpus.length) {
                                for (var t = 0, r = 0, i = 0, s = 0, a = 0, c = 0; e && c < e.length; c++) {
                                    var l = e[c],
                                        u = this._lastCpus[c],
                                        d = (l.model, l.speed, l.times),
                                        p = u.times;
                                    t += d.user - p.user || 0, r += d.sys - p.sys || 0, i += d.nice - p.nice || 0, s += d.idle - p.idle || 0, a += d.irq - p.irq || 0
                                }
                                var h = void 0;
                                if ("function" == typeof process.cpuUsage) {
                                    var f = process.cpuUsage(),
                                        m = process.hrtime(),
                                        g = f.user - this._lastAppCpuUsage.user + (f.system - this._lastAppCpuUsage.system) || 0;
                                    void 0 !== this._lastHrtime && 2 === this._lastHrtime.length && (h = 100 * g / ((1e6 * (m[0] - this._lastHrtime[0]) + (m[1] - this._lastHrtime[1]) / 1e3 || 0) * e.length)), this._lastAppCpuUsage = f, this._lastHrtime = m
                                }
                                var _ = t + r + i + s + a || 1;
                                this._client.trackMetric({
                                    name: o.PerformanceCounter.PROCESSOR_TIME,
                                    value: (_ - s) / _ * 100
                                }), this._client.trackMetric({
                                    name: o.PerformanceCounter.PROCESS_TIME,
                                    value: h || t / _ * 100
                                })
                            }
                            this._lastCpus = e
                        }, e.prototype._trackMemory = function() {
                            var e = n.freemem(),
                                t = process.memoryUsage().rss,
                                r = n.totalmem() - e;
                            this._client.trackMetric({
                                name: o.PerformanceCounter.PRIVATE_BYTES,
                                value: t
                            }), this._client.trackMetric({
                                name: o.PerformanceCounter.AVAILABLE_BYTES,
                                value: e
                            }), this._enableLiveMetricsCounters && this._client.trackMetric({
                                name: o.QuickPulseCounter.COMMITTED_BYTES,
                                value: r
                            })
                        }, e.prototype._trackNetwork = function() {
                            var t = this._lastRequests,
                                r = {
                                    totalRequestCount: e._totalRequestCount,
                                    totalFailedRequestCount: e._totalFailedRequestCount,
                                    time: +new Date
                                },
                                n = r.totalRequestCount - t.totalRequestCount || 0,
                                i = r.totalFailedRequestCount - t.totalFailedRequestCount || 0,
                                s = r.time - t.time,
                                a = s / 1e3,
                                c = (e._intervalRequestExecutionTime - this._lastIntervalRequestExecutionTime) / n || 0;
                            if (this._lastIntervalRequestExecutionTime = e._intervalRequestExecutionTime, s > 0) {
                                var l = n / a,
                                    u = i / a;
                                this._client.trackMetric({
                                    name: o.PerformanceCounter.REQUEST_RATE,
                                    value: l
                                }), (!this._enableLiveMetricsCounters || n > 0) && this._client.trackMetric({
                                    name: o.PerformanceCounter.REQUEST_DURATION,
                                    value: c
                                }), this._enableLiveMetricsCounters && this._client.trackMetric({
                                    name: o.QuickPulseCounter.REQUEST_FAILURE_RATE,
                                    value: u
                                })
                            }
                            this._lastRequests = r
                        }, e.prototype._trackDependencyRate = function() {
                            if (this._enableLiveMetricsCounters) {
                                var t = this._lastDependencies,
                                    r = {
                                        totalDependencyCount: e._totalDependencyCount,
                                        totalFailedDependencyCount: e._totalFailedDependencyCount,
                                        time: +new Date
                                    },
                                    n = r.totalDependencyCount - t.totalDependencyCount || 0,
                                    i = r.totalFailedDependencyCount - t.totalFailedDependencyCount || 0,
                                    s = r.time - t.time,
                                    a = s / 1e3,
                                    c = (e._intervalDependencyExecutionTime - this._lastIntervalDependencyExecutionTime) / n || 0;
                                if (this._lastIntervalDependencyExecutionTime = e._intervalDependencyExecutionTime, s > 0) {
                                    var l = n / a,
                                        u = i / a;
                                    this._client.trackMetric({
                                        name: o.QuickPulseCounter.DEPENDENCY_RATE,
                                        value: l
                                    }), this._client.trackMetric({
                                        name: o.QuickPulseCounter.DEPENDENCY_FAILURE_RATE,
                                        value: u
                                    }), (!this._enableLiveMetricsCounters || n > 0) && this._client.trackMetric({
                                        name: o.QuickPulseCounter.DEPENDENCY_DURATION,
                                        value: c
                                    })
                                }
                                this._lastDependencies = r
                            }
                        }, e.prototype._trackExceptionRate = function() {
                            if (this._enableLiveMetricsCounters) {
                                var t = this._lastExceptions,
                                    r = {
                                        totalExceptionCount: e._totalExceptionCount,
                                        time: +new Date
                                    },
                                    n = r.totalExceptionCount - t.totalExceptionCount || 0,
                                    i = r.time - t.time;
                                if (i > 0) {
                                    var s = n / (i / 1e3);
                                    this._client.trackMetric({
                                        name: o.QuickPulseCounter.EXCEPTION_RATE,
                                        value: s
                                    })
                                }
                                this._lastExceptions = r
                            }
                        }, e.prototype.dispose = function() {
                            e.INSTANCE = null, this.enable(!1), this._isInitialized = !1
                        }, e._totalRequestCount = 0, e._totalFailedRequestCount = 0, e._lastRequestExecutionTime = 0, e._totalDependencyCount = 0, e._totalFailedDependencyCount = 0, e._lastDependencyExecutionTime = 0, e._totalExceptionCount = 0, e._intervalDependencyExecutionTime = 0, e._intervalRequestExecutionTime = 0, e
                    }();
                e.exports = i
            },
            3054: e => {
                "use strict";
                var t = function() {
                    function e() {}
                    return e.prototype.getUrl = function() {
                        return this.url
                    }, e.prototype.RequestParser = function() {
                        this.startTime = +new Date
                    }, e.prototype._setStatus = function(e, t) {
                        var r = +new Date;
                        this.duration = r - this.startTime, this.statusCode = e;
                        var n = this.properties || {};
                        if (t)
                            if ("string" == typeof t) n.error = t;
                            else if (t instanceof Error) n.error = t.message;
                        else if ("object" == typeof t)
                            for (var o in t) n[o] = t[o] && t[o].toString && t[o].toString();
                        this.properties = n
                    }, e.prototype._isSuccess = function() {
                        return 0 < this.statusCode && this.statusCode < 400
                    }, e
                }();
                e.exports = t
            },
            5823: (e, t, r) => {
                "use strict";
                var n = r(5290),
                    o = r(4953),
                    i = [],
                    s = {
                        10: n.SeverityLevel.Verbose,
                        20: n.SeverityLevel.Verbose,
                        30: n.SeverityLevel.Information,
                        40: n.SeverityLevel.Warning,
                        50: n.SeverityLevel.Error,
                        60: n.SeverityLevel.Critical
                    },
                    a = function(e) {
                        var t = e.data.result;
                        i.forEach((function(r) {
                            var n = s[e.data.level];
                            t instanceof Error ? r.trackException({
                                exception: t
                            }) : r.trackTrace({
                                message: t,
                                severity: n
                            })
                        }))
                    };
                t.wp = function(e, t) {
                    e ? (0 === i.length && o.channel.subscribe("bunyan", a), i.push(t)) : 0 === (i = i.filter((function(e) {
                        return e != t
                    }))).length && o.channel.unsubscribe("bunyan", a)
                }
            },
            4309: (e, t, r) => {
                "use strict";
                var n = r(5290),
                    o = r(4953),
                    i = [],
                    s = function(e) {
                        var t = e.data.message;
                        i.forEach((function(r) {
                            t instanceof Error ? r.trackException({
                                exception: t
                            }) : (t.lastIndexOf("\n") == t.length - 1 && (t = t.substring(0, t.length - 1)), r.trackTrace({
                                message: t,
                                severity: e.data.stderr ? n.SeverityLevel.Warning : n.SeverityLevel.Information
                            }))
                        }))
                    };
                t.wp = function(e, t) {
                    e ? (0 === i.length && o.channel.subscribe("console", s), i.push(t)) : 0 === (i = i.filter((function(e) {
                        return e != t
                    }))).length && o.channel.unsubscribe("console", s)
                }
            },
            7396: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(5282);
                t.IsInitialized = !process.env.APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL;
                var o = "DiagnosticChannel";
                if (t.IsInitialized) {
                    var i = r(4106),
                        s = (process.env.APPLICATION_INSIGHTS_NO_PATCH_MODULES || "").split(","),
                        a = {
                            bunyan: i.bunyan,
                            console: i.console,
                            mongodb: i.mongodb,
                            mongodbCore: i.mongodbCore,
                            mysql: i.mysql,
                            redis: i.redis,
                            pg: i.pg,
                            pgPool: i.pgPool,
                            winston: i.winston
                        };
                    for (var c in a) - 1 === s.indexOf(c) && (a[c].enable(), n.info(o, "Subscribed to " + c + " events"));
                    s.length > 0 && n.info(o, "Some modules will not be patched", s)
                } else n.info(o, "Not subscribing to dependency autocollection because APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL was set");
                t.registerContextPreservation = function(e) {
                    t.IsInitialized && r(4953).channel.addContextPreservation(e)
                }
            },
            7886: (e, t, r) => {
                "use strict";
                var n = r(4953),
                    o = [];
                t.qP = function(e) {
                    e.data.event.commandName, o.forEach((function(t) {
                        var r = e.data.startedData && e.data.startedData.databaseName || "Unknown database";
                        t.trackDependency({
                            target: r,
                            data: e.data.event.commandName,
                            name: e.data.event.commandName,
                            duration: e.data.event.duration,
                            success: e.data.succeeded,
                            resultCode: e.data.succeeded ? "0" : "1",
                            dependencyTypeName: "mongodb"
                        })
                    }))
                }, t.wp = function(e, r) {
                    e ? (0 === o.length && n.channel.subscribe("mongodb", t.qP), o.push(r)) : 0 === (o = o.filter((function(e) {
                        return e != r
                    }))).length && n.channel.unsubscribe("mongodb", t.qP)
                }
            },
            4777: (e, t, r) => {
                "use strict";
                var n = r(4953),
                    o = [];
                t.qP = function(e) {
                    o.forEach((function(t) {
                        var r = e.data.query || {},
                            n = r.sql || "Unknown query",
                            o = !e.data.err,
                            i = (r._connection || {}).config || {},
                            s = i.socketPath ? i.socketPath : (i.host || "localhost") + ":" + i.port;
                        t.trackDependency({
                            target: s,
                            data: n,
                            name: n,
                            duration: e.data.duration,
                            success: o,
                            resultCode: o ? "0" : "1",
                            dependencyTypeName: "mysql"
                        })
                    }))
                }, t.wp = function(e, r) {
                    e ? (0 === o.length && n.channel.subscribe("mysql", t.qP), o.push(r)) : 0 === (o = o.filter((function(e) {
                        return e != r
                    }))).length && n.channel.unsubscribe("mysql", t.qP)
                }
            },
            1227: (e, t, r) => {
                "use strict";
                var n = r(4953),
                    o = [];
                t.qP = function(e) {
                    o.forEach((function(t) {
                        var r = e.data.query,
                            n = r.preparable && r.preparable.text || r.plan || r.text || "unknown query",
                            o = !e.data.error,
                            i = e.data.database.host + ":" + e.data.database.port;
                        t.trackDependency({
                            target: i,
                            data: n,
                            name: n,
                            duration: e.data.duration,
                            success: o,
                            resultCode: o ? "0" : "1",
                            dependencyTypeName: "postgres"
                        })
                    }))
                }, t.wp = function(e, r) {
                    e ? (0 === o.length && n.channel.subscribe("postgres", t.qP), o.push(r)) : 0 === (o = o.filter((function(e) {
                        return e != r
                    }))).length && n.channel.unsubscribe("postgres", t.qP)
                }
            },
            5071: (e, t, r) => {
                "use strict";
                var n = r(4953),
                    o = [];
                t.qP = function(e) {
                    o.forEach((function(t) {
                        "info" !== e.data.commandObj.command && t.trackDependency({
                            target: e.data.address,
                            name: e.data.commandObj.command,
                            data: e.data.commandObj.command,
                            duration: e.data.duration,
                            success: !e.data.err,
                            resultCode: e.data.err ? "1" : "0",
                            dependencyTypeName: "redis"
                        })
                    }))
                }, t.wp = function(e, r) {
                    e ? (0 === o.length && n.channel.subscribe("redis", t.qP), o.push(r)) : 0 === (o = o.filter((function(e) {
                        return e != r
                    }))).length && n.channel.unsubscribe("redis", t.qP)
                }
            },
            454: (e, t, r) => {
                "use strict";
                var n = r(5290),
                    o = r(4953),
                    i = [],
                    s = {
                        syslog: function(e) {
                            var t = {
                                emerg: n.SeverityLevel.Critical,
                                alert: n.SeverityLevel.Critical,
                                crit: n.SeverityLevel.Critical,
                                error: n.SeverityLevel.Error,
                                warning: n.SeverityLevel.Warning,
                                notice: n.SeverityLevel.Information,
                                info: n.SeverityLevel.Information,
                                debug: n.SeverityLevel.Verbose
                            };
                            return void 0 === t[e] ? n.SeverityLevel.Information : t[e]
                        },
                        npm: function(e) {
                            var t = {
                                error: n.SeverityLevel.Error,
                                warn: n.SeverityLevel.Warning,
                                info: n.SeverityLevel.Information,
                                verbose: n.SeverityLevel.Verbose,
                                debug: n.SeverityLevel.Verbose,
                                silly: n.SeverityLevel.Verbose
                            };
                            return void 0 === t[e] ? n.SeverityLevel.Information : t[e]
                        },
                        unknown: function(e) {
                            return n.SeverityLevel.Information
                        }
                    },
                    a = function(e) {
                        var t = e.data.message;
                        i.forEach((function(r) {
                            if (t instanceof Error) r.trackException({
                                exception: t,
                                properties: e.data.meta
                            });
                            else {
                                var n = s[e.data.levelKind](e.data.level);
                                r.trackTrace({
                                    message: t,
                                    severity: n,
                                    properties: e.data.meta
                                })
                            }
                        }))
                    };
                t.wp = function(e, t) {
                    e ? (0 === i.length && o.channel.subscribe("winston", a), i.push(t)) : 0 === (i = i.filter((function(e) {
                        return e != t
                    }))).length && o.channel.unsubscribe("winston", a)
                }
            },
            3580: (e, t) => {
                "use strict";
                var r, n, o;
                Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com", t.DEFAULT_LIVEMETRICS_ENDPOINT = "https://rt.services.visualstudio.com", t.DEFAULT_LIVEMETRICS_HOST = "rt.services.visualstudio.com",
                    function(e) {
                        e.COMMITTED_BYTES = "\\Memory\\Committed Bytes", e.PROCESSOR_TIME = "\\Processor(_Total)\\% Processor Time", e.REQUEST_RATE = "\\ApplicationInsights\\Requests/Sec", e.REQUEST_FAILURE_RATE = "\\ApplicationInsights\\Requests Failed/Sec", e.REQUEST_DURATION = "\\ApplicationInsights\\Request Duration", e.DEPENDENCY_RATE = "\\ApplicationInsights\\Dependency Calls/Sec", e.DEPENDENCY_FAILURE_RATE = "\\ApplicationInsights\\Dependency Calls Failed/Sec", e.DEPENDENCY_DURATION = "\\ApplicationInsights\\Dependency Call Duration", e.EXCEPTION_RATE = "\\ApplicationInsights\\Exceptions/Sec"
                    }(r = t.QuickPulseCounter || (t.QuickPulseCounter = {})),
                    function(e) {
                        e.PRIVATE_BYTES = "\\Process(??APP_WIN32_PROC??)\\Private Bytes", e.AVAILABLE_BYTES = "\\Memory\\Available Bytes", e.PROCESSOR_TIME = "\\Processor(_Total)\\% Processor Time", e.PROCESS_TIME = "\\Process(??APP_WIN32_PROC??)\\% Processor Time", e.REQUEST_RATE = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Requests/Sec", e.REQUEST_DURATION = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Request Execution Time"
                    }(n = t.PerformanceCounter || (t.PerformanceCounter = {})), t.PerformanceToQuickPulseCounter = ((o = {})[n.PROCESSOR_TIME] = r.PROCESSOR_TIME, o[n.REQUEST_RATE] = r.REQUEST_RATE, o[n.REQUEST_DURATION] = r.REQUEST_DURATION, o[r.COMMITTED_BYTES] = r.COMMITTED_BYTES, o[r.REQUEST_FAILURE_RATE] = r.REQUEST_FAILURE_RATE, o[r.DEPENDENCY_RATE] = r.DEPENDENCY_RATE, o[r.DEPENDENCY_FAILURE_RATE] = r.DEPENDENCY_FAILURE_RATE, o[r.DEPENDENCY_DURATION] = r.DEPENDENCY_DURATION, o[r.EXCEPTION_RATE] = r.EXCEPTION_RATE, o), t.QuickPulseDocumentType = {
                        Event: "Event",
                        Exception: "Exception",
                        Trace: "Trace",
                        Metric: "Metric",
                        Request: "Request",
                        Dependency: "RemoteDependency",
                        Availability: "Availability"
                    }, t.QuickPulseType = {
                        Event: "EventTelemetryDocument",
                        Exception: "ExceptionTelemetryDocument",
                        Trace: "TraceTelemetryDocument",
                        Metric: "MetricTelemetryDocument",
                        Request: "RequestTelemetryDocument",
                        Dependency: "DependencyTelemetryDocument",
                        Availability: "AvailabilityTelemetryDocument"
                    }, t.TelemetryTypeStringToQuickPulseType = {
                        EventData: t.QuickPulseType.Event,
                        ExceptionData: t.QuickPulseType.Exception,
                        MessageData: t.QuickPulseType.Trace,
                        MetricData: t.QuickPulseType.Metric,
                        RequestData: t.QuickPulseType.Request,
                        RemoteDependencyData: t.QuickPulseType.Dependency,
                        AvailabilityData: t.QuickPulseType.Availability
                    }, t.TelemetryTypeStringToQuickPulseDocumentType = {
                        EventData: t.QuickPulseDocumentType.Event,
                        ExceptionData: t.QuickPulseDocumentType.Exception,
                        MessageData: t.QuickPulseDocumentType.Trace,
                        MetricData: t.QuickPulseDocumentType.Metric,
                        RequestData: t.QuickPulseDocumentType.Request,
                        RemoteDependencyData: t.QuickPulseDocumentType.Dependency,
                        AvailabilityData: t.QuickPulseDocumentType.Availability
                    }
            },
            9382: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(9958),
                    o = function() {
                        function e() {}
                        return e.TYPE_HTTP = "Http", e.TYPE_AI = "Http (tracked component)", e
                    }();
                t.RemoteDependencyDataConstants = o, t.domainSupportsProperties = function(e) {
                    return "properties" in e || e instanceof n.EventData || e instanceof n.ExceptionData || e instanceof n.MessageData || e instanceof n.MetricData || e instanceof n.PageViewData || e instanceof n.RemoteDependencyData || e instanceof n.RequestData
                }
            },
            7220: function(e, t, r) {
                "use strict";
                var n, o = this && this.__extends || (n = Object.setPrototypeOf || {
                            __proto__: []
                        }
                        instanceof Array && function(e, t) {
                            e.__proto__ = t
                        } || function(e, t) {
                            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                        },
                        function(e, t) {
                            function r() {
                                this.constructor = e
                            }
                            n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                        }),
                    i = function(e) {
                        function t() {
                            var t = e.call(this) || this;
                            return t.ver = 2, t.properties = {}, t.measurements = {}, t
                        }
                        return o(t, e), t
                    }(r(8934));
                e.exports = i
            },
            4101: e => {
                "use strict";
                e.exports = function() {}
            },
            9871: e => {
                "use strict";
                e.exports = function() {
                    this.applicationVersion = "ai.application.ver", this.deviceId = "ai.device.id", this.deviceLocale = "ai.device.locale", this.deviceModel = "ai.device.model", this.deviceOEMName = "ai.device.oemName", this.deviceOSVersion = "ai.device.osVersion", this.deviceType = "ai.device.type", this.locationIp = "ai.location.ip", this.operationId = "ai.operation.id", this.operationName = "ai.operation.name", this.operationParentId = "ai.operation.parentId", this.operationSyntheticSource = "ai.operation.syntheticSource", this.operationCorrelationVector = "ai.operation.correlationVector", this.sessionId = "ai.session.id", this.sessionIsFirst = "ai.session.isFirst", this.userAccountId = "ai.user.accountId", this.userId = "ai.user.id", this.userAuthUserId = "ai.user.authUserId", this.cloudRole = "ai.cloud.role", this.cloudRoleInstance = "ai.cloud.roleInstance", this.internalSdkVersion = "ai.internal.sdkVersion", this.internalAgentVersion = "ai.internal.agentVersion", this.internalNodeName = "ai.internal.nodeName"
                }
            },
            320: function(e, t, r) {
                "use strict";
                var n, o = this && this.__extends || (n = Object.setPrototypeOf || {
                            __proto__: []
                        }
                        instanceof Array && function(e, t) {
                            e.__proto__ = t
                        } || function(e, t) {
                            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                        },
                        function(e, t) {
                            function r() {
                                this.constructor = e
                            }
                            n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                        }),
                    i = function(e) {
                        function t() {
                            return e.call(this) || this
                        }
                        return o(t, e), t
                    }(r(4101));
                e.exports = i
            },
            8602: (e, t, r) => {
                "use strict";
                var n = r(495);
                e.exports = function() {
                    this.kind = n.Measurement
                }
            },
            495: e => {
                "use strict";
                var t;
                ! function(e) {
                    e[e.Measurement = 0] = "Measurement", e[e.Aggregation = 1] = "Aggregation"
                }(t || (t = {})), e.exports = t
            },
            8934: e => {
                "use strict";
                e.exports = function() {}
            },
            7300: e => {
                "use strict";
                e.exports = function() {
                    this.ver = 1, this.sampleRate = 100, this.tags = {}
                }
            },
            4526: function(e, t, r) {
                "use strict";
                var n, o = this && this.__extends || (n = Object.setPrototypeOf || {
                            __proto__: []
                        }
                        instanceof Array && function(e, t) {
                            e.__proto__ = t
                        } || function(e, t) {
                            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                        },
                        function(e, t) {
                            function r() {
                                this.constructor = e
                            }
                            n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                        }),
                    i = function(e) {
                        function t() {
                            var t = e.call(this) || this;
                            return t.ver = 2, t.properties = {}, t.measurements = {}, t
                        }
                        return o(t, e), t
                    }(r(8934));
                e.exports = i
            },
            935: function(e, t, r) {
                "use strict";
                var n, o = this && this.__extends || (n = Object.setPrototypeOf || {
                            __proto__: []
                        }
                        instanceof Array && function(e, t) {
                            e.__proto__ = t
                        } || function(e, t) {
                            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                        },
                        function(e, t) {
                            function r() {
                                this.constructor = e
                            }
                            n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                        }),
                    i = function(e) {
                        function t() {
                            var t = e.call(this) || this;
                            return t.ver = 2, t.exceptions = [], t.properties = {}, t.measurements = {}, t
                        }
                        return o(t, e), t
                    }(r(8934));
                e.exports = i
            },
            8082: e => {
                "use strict";
                e.exports = function() {
                    this.hasFullStack = !0, this.parsedStack = []
                }
            },
            901: function(e, t, r) {
                "use strict";
                var n, o = this && this.__extends || (n = Object.setPrototypeOf || {
                            __proto__: []
                        }
                        instanceof Array && function(e, t) {
                            e.__proto__ = t
                        } || function(e, t) {
                            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                        },
                        function(e, t) {
                            function r() {
                                this.constructor = e
                            }
                            n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                        }),
                    i = function(e) {
                        function t() {
                            var t = e.call(this) || this;
                            return t.ver = 2, t.properties = {}, t
                        }
                        return o(t, e), t
                    }(r(8934));
                e.exports = i
            },
            3092: function(e, t, r) {
                "use strict";
                var n, o = this && this.__extends || (n = Object.setPrototypeOf || {
                            __proto__: []
                        }
                        instanceof Array && function(e, t) {
                            e.__proto__ = t
                        } || function(e, t) {
                            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                        },
                        function(e, t) {
                            function r() {
                                this.constructor = e
                            }
                            n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                        }),
                    i = function(e) {
                        function t() {
                            var t = e.call(this) || this;
                            return t.ver = 2, t.metrics = [], t.properties = {}, t
                        }
                        return o(t, e), t
                    }(r(8934));
                e.exports = i
            },
            6279: function(e, t, r) {
                "use strict";
                var n, o = this && this.__extends || (n = Object.setPrototypeOf || {
                            __proto__: []
                        }
                        instanceof Array && function(e, t) {
                            e.__proto__ = t
                        } || function(e, t) {
                            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                        },
                        function(e, t) {
                            function r() {
                                this.constructor = e
                            }
                            n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                        }),
                    i = function(e) {
                        function t() {
                            var t = e.call(this) || this;
                            return t.ver = 2, t.properties = {}, t.measurements = {}, t
                        }
                        return o(t, e), t
                    }(r(4526));
                e.exports = i
            },
            6290: function(e, t, r) {
                "use strict";
                var n, o = this && this.__extends || (n = Object.setPrototypeOf || {
                            __proto__: []
                        }
                        instanceof Array && function(e, t) {
                            e.__proto__ = t
                        } || function(e, t) {
                            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                        },
                        function(e, t) {
                            function r() {
                                this.constructor = e
                            }
                            n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                        }),
                    i = function(e) {
                        function t() {
                            var t = e.call(this) || this;
                            return t.ver = 2, t.success = !0, t.properties = {}, t.measurements = {}, t
                        }
                        return o(t, e), t
                    }(r(8934));
                e.exports = i
            },
            7339: function(e, t, r) {
                "use strict";
                var n, o = this && this.__extends || (n = Object.setPrototypeOf || {
                            __proto__: []
                        }
                        instanceof Array && function(e, t) {
                            e.__proto__ = t
                        } || function(e, t) {
                            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                        },
                        function(e, t) {
                            function r() {
                                this.constructor = e
                            }
                            n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                        }),
                    i = function(e) {
                        function t() {
                            var t = e.call(this) || this;
                            return t.ver = 2, t.properties = {}, t.measurements = {}, t
                        }
                        return o(t, e), t
                    }(r(8934));
                e.exports = i
            },
            9697: e => {
                "use strict";
                var t;
                ! function(e) {
                    e[e.Verbose = 0] = "Verbose", e[e.Information = 1] = "Information", e[e.Warning = 2] = "Warning", e[e.Error = 3] = "Error", e[e.Critical = 4] = "Critical"
                }(t || (t = {})), e.exports = t
            },
            6376: e => {
                "use strict";
                e.exports = function() {}
            },
            9958: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.AvailabilityData = r(7220), t.Base = r(4101), t.ContextTagKeys = r(9871), t.Data = r(320), t.DataPoint = r(8602), t.DataPointType = r(495), t.Domain = r(8934), t.Envelope = r(7300), t.EventData = r(4526), t.ExceptionData = r(935), t.ExceptionDetails = r(8082), t.MessageData = r(901), t.MetricData = r(3092), t.PageViewData = r(6279), t.RemoteDependencyData = r(6290), t.RequestData = r(7339), t.SeverityLevel = r(9697), t.StackFrame = r(6376)
            },
            5481: (e, t) => {
                "use strict";
                var r;
                Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.telemetryTypeToBaseType = function(e) {
                        switch (e) {
                            case r.Event:
                                return "EventData";
                            case r.Exception:
                                return "ExceptionData";
                            case r.Trace:
                                return "MessageData";
                            case r.Metric:
                                return "MetricData";
                            case r.Request:
                                return "RequestData";
                            case r.Dependency:
                                return "RemoteDependencyData";
                            case r.Availability:
                                return "AvailabilityData"
                        }
                    }, t.baseTypeToTelemetryType = function(e) {
                        switch (e) {
                            case "EventData":
                                return r.Event;
                            case "ExceptionData":
                                return r.Exception;
                            case "MessageData":
                                return r.Trace;
                            case "MetricData":
                                return r.Metric;
                            case "RequestData":
                                return r.Request;
                            case "RemoteDependencyData":
                                return r.Dependency;
                            case "AvailabilityData":
                                return r.Availability
                        }
                    }, t.TelemetryTypeString = {
                        Event: "EventData",
                        Exception: "ExceptionData",
                        Trace: "MessageData",
                        Metric: "MetricData",
                        Request: "RequestData",
                        Dependency: "RemoteDependencyData",
                        Availability: "AvailabilityData"
                    },
                    function(e) {
                        e[e.Event = 0] = "Event", e[e.Exception = 1] = "Exception", e[e.Trace = 2] = "Trace", e[e.Metric = 3] = "Metric", e[e.Request = 4] = "Request", e[e.Dependency = 5] = "Dependency", e[e.Availability = 6] = "Availability"
                    }(r = t.TelemetryType || (t.TelemetryType = {}))
            },
            2626: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    function(e) {
                        for (var r in e) t.hasOwnProperty(r) || (t[r] = e[r])
                    }(r(5481))
            },
            5290: (e, t, r) => {
                "use strict";

                function n(e) {
                    for (var r in e) t.hasOwnProperty(r) || (t[r] = e[r])
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), n(r(9382)), n(r(9958)), n(r(2626))
            },
            3504: (e, t, r) => {
                "use strict";
                var n = r(5282),
                    o = function() {
                        function e(e, t, r, n) {
                            this._buffer = [], this._lastSend = 0, this._isDisabled = e, this._getBatchSize = t, this._getBatchIntervalMs = r, this._sender = n
                        }
                        return e.prototype.setUseDiskRetryCaching = function(e, t, r) {
                            this._sender.setDiskRetryMode(e, t, r)
                        }, e.prototype.send = function(e) {
                            var t = this;
                            if (!this._isDisabled())
                                if (e) {
                                    var r = this._stringify(e);
                                    "string" == typeof r && (this._buffer.push(r), this._buffer.length >= this._getBatchSize() ? this.triggerSend(!1) : !this._timeoutHandle && this._buffer.length > 0 && (this._timeoutHandle = setTimeout((function() {
                                        t._timeoutHandle = null, t.triggerSend(!1)
                                    }), this._getBatchIntervalMs())))
                                } else n.warn("Cannot send null/undefined telemetry")
                        }, e.prototype.triggerSend = function(e, t) {
                            var r = this._buffer.length < 1;
                            if (!r) {
                                var n = this._buffer.join("\n");
                                e ? (this._sender.saveOnCrash(n), "function" == typeof t && t("data saved on crash")) : this._sender.send(Buffer.from ? Buffer.from(n) : new Buffer(n), t)
                            }
                            this._lastSend = +new Date, this._buffer.length = 0, clearTimeout(this._timeoutHandle), this._timeoutHandle = null, r && "function" == typeof t && t("no data to send")
                        }, e.prototype._stringify = function(e) {
                            try {
                                return JSON.stringify(e)
                            } catch (t) {
                                n.warn("Failed to serialize payload", t, e)
                            }
                        }, e
                    }();
                e.exports = o
            },
            9253: (e, t, r) => {
                "use strict";
                var n = r(9962),
                    o = r(5158),
                    i = r(3580),
                    s = r(7310),
                    a = function() {
                        function e(t) {
                            var r = this;
                            this.endpointBase = i.DEFAULT_BREEZE_ENDPOINT;
                            var n = process.env[e.ENV_connectionString],
                                a = o.parse(t),
                                c = o.parse(n),
                                l = !a.instrumentationkey && Object.keys(a).length > 0 ? null : t;
                            this.instrumentationKey = a.instrumentationkey || l || c.instrumentationkey || e._getInstrumentationKey(), this.endpointUrl = (a.ingestionendpoint || c.ingestionendpoint || this.endpointBase) + "/v2/track", this.maxBatchSize = 250, this.maxBatchIntervalMs = 15e3, this.disableAppInsights = !1, this.samplingPercentage = 100, this.correlationIdRetryIntervalMs = 3e4, this.correlationHeaderExcludedDomains = ["*.core.windows.net", "*.core.chinacloudapi.cn", "*.core.cloudapi.de", "*.core.usgovcloudapi.net", "*.core.microsoft.scloud", "*.core.eaglex.ic.gov"], this.setCorrelationId = function(e) {
                                return r.correlationId = e
                            }, this.proxyHttpUrl = process.env[e.ENV_http_proxy] || void 0, this.proxyHttpsUrl = process.env[e.ENV_https_proxy] || void 0, this.httpAgent = void 0, this.httpsAgent = void 0, this.profileQueryEndpoint = a.ingestionendpoint || c.ingestionendpoint || process.env[e.ENV_profileQueryEndpoint] || this.endpointBase, this._quickPulseHost = a.liveendpoint || c.liveendpoint || process.env[e.ENV_quickPulseHost] || i.DEFAULT_LIVEMETRICS_HOST, this._quickPulseHost.match(/^https?:\/\//) && (this._quickPulseHost = s.parse(this._quickPulseHost).host)
                        }
                        return Object.defineProperty(e.prototype, "profileQueryEndpoint", {
                            get: function() {
                                return this._profileQueryEndpoint
                            },
                            set: function(e) {
                                n.cancelCorrelationIdQuery(this, this.setCorrelationId), this._profileQueryEndpoint = e, this.correlationId = n.correlationIdPrefix, n.queryCorrelationId(this, this.setCorrelationId)
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "quickPulseHost", {
                            get: function() {
                                return this._quickPulseHost
                            },
                            set: function(e) {
                                this._quickPulseHost = e
                            },
                            enumerable: !0,
                            configurable: !0
                        }), e._getInstrumentationKey = function() {
                            var t = process.env[e.ENV_iKey] || process.env[e.ENV_azurePrefix + e.ENV_iKey] || process.env[e.legacy_ENV_iKey] || process.env[e.ENV_azurePrefix + e.legacy_ENV_iKey];
                            if (!t || "" == t) throw new Error("Instrumentation key not found, pass the key in the config to this method or set the key in the environment variable APPINSIGHTS_INSTRUMENTATIONKEY before starting the server");
                            return t
                        }, e.ENV_azurePrefix = "APPSETTING_", e.ENV_iKey = "APPINSIGHTS_INSTRUMENTATIONKEY", e.legacy_ENV_iKey = "APPINSIGHTS_INSTRUMENTATION_KEY", e.ENV_profileQueryEndpoint = "APPINSIGHTS_PROFILE_QUERY_ENDPOINT", e.ENV_quickPulseHost = "APPINSIGHTS_QUICKPULSE_HOST", e.ENV_connectionString = "APPLICATIONINSIGHTS_CONNECTION_STRING", e.ENV_nativeMetricsDisablers = "APPLICATION_INSIGHTS_DISABLE_EXTENDED_METRIC", e.ENV_nativeMetricsDisableAll = "APPLICATION_INSIGHTS_DISABLE_ALL_EXTENDED_METRICS", e.ENV_http_proxy = "http_proxy", e.ENV_https_proxy = "https_proxy", e
                    }();
                e.exports = a
            },
            5158: (e, t, r) => {
                "use strict";
                var n = r(3580),
                    o = function() {
                        function e() {}
                        return e.parse = function(t) {
                            if (!t) return {};
                            var r = t.split(e._FIELDS_SEPARATOR).reduce((function(t, r) {
                                var n = r.split(e._FIELD_KEY_VALUE_SEPARATOR);
                                if (2 === n.length) {
                                    var o = n[0].toLowerCase(),
                                        i = n[1];
                                    t[o] = i
                                }
                                return t
                            }), {});
                            if (Object.keys(r).length > 0) {
                                if (r.endpointsuffix) {
                                    var o = r.location ? r.location + "." : "";
                                    r.ingestionendpoint = r.ingestionendpoint || "https://" + o + "dc." + r.endpointsuffix, r.liveendpoint = r.liveendpoint || "https://" + o + "live." + r.endpointsuffix
                                }
                                r.ingestionendpoint = r.ingestionendpoint || n.DEFAULT_BREEZE_ENDPOINT, r.liveendpoint = r.liveendpoint || n.DEFAULT_LIVEMETRICS_ENDPOINT
                            }
                            return r
                        }, e._FIELDS_SEPARATOR = ";", e._FIELD_KEY_VALUE_SEPARATOR = "=", e
                    }();
                e.exports = o
            },
            4470: (e, t, r) => {
                "use strict";
                var n = r(2037),
                    o = r(7147),
                    i = r(1017),
                    s = r(5290),
                    a = r(5282),
                    c = function() {
                        function e(e) {
                            this.keys = new s.ContextTagKeys, this.tags = {}, this._loadApplicationContext(), this._loadDeviceContext(), this._loadInternalContext()
                        }
                        return e.prototype._loadApplicationContext = function(t) {
                            if (t = t || i.resolve(__dirname, "../../../../package.json"), !e.appVersion[t]) {
                                e.appVersion[t] = "unknown";
                                try {
                                    var r = JSON.parse(o.readFileSync(t, "utf8"));
                                    r && "string" == typeof r.version && (e.appVersion[t] = r.version)
                                } catch (e) {
                                    a.info("unable to read app version: ", e)
                                }
                            }
                            this.tags[this.keys.applicationVersion] = e.appVersion[t]
                        }, e.prototype._loadDeviceContext = function() {
                            this.tags[this.keys.deviceId] = "", this.tags[this.keys.cloudRoleInstance] = n && n.hostname(), this.tags[this.keys.deviceOSVersion] = n && n.type() + " " + n.release(), this.tags[this.keys.cloudRole] = e.DefaultRoleName, this.tags["ai.device.osArchitecture"] = n && n.arch(), this.tags["ai.device.osPlatform"] = n && n.platform()
                        }, e.prototype._loadInternalContext = function() {
                            var t = i.resolve(__dirname, "../../package.json");
                            if (!e.sdkVersion) {
                                e.sdkVersion = "unknown";
                                try {
                                    var r = JSON.parse(o.readFileSync(t, "utf8"));
                                    r && "string" == typeof r.version && (e.sdkVersion = r.version)
                                } catch (e) {
                                    a.info("unable to read app version: ", e)
                                }
                            }
                            this.tags[this.keys.internalSdkVersion] = "node:" + e.sdkVersion
                        }, e.DefaultRoleName = "Web", e.appVersion = {}, e.sdkVersion = null, e
                    }();
                e.exports = c
            },
            9962: (e, t, r) => {
                "use strict";
                var n = r(5740),
                    o = r(5282),
                    i = function() {
                        function e() {}
                        return e.queryCorrelationId = function(t, r) {
                            var i = t.profileQueryEndpoint + "/api/profiles/" + t.instrumentationKey + "/appId";
                            if (e.completedLookups.hasOwnProperty(i)) r(e.completedLookups[i]);
                            else if (e.pendingLookups[i]) e.pendingLookups[i].push(r);
                            else {
                                e.pendingLookups[i] = [r];
                                var s = function() {
                                    if (e.pendingLookups[i]) {
                                        var r = {
                                            method: "GET",
                                            disableAppInsightsAutoCollection: !0
                                        };
                                        o.info(e.TAG, r);
                                        var a = n.makeRequest(t, i, r, (function(r) {
                                            if (200 === r.statusCode) {
                                                var n = "";
                                                r.setEncoding("utf-8"), r.on("data", (function(e) {
                                                    n += e
                                                })), r.on("end", (function() {
                                                    o.info(e.TAG, n);
                                                    var t = e.correlationIdPrefix + n;
                                                    e.completedLookups[i] = t, e.pendingLookups[i] && e.pendingLookups[i].forEach((function(e) {
                                                        return e(t)
                                                    })), delete e.pendingLookups[i]
                                                }))
                                            } else r.statusCode >= 400 && r.statusCode < 500 ? (e.completedLookups[i] = void 0, delete e.pendingLookups[i]) : setTimeout(s, t.correlationIdRetryIntervalMs)
                                        }));
                                        a && (a.on("error", (function(t) {
                                            o.warn(e.TAG, t)
                                        })), a.end())
                                    }
                                };
                                setTimeout(s, 0)
                            }
                        }, e.cancelCorrelationIdQuery = function(t, r) {
                            var n = t.profileQueryEndpoint + "/api/profiles/" + t.instrumentationKey + "/appId",
                                o = e.pendingLookups[n];
                            o && (e.pendingLookups[n] = o.filter((function(e) {
                                return e != r
                            })), 0 == e.pendingLookups[n].length && delete e.pendingLookups[n])
                        }, e.generateRequestId = function(t) {
                            if (t) {
                                "." !== (t = "|" == t[0] ? t : "|" + t)[t.length - 1] && (t += ".");
                                var r = (e.currentRootId++).toString(16);
                                return e.appendSuffix(t, r, "_")
                            }
                            return e.generateRootId()
                        }, e.getRootId = function(e) {
                            var t = e.indexOf(".");
                            t < 0 && (t = e.length);
                            var r = "|" === e[0] ? 1 : 0;
                            return e.substring(r, t)
                        }, e.generateRootId = function() {
                            return "|" + n.w3cTraceId() + "."
                        }, e.appendSuffix = function(t, r, o) {
                            if (t.length + r.length < e.requestIdMaxLength) return t + r + o;
                            var i = e.requestIdMaxLength - 9;
                            if (t.length > i)
                                for (; i > 1; --i) {
                                    var s = t[i - 1];
                                    if ("." === s || "_" === s) break
                                }
                            if (i <= 1) return e.generateRootId();
                            for (r = n.randomu32().toString(16); r.length < 8;) r = "0" + r;
                            return t.substring(0, i) + r + "#"
                        }, e.TAG = "CorrelationIdManager", e.correlationIdPrefix = "cid-v1:", e.w3cEnabled = !1, e.pendingLookups = {}, e.completedLookups = {}, e.requestIdMaxLength = 1024, e.currentRootId = n.randomu32(), e
                    }();
                e.exports = i
            },
            9813: (e, t, r) => {
                "use strict";
                var n = r(5290),
                    o = r(5740),
                    i = r(894),
                    s = function() {
                        function e() {}
                        return e.createEnvelope = function(t, r, i, s, a) {
                            var c = null;
                            switch (r) {
                                case n.TelemetryType.Trace:
                                    c = e.createTraceData(t);
                                    break;
                                case n.TelemetryType.Dependency:
                                    c = e.createDependencyData(t);
                                    break;
                                case n.TelemetryType.Event:
                                    c = e.createEventData(t);
                                    break;
                                case n.TelemetryType.Exception:
                                    c = e.createExceptionData(t);
                                    break;
                                case n.TelemetryType.Request:
                                    c = e.createRequestData(t);
                                    break;
                                case n.TelemetryType.Metric:
                                    c = e.createMetricData(t);
                                    break;
                                case n.TelemetryType.Availability:
                                    c = e.createAvailabilityData(t)
                            }
                            if (i && n.domainSupportsProperties(c.baseData)) {
                                if (c && c.baseData)
                                    if (c.baseData.properties)
                                        for (var l in i) c.baseData.properties[l] || (c.baseData.properties[l] = i[l]);
                                    else c.baseData.properties = i;
                                c.baseData.properties = o.validateStringMap(c.baseData.properties)
                            }
                            var u = a && a.instrumentationKey || "",
                                d = new n.Envelope;
                            return d.data = c, d.iKey = u, d.name = "Microsoft.ApplicationInsights." + u.replace(/-/g, "") + "." + c.baseType.substr(0, c.baseType.length - 4), d.tags = this.getTags(s, t.tagOverrides), d.time = (new Date).toISOString(), d.ver = 1, d.sampleRate = a ? a.samplingPercentage : 100, r === n.TelemetryType.Metric && (d.sampleRate = 100), d
                        }, e.createTraceData = function(e) {
                            var t = new n.MessageData;
                            t.message = e.message, t.properties = e.properties, isNaN(e.severity) ? t.severityLevel = n.SeverityLevel.Information : t.severityLevel = e.severity;
                            var r = new n.Data;
                            return r.baseType = n.telemetryTypeToBaseType(n.TelemetryType.Trace), r.baseData = t, r
                        }, e.createDependencyData = function(e) {
                            var t = new n.RemoteDependencyData;
                            "string" == typeof e.name && (t.name = e.name.length > 1024 ? e.name.slice(0, 1021) + "..." : e.name), t.data = e.data, t.target = e.target, t.duration = o.msToTimeSpan(e.duration), t.success = e.success, t.type = e.dependencyTypeName, t.properties = e.properties, t.resultCode = e.resultCode ? e.resultCode + "" : "", e.id ? t.id = e.id : t.id = o.w3cTraceId();
                            var r = new n.Data;
                            return r.baseType = n.telemetryTypeToBaseType(n.TelemetryType.Dependency), r.baseData = t, r
                        }, e.createEventData = function(e) {
                            var t = new n.EventData;
                            t.name = e.name, t.properties = e.properties, t.measurements = e.measurements;
                            var r = new n.Data;
                            return r.baseType = n.telemetryTypeToBaseType(n.TelemetryType.Event), r.baseData = t, r
                        }, e.createExceptionData = function(e) {
                            var t = new n.ExceptionData;
                            t.properties = e.properties, isNaN(e.severity) ? t.severityLevel = n.SeverityLevel.Error : t.severityLevel = e.severity, t.measurements = e.measurements, t.exceptions = [];
                            var r = e.exception.stack,
                                i = new n.ExceptionDetails;
                            i.message = e.exception.message, i.typeName = e.exception.name, i.parsedStack = this.parseStack(r), i.hasFullStack = o.isArray(i.parsedStack) && i.parsedStack.length > 0, t.exceptions.push(i);
                            var s = new n.Data;
                            return s.baseType = n.telemetryTypeToBaseType(n.TelemetryType.Exception), s.baseData = t, s
                        }, e.createRequestData = function(e) {
                            var t = new n.RequestData;
                            e.id ? t.id = e.id : t.id = o.w3cTraceId(), t.name = e.name, t.url = e.url, t.source = e.source, t.duration = o.msToTimeSpan(e.duration), t.responseCode = e.resultCode ? e.resultCode + "" : "", t.success = e.success, t.properties = e.properties;
                            var r = new n.Data;
                            return r.baseType = n.telemetryTypeToBaseType(n.TelemetryType.Request), r.baseData = t, r
                        }, e.createMetricData = function(e) {
                            var t = new n.MetricData;
                            t.metrics = [];
                            var r = new n.DataPoint;
                            r.count = isNaN(e.count) ? 1 : e.count, r.kind = n.DataPointType.Aggregation, r.max = isNaN(e.max) ? e.value : e.max, r.min = isNaN(e.min) ? e.value : e.min, r.name = e.name, r.stdDev = isNaN(e.stdDev) ? 0 : e.stdDev, r.value = e.value, t.metrics.push(r), t.properties = e.properties;
                            var o = new n.Data;
                            return o.baseType = n.telemetryTypeToBaseType(n.TelemetryType.Metric), o.baseData = t, o
                        }, e.createAvailabilityData = function(e) {
                            var t = new n.AvailabilityData;
                            e.id ? t.id = e.id : t.id = o.w3cTraceId(), t.name = e.name, t.duration = o.msToTimeSpan(e.duration), t.success = e.success, t.runLocation = e.runLocation, t.message = e.message, t.measurements = e.measurements, t.properties = e.properties;
                            var r = new n.Data;
                            return r.baseType = n.telemetryTypeToBaseType(n.TelemetryType.Availability), r.baseData = t, r
                        }, e.getTags = function(e, t) {
                            var r = i.CorrelationContextManager.getCurrentContext(),
                                n = {};
                            if (e && e.tags)
                                for (var o in e.tags) n[o] = e.tags[o];
                            if (t)
                                for (var o in t) n[o] = t[o];
                            return r && (n[e.keys.operationId] = n[e.keys.operationId] || r.operation.id, n[e.keys.operationName] = n[e.keys.operationName] || r.operation.name, n[e.keys.operationParentId] = n[e.keys.operationParentId] || r.operation.parentId), n
                        }, e.parseStack = function(e) {
                            var t = void 0;
                            if ("string" == typeof e) {
                                var r = e.split("\n");
                                t = [];
                                for (var n = 0, o = 0, i = 0; i <= r.length; i++) {
                                    var s = r[i];
                                    if (a.regex.test(s)) {
                                        var c = new a(r[i], n++);
                                        o += c.sizeInBytes, t.push(c)
                                    }
                                }
                                if (o > 32768)
                                    for (var l = 0, u = t.length - 1, d = 0, p = l, h = u; l < u;) {
                                        if ((d += t[l].sizeInBytes + t[u].sizeInBytes) > 32768) {
                                            var f = h - p + 1;
                                            t.splice(p, f);
                                            break
                                        }
                                        p = l, h = u, l++, u--
                                    }
                            }
                            return t
                        }, e
                    }(),
                    a = function() {
                        function e(t, r) {
                            this.sizeInBytes = 0, this.level = r, this.method = "<no_method>", this.assembly = o.trim(t);
                            var n = t.match(e.regex);
                            n && n.length >= 5 && (this.method = o.trim(n[2]) || this.method, this.fileName = o.trim(n[4]) || "<no_filename>", this.line = parseInt(n[5]) || 0), this.sizeInBytes += this.method.length, this.sizeInBytes += this.fileName.length, this.sizeInBytes += this.assembly.length, this.sizeInBytes += e.baseSize, this.sizeInBytes += this.level.toString().length, this.sizeInBytes += this.line.toString().length
                        }
                        return e.regex = /^([\s]+at)?(.*?)(\@|\s\(|\s)([^\(\@\n]+):([0-9]+):([0-9]+)(\)?)$/, e.baseSize = 58, e
                    }();
                e.exports = s
            },
            5282: e => {
                "use strict";
                var t = function() {
                    function e() {}
                    return e.info = function(t) {
                        for (var r = [], n = 1; n < arguments.length; n++) r[n - 1] = arguments[n];
                        e.enableDebug && console.info(e.TAG + t, r)
                    }, e.warn = function(t) {
                        for (var r = [], n = 1; n < arguments.length; n++) r[n - 1] = arguments[n];
                        e.disableWarnings || console.warn(e.TAG + t, r)
                    }, e.enableDebug = !1, e.disableWarnings = !1, e.disableErrors = !1, e.TAG = "ApplicationInsights:", e
                }();
                e.exports = t
            },
            1259: function(e, t, r) {
                "use strict";
                var n, o = this && this.__extends || (n = Object.setPrototypeOf || {
                            __proto__: []
                        }
                        instanceof Array && function(e, t) {
                            e.__proto__ = t
                        } || function(e, t) {
                            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                        },
                        function(e, t) {
                            function r() {
                                this.constructor = e
                            }
                            n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                        }),
                    i = r(7625),
                    s = r(731),
                    a = r(8723),
                    c = r(5282),
                    l = function(e) {
                        function t() {
                            return null !== e && e.apply(this, arguments) || this
                        }
                        return o(t, e), t.prototype.trackNodeHttpRequestSync = function(e) {
                            e && e.request && e.response && e.duration ? s.trackRequestSync(this, e) : c.warn("trackNodeHttpRequestSync requires NodeHttpRequestTelemetry object with request, response and duration specified.")
                        }, t.prototype.trackNodeHttpRequest = function(e) {
                            (e.duration || e.error) && c.warn("trackNodeHttpRequest will ignore supplied duration and error parameters. These values are collected from the request and response objects."), e && e.request && e.response ? s.trackRequest(this, e) : c.warn("trackNodeHttpRequest requires NodeHttpRequestTelemetry object with request and response specified.")
                        }, t.prototype.trackNodeHttpDependency = function(e) {
                            e && e.request ? a.trackRequest(this, e) : c.warn("trackNodeHttpDependency requires NodeHttpDependencyTelemetry object with request specified.")
                        }, t
                    }(i);
                e.exports = l
            },
            7148: function(e, t, r) {
                "use strict";
                var n = this && this.__assign || Object.assign || function(e) {
                        for (var t, r = 1, n = arguments.length; r < n; r++)
                            for (var o in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
                        return e
                    },
                    o = r(2037),
                    i = r(5290),
                    s = r(3580),
                    a = r(5740),
                    c = r(5282),
                    l = a.w3cTraceId(),
                    u = function() {
                        function e() {}
                        return e.createQuickPulseEnvelope = function(e, t, r, n) {
                            var i = o && "function" == typeof o.hostname && o.hostname() || "Unknown",
                                s = n.tags && n.keys && n.keys.cloudRoleInstance && n.tags[n.keys.cloudRoleInstance] || i;
                            return {
                                Documents: t.length > 0 ? t : null,
                                InstrumentationKey: r.instrumentationKey || "",
                                Metrics: e.length > 0 ? e : null,
                                InvariantVersion: 1,
                                Timestamp: "/Date(" + Date.now() + ")/",
                                Version: n.tags[n.keys.internalSdkVersion],
                                StreamId: l,
                                MachineName: i,
                                Instance: s
                            }
                        }, e.createQuickPulseMetric = function(e) {
                            return {
                                Name: e.name,
                                Value: e.value,
                                Weight: e.count || 1
                            }
                        }, e.telemetryEnvelopeToQuickPulseDocument = function(t) {
                            switch (t.data.baseType) {
                                case i.TelemetryTypeString.Event:
                                    return e.createQuickPulseEventDocument(t);
                                case i.TelemetryTypeString.Exception:
                                    return e.createQuickPulseExceptionDocument(t);
                                case i.TelemetryTypeString.Trace:
                                    return e.createQuickPulseTraceDocument(t);
                                case i.TelemetryTypeString.Dependency:
                                    return e.createQuickPulseDependencyDocument(t);
                                case i.TelemetryTypeString.Request:
                                    return e.createQuickPulseRequestDocument(t)
                            }
                            return null
                        }, e.createQuickPulseEventDocument = function(t) {
                            var r = e.createQuickPulseDocument(t),
                                o = t.data.baseData.name;
                            return n({}, r, {
                                Name: o
                            })
                        }, e.createQuickPulseTraceDocument = function(t) {
                            var r = e.createQuickPulseDocument(t),
                                o = t.data.baseData.severityLevel || 0;
                            return n({}, r, {
                                Message: t.data.baseData.message,
                                SeverityLevel: i.SeverityLevel[o]
                            })
                        }, e.createQuickPulseExceptionDocument = function(t) {
                            var r = e.createQuickPulseDocument(t),
                                o = t.data.baseData.exceptions,
                                i = "",
                                s = "",
                                a = "";
                            return o && o.length > 0 && (o[0].parsedStack && o[0].parsedStack.length > 0 ? o[0].parsedStack.forEach((function(e) {
                                i += e.assembly + "\n"
                            })) : o[0].stack && o[0].stack.length > 0 && (i = o[0].stack), s = o[0].message, a = o[0].typeName), n({}, r, {
                                Exception: i,
                                ExceptionMessage: s,
                                ExceptionType: a
                            })
                        }, e.createQuickPulseRequestDocument = function(t) {
                            var r = e.createQuickPulseDocument(t),
                                o = t.data.baseData;
                            return n({}, r, {
                                Name: o.name,
                                Success: o.success,
                                Duration: o.duration,
                                ResponseCode: o.responseCode,
                                OperationName: o.name
                            })
                        }, e.createQuickPulseDependencyDocument = function(t) {
                            var r = e.createQuickPulseDocument(t),
                                o = t.data.baseData;
                            return n({}, r, {
                                Name: o.name,
                                Target: o.target,
                                Success: o.success,
                                Duration: o.duration,
                                ResultCode: o.resultCode,
                                CommandName: o.data,
                                OperationName: r.OperationId,
                                DependencyTypeName: o.type
                            })
                        }, e.createQuickPulseDocument = function(t) {
                            var r, n;
                            return t.data.baseType ? (n = s.TelemetryTypeStringToQuickPulseType[t.data.baseType], r = s.TelemetryTypeStringToQuickPulseDocumentType[t.data.baseType]) : c.warn("Document type invalid; not sending live metric document", t.data.baseType), {
                                DocumentType: r,
                                __type: n,
                                OperationId: t.tags[e.keys.operationId],
                                Version: "1.0",
                                Properties: e.aggregateProperties(t)
                            }
                        }, e.aggregateProperties = function(e) {
                            var t = [],
                                r = e.data.baseData.measurements || {};
                            for (var n in r)
                                if (r.hasOwnProperty(n)) {
                                    var o = {
                                        key: n,
                                        value: r[n]
                                    };
                                    t.push(o)
                                }
                            var i = e.data.baseData.properties || {};
                            for (var n in i) i.hasOwnProperty(n) && (o = {
                                key: n,
                                value: i[n]
                            }, t.push(o));
                            return t
                        }, e.keys = new i.ContextTagKeys, e
                    }();
                e.exports = u
            },
            9184: (e, t, r) => {
                "use strict";
                var n = r(5687),
                    o = r(8723),
                    i = r(5282),
                    s = function() {
                        function e(e) {
                            this._config = e, this._consecutiveErrors = 0
                        }
                        return e.prototype.ping = function(e, t) {
                            this._submitData(e, t, "ping")
                        }, e.prototype.post = function(e, t) {
                            this._submitData([e], t, "post")
                        }, e.prototype._submitData = function(t, r, s) {
                            var a, c, l = this,
                                u = JSON.stringify(t),
                                d = ((a = {})[o.disableCollectionRequestOption] = !0, a.host = this._config.quickPulseHost, a.method = "POST", a.path = "/QuickPulseService.svc/" + s + "?ikey=" + this._config.instrumentationKey, a.headers = ((c = {
                                    Expect: "100-continue"
                                })["x-ms-qps-transmission-time"] = 1e4 * Date.now(), c["Content-Type"] = "application/json", c["Content-Length"] = Buffer.byteLength(u), c), a),
                                p = n.request(d, (function(e) {
                                    var t = "true" === e.headers["x-ms-qps-subscribed"];
                                    l._consecutiveErrors = 0, r(t, e)
                                }));
                            p.on("error", (function(t) {
                                l._consecutiveErrors++;
                                var n = "Transient error connecting to the Live Metrics endpoint. This packet will not appear in your Live Metrics Stream. Error:";
                                l._consecutiveErrors % e.MAX_QPS_FAILURES_BEFORE_WARN == 0 ? (n = "Live Metrics endpoint could not be reached " + l._consecutiveErrors + " consecutive times. Most recent error:", i.warn(e.TAG, n, t)) : i.info(e.TAG, n, t), r()
                            })), p.write(u), p.end()
                        }, e.TAG = "QuickPulseSender", e.MAX_QPS_FAILURES_BEFORE_WARN = 25, e
                    }();
                e.exports = s
            },
            3668: (e, t, r) => {
                "use strict";
                var n = r(5282),
                    o = r(9253),
                    i = r(7148),
                    s = r(9184),
                    a = r(3580),
                    c = r(4470),
                    l = function() {
                        function e(e, t) {
                            this._isCollectingData = !1, this._lastSuccessTime = Date.now(), this._lastSendSucceeded = !0, this._metrics = {}, this._documents = [], this._collectors = [], this.config = new o(e), this.context = t || new c, this._sender = new s(this.config), this._isEnabled = !1
                        }
                        return e.prototype.addCollector = function(e) {
                            this._collectors.push(e)
                        }, e.prototype.trackMetric = function(e) {
                            this._addMetric(e)
                        }, e.prototype.addDocument = function(e) {
                            var t = i.telemetryEnvelopeToQuickPulseDocument(e);
                            t && this._documents.push(t)
                        }, e.prototype.enable = function(e) {
                            e && !this._isEnabled ? (this._isEnabled = !0, this._goQuickPulse()) : !e && this._isEnabled && (this._isEnabled = !1, clearTimeout(this._handle), this._handle = void 0)
                        }, e.prototype.enableCollectors = function(e) {
                            this._collectors.forEach((function(t) {
                                t.enable(e)
                            }))
                        }, e.prototype._addMetric = function(e) {
                            var t = e.value,
                                r = e.count || 1,
                                n = a.PerformanceToQuickPulseCounter[e.name];
                            n && (this._metrics[n] ? (this._metrics[n].Value = (this._metrics[n].Value * this._metrics[n].Weight + t * r) / (this._metrics[n].Weight + r), this._metrics[n].Weight += r) : (this._metrics[n] = i.createQuickPulseMetric(e), this._metrics[n].Name = n, this._metrics[n].Weight = 1))
                        }, e.prototype._resetQuickPulseBuffer = function() {
                            delete this._metrics, this._metrics = {}, this._documents.length = 0
                        }, e.prototype._goQuickPulse = function() {
                            var t = this,
                                r = Object.keys(this._metrics).map((function(e) {
                                    return t._metrics[e]
                                })),
                                n = i.createQuickPulseEnvelope(r, this._documents.slice(), this.config, this.context);
                            this._resetQuickPulseBuffer(), this._isCollectingData ? this._post(n) : this._ping(n);
                            var o = this._isCollectingData ? e.POST_INTERVAL : e.PING_INTERVAL;
                            this._isCollectingData && Date.now() - this._lastSuccessTime >= e.MAX_POST_WAIT_TIME && !this._lastSendSucceeded ? (this._isCollectingData = !1, o = e.FALLBACK_INTERVAL) : !this._isCollectingData && Date.now() - this._lastSuccessTime >= e.MAX_PING_WAIT_TIME && !this._lastSendSucceeded && (o = e.FALLBACK_INTERVAL), this._lastSendSucceeded = null, this._handle = setTimeout(this._goQuickPulse.bind(this), o), this._handle.unref()
                        }, e.prototype._ping = function(e) {
                            this._sender.ping(e, this._quickPulseDone.bind(this))
                        }, e.prototype._post = function(e) {
                            this._sender.post(e, this._quickPulseDone.bind(this))
                        }, e.prototype._quickPulseDone = function(e, t) {
                            null != e ? (this._isCollectingData !== e && (n.info("Live Metrics sending data", e), this.enableCollectors(e)), this._isCollectingData = e, t && t.statusCode < 300 && t.statusCode >= 200 ? (this._lastSuccessTime = Date.now(), this._lastSendSucceeded = !0) : this._lastSendSucceeded = !1) : this._lastSendSucceeded = !1
                        }, e.MAX_POST_WAIT_TIME = 2e4, e.MAX_PING_WAIT_TIME = 6e4, e.FALLBACK_INTERVAL = 6e4, e.PING_INTERVAL = 5e3, e.POST_INTERVAL = 1e3, e
                    }();
                e.exports = l
            },
            9036: e => {
                "use strict";
                e.exports = {
                    requestContextHeader: "request-context",
                    requestContextSourceKey: "appId",
                    requestContextTargetKey: "appId",
                    requestIdHeader: "request-id",
                    parentIdHeader: "x-ms-request-id",
                    rootIdHeader: "x-ms-request-root-id",
                    correlationContextHeader: "correlation-context",
                    traceparentHeader: "traceparent",
                    traceStateHeader: "tracestate"
                }
            },
            2588: (e, t, r) => {
                "use strict";
                var n = r(7147),
                    o = r(2037),
                    i = r(1017),
                    s = r(9796),
                    a = r(2081),
                    c = r(5282),
                    l = r(8723),
                    u = r(5740),
                    d = function() {
                        function e(t, r, o) {
                            if (this._config = t, this._onSuccess = r, this._onError = o, this._enableDiskRetryMode = !1, this._resendInterval = e.WAIT_BETWEEN_RESEND, this._maxBytesOnDisk = e.MAX_BYTES_ON_DISK, this._numConsecutiveFailures = 0, !e.OS_PROVIDES_FILE_PROTECTION)
                                if (e.USE_ICACLS) {
                                    try {
                                        e.OS_PROVIDES_FILE_PROTECTION = n.existsSync(e.ICACLS_PATH)
                                    } catch (e) {}
                                    e.OS_PROVIDES_FILE_PROTECTION || c.warn(e.TAG, "Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.")
                                } else e.OS_PROVIDES_FILE_PROTECTION = !0
                        }
                        return e.prototype.setDiskRetryMode = function(t, r, n) {
                            this._enableDiskRetryMode = e.OS_PROVIDES_FILE_PROTECTION && t, "number" == typeof r && r >= 0 && (this._resendInterval = Math.floor(r)), "number" == typeof n && n >= 0 && (this._maxBytesOnDisk = Math.floor(n)), t && !e.OS_PROVIDES_FILE_PROTECTION && (this._enableDiskRetryMode = !1, c.warn(e.TAG, "Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected."))
                        }, e.prototype.send = function(t, r) {
                            var n = this,
                                o = this._config.endpointUrl,
                                i = {
                                    method: "POST",
                                    withCredentials: !1,
                                    headers: {
                                        "Content-Type": "application/x-json-stream"
                                    }
                                };
                            s.gzip(t, (function(s, a) {
                                var d = a;
                                s ? (c.warn(s), d = t, i.headers["Content-Length"] = t.length.toString()) : (i.headers["Content-Encoding"] = "gzip", i.headers["Content-Length"] = a.length), c.info(e.TAG, i), i[l.disableCollectionRequestOption] = !0;
                                var p = u.makeRequest(n._config, o, i, (function(o) {
                                    o.setEncoding("utf-8");
                                    var i = "";
                                    o.on("data", (function(e) {
                                        i += e
                                    })), o.on("end", (function() {
                                        n._numConsecutiveFailures = 0, c.info(e.TAG, i), "function" == typeof n._onSuccess && n._onSuccess(i), "function" == typeof r && r(i), n._enableDiskRetryMode && (200 === o.statusCode ? setTimeout((function() {
                                            return n._sendFirstFileOnDisk()
                                        }), n._resendInterval).unref() : 408 !== o.statusCode && 429 !== o.statusCode && 439 !== o.statusCode && 500 !== o.statusCode && 503 !== o.statusCode || n._storeToDisk(t))
                                    }))
                                }));
                                p.on("error", (function(o) {
                                    if (n._numConsecutiveFailures++, !n._enableDiskRetryMode || n._numConsecutiveFailures > 0 && n._numConsecutiveFailures % e.MAX_CONNECTION_FAILURES_BEFORE_WARN == 0) {
                                        var i = "Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:";
                                        n._enableDiskRetryMode && (i = "Ingestion endpoint could not be reached " + n._numConsecutiveFailures + " consecutive times. There may be resulting telemetry loss. Most recent error:"), c.warn(e.TAG, i, o)
                                    } else i = "Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:", c.info(e.TAG, i, o);
                                    if (n._onErrorHelper(o), "function" == typeof r) {
                                        var s = "error sending telemetry";
                                        o && "function" == typeof o.toString && (s = o.toString()), r(s)
                                    }
                                    n._enableDiskRetryMode && n._storeToDisk(t)
                                })), p.write(d), p.end()
                            }))
                        }, e.prototype.saveOnCrash = function(e) {
                            this._enableDiskRetryMode && this._storeToDiskSync(e)
                        }, e.prototype._runICACLS = function(t, r) {
                            var n = a.spawn(e.ICACLS_PATH, t, {
                                windowsHide: !0
                            });
                            n.on("error", (function(e) {
                                return r(e)
                            })), n.on("close", (function(e, t) {
                                return r(0 === e ? null : new Error("Setting ACL restrictions did not succeed (ICACLS returned code " + e + ")"))
                            }))
                        }, e.prototype._runICACLSSync = function(t) {
                            if (!a.spawnSync) throw new Error("Could not synchronously call ICACLS under current version of Node.js");
                            var r = a.spawnSync(e.ICACLS_PATH, t, {
                                windowsHide: !0
                            });
                            if (r.error) throw r.error;
                            if (0 !== r.status) throw new Error("Setting ACL restrictions did not succeed (ICACLS returned code " + r.status + ")")
                        }, e.prototype._getACLIdentity = function(t) {
                            if (e.ACL_IDENTITY) return t(null, e.ACL_IDENTITY);
                            var r = a.spawn(e.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
                                    windowsHide: !0,
                                    stdio: ["ignore", "pipe", "pipe"]
                                }),
                                n = "";
                            r.stdout.on("data", (function(e) {
                                return n += e
                            })), r.on("error", (function(e) {
                                return t(e, null)
                            })), r.on("close", (function(r, o) {
                                return e.ACL_IDENTITY = n && n.trim(), t(0 === r ? null : new Error("Getting ACL identity did not succeed (PS returned code " + r + ")"), e.ACL_IDENTITY)
                            }))
                        }, e.prototype._getACLIdentitySync = function() {
                            if (e.ACL_IDENTITY) return e.ACL_IDENTITY;
                            if (a.spawnSync) {
                                var t = a.spawnSync(e.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
                                    windowsHide: !0,
                                    stdio: ["ignore", "pipe", "pipe"]
                                });
                                if (t.error) throw t.error;
                                if (0 !== t.status) throw new Error("Getting ACL identity did not succeed (PS returned code " + t.status + ")");
                                return e.ACL_IDENTITY = t.stdout && t.stdout.toString().trim(), e.ACL_IDENTITY
                            }
                            throw new Error("Could not synchronously get ACL identity under current version of Node.js")
                        }, e.prototype._getACLArguments = function(e, t) {
                            return [e, "/grant", "*S-1-5-32-544:(OI)(CI)F", "/grant", t + ":(OI)(CI)F", "/inheritance:r"]
                        }, e.prototype._applyACLRules = function(t, r) {
                            var n = this;
                            return e.USE_ICACLS ? void 0 !== e.ACLED_DIRECTORIES[t] ? r(e.ACLED_DIRECTORIES[t] ? null : new Error("Setting ACL restrictions did not succeed (cached result)")) : (e.ACLED_DIRECTORIES[t] = !1, void this._getACLIdentity((function(o, i) {
                                if (o) return e.ACLED_DIRECTORIES[t] = !1, r(o);
                                n._runICACLS(n._getACLArguments(t, i), (function(n) {
                                    return e.ACLED_DIRECTORIES[t] = !n, r(n)
                                }))
                            }))) : r(null)
                        }, e.prototype._applyACLRulesSync = function(t) {
                            if (e.USE_ICACLS) {
                                if (void 0 === e.ACLED_DIRECTORIES[t]) return this._runICACLSSync(this._getACLArguments(t, this._getACLIdentitySync())), void(e.ACLED_DIRECTORIES[t] = !0);
                                if (!e.ACLED_DIRECTORIES[t]) throw new Error("Setting ACL restrictions did not succeed (cached result)")
                            }
                        }, e.prototype._confirmDirExists = function(e, t) {
                            var r = this;
                            n.lstat(e, (function(o, i) {
                                o && "ENOENT" === o.code ? n.mkdir(e, (function(n) {
                                    n && "EEXIST" !== n.code ? t(n) : r._applyACLRules(e, t)
                                })) : !o && i.isDirectory() ? r._applyACLRules(e, t) : t(o || new Error("Path existed but was not a directory"))
                            }))
                        }, e.prototype._getShallowDirectorySize = function(e, t) {
                            n.readdir(e, (function(r, o) {
                                if (r) return t(r, -1);
                                var s = null,
                                    a = 0,
                                    c = 0;
                                if (0 !== o.length)
                                    for (var l = 0; l < o.length; l++) n.stat(i.join(e, o[l]), (function(e, r) {
                                        c++, e ? s = e : r.isFile() && (a += r.size), c === o.length && t(s, s ? -1 : a)
                                    }));
                                else t(null, 0)
                            }))
                        }, e.prototype._getShallowDirectorySizeSync = function(e) {
                            for (var t = n.readdirSync(e), r = 0, o = 0; o < t.length; o++) r += n.statSync(i.join(e, t[o])).size;
                            return r
                        }, e.prototype._storeToDisk = function(t) {
                            var r = this,
                                s = i.join(o.tmpdir(), e.TEMPDIR_PREFIX + this._config.instrumentationKey);
                            c.info(e.TAG, "Checking existance of data storage directory: " + s), this._confirmDirExists(s, (function(o) {
                                if (o) return c.warn(e.TAG, "Error while checking/creating directory: " + (o && o.message)), void r._onErrorHelper(o);
                                r._getShallowDirectorySize(s, (function(o, a) {
                                    if (o || a < 0) return c.warn(e.TAG, "Error while checking directory size: " + (o && o.message)), void r._onErrorHelper(o);
                                    if (a > r._maxBytesOnDisk) c.warn(e.TAG, "Not saving data due to max size limit being met. Directory size in bytes is: " + a);
                                    else {
                                        var l = (new Date).getTime() + ".ai.json",
                                            u = i.join(s, l);
                                        c.info(e.TAG, "saving data to disk at: " + u), n.writeFile(u, t, {
                                            mode: 384
                                        }, (function(e) {
                                            return r._onErrorHelper(e)
                                        }))
                                    }
                                }))
                            }))
                        }, e.prototype._storeToDiskSync = function(t) {
                            var r = i.join(o.tmpdir(), e.TEMPDIR_PREFIX + this._config.instrumentationKey);
                            try {
                                c.info(e.TAG, "Checking existance of data storage directory: " + r), n.existsSync(r) || n.mkdirSync(r), this._applyACLRulesSync(r);
                                var s = this._getShallowDirectorySizeSync(r);
                                if (s > this._maxBytesOnDisk) return void c.info(e.TAG, "Not saving data due to max size limit being met. Directory size in bytes is: " + s);
                                var a = (new Date).getTime() + ".ai.json",
                                    l = i.join(r, a);
                                c.info(e.TAG, "saving data before crash to disk at: " + l), n.writeFileSync(l, t, {
                                    mode: 384
                                })
                            } catch (t) {
                                c.warn(e.TAG, "Error while saving data to disk: " + (t && t.message)), this._onErrorHelper(t)
                            }
                        }, e.prototype._sendFirstFileOnDisk = function() {
                            var t = this,
                                r = i.join(o.tmpdir(), e.TEMPDIR_PREFIX + this._config.instrumentationKey);
                            n.exists(r, (function(e) {
                                e && n.readdir(r, (function(e, o) {
                                    if (e) t._onErrorHelper(e);
                                    else if ((o = o.filter((function(e) {
                                            return i.basename(e).indexOf(".ai.json") > -1
                                        }))).length > 0) {
                                        var s = o[0],
                                            a = i.join(r, s);
                                        n.readFile(a, (function(e, r) {
                                            e ? t._onErrorHelper(e) : n.unlink(a, (function(e) {
                                                e ? t._onErrorHelper(e) : t.send(r)
                                            }))
                                        }))
                                    }
                                }))
                            }))
                        }, e.prototype._onErrorHelper = function(e) {
                            "function" == typeof this._onError && this._onError(e)
                        }, e.TAG = "Sender", e.ICACLS_PATH = process.env.systemdrive + "/windows/system32/icacls.exe", e.POWERSHELL_PATH = process.env.systemdrive + "/windows/system32/windowspowershell/v1.0/powershell.exe", e.ACLED_DIRECTORIES = {}, e.ACL_IDENTITY = null, e.WAIT_BETWEEN_RESEND = 6e4, e.MAX_BYTES_ON_DISK = 5e7, e.MAX_CONNECTION_FAILURES_BEFORE_WARN = 5, e.TEMPDIR_PREFIX = "appInsights-node", e.OS_PROVIDES_FILE_PROTECTION = !1, e.USE_ICACLS = "Windows_NT" === o.type(), e
                    }();
                e.exports = d
            },
            7625: (e, t, r) => {
                "use strict";
                var n = r(7310),
                    o = r(9253),
                    i = r(4470),
                    s = r(5290),
                    a = r(3504),
                    c = r(9428),
                    l = r(894),
                    u = r(2588),
                    d = r(5740),
                    p = r(5282),
                    h = r(9813),
                    f = function() {
                        function e(e) {
                            this._telemetryProcessors = [];
                            var t = new o(e);
                            this.config = t, this.context = new i, this.commonProperties = {};
                            var r = new u(this.config);
                            this.channel = new a((function() {
                                return t.disableAppInsights
                            }), (function() {
                                return t.maxBatchSize
                            }), (function() {
                                return t.maxBatchIntervalMs
                            }), r)
                        }
                        return e.prototype.trackAvailability = function(e) {
                            this.track(e, s.TelemetryType.Availability)
                        }, e.prototype.trackTrace = function(e) {
                            this.track(e, s.TelemetryType.Trace)
                        }, e.prototype.trackMetric = function(e) {
                            this.track(e, s.TelemetryType.Metric)
                        }, e.prototype.trackException = function(e) {
                            e && e.exception && !d.isError(e.exception) && (e.exception = new Error(e.exception.toString())), this.track(e, s.TelemetryType.Exception)
                        }, e.prototype.trackEvent = function(e) {
                            this.track(e, s.TelemetryType.Event)
                        }, e.prototype.trackRequest = function(e) {
                            this.track(e, s.TelemetryType.Request)
                        }, e.prototype.trackDependency = function(e) {
                            e && !e.target && e.data && (e.target = n.parse(e.data).host), this.track(e, s.TelemetryType.Dependency)
                        }, e.prototype.flush = function(e) {
                            this.channel.triggerSend(!!e && !!e.isAppCrashing, e ? e.callback : void 0)
                        }, e.prototype.track = function(e, t) {
                            if (e && s.telemetryTypeToBaseType(t)) {
                                var r = h.createEnvelope(e, t, this.commonProperties, this.context, this.config);
                                e.time && (r.time = e.time.toISOString());
                                var n = this.runTelemetryProcessors(r, e.contextObjects);
                                n = n && c.samplingTelemetryProcessor(r, {
                                    correlationContext: l.CorrelationContextManager.getCurrentContext()
                                }), c.performanceMetricsTelemetryProcessor(r, this.quickPulseClient), n && this.channel.send(r)
                            } else p.warn("track() requires telemetry object and telemetryType to be specified.")
                        }, e.prototype.addTelemetryProcessor = function(e) {
                            this._telemetryProcessors.push(e)
                        }, e.prototype.clearTelemetryProcessors = function() {
                            this._telemetryProcessors = []
                        }, e.prototype.runTelemetryProcessors = function(e, t) {
                            var r = !0,
                                n = this._telemetryProcessors.length;
                            if (0 === n) return r;
                            (t = t || {}).correlationContext = l.CorrelationContextManager.getCurrentContext();
                            for (var o = 0; o < n; ++o) try {
                                var i = this._telemetryProcessors[o];
                                if (i && !1 === i.apply(null, [e, t])) {
                                    r = !1;
                                    break
                                }
                            } catch (t) {
                                r = !0, p.warn("One of telemetry processors failed, telemetry item will be sent.", t, e)
                            }
                            return r
                        }, e
                    }();
                e.exports = f
            },
            8090: (e, t, r) => {
                "use strict";
                var n = r(5740),
                    o = r(9962),
                    i = function() {
                        function e(t, r) {
                            if (this.traceFlag = e.DEFAULT_TRACE_FLAG, this.version = e.DEFAULT_VERSION, t && "string" == typeof t)
                                if (t.split(",").length > 1) this.traceId = n.w3cTraceId(), this.spanId = n.w3cTraceId().substr(0, 16);
                                else {
                                    var i = t.trim().split("-"),
                                        s = i.length;
                                    s >= 4 ? (this.version = i[0], this.traceId = i[1], this.spanId = i[2], this.traceFlag = i[3]) : (this.traceId = n.w3cTraceId(), this.spanId = n.w3cTraceId().substr(0, 16)), this.version.match(/^[0-9a-f]{2}$/g) || (this.version = e.DEFAULT_VERSION, this.traceId = n.w3cTraceId()), "00" === this.version && 4 !== s && (this.traceId = n.w3cTraceId(), this.spanId = n.w3cTraceId().substr(0, 16)), "ff" === this.version && (this.version = e.DEFAULT_VERSION, this.traceId = n.w3cTraceId(), this.spanId = n.w3cTraceId().substr(0, 16)), this.version.match(/^0[0-9a-f]$/g) || (this.version = e.DEFAULT_VERSION), this.traceFlag.match(/^[0-9a-f]{2}$/g) || (this.traceFlag = e.DEFAULT_TRACE_FLAG, this.traceId = n.w3cTraceId()), e.isValidTraceId(this.traceId) || (this.traceId = n.w3cTraceId()), e.isValidSpanId(this.spanId) || (this.spanId = n.w3cTraceId().substr(0, 16), this.traceId = n.w3cTraceId()), this.parentId = this.getBackCompatRequestId()
                                }
                            else if (r) {
                                this.parentId = r.slice();
                                var a = o.getRootId(r);
                                e.isValidTraceId(a) || (this.legacyRootId = a, a = n.w3cTraceId()), -1 !== r.indexOf("|") && (r = r.substring(1 + r.substring(0, r.length - 1).lastIndexOf("."), r.length - 1)), this.traceId = a, this.spanId = r
                            } else this.traceId = n.w3cTraceId(), this.spanId = n.w3cTraceId().substr(0, 16)
                        }
                        return e.isValidTraceId = function(e) {
                            return e.match(/^[0-9a-f]{32}$/) && "00000000000000000000000000000000" !== e
                        }, e.isValidSpanId = function(e) {
                            return e.match(/^[0-9a-f]{16}$/) && "0000000000000000" !== e
                        }, e.prototype.getBackCompatRequestId = function() {
                            return "|" + this.traceId + "." + this.spanId + "."
                        }, e.prototype.toString = function() {
                            return this.version + "-" + this.traceId + "-" + this.spanId + "-" + this.traceFlag
                        }, e.prototype.updateSpanId = function() {
                            this.spanId = n.w3cTraceId().substr(0, 16)
                        }, e.DEFAULT_TRACE_FLAG = "01", e.DEFAULT_VERSION = "00", e
                    }();
                e.exports = i
            },
            1974: e => {
                "use strict";
                var t = function() {
                    function e(e) {
                        this.fieldmap = [], e && (this.fieldmap = this.parseHeader(e))
                    }
                    return e.prototype.toString = function() {
                        var e = this.fieldmap;
                        return e && 0 != e.length ? e.join(", ") : null
                    }, e.validateKeyChars = function(e) {
                        var t = e.split("@");
                        if (2 == t.length) {
                            var r = t[0].trim(),
                                n = t[1].trim(),
                                o = Boolean(r.match(/^[\ ]?[a-z0-9\*\-\_/]{1,241}$/)),
                                i = Boolean(n.match(/^[\ ]?[a-z0-9\*\-\_/]{1,14}$/));
                            return o && i
                        }
                        return 1 == t.length && Boolean(e.match(/^[\ ]?[a-z0-9\*\-\_/]{1,256}$/))
                    }, e.prototype.parseHeader = function(t) {
                        var r = [],
                            n = {},
                            o = t.split(",");
                        if (o.length > 32) return null;
                        for (var i = 0, s = o; i < s.length; i++) {
                            var a = s[i].trim();
                            if (0 !== a.length) {
                                var c = a.split("=");
                                if (2 !== c.length) return null;
                                if (!e.validateKeyChars(c[0])) return null;
                                if (n[c[0]]) return null;
                                n[c[0]] = !0, r.push(a)
                            }
                        }
                        return r
                    }, e.strict = !0, e
                }();
                e.exports = t
            },
            5740: function(e, t, r) {
                "use strict";
                var n = this && this.__assign || Object.assign || function(e) {
                        for (var t, r = 1, n = arguments.length; r < n; r++)
                            for (var o in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
                        return e
                    },
                    o = r(3685),
                    i = r(5687),
                    s = r(7310),
                    a = r(2057),
                    c = r(5282),
                    l = r(9036),
                    u = function() {
                        function e() {}
                        return e.getCookie = function(t, r) {
                            var n = "";
                            if (t && t.length && "string" == typeof r)
                                for (var o = t + "=", i = r.split(";"), s = 0; s < i.length; s++)
                                    if (r = i[s], (r = e.trim(r)) && 0 === r.indexOf(o)) {
                                        n = r.substring(o.length, i[s].length);
                                        break
                                    }
                            return n
                        }, e.trim = function(e) {
                            return "string" == typeof e ? e.replace(/^\s+|\s+$/g, "") : ""
                        }, e.int32ArrayToBase64 = function(e) {
                            var t = function(e, t) {
                                    return String.fromCharCode(e >> t & 255)
                                },
                                r = e.map((function(e) {
                                    return t(e, 24) + t(e, 16) + t(e, 8) + t(e, 0)
                                })).join(""),
                                n = (Buffer.from ? Buffer.from(r, "binary") : new Buffer(r, "binary")).toString("base64");
                            return n.substr(0, n.indexOf("="))
                        }, e.random32 = function() {
                            return 4294967296 * Math.random() | 0
                        }, e.randomu32 = function() {
                            return e.random32() + 2147483648
                        }, e.w3cTraceId = function() {
                            for (var t, r = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"], n = "", o = 0; o < 4; o++) n += r[15 & (t = e.random32())] + r[t >> 4 & 15] + r[t >> 8 & 15] + r[t >> 12 & 15] + r[t >> 16 & 15] + r[t >> 20 & 15] + r[t >> 24 & 15] + r[t >> 28 & 15];
                            var i = r[8 + 4 * Math.random() | 0];
                            return n.substr(0, 8) + n.substr(9, 4) + "4" + n.substr(13, 3) + i + n.substr(16, 3) + n.substr(19, 12)
                        }, e.isValidW3CId = function(e) {
                            return 32 === e.length && "00000000000000000000000000000000" !== e
                        }, e.isArray = function(e) {
                            return "[object Array]" === Object.prototype.toString.call(e)
                        }, e.isError = function(e) {
                            return e instanceof Error
                        }, e.isPrimitive = function(e) {
                            var t = typeof e;
                            return "string" === t || "number" === t || "boolean" === t
                        }, e.isDate = function(e) {
                            return "[object Date]" === Object.prototype.toString.call(e)
                        }, e.msToTimeSpan = function(e) {
                            (isNaN(e) || e < 0) && (e = 0);
                            var t = (e / 1e3 % 60).toFixed(7).replace(/0{0,4}$/, ""),
                                r = "" + Math.floor(e / 6e4) % 60,
                                n = "" + Math.floor(e / 36e5) % 24,
                                o = Math.floor(e / 864e5);
                            return t = t.indexOf(".") < 2 ? "0" + t : t, r = r.length < 2 ? "0" + r : r, (o > 0 ? o + "." : "") + (n = n.length < 2 ? "0" + n : n) + ":" + r + ":" + t
                        }, e.extractError = function(e) {
                            var t = e;
                            return {
                                message: e.message,
                                code: t.code || t.id || ""
                            }
                        }, e.extractObject = function(t) {
                            return t instanceof Error ? e.extractError(t) : "function" == typeof t.toJSON ? t.toJSON() : t
                        }, e.validateStringMap = function(t) {
                            if ("object" == typeof t) {
                                var r = {};
                                for (var n in t) {
                                    var o = "",
                                        i = t[n],
                                        s = typeof i;
                                    if (e.isPrimitive(i)) o = i.toString();
                                    else if (null === i || "undefined" === s) o = "";
                                    else {
                                        if ("function" === s) {
                                            c.info("key: " + n + " was function; will not serialize");
                                            continue
                                        }
                                        var a = e.isArray(i) ? i : e.extractObject(i);
                                        try {
                                            o = e.isPrimitive(a) ? a : JSON.stringify(a)
                                        } catch (e) {
                                            o = i.constructor.name.toString() + " (Error: " + e.message + ")", c.info("key: " + n + ", could not be serialized")
                                        }
                                    }
                                    r[n] = o.substring(0, e.MAX_PROPERTY_LENGTH)
                                }
                                return r
                            }
                            c.info("Invalid properties dropped from payload")
                        }, e.canIncludeCorrelationHeader = function(e, t) {
                            var r = e && e.config && e.config.correlationHeaderExcludedDomains;
                            if (!r || 0 == r.length || !t) return !0;
                            for (var n = 0; n < r.length; n++)
                                if (new RegExp(r[n].replace(/\./g, ".").replace(/\*/g, ".*")).test(s.parse(t).hostname)) return !1;
                            return !0
                        }, e.getCorrelationContextTarget = function(e, t) {
                            var r = e.headers && e.headers[l.requestContextHeader];
                            if (r)
                                for (var n = r.split(","), o = 0; o < n.length; ++o) {
                                    var i = n[o].split("=");
                                    if (2 == i.length && i[0] == t) return i[1]
                                }
                        }, e.makeRequest = function(t, r, a, l) {
                            r && 0 === r.indexOf("//") && (r = "https:" + r);
                            var u = s.parse(r),
                                d = n({}, a, {
                                    host: u.hostname,
                                    port: u.port,
                                    path: u.pathname
                                }),
                                p = void 0;
                            if ("https:" === u.protocol && (p = t.proxyHttpsUrl || void 0), "http:" === u.protocol && (p = t.proxyHttpUrl || void 0), p) {
                                0 === p.indexOf("//") && (p = "http:" + p);
                                var h = s.parse(p);
                                "https:" === h.protocol ? (c.info("Proxies that use HTTPS are not supported"), p = void 0) : d = n({}, d, {
                                    host: h.hostname,
                                    port: h.port || "80",
                                    path: r,
                                    headers: n({}, d.headers, {
                                        Host: u.hostname
                                    })
                                })
                            }
                            var f = "https:" === u.protocol && !p;
                            return f && void 0 !== t.httpsAgent ? d.agent = t.httpsAgent : f || void 0 === t.httpAgent ? f && (d.agent = e.tlsRestrictedAgent) : d.agent = t.httpAgent, f ? i.request(d, l) : o.request(d, l)
                        }, e.safeIncludeCorrelationHeader = function(t, r, n) {
                            var o;
                            if ("string" == typeof n) o = n;
                            else if (n instanceof Array) o = n.join(",");
                            else if (n && "function" == typeof n.toString) try {
                                o = n.toString()
                            } catch (e) {
                                c.warn("Outgoing request-context header could not be read. Correlation of requests may be lost.", e, n)
                            }
                            o ? e.addCorrelationIdHeaderFromString(t, r, o) : r.setHeader(l.requestContextHeader, l.requestContextSourceKey + "=" + t.config.correlationId)
                        }, e.addCorrelationIdHeaderFromString = function(e, t, r) {
                            var n = r.split(","),
                                o = l.requestContextSourceKey + "=";
                            n.some((function(e) {
                                return e.substring(0, o.length) === o
                            })) || t.setHeader(l.requestContextHeader, r + "," + l.requestContextSourceKey + "=" + e.config.correlationId)
                        }, e.MAX_PROPERTY_LENGTH = 8192, e.tlsRestrictedAgent = new i.Agent({
                            secureOptions: a.SSL_OP_NO_SSLv2 | a.SSL_OP_NO_SSLv3 | a.SSL_OP_NO_TLSv1 | a.SSL_OP_NO_TLSv1_1
                        }), e
                    }();
                e.exports = u
            },
            4127: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(4350),
                    o = r(5290);
                t.performanceMetricsTelemetryProcessor = function(e, t) {
                    switch (t && t.addDocument(e), e.data.baseType) {
                        case o.TelemetryTypeString.Exception:
                            n.countException();
                            break;
                        case o.TelemetryTypeString.Request:
                            var r = e.data.baseData;
                            n.countRequest(r.duration, r.success);
                            break;
                        case o.TelemetryTypeString.Dependency:
                            var i = e.data.baseData;
                            n.countDependency(i.duration, i.success)
                    }
                    return !0
                }
            },
            608: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(5290);

                function o(e) {
                    var t = 2147483647,
                        r = 5381;
                    if (!e) return 0;
                    for (; e.length < 8;) e += e;
                    for (var n = 0; n < e.length; n++) r = ((r << 5) + r | 0) + e.charCodeAt(n) | 0;
                    return (r = r <= -2147483648 ? t : Math.abs(r)) / t * 100
                }
                t.samplingTelemetryProcessor = function(e, t) {
                    var r = e.sampleRate;
                    return null == r || r >= 100 || !(!e.data || n.TelemetryType.Metric !== n.baseTypeToTelemetryType(e.data.baseType)) || (t.correlationContext && t.correlationContext.operation ? o(t.correlationContext.operation.id) < r : 100 * Math.random() < r)
                }, t.getSamplingHashCode = o
            },
            9428: (e, t, r) => {
                "use strict";

                function n(e) {
                    for (var r in e) t.hasOwnProperty(r) || (t[r] = e[r])
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), n(r(608)), n(r(4127))
            },
            9574: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n, o = r(894),
                    i = r(6281),
                    s = r(6639),
                    a = r(4350),
                    c = r(8723),
                    l = r(731),
                    u = r(9962),
                    d = r(5282),
                    p = r(3668),
                    h = r(1629);
                t.TelemetryClient = r(1259), t.Contracts = r(5290),
                    function(e) {
                        e[e.AI = 0] = "AI", e[e.AI_AND_W3C = 1] = "AI_AND_W3C"
                    }(n = t.DistributedTracingModes || (t.DistributedTracingModes = {}));
                var f, m, g, _, y, v, b, w, x, E = !0,
                    C = !1,
                    S = !0,
                    T = !0,
                    k = !0,
                    I = !0,
                    P = !0,
                    A = !0,
                    O = !1,
                    N = !0,
                    R = void 0,
                    $ = void 0,
                    M = !1;

                function D() {
                    return t.defaultClient ? (M = !0, g.enable(E, C), _.enable(S), y.enable(T), v.enable(N, m), b.useAutoCorrelation(A, f), b.enable(k), w.enable(I), t.liveMetricsClient && O && t.liveMetricsClient.enable(O)) : d.warn("Start cannot be called before setup"), L
                }
                t.setup = function(e) {
                    return t.defaultClient ? d.info("The default client is already setup") : (t.defaultClient = new t.TelemetryClient(e), g = new i(t.defaultClient), _ = new s(t.defaultClient), y = new a(t.defaultClient), b = new l(t.defaultClient), w = new c(t.defaultClient), v || (v = new h.AutoCollectNativePerformance(t.defaultClient))), t.defaultClient && t.defaultClient.channel && t.defaultClient.channel.setUseDiskRetryCaching(P, R, $), L
                }, t.start = D, t.getCorrelationContext = function() {
                    return A ? o.CorrelationContextManager.getCurrentContext() : null
                }, t.wrapWithCorrelationContext = function(e) {
                    return o.CorrelationContextManager.wrapCallback(e)
                };
                var L = function() {
                    function e() {}
                    return e.setDistributedTracingMode = function(t) {
                        return u.w3cEnabled = t === n.AI_AND_W3C, e
                    }, e.setAutoCollectConsole = function(t, r) {
                        return void 0 === r && (r = !1), E = t, C = r, M && g.enable(t, r), e
                    }, e.setAutoCollectExceptions = function(t) {
                        return S = t, M && _.enable(t), e
                    }, e.setAutoCollectPerformance = function(t, r) {
                        void 0 === r && (r = !0), T = t;
                        var n = h.AutoCollectNativePerformance.parseEnabled(r);
                        return N = n.isEnabled, m = n.disabledMetrics, M && (y.enable(t), v.enable(n.isEnabled, n.disabledMetrics)), e
                    }, e.setAutoCollectRequests = function(t) {
                        return k = t, M && b.enable(t), e
                    }, e.setAutoCollectDependencies = function(t) {
                        return I = t, M && w.enable(t), e
                    }, e.setAutoDependencyCorrelation = function(t, r) {
                        return A = t, f = r, M && b.useAutoCorrelation(t, r), e
                    }, e.setUseDiskRetryCaching = function(r, n, o) {
                        return P = r, R = n, $ = o, t.defaultClient && t.defaultClient.channel && t.defaultClient.channel.setUseDiskRetryCaching(r, n, o), e
                    }, e.setInternalLogging = function(t, r) {
                        return void 0 === t && (t = !1), void 0 === r && (r = !0), d.enableDebug = t, d.disableWarnings = !r, e
                    }, e.setSendLiveMetrics = function(r) {
                        return void 0 === r && (r = !1), t.defaultClient ? (!t.liveMetricsClient && r ? (t.liveMetricsClient = new p(t.defaultClient.config.instrumentationKey), x = new a(t.liveMetricsClient, 1e3, !0), t.liveMetricsClient.addCollector(x), t.defaultClient.quickPulseClient = t.liveMetricsClient) : t.liveMetricsClient && t.liveMetricsClient.enable(r), O = r, e) : (d.warn("Live metrics client cannot be setup without the default client"), e)
                    }, e.start = D, e
                }();
                t.Configuration = L, t.dispose = function() {
                    t.defaultClient = null, M = !1, g && g.dispose(), _ && _.dispose(), y && y.dispose(), v && v.dispose(), b && b.dispose(), w && w.dispose(), t.liveMetricsClient && (t.liveMetricsClient.enable(!1), O = !1, t.liveMetricsClient = void 0)
                }
            },
            9822: (e, t, r) => {
                "use strict";
                const n = process.binding("async_wrap"),
                    o = n.Providers.TIMERWRAP,
                    i = {
                        nextTick: r(3269),
                        promise: r(9565),
                        timers: r(7190)
                    },
                    s = new Set;

                function a() {
                    this.enabled = !1, this.counter = 0
                }

                function c() {
                    const e = this.initFns = [],
                        t = this.preFns = [],
                        r = this.postFns = [],
                        n = this.destroyFns = [];
                    this.init = function(t, r, n, i) {
                        if (r !== o)
                            for (const o of e) o(t, this, r, n, i);
                        else s.add(t)
                    }, this.pre = function(e) {
                        if (!s.has(e))
                            for (const r of t) r(e, this)
                    }, this.post = function(e, t) {
                        if (!s.has(e))
                            for (const n of r) n(e, this, t)
                    }, this.destroy = function(e) {
                        if (s.has(e)) s.delete(e);
                        else
                            for (const t of n) t(e)
                    }
                }

                function l(e, t) {
                    const r = e.indexOf(t); - 1 !== r && e.splice(r, 1)
                }

                function u() {
                    this._state = new a, this._hooks = new c, this.version = r(6157).i8, this.providers = n.Providers;
                    for (const e of Object.keys(i)) i[e].call(this);
                    process.env.hasOwnProperty("NODE_ASYNC_HOOK_WARNING") && console.warn("warning: you are using async-hook-jl which is unstable."), n.setupHooks({
                        init: this._hooks.init,
                        pre: this._hooks.pre,
                        post: this._hooks.post,
                        destroy: this._hooks.destroy
                    })
                }
                c.prototype.add = function(e) {
                    e.init && this.initFns.push(e.init), e.pre && this.preFns.push(e.pre), e.post && this.postFns.push(e.post), e.destroy && this.destroyFns.push(e.destroy)
                }, c.prototype.remove = function(e) {
                    e.init && l(this.initFns, e.init), e.pre && l(this.preFns, e.pre), e.post && l(this.postFns, e.post), e.destroy && l(this.destroyFns, e.destroy)
                }, e.exports = u, u.prototype.addHooks = function(e) {
                    this._hooks.add(e)
                }, u.prototype.removeHooks = function(e) {
                    this._hooks.remove(e)
                }, u.prototype.enable = function() {
                    this._state.enabled = !0, n.enable()
                }, u.prototype.disable = function() {
                    this._state.enabled = !1, n.disable()
                }
            },
            3223: (e, t, r) => {
                "use strict";
                const n = r(9822);
                if (global._asyncHook) {
                    if (global._asyncHook.version !== r(6157).i8) throw new Error("Conflicting version of async-hook-jl found");
                    e.exports = global._asyncHook
                } else r(2512).filter.attach((function(e, t) {
                    return t.filter((function(e) {
                        const t = e.getFileName();
                        return !(t && t.slice(0, __dirname.length) === __dirname)
                    }))
                })), e.exports = global._asyncHook = new n
            },
            3269: e => {
                "use strict";

                function t() {}
                e.exports = function() {
                    const e = this._hooks,
                        r = this._state,
                        n = process.nextTick;
                    process.nextTick = function() {
                        if (!r.enabled) return n.apply(process, arguments);
                        const o = new Array(arguments.length);
                        for (let e = 0; e < arguments.length; e++) o[e] = arguments[e];
                        const i = o[0];
                        if ("function" != typeof i) throw new TypeError("callback is not a function");
                        const s = new t,
                            a = --r.counter;
                        return e.init.call(s, a, 0, null, null), o[0] = function() {
                            e.pre.call(s, a);
                            let t = !0;
                            try {
                                i.apply(this, arguments), t = !1
                            } finally {
                                t && process.listenerCount("uncaughtException") > 0 && process.once("uncaughtException", (function() {
                                    e.post.call(s, a, !0), e.destroy.call(null, a)
                                }))
                            }
                            e.post.call(s, a, !1), e.destroy.call(null, a)
                        }, n.apply(process, o)
                    }
                }
            },
            9565: e => {
                "use strict";

                function t() {}
                e.exports = function() {
                    const e = this._hooks,
                        r = this._state,
                        n = global.Promise,
                        o = n.prototype.then;

                    function i(t, r, n, o) {
                        return "function" != typeof t ? o ? function(t) {
                            return function(r) {
                                return e.destroy.call(null, t), r
                            }
                        }(n) : function(t) {
                            return function(r) {
                                throw e.destroy.call(null, t), r
                            }
                        }(n) : function() {
                            e.pre.call(r, n);
                            try {
                                return t.apply(this, arguments)
                            } finally {
                                e.post.call(r, n, !1), e.destroy.call(null, n)
                            }
                        }
                    }
                    n.prototype.then = function(n, s) {
                        if (!r.enabled) return o.call(this, n, s);
                        const a = new t,
                            c = --r.counter;
                        return e.init.call(a, c, 0, null, null), o.call(this, i(n, a, c, !0), i(s, a, c, !1))
                    }
                }
            },
            7190: (e, t, r) => {
                "use strict";
                const n = r(9512);

                function o() {}

                function i() {}

                function s() {}
                const a = new Map,
                    c = new Map,
                    l = new Map;
                let u = null,
                    d = !1;

                function p(e, t, r, o, i, s, a) {
                    const c = n[r],
                        l = n[o];
                    n[r] = function() {
                        if (!t.enabled) return c.apply(n, arguments);
                        const r = new Array(arguments.length);
                        for (let e = 0; e < arguments.length; e++) r[e] = arguments[e];
                        const o = r[0];
                        if ("function" != typeof o) throw new TypeError('"callback" argument must be a function');
                        const l = new i,
                            p = --t.counter;
                        let h;
                        return e.init.call(l, p, 0, null, null), r[0] = function() {
                            u = h, e.pre.call(l, p);
                            let t = !0;
                            try {
                                o.apply(this, arguments), t = !1
                            } finally {
                                t && process.listenerCount("uncaughtException") > 0 && process.once("uncaughtException", (function() {
                                    e.post.call(l, p, !0), s.delete(h), e.destroy.call(null, p)
                                }))
                            }
                            e.post.call(l, p, !1), u = null, (a || d) && (d = !1, s.delete(h), e.destroy.call(null, p))
                        }, h = c.apply(n, r), s.set(h, p), h
                    }, n[o] = function(t) {
                        if (u === t && null !== t) d = !0;
                        else if (s.has(t)) {
                            const r = s.get(t);
                            s.delete(t), e.destroy.call(null, r)
                        }
                        l.apply(n, arguments)
                    }
                }
                e.exports = function() {
                    p(this._hooks, this._state, "setTimeout", "clearTimeout", o, a, !0), p(this._hooks, this._state, "setInterval", "clearInterval", i, c, !1), p(this._hooks, this._state, "setImmediate", "clearImmediate", s, l, !0), global.setTimeout = n.setTimeout, global.setInterval = n.setInterval, global.setImmediate = n.setImmediate, global.clearTimeout = n.clearTimeout, global.clearInterval = n.clearInterval, global.clearImmediate = n.clearImmediate
                }
            },
            8286: e => {
                "use strict";
                e.exports = (e, t) => class extends e {
                    constructor(e) {
                        var r, n;
                        super((function(e, i) {
                            r = this, n = [function(r) {
                                return t(o, !1), e(r)
                            }, function(e) {
                                return t(o, !1), i(e)
                            }]
                        }));
                        var o = this;
                        try {
                            e.apply(r, n)
                        } catch (e) {
                            n[1](e)
                        }
                        return o
                    }
                }
            },
            9090: (e, t, r) => {
                var n, o, i = r(6372).wrap,
                    s = [],
                    a = 0,
                    c = !1,
                    l = [];

                function u(e, t) {
                    var r = e.length,
                        n = t.length,
                        o = [];
                    if (0 === r && 0 === n) return o;
                    for (var i = 0; i < r; i++) o[i] = e[i];
                    if (0 === n) return o;
                    for (var s = 0; s < n; s++) {
                        var a = !0;
                        for (i = 0; i < r; i++)
                            if (e[i].uid === t[s].uid) {
                                a = !1;
                                break
                            }
                        a && o.push(t[s])
                    }
                    return o
                }
                if (process._fatalException) {
                    var d, p = !1;
                    n = function(e) {
                        var t = s.length;
                        if (p || 0 === t) return !1;
                        var r = !1;
                        p = !0;
                        for (var n = 0; n < t; ++n) {
                            var o = s[n];
                            if (0 != (8 & o.flags)) {
                                var i = d && d[o.uid];
                                r = o.error(i, e) || r
                            }
                        }
                        return p = !1, l.length > 0 && (s = l.pop()), d = void 0, r && !c
                    }, o = function(e, t, r) {
                        var n = [];
                        c = !0;
                        for (var o = 0; o < r; ++o) {
                            var i = t[o];
                            if (n[i.uid] = i.data, 0 != (1 & i.flags)) {
                                var a = i.create(i.data);
                                void 0 !== a && (n[i.uid] = a)
                            }
                        }
                        return c = !1,
                            function() {
                                d = n, l.push(s), s = u(t, s), c = !0;
                                for (var o = 0; o < r; ++o)(2 & t[o].flags) > 0 && t[o].before(this, n[t[o].uid]);
                                c = !1;
                                var i = e.apply(this, arguments);
                                for (c = !0, o = 0; o < r; ++o)(4 & t[o].flags) > 0 && t[o].after(this, n[t[o].uid]);
                                return c = !1, s = l.pop(), d = void 0, i
                            }
                    }, i(process, "_fatalException", (function(e) {
                        return function(t) {
                            return n(t) || e(t)
                        }
                    }))
                } else {
                    var h = !1;
                    n = function(e) {
                        if (h) throw e;
                        for (var t = !1, r = s.length, n = 0; n < r; ++n) {
                            var o = s[n];
                            0 != (8 & o.flags) && (t = o.error(null, e) || t)
                        }
                        if (!t && c) throw e
                    }, o = function(e, t, r) {
                        var o = [];
                        c = !0;
                        for (var i = 0; i < r; ++i) {
                            var a = t[i];
                            if (o[a.uid] = a.data, 0 != (1 & a.flags)) {
                                var d = a.create(a.data);
                                void 0 !== d && (o[a.uid] = d)
                            }
                        }
                        return c = !1,
                            function() {
                                var i, a = !1,
                                    d = !1;
                                l.push(s), s = u(t, s), c = !0;
                                for (var p = 0; p < r; ++p)(2 & t[p].flags) > 0 && t[p].before(this, o[t[p].uid]);
                                c = !1;
                                try {
                                    i = e.apply(this, arguments)
                                } catch (e) {
                                    for (a = !0, p = 0; p < r; ++p)
                                        if (0 != (8 & s[p].flags)) try {
                                            d = s[p].error(o[t[p].uid], e) || d
                                        } catch (e) {
                                            throw h = !0, e
                                        }
                                    if (!d) throw process.removeListener("uncaughtException", n), process._originalNextTick((function() {
                                        process.addListener("uncaughtException", n)
                                    })), e
                                } finally {
                                    if (!a || d) {
                                        for (c = !0, p = 0; p < r; ++p)(4 & t[p].flags) > 0 && t[p].after(this, o[t[p].uid]);
                                        c = !1
                                    }
                                    s = l.pop()
                                }
                                return i
                            }
                    }, process.addListener("uncaughtException", n)
                }

                function f(e, t) {
                    "function" == typeof e.create && (this.create = e.create, this.flags |= 1), "function" == typeof e.before && (this.before = e.before, this.flags |= 2), "function" == typeof e.after && (this.after = e.after, this.flags |= 4), "function" == typeof e.error && (this.error = e.error, this.flags |= 8), this.uid = ++a, this.data = void 0 === t ? null : t
                }

                function m(e, t) {
                    if ("object" != typeof e || !e) throw new TypeError("callbacks argument must be an object");
                    return e instanceof f ? e : new f(e, t)
                }
                f.prototype.create = void 0, f.prototype.before = void 0, f.prototype.after = void 0, f.prototype.error = void 0, f.prototype.data = void 0, f.prototype.uid = 0, f.prototype.flags = 0, process.createAsyncListener = m, process.addAsyncListener = function(e, t) {
                    var r;
                    r = e instanceof f ? e : m(e, t);
                    for (var n = !1, o = 0; o < s.length; o++)
                        if (r === s[o]) {
                            n = !0;
                            break
                        }
                    return n || s.push(r), r
                }, process.removeAsyncListener = function(e) {
                    for (var t = 0; t < s.length; t++)
                        if (e === s[t]) {
                            s.splice(t, 1);
                            break
                        }
                }, e.exports = function(e) {
                    var t = s.length;
                    if (0 === t) return e;
                    for (var r = s.slice(), n = 0; n < t; ++n)
                        if (r[n].flags > 0) return o(e, r, t);
                    return function(e, t, r) {
                        c = !0;
                        for (var n = 0; n < r; ++n) {
                            var o = t[n];
                            o.create && o.create(o.data)
                        }
                        return c = !1,
                            function() {
                                l.push(s), s = u(t, s);
                                var r = e.apply(this, arguments);
                                return s = l.pop(), r
                            }
                    }(e, r, t)
                }
            },
            7645: (e, t, r) => {
                "use strict";
                if (process.addAsyncListener) throw new Error("Don't require polyfill unless needed");
                var n = r(6372),
                    o = r(2249),
                    i = n.wrap,
                    s = n.massWrap,
                    a = r(9090),
                    c = r(3837),
                    l = o.gte(process.version, "6.0.0"),
                    u = o.gte(process.version, "7.0.0"),
                    d = o.gte(process.version, "8.0.0"),
                    p = o.gte(process.version, "11.0.0"),
                    h = r(1808);

                function f(e) {
                    return function() {
                        this.on("connection", (function(e) {
                            e._handle && (e._handle.onread = a(e._handle.onread))
                        }));
                        try {
                            return e.apply(this, arguments)
                        } finally {
                            this._handle && this._handle.onconnection && (this._handle.onconnection = a(this._handle.onconnection))
                        }
                    }
                }

                function m(e) {
                    if (e && e._handle) {
                        var t = e._handle;
                        t._originalOnread || (t._originalOnread = t.onread), t.onread = a(t._originalOnread)
                    }
                }
                u && !h._normalizeArgs ? h._normalizeArgs = function(e) {
                    if (0 === e.length) return [{}, null];
                    var t, r, n = e[0],
                        o = {};
                    "object" == typeof n && null !== n ? o = n : "string" == typeof(t = n) && !1 === (r = t, (r = Number(r)) >= 0 && r) ? o.path = n : (o.port = n, e.length > 1 && "string" == typeof e[1] && (o.host = e[1]));
                    var i = e[e.length - 1];
                    return "function" != typeof i ? [o, null] : [o, i]
                } : u || h._normalizeConnectArgs || (h._normalizeConnectArgs = function(e) {
                    var t, r = {};
                    "object" == typeof e[0] && null !== e[0] ? r = e[0] : "string" == typeof e[0] && !1 === (t = e[0], (t = Number(t)) >= 0 && t) ? r.path = e[0] : (r.port = e[0], "string" == typeof e[1] && (r.host = e[1]));
                    var n = e[e.length - 1];
                    return "function" == typeof n ? [r, n] : [r]
                }), "_setUpListenHandle" in h.Server.prototype ? i(h.Server.prototype, "_setUpListenHandle", f) : i(h.Server.prototype, "_listen2", f), i(h.Socket.prototype, "connect", (function(e) {
                    return function() {
                        var t;
                        (t = d && Array.isArray(arguments[0]) && Object.getOwnPropertySymbols(arguments[0]).length > 0 ? arguments[0] : u ? h._normalizeArgs(arguments) : h._normalizeConnectArgs(arguments))[1] && (t[1] = a(t[1]));
                        var r = e.apply(this, t);
                        return m(this), r
                    }
                }));
                var g = r(3685);
                i(g.Agent.prototype, "addRequest", (function(e) {
                    return function(t) {
                        var r = t.onSocket;
                        return t.onSocket = a((function(e) {
                            return m(e), r.apply(this, arguments)
                        })), e.apply(this, arguments)
                    }
                }));
                var _ = r(2081);

                function y(e) {
                    Array.isArray(e.stdio) && e.stdio.forEach((function(e) {
                        e && e._handle && (e._handle.onread = a(e._handle.onread), i(e._handle, "close", N))
                    })), e._handle && (e._handle.onexit = a(e._handle.onexit))
                }
                _.ChildProcess ? i(_.ChildProcess.prototype, "spawn", (function(e) {
                    return function() {
                        var t = e.apply(this, arguments);
                        return y(this), t
                    }
                })) : s(_, ["execFile", "fork", "spawn"], (function(e) {
                    return function() {
                        var t = e.apply(this, arguments);
                        return y(t), t
                    }
                })), process._fatalException || (process._originalNextTick = process.nextTick);
                var v = [];
                process._nextDomainTick && v.push("_nextDomainTick"), process._tickDomainCallback && v.push("_tickDomainCallback"), s(process, v, O), i(process, "nextTick", N);
                var b = ["setTimeout", "setInterval"];
                global.setImmediate && b.push("setImmediate");
                var w = r(9512),
                    x = global.setTimeout === w.setTimeout;
                s(w, b, N), x && s(global, b, N);
                var E = r(9523);
                s(E, ["lookup", "resolve", "resolve4", "resolve6", "resolveCname", "resolveMx", "resolveNs", "resolveTxt", "resolveSrv", "reverse"], O), E.resolveNaptr && i(E, "resolveNaptr", O);
                var C, S, T = r(7147);
                s(T, ["watch", "rename", "truncate", "chown", "fchown", "chmod", "fchmod", "stat", "lstat", "fstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "mkdir", "readdir", "close", "open", "utimes", "futimes", "fsync", "write", "read", "readFile", "writeFile", "appendFile", "watchFile", "unwatchFile", "exists"], O), T.lchown && i(T, "lchown", O), T.lchmod && i(T, "lchmod", O), T.ftruncate && i(T, "ftruncate", O);
                try {
                    C = r(9796)
                } catch (e) {}
                if (C && C.Deflate && C.Deflate.prototype) {
                    var k = Object.getPrototypeOf(C.Deflate.prototype);
                    k._transform ? i(k, "_transform", O) : k.write && k.flush && k.end && s(k, ["write", "flush", "end"], O)
                }
                try {
                    S = r(6113)
                } catch (e) {}
                if (S) {
                    var I = ["pbkdf2", "randomBytes"];
                    p || I.push("pseudoRandomBytes"), s(S, I, O)
                }
                var P = !!global.Promise && "function Promise() { [native code] }" === Promise.toString() && "function toString() { [native code] }" === Promise.toString.toString();
                if (P) {
                    var A = process.addAsyncListener({
                        create: function() {
                            P = !1
                        }
                    });
                    global.Promise.resolve(!0).then((function() {
                        P = !1
                    })), process.removeAsyncListener(A)
                }

                function O(e) {
                    var t = function() {
                        var t, r = arguments.length - 1;
                        if ("function" == typeof arguments[r]) {
                            t = Array(arguments.length);
                            for (var n = 0; n < arguments.length - 1; n++) t[n] = arguments[n];
                            t[r] = a(arguments[r])
                        }
                        return e.apply(this, t || arguments)
                    };
                    switch (e.length) {
                        case 1:
                            return function(r) {
                                return 1 !== arguments.length ? t.apply(this, arguments) : ("function" == typeof r && (r = a(r)), e.call(this, r))
                            };
                        case 2:
                            return function(r, n) {
                                return 2 !== arguments.length ? t.apply(this, arguments) : ("function" == typeof n && (n = a(n)), e.call(this, r, n))
                            };
                        case 3:
                            return function(r, n, o) {
                                return 3 !== arguments.length ? t.apply(this, arguments) : ("function" == typeof o && (o = a(o)), e.call(this, r, n, o))
                            };
                        case 4:
                            return function(r, n, o, i) {
                                return 4 !== arguments.length ? t.apply(this, arguments) : ("function" == typeof i && (i = a(i)), e.call(this, r, n, o, i))
                            };
                        case 5:
                            return function(r, n, o, i, s) {
                                return 5 !== arguments.length ? t.apply(this, arguments) : ("function" == typeof s && (s = a(s)), e.call(this, r, n, o, i, s))
                            };
                        case 6:
                            return function(r, n, o, i, s, c) {
                                return 6 !== arguments.length ? t.apply(this, arguments) : ("function" == typeof c && (c = a(c)), e.call(this, r, n, o, i, s, c))
                            };
                        default:
                            return t
                    }
                }

                function N(e) {
                    var t = function() {
                        var t;
                        if ("function" == typeof arguments[0]) {
                            (t = Array(arguments.length))[0] = a(arguments[0]);
                            for (var r = 1; r < arguments.length; r++) t[r] = arguments[r]
                        }
                        return e.apply(this, t || arguments)
                    };
                    switch (e.length) {
                        case 1:
                            return function(r) {
                                return 1 !== arguments.length ? t.apply(this, arguments) : ("function" == typeof r && (r = a(r)), e.call(this, r))
                            };
                        case 2:
                            return function(r, n) {
                                return 2 !== arguments.length ? t.apply(this, arguments) : ("function" == typeof r && (r = a(r)), e.call(this, r, n))
                            };
                        case 3:
                            return function(r, n, o) {
                                return 3 !== arguments.length ? t.apply(this, arguments) : ("function" == typeof r && (r = a(r)), e.call(this, r, n, o))
                            };
                        case 4:
                            return function(r, n, o, i) {
                                return 4 !== arguments.length ? t.apply(this, arguments) : ("function" == typeof r && (r = a(r)), e.call(this, r, n, o, i))
                            };
                        case 5:
                            return function(r, n, o, i, s) {
                                return 5 !== arguments.length ? t.apply(this, arguments) : ("function" == typeof r && (r = a(r)), e.call(this, r, n, o, i, s))
                            };
                        case 6:
                            return function(r, n, o, i, s, c) {
                                return 6 !== arguments.length ? t.apply(this, arguments) : ("function" == typeof r && (r = a(r)), e.call(this, r, n, o, i, s, c))
                            };
                        default:
                            return t
                    }
                }
                P && function() {
                    var e = global.Promise;

                    function t(r) {
                        if (!(this instanceof t)) return e(r);
                        if ("function" != typeof r) return new e(r);
                        var o, i, s = new e((function(e, t) {
                            o = this, i = [function(t) {
                                return n(s, !1), e(t)
                            }, function(e) {
                                return n(s, !1), t(e)
                            }]
                        }));
                        s.__proto__ = t.prototype;
                        try {
                            r.apply(o, i)
                        } catch (e) {
                            i[1](e)
                        }
                        return s
                    }

                    function n(e, t) {
                        e.__asl_wrapper && !t || (e.__asl_wrapper = a(o))
                    }

                    function o(t, r, i, s) {
                        var a;
                        try {
                            return {
                                returnVal: a = r.call(t, i),
                                error: !1
                            }
                        } catch (e) {
                            return {
                                errorVal: e,
                                error: !0
                            }
                        } finally {
                            a instanceof e ? s.__asl_wrapper = function() {
                                return (a.__asl_wrapper || o).apply(this, arguments)
                            } : n(s, !0)
                        }
                    }

                    function s(e) {
                        return function() {
                            var t = this,
                                r = e.apply(t, Array.prototype.map.call(arguments, n));
                            return r.__asl_wrapper = function(e, n, i, s) {
                                return t.__asl_wrapper ? (t.__asl_wrapper(e, (function() {}), null, r), r.__asl_wrapper(e, n, i, s)) : o(e, n, i, s)
                            }, r;

                            function n(e) {
                                return "function" != typeof e ? e : a((function(n) {
                                    var i = (t.__asl_wrapper || o)(this, e, n, r);
                                    if (i.error) throw i.errorVal;
                                    return i.returnVal
                                }))
                            }
                        }
                    }
                    c.inherits(t, e), i(e.prototype, "then", s), e.prototype.chain && i(e.prototype, "chain", s), l ? global.Promise = r(8286)(e, n) : (["all", "race", "reject", "resolve", "accept", "defer"].forEach((function(r) {
                        "function" == typeof e[r] && (t[r] = e[r])
                    })), global.Promise = t)
                }()
            },
            2249: (e, t) => {
                var r;
                t = e.exports = V, r = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
                    var e = Array.prototype.slice.call(arguments, 0);
                    e.unshift("SEMVER"), console.log.apply(console, e)
                } : function() {}, t.SEMVER_SPEC_VERSION = "2.0.0";
                var n = Number.MAX_SAFE_INTEGER || 9007199254740991,
                    o = t.re = [],
                    i = t.src = [],
                    s = 0,
                    a = s++;
                i[a] = "0|[1-9]\\d*";
                var c = s++;
                i[c] = "[0-9]+";
                var l = s++;
                i[l] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
                var u = s++;
                i[u] = "(" + i[a] + ")\\.(" + i[a] + ")\\.(" + i[a] + ")";
                var d = s++;
                i[d] = "(" + i[c] + ")\\.(" + i[c] + ")\\.(" + i[c] + ")";
                var p = s++;
                i[p] = "(?:" + i[a] + "|" + i[l] + ")";
                var h = s++;
                i[h] = "(?:" + i[c] + "|" + i[l] + ")";
                var f = s++;
                i[f] = "(?:-(" + i[p] + "(?:\\." + i[p] + ")*))";
                var m = s++;
                i[m] = "(?:-?(" + i[h] + "(?:\\." + i[h] + ")*))";
                var g = s++;
                i[g] = "[0-9A-Za-z-]+";
                var _ = s++;
                i[_] = "(?:\\+(" + i[g] + "(?:\\." + i[g] + ")*))";
                var y = s++,
                    v = "v?" + i[u] + i[f] + "?" + i[_] + "?";
                i[y] = "^" + v + "$";
                var b = "[v=\\s]*" + i[d] + i[m] + "?" + i[_] + "?",
                    w = s++;
                i[w] = "^" + b + "$";
                var x = s++;
                i[x] = "((?:<|>)?=?)";
                var E = s++;
                i[E] = i[c] + "|x|X|\\*";
                var C = s++;
                i[C] = i[a] + "|x|X|\\*";
                var S = s++;
                i[S] = "[v=\\s]*(" + i[C] + ")(?:\\.(" + i[C] + ")(?:\\.(" + i[C] + ")(?:" + i[f] + ")?" + i[_] + "?)?)?";
                var T = s++;
                i[T] = "[v=\\s]*(" + i[E] + ")(?:\\.(" + i[E] + ")(?:\\.(" + i[E] + ")(?:" + i[m] + ")?" + i[_] + "?)?)?";
                var k = s++;
                i[k] = "^" + i[x] + "\\s*" + i[S] + "$";
                var I = s++;
                i[I] = "^" + i[x] + "\\s*" + i[T] + "$";
                var P = s++;
                i[P] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
                var A = s++;
                i[A] = "(?:~>?)";
                var O = s++;
                i[O] = "(\\s*)" + i[A] + "\\s+", o[O] = new RegExp(i[O], "g");
                var N = s++;
                i[N] = "^" + i[A] + i[S] + "$";
                var R = s++;
                i[R] = "^" + i[A] + i[T] + "$";
                var $ = s++;
                i[$] = "(?:\\^)";
                var M = s++;
                i[M] = "(\\s*)" + i[$] + "\\s+", o[M] = new RegExp(i[M], "g");
                var D = s++;
                i[D] = "^" + i[$] + i[S] + "$";
                var L = s++;
                i[L] = "^" + i[$] + i[T] + "$";
                var F = s++;
                i[F] = "^" + i[x] + "\\s*(" + b + ")$|^$";
                var j = s++;
                i[j] = "^" + i[x] + "\\s*(" + v + ")$|^$";
                var B = s++;
                i[B] = "(\\s*)" + i[x] + "\\s*(" + b + "|" + i[S] + ")", o[B] = new RegExp(i[B], "g");
                var q = s++;
                i[q] = "^\\s*(" + i[S] + ")\\s+-\\s+(" + i[S] + ")\\s*$";
                var U = s++;
                i[U] = "^\\s*(" + i[T] + ")\\s+-\\s+(" + i[T] + ")\\s*$";
                var H = s++;
                i[H] = "(<|>)?=?\\s*\\*";
                for (var G = 0; G < 35; G++) r(G, i[G]), o[G] || (o[G] = new RegExp(i[G]));

                function z(e, t) {
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), e instanceof V) return e;
                    if ("string" != typeof e) return null;
                    if (e.length > 256) return null;
                    if (!(t.loose ? o[w] : o[y]).test(e)) return null;
                    try {
                        return new V(e, t)
                    } catch (e) {
                        return null
                    }
                }

                function V(e, t) {
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), e instanceof V) {
                        if (e.loose === t.loose) return e;
                        e = e.version
                    } else if ("string" != typeof e) throw new TypeError("Invalid Version: " + e);
                    if (e.length > 256) throw new TypeError("version is longer than 256 characters");
                    if (!(this instanceof V)) return new V(e, t);
                    r("SemVer", e, t), this.options = t, this.loose = !!t.loose;
                    var i = e.trim().match(t.loose ? o[w] : o[y]);
                    if (!i) throw new TypeError("Invalid Version: " + e);
                    if (this.raw = e, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > n || this.major < 0) throw new TypeError("Invalid major version");
                    if (this.minor > n || this.minor < 0) throw new TypeError("Invalid minor version");
                    if (this.patch > n || this.patch < 0) throw new TypeError("Invalid patch version");
                    i[4] ? this.prerelease = i[4].split(".").map((function(e) {
                        if (/^[0-9]+$/.test(e)) {
                            var t = +e;
                            if (t >= 0 && t < n) return t
                        }
                        return e
                    })) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format()
                }
                t.parse = z, t.valid = function(e, t) {
                    var r = z(e, t);
                    return r ? r.version : null
                }, t.clean = function(e, t) {
                    var r = z(e.trim().replace(/^[=v]+/, ""), t);
                    return r ? r.version : null
                }, t.SemVer = V, V.prototype.format = function() {
                    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version
                }, V.prototype.toString = function() {
                    return this.version
                }, V.prototype.compare = function(e) {
                    return r("SemVer.compare", this.version, this.options, e), e instanceof V || (e = new V(e, this.options)), this.compareMain(e) || this.comparePre(e)
                }, V.prototype.compareMain = function(e) {
                    return e instanceof V || (e = new V(e, this.options)), K(this.major, e.major) || K(this.minor, e.minor) || K(this.patch, e.patch)
                }, V.prototype.comparePre = function(e) {
                    if (e instanceof V || (e = new V(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
                    if (!this.prerelease.length && e.prerelease.length) return 1;
                    if (!this.prerelease.length && !e.prerelease.length) return 0;
                    var t = 0;
                    do {
                        var n = this.prerelease[t],
                            o = e.prerelease[t];
                        if (r("prerelease compare", t, n, o), void 0 === n && void 0 === o) return 0;
                        if (void 0 === o) return 1;
                        if (void 0 === n) return -1;
                        if (n !== o) return K(n, o)
                    } while (++t)
                }, V.prototype.inc = function(e, t) {
                    switch (e) {
                        case "premajor":
                            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
                            break;
                        case "preminor":
                            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
                            break;
                        case "prepatch":
                            this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
                            break;
                        case "prerelease":
                            0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t);
                            break;
                        case "major":
                            0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                            break;
                        case "minor":
                            0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                            break;
                        case "patch":
                            0 === this.prerelease.length && this.patch++, this.prerelease = [];
                            break;
                        case "pre":
                            if (0 === this.prerelease.length) this.prerelease = [0];
                            else {
                                for (var r = this.prerelease.length; --r >= 0;) "number" == typeof this.prerelease[r] && (this.prerelease[r]++, r = -2); - 1 === r && this.prerelease.push(0)
                            }
                            t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);
                            break;
                        default:
                            throw new Error("invalid increment argument: " + e)
                    }
                    return this.format(), this.raw = this.version, this
                }, t.inc = function(e, t, r, n) {
                    "string" == typeof r && (n = r, r = void 0);
                    try {
                        return new V(e, r).inc(t, n).version
                    } catch (e) {
                        return null
                    }
                }, t.diff = function(e, t) {
                    if (Y(e, t)) return null;
                    var r = z(e),
                        n = z(t),
                        o = "";
                    if (r.prerelease.length || n.prerelease.length) {
                        o = "pre";
                        var i = "prerelease"
                    }
                    for (var s in r)
                        if (("major" === s || "minor" === s || "patch" === s) && r[s] !== n[s]) return o + s;
                    return i
                }, t.compareIdentifiers = K;
                var W = /^[0-9]+$/;

                function K(e, t) {
                    var r = W.test(e),
                        n = W.test(t);
                    return r && n && (e = +e, t = +t), e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1
                }

                function J(e, t, r) {
                    return new V(e, r).compare(new V(t, r))
                }

                function X(e, t, r) {
                    return J(e, t, r) > 0
                }

                function Q(e, t, r) {
                    return J(e, t, r) < 0
                }

                function Y(e, t, r) {
                    return 0 === J(e, t, r)
                }

                function Z(e, t, r) {
                    return 0 !== J(e, t, r)
                }

                function ee(e, t, r) {
                    return J(e, t, r) >= 0
                }

                function te(e, t, r) {
                    return J(e, t, r) <= 0
                }

                function re(e, t, r, n) {
                    switch (t) {
                        case "===":
                            return "object" == typeof e && (e = e.version), "object" == typeof r && (r = r.version), e === r;
                        case "!==":
                            return "object" == typeof e && (e = e.version), "object" == typeof r && (r = r.version), e !== r;
                        case "":
                        case "=":
                        case "==":
                            return Y(e, r, n);
                        case "!=":
                            return Z(e, r, n);
                        case ">":
                            return X(e, r, n);
                        case ">=":
                            return ee(e, r, n);
                        case "<":
                            return Q(e, r, n);
                        case "<=":
                            return te(e, r, n);
                        default:
                            throw new TypeError("Invalid operator: " + t)
                    }
                }

                function ne(e, t) {
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), e instanceof ne) {
                        if (e.loose === !!t.loose) return e;
                        e = e.value
                    }
                    if (!(this instanceof ne)) return new ne(e, t);
                    r("comparator", e, t), this.options = t, this.loose = !!t.loose, this.parse(e), this.semver === oe ? this.value = "" : this.value = this.operator + this.semver.version, r("comp", this)
                }
                t.rcompareIdentifiers = function(e, t) {
                    return K(t, e)
                }, t.major = function(e, t) {
                    return new V(e, t).major
                }, t.minor = function(e, t) {
                    return new V(e, t).minor
                }, t.patch = function(e, t) {
                    return new V(e, t).patch
                }, t.compare = J, t.compareLoose = function(e, t) {
                    return J(e, t, !0)
                }, t.rcompare = function(e, t, r) {
                    return J(t, e, r)
                }, t.sort = function(e, r) {
                    return e.sort((function(e, n) {
                        return t.compare(e, n, r)
                    }))
                }, t.rsort = function(e, r) {
                    return e.sort((function(e, n) {
                        return t.rcompare(e, n, r)
                    }))
                }, t.gt = X, t.lt = Q, t.eq = Y, t.neq = Z, t.gte = ee, t.lte = te, t.cmp = re, t.Comparator = ne;
                var oe = {};

                function ie(e, t) {
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), e instanceof ie) return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new ie(e.raw, t);
                    if (e instanceof ne) return new ie(e.value, t);
                    if (!(this instanceof ie)) return new ie(e, t);
                    if (this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease, this.raw = e, this.set = e.split(/\s*\|\|\s*/).map((function(e) {
                            return this.parseRange(e.trim())
                        }), this).filter((function(e) {
                            return e.length
                        })), !this.set.length) throw new TypeError("Invalid SemVer Range: " + e);
                    this.format()
                }

                function se(e) {
                    return !e || "x" === e.toLowerCase() || "*" === e
                }

                function ae(e, t, r, n, o, i, s, a, c, l, u, d, p) {
                    return ((t = se(r) ? "" : se(n) ? ">=" + r + ".0.0" : se(o) ? ">=" + r + "." + n + ".0" : ">=" + t) + " " + (a = se(c) ? "" : se(l) ? "<" + (+c + 1) + ".0.0" : se(u) ? "<" + c + "." + (+l + 1) + ".0" : d ? "<=" + c + "." + l + "." + u + "-" + d : "<=" + a)).trim()
                }

                function ce(e, t, n) {
                    for (var o = 0; o < e.length; o++)
                        if (!e[o].test(t)) return !1;
                    if (t.prerelease.length && !n.includePrerelease) {
                        for (o = 0; o < e.length; o++)
                            if (r(e[o].semver), e[o].semver !== oe && e[o].semver.prerelease.length > 0) {
                                var i = e[o].semver;
                                if (i.major === t.major && i.minor === t.minor && i.patch === t.patch) return !0
                            }
                        return !1
                    }
                    return !0
                }

                function le(e, t, r) {
                    try {
                        t = new ie(t, r)
                    } catch (e) {
                        return !1
                    }
                    return t.test(e)
                }

                function ue(e, t, r, n) {
                    var o, i, s, a, c;
                    switch (e = new V(e, n), t = new ie(t, n), r) {
                        case ">":
                            o = X, i = te, s = Q, a = ">", c = ">=";
                            break;
                        case "<":
                            o = Q, i = ee, s = X, a = "<", c = "<=";
                            break;
                        default:
                            throw new TypeError('Must provide a hilo val of "<" or ">"')
                    }
                    if (le(e, t, n)) return !1;
                    for (var l = 0; l < t.set.length; ++l) {
                        var u = t.set[l],
                            d = null,
                            p = null;
                        if (u.forEach((function(e) {
                                e.semver === oe && (e = new ne(">=0.0.0")), d = d || e, p = p || e, o(e.semver, d.semver, n) ? d = e : s(e.semver, p.semver, n) && (p = e)
                            })), d.operator === a || d.operator === c) return !1;
                        if ((!p.operator || p.operator === a) && i(e, p.semver)) return !1;
                        if (p.operator === c && s(e, p.semver)) return !1
                    }
                    return !0
                }
                ne.prototype.parse = function(e) {
                    var t = this.options.loose ? o[F] : o[j],
                        r = e.match(t);
                    if (!r) throw new TypeError("Invalid comparator: " + e);
                    this.operator = r[1], "=" === this.operator && (this.operator = ""), r[2] ? this.semver = new V(r[2], this.options.loose) : this.semver = oe
                }, ne.prototype.toString = function() {
                    return this.value
                }, ne.prototype.test = function(e) {
                    return r("Comparator.test", e, this.options.loose), this.semver === oe || ("string" == typeof e && (e = new V(e, this.options)), re(e, this.operator, this.semver, this.options))
                }, ne.prototype.intersects = function(e, t) {
                    if (!(e instanceof ne)) throw new TypeError("a Comparator is required");
                    var r;
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), "" === this.operator) return r = new ie(e.value, t), le(this.value, r, t);
                    if ("" === e.operator) return r = new ie(this.value, t), le(e.semver, r, t);
                    var n = !(">=" !== this.operator && ">" !== this.operator || ">=" !== e.operator && ">" !== e.operator),
                        o = !("<=" !== this.operator && "<" !== this.operator || "<=" !== e.operator && "<" !== e.operator),
                        i = this.semver.version === e.semver.version,
                        s = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== e.operator && "<=" !== e.operator),
                        a = re(this.semver, "<", e.semver, t) && (">=" === this.operator || ">" === this.operator) && ("<=" === e.operator || "<" === e.operator),
                        c = re(this.semver, ">", e.semver, t) && ("<=" === this.operator || "<" === this.operator) && (">=" === e.operator || ">" === e.operator);
                    return n || o || i && s || a || c
                }, t.Range = ie, ie.prototype.format = function() {
                    return this.range = this.set.map((function(e) {
                        return e.join(" ").trim()
                    })).join("||").trim(), this.range
                }, ie.prototype.toString = function() {
                    return this.range
                }, ie.prototype.parseRange = function(e) {
                    var t = this.options.loose;
                    e = e.trim();
                    var n = t ? o[U] : o[q];
                    e = e.replace(n, ae), r("hyphen replace", e), e = e.replace(o[B], "$1$2$3"), r("comparator trim", e, o[B]), e = (e = (e = e.replace(o[O], "$1~")).replace(o[M], "$1^")).split(/\s+/).join(" ");
                    var i = t ? o[F] : o[j],
                        s = e.split(" ").map((function(e) {
                            return function(e, t) {
                                return r("comp", e, t), e = function(e, t) {
                                    return e.trim().split(/\s+/).map((function(e) {
                                        return function(e, t) {
                                            r("caret", e, t);
                                            var n = t.loose ? o[L] : o[D];
                                            return e.replace(n, (function(t, n, o, i, s) {
                                                var a;
                                                return r("caret", e, t, n, o, i, s), se(n) ? a = "" : se(o) ? a = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : se(i) ? a = "0" === n ? ">=" + n + "." + o + ".0 <" + n + "." + (+o + 1) + ".0" : ">=" + n + "." + o + ".0 <" + (+n + 1) + ".0.0" : s ? (r("replaceCaret pr", s), a = "0" === n ? "0" === o ? ">=" + n + "." + o + "." + i + "-" + s + " <" + n + "." + o + "." + (+i + 1) : ">=" + n + "." + o + "." + i + "-" + s + " <" + n + "." + (+o + 1) + ".0" : ">=" + n + "." + o + "." + i + "-" + s + " <" + (+n + 1) + ".0.0") : (r("no pr"), a = "0" === n ? "0" === o ? ">=" + n + "." + o + "." + i + " <" + n + "." + o + "." + (+i + 1) : ">=" + n + "." + o + "." + i + " <" + n + "." + (+o + 1) + ".0" : ">=" + n + "." + o + "." + i + " <" + (+n + 1) + ".0.0"), r("caret return", a), a
                                            }))
                                        }(e, t)
                                    })).join(" ")
                                }(e, t), r("caret", e), e = function(e, t) {
                                    return e.trim().split(/\s+/).map((function(e) {
                                        return function(e, t) {
                                            var n = t.loose ? o[R] : o[N];
                                            return e.replace(n, (function(t, n, o, i, s) {
                                                var a;
                                                return r("tilde", e, t, n, o, i, s), se(n) ? a = "" : se(o) ? a = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : se(i) ? a = ">=" + n + "." + o + ".0 <" + n + "." + (+o + 1) + ".0" : s ? (r("replaceTilde pr", s), a = ">=" + n + "." + o + "." + i + "-" + s + " <" + n + "." + (+o + 1) + ".0") : a = ">=" + n + "." + o + "." + i + " <" + n + "." + (+o + 1) + ".0", r("tilde return", a), a
                                            }))
                                        }(e, t)
                                    })).join(" ")
                                }(e, t), r("tildes", e), e = function(e, t) {
                                    return r("replaceXRanges", e, t), e.split(/\s+/).map((function(e) {
                                        return function(e, t) {
                                            e = e.trim();
                                            var n = t.loose ? o[I] : o[k];
                                            return e.replace(n, (function(t, n, o, i, s, a) {
                                                r("xRange", e, t, n, o, i, s, a);
                                                var c = se(o),
                                                    l = c || se(i),
                                                    u = l || se(s);
                                                return "=" === n && u && (n = ""), c ? t = ">" === n || "<" === n ? "<0.0.0" : "*" : n && u ? (l && (i = 0), s = 0, ">" === n ? (n = ">=", l ? (o = +o + 1, i = 0, s = 0) : (i = +i + 1, s = 0)) : "<=" === n && (n = "<", l ? o = +o + 1 : i = +i + 1), t = n + o + "." + i + "." + s) : l ? t = ">=" + o + ".0.0 <" + (+o + 1) + ".0.0" : u && (t = ">=" + o + "." + i + ".0 <" + o + "." + (+i + 1) + ".0"), r("xRange return", t), t
                                            }))
                                        }(e, t)
                                    })).join(" ")
                                }(e, t), r("xrange", e), e = function(e, t) {
                                    return r("replaceStars", e, t), e.trim().replace(o[H], "")
                                }(e, t), r("stars", e), e
                            }(e, this.options)
                        }), this).join(" ").split(/\s+/);
                    return this.options.loose && (s = s.filter((function(e) {
                        return !!e.match(i)
                    }))), s.map((function(e) {
                        return new ne(e, this.options)
                    }), this)
                }, ie.prototype.intersects = function(e, t) {
                    if (!(e instanceof ie)) throw new TypeError("a Range is required");
                    return this.set.some((function(r) {
                        return r.every((function(r) {
                            return e.set.some((function(e) {
                                return e.every((function(e) {
                                    return r.intersects(e, t)
                                }))
                            }))
                        }))
                    }))
                }, t.toComparators = function(e, t) {
                    return new ie(e, t).set.map((function(e) {
                        return e.map((function(e) {
                            return e.value
                        })).join(" ").trim().split(" ")
                    }))
                }, ie.prototype.test = function(e) {
                    if (!e) return !1;
                    "string" == typeof e && (e = new V(e, this.options));
                    for (var t = 0; t < this.set.length; t++)
                        if (ce(this.set[t], e, this.options)) return !0;
                    return !1
                }, t.satisfies = le, t.maxSatisfying = function(e, t, r) {
                    var n = null,
                        o = null;
                    try {
                        var i = new ie(t, r)
                    } catch (e) {
                        return null
                    }
                    return e.forEach((function(e) {
                        i.test(e) && (n && -1 !== o.compare(e) || (o = new V(n = e, r)))
                    })), n
                }, t.minSatisfying = function(e, t, r) {
                    var n = null,
                        o = null;
                    try {
                        var i = new ie(t, r)
                    } catch (e) {
                        return null
                    }
                    return e.forEach((function(e) {
                        i.test(e) && (n && 1 !== o.compare(e) || (o = new V(n = e, r)))
                    })), n
                }, t.minVersion = function(e, t) {
                    e = new ie(e, t);
                    var r = new V("0.0.0");
                    if (e.test(r)) return r;
                    if (r = new V("0.0.0-0"), e.test(r)) return r;
                    r = null;
                    for (var n = 0; n < e.set.length; ++n) e.set[n].forEach((function(e) {
                        var t = new V(e.semver.version);
                        switch (e.operator) {
                            case ">":
                                0 === t.prerelease.length ? t.patch++ : t.prerelease.push(0), t.raw = t.format();
                            case "":
                            case ">=":
                                r && !X(r, t) || (r = t);
                                break;
                            case "<":
                            case "<=":
                                break;
                            default:
                                throw new Error("Unexpected operation: " + e.operator)
                        }
                    }));
                    return r && e.test(r) ? r : null
                }, t.validRange = function(e, t) {
                    try {
                        return new ie(e, t).range || "*"
                    } catch (e) {
                        return null
                    }
                }, t.ltr = function(e, t, r) {
                    return ue(e, t, "<", r)
                }, t.gtr = function(e, t, r) {
                    return ue(e, t, ">", r)
                }, t.outside = ue, t.prerelease = function(e, t) {
                    var r = z(e, t);
                    return r && r.prerelease.length ? r.prerelease : null
                }, t.intersects = function(e, t, r) {
                    return e = new ie(e, r), t = new ie(t, r), e.intersects(t)
                }, t.coerce = function(e) {
                    if (e instanceof V) return e;
                    if ("string" != typeof e) return null;
                    var t = e.match(o[P]);
                    return null == t ? null : z(t[1] + "." + (t[2] || "0") + "." + (t[3] || "0"))
                }
            },
            5420: e => {
                var t = Object.prototype.toString,
                    r = "function" == typeof Buffer.alloc && "function" == typeof Buffer.allocUnsafe && "function" == typeof Buffer.from;
                e.exports = function(e, n, o) {
                    if ("number" == typeof e) throw new TypeError('"value" argument must not be a number');
                    return i = e, "ArrayBuffer" === t.call(i).slice(8, -1) ? function(e, t, n) {
                        t >>>= 0;
                        var o = e.byteLength - t;
                        if (o < 0) throw new RangeError("'offset' is out of bounds");
                        if (void 0 === n) n = o;
                        else if ((n >>>= 0) > o) throw new RangeError("'length' is out of bounds");
                        return r ? Buffer.from(e.slice(t, t + n)) : new Buffer(new Uint8Array(e.slice(t, t + n)))
                    }(e, n, o) : "string" == typeof e ? function(e, t) {
                        if ("string" == typeof t && "" !== t || (t = "utf8"), !Buffer.isEncoding(t)) throw new TypeError('"encoding" must be a valid string encoding');
                        return r ? Buffer.from(e, t) : new Buffer(e, t)
                    }(e, n) : r ? Buffer.from(e) : new Buffer(e);
                    var i
                }
            },
            4046: (e, t, r) => {
                "use strict";
                const n = r(3837),
                    o = r(9491),
                    i = r(9867),
                    s = r(3223),
                    a = "error@context",
                    c = [];
                for (let e in s.providers) c[s.providers[e]] = e;
                const l = process.env.DEBUG_CLS_HOOKED;
                let u = -1;

                function d(e) {
                    this.name = e, this.active = null, this._set = [], this.id = null, this._contexts = new Map
                }

                function p(e) {
                    return process.namespaces[e]
                }

                function h(e) {
                    let t = p(e);
                    o.ok(t, "can't delete nonexistent namespace! \"" + e + '"'), o.ok(t.id, "don't assign to process.namespaces directly! " + n.inspect(t)), process.namespaces[e] = null
                }

                function f(e) {
                    process.env.DEBUG && process._rawDebug(e)
                }

                function m(e) {
                    return e ? "function" == typeof e ? e.name ? e.name : (e.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1] : e.constructor && e.constructor.name ? e.constructor.name : void 0 : e
                }
                if (e.exports = {
                        getNamespace: p,
                        createNamespace: function(e) {
                            o.ok(e, "namespace must be given a name."), l && f("CREATING NAMESPACE " + e);
                            let t = new d(e);
                            return t.id = u, s.addHooks({
                                init(r, o, i, s, a) {
                                    u = r, s ? (t._contexts.set(r, t._contexts.get(s)), l && f("PARENTID: " + e + " uid:" + r + " parent:" + s + " provider:" + i)) : t._contexts.set(u, t.active), l && f("INIT " + e + " uid:" + r + " parent:" + s + " provider:" + c[i] + " active:" + n.inspect(t.active, !0))
                                },
                                pre(r, o) {
                                    u = r;
                                    let i = t._contexts.get(r);
                                    i ? (l && f(" PRE " + e + " uid:" + r + " handle:" + m(o) + " context:" + n.inspect(i)), t.enter(i)) : l && f(" PRE MISSING CONTEXT " + e + " uid:" + r + " handle:" + m(o))
                                },
                                post(r, o) {
                                    u = r;
                                    let i = t._contexts.get(r);
                                    i ? (l && f(" POST " + e + " uid:" + r + " handle:" + m(o) + " context:" + n.inspect(i)), t.exit(i)) : l && f(" POST MISSING CONTEXT " + e + " uid:" + r + " handle:" + m(o))
                                },
                                destroy(r) {
                                    u = r, l && f("DESTROY " + e + " uid:" + r + " context:" + n.inspect(t._contexts.get(u)) + " active:" + n.inspect(t.active, !0)), t._contexts.delete(r)
                                }
                            }), process.namespaces[e] = t, t
                        },
                        destroyNamespace: h,
                        reset: function() {
                            process.namespaces && Object.keys(process.namespaces).forEach((function(e) {
                                h(e)
                            })), process.namespaces = Object.create(null)
                        },
                        ERROR_SYMBOL: a
                    }, d.prototype.set = function(e, t) {
                        if (!this.active) throw new Error("No context available. ns.run() or ns.bind() must be called first.");
                        return l && f("    SETTING KEY:" + e + "=" + t + " in ns:" + this.name + " uid:" + u + " active:" + n.inspect(this.active, !0)), this.active[e] = t, t
                    }, d.prototype.get = function(e) {
                        if (this.active) return l && f("    GETTING KEY:" + e + "=" + this.active[e] + " " + this.name + " uid:" + u + " active:" + n.inspect(this.active, !0)), this.active[e];
                        l && f("    GETTING KEY:" + e + "=undefined " + this.name + " uid:" + u + " active:" + n.inspect(this.active, !0))
                    }, d.prototype.createContext = function() {
                        l && f("   CREATING Context: " + this.name + " uid:" + u + " len:" + this._set.length + "  active:" + n.inspect(this.active, !0, 2, !0));
                        let e = Object.create(this.active ? this.active : Object.prototype);
                        return e._ns_name = this.name, e.id = u, l && f("   CREATED Context: " + this.name + " uid:" + u + " len:" + this._set.length + "  context:" + n.inspect(e, !0, 2, !0)), e
                    }, d.prototype.run = function(e) {
                        let t = this.createContext();
                        this.enter(t);
                        try {
                            return l && f(" BEFORE RUN: " + this.name + " uid:" + u + " len:" + this._set.length + " " + n.inspect(t)), e(t), t
                        } catch (e) {
                            throw e && (e[a] = t), e
                        } finally {
                            l && f(" AFTER RUN: " + this.name + " uid:" + u + " len:" + this._set.length + " " + n.inspect(t)), this.exit(t)
                        }
                    }, d.prototype.runAndReturn = function(e) {
                        var t;
                        return this.run((function(r) {
                            t = e(r)
                        })), t
                    }, d.prototype.runPromise = function(e) {
                        let t = this.createContext();
                        this.enter(t);
                        let r = e(t);
                        if (!r || !r.then || !r.catch) throw new Error("fn must return a promise.");
                        return l && f(" BEFORE runPromise: " + this.name + " uid:" + u + " len:" + this._set.length + " " + n.inspect(t)), r.then((e => (l && f(" AFTER runPromise: " + this.name + " uid:" + u + " len:" + this._set.length + " " + n.inspect(t)), this.exit(t), e))).catch((e => {
                            throw e[a] = t, l && f(" AFTER runPromise: " + this.name + " uid:" + u + " len:" + this._set.length + " " + n.inspect(t)), this.exit(t), e
                        }))
                    }, d.prototype.bind = function(e, t) {
                        t || (t = this.active ? this.active : this.createContext());
                        let r = this;
                        return function() {
                            r.enter(t);
                            try {
                                return e.apply(this, arguments)
                            } catch (e) {
                                throw e && (e[a] = t), e
                            } finally {
                                r.exit(t)
                            }
                        }
                    }, d.prototype.enter = function(e) {
                        o.ok(e, "context must be provided for entering"), l && f("  ENTER " + this.name + " uid:" + u + " len:" + this._set.length + " context: " + n.inspect(e)), this._set.push(this.active), this.active = e
                    }, d.prototype.exit = function(e) {
                        if (o.ok(e, "context must be provided for exiting"), l && f("  EXIT " + this.name + " uid:" + u + " len:" + this._set.length + " context: " + n.inspect(e)), this.active === e) return o.ok(this._set.length, "can't remove top context"), void(this.active = this._set.pop());
                        let t = this._set.lastIndexOf(e);
                        t < 0 ? (l && f("??ERROR?? context exiting but not entered - ignoring: " + n.inspect(e)), o.ok(t >= 0, "context not currently entered; can't exit. \n" + n.inspect(this) + "\n" + n.inspect(e))) : (o.ok(t, "can't remove top context"), this._set.splice(t, 1))
                    }, d.prototype.bindEmitter = function(e) {
                        o.ok(e.on && e.addListener && e.emit, "can only bind real EEs");
                        let t = this,
                            r = "context@" + this.name;
                        i(e, (function(e) {
                            e && (e["cls@contexts"] || (e["cls@contexts"] = Object.create(null)), e["cls@contexts"][r] = {
                                namespace: t,
                                context: t.active
                            })
                        }), (function(e) {
                            if (!e || !e["cls@contexts"]) return e;
                            let t = e,
                                r = e["cls@contexts"];
                            return Object.keys(r).forEach((function(e) {
                                let n = r[e];
                                t = n.namespace.bind(t, n.context)
                            })), t
                        }))
                    }, d.prototype.fromException = function(e) {
                        return e[a]
                    }, process.namespaces = {}, s._state && !s._state.enabled && s.enable(), l) {
                    var g = r(2512);
                    for (var _ in g.filter._modifiers) g.filter.deattach(_)
                }
            },
            3964: (e, t, r) => {
                "use strict";
                const n = r(3837),
                    o = r(9491),
                    i = r(9867),
                    s = r(852),
                    a = "error@context",
                    c = process.env.DEBUG_CLS_HOOKED;
                let l = -1;

                function u(e) {
                    this.name = e, this.active = null, this._set = [], this.id = null, this._contexts = new Map, this._indent = 0
                }

                function d(e) {
                    return process.namespaces[e]
                }

                function p(e) {
                    let t = d(e);
                    o.ok(t, "can't delete nonexistent namespace! \"" + e + '"'), o.ok(t.id, "don't assign to process.namespaces directly! " + n.inspect(t)), process.namespaces[e] = null
                }

                function h(...e) {
                    c && process._rawDebug(`${n.format(...e)}`)
                }
                e.exports = {
                    getNamespace: d,
                    createNamespace: function(e) {
                        o.ok(e, "namespace must be given a name."), c && h(`NS-CREATING NAMESPACE (${e})`);
                        let t = new u(e);
                        return t.id = l, s.createHook({
                            init(r, o, i, a) {
                                if (l = s.executionAsyncId(), t.active) {
                                    if (t._contexts.set(r, t.active), c) {
                                        h(`${" ".repeat(t._indent<0?0:t._indent)}INIT [${o}] (${e}) asyncId:${r} currentUid:${l} triggerId:${i} active:${n.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} resource:${a}`)
                                    }
                                } else if (0 === l) {
                                    const i = s.triggerAsyncId(),
                                        u = t._contexts.get(i);
                                    if (u) {
                                        if (t._contexts.set(r, u), c) {
                                            h(`${" ".repeat(t._indent<0?0:t._indent)}INIT USING CONTEXT FROM TRIGGERID [${o}] (${e}) asyncId:${r} currentUid:${l} triggerId:${i} active:${n.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} resource:${a}`)
                                        }
                                    } else if (c) {
                                        h(`${" ".repeat(t._indent<0?0:t._indent)}INIT MISSING CONTEXT [${o}] (${e}) asyncId:${r} currentUid:${l} triggerId:${i} active:${n.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} resource:${a}`)
                                    }
                                }
                                if (c && "PROMISE" === o) {
                                    h(n.inspect(a, {
                                        showHidden: !0
                                    }));
                                    const s = a.parentId;
                                    h(`${" ".repeat(t._indent<0?0:t._indent)}INIT RESOURCE-PROMISE [${o}] (${e}) parentId:${s} asyncId:${r} currentUid:${l} triggerId:${i} active:${n.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} resource:${a}`)
                                }
                            },
                            before(r) {
                                let o;
                                if (l = s.executionAsyncId(), o = t._contexts.get(r) || t._contexts.get(l), o) {
                                    if (c) {
                                        const i = s.triggerAsyncId();
                                        h(`${" ".repeat(t._indent<0?0:t._indent)}BEFORE (${e}) asyncId:${r} currentUid:${l} triggerId:${i} active:${n.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} context:${n.inspect(o)}`), t._indent += 2
                                    }
                                    t.enter(o)
                                } else if (c) {
                                    const o = s.triggerAsyncId();
                                    h(`${" ".repeat(t._indent<0?0:t._indent)}BEFORE MISSING CONTEXT (${e}) asyncId:${r} currentUid:${l} triggerId:${o} active:${n.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} namespace._contexts:${n.inspect(t._contexts,{showHidden:!0,depth:2,colors:!0})}`), t._indent += 2
                                }
                            },
                            after(r) {
                                let o;
                                if (l = s.executionAsyncId(), o = t._contexts.get(r) || t._contexts.get(l), o) {
                                    if (c) {
                                        const i = s.triggerAsyncId();
                                        t._indent -= 2;
                                        h(`${" ".repeat(t._indent<0?0:t._indent)}AFTER (${e}) asyncId:${r} currentUid:${l} triggerId:${i} active:${n.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} context:${n.inspect(o)}`)
                                    }
                                    t.exit(o)
                                } else if (c) {
                                    const i = s.triggerAsyncId();
                                    t._indent -= 2;
                                    h(`${" ".repeat(t._indent<0?0:t._indent)}AFTER MISSING CONTEXT (${e}) asyncId:${r} currentUid:${l} triggerId:${i} active:${n.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} context:${n.inspect(o)}`)
                                }
                            },
                            destroy(r) {
                                if (l = s.executionAsyncId(), c) {
                                    const o = s.triggerAsyncId();
                                    h(`${" ".repeat(t._indent<0?0:t._indent)}DESTROY (${e}) currentUid:${l} asyncId:${r} triggerId:${o} active:${n.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} context:${n.inspect(t._contexts.get(l))}`)
                                }
                                t._contexts.delete(r)
                            }
                        }).enable(), process.namespaces[e] = t, t
                    },
                    destroyNamespace: p,
                    reset: function() {
                        process.namespaces && Object.keys(process.namespaces).forEach((function(e) {
                            p(e)
                        })), process.namespaces = Object.create(null)
                    },
                    ERROR_SYMBOL: a
                }, u.prototype.set = function(e, t) {
                    if (!this.active) throw new Error("No context available. ns.run() or ns.bind() must be called first.");
                    return this.active[e] = t, c && h(" ".repeat(this._indent < 0 ? 0 : this._indent) + "CONTEXT-SET KEY:" + e + "=" + t + " in ns:" + this.name + " currentUid:" + l + " active:" + n.inspect(this.active, {
                        showHidden: !0,
                        depth: 2,
                        colors: !0
                    })), t
                }, u.prototype.get = function(e) {
                    if (this.active) {
                        if (c) {
                            const t = s.executionAsyncId(),
                                r = s.triggerAsyncId(),
                                o = " ".repeat(this._indent < 0 ? 0 : this._indent);
                            h(o + "CONTEXT-GETTING KEY:" + e + "=" + this.active[e] + " (" + this.name + ") currentUid:" + l + " active:" + n.inspect(this.active, {
                                showHidden: !0,
                                depth: 2,
                                colors: !0
                            })), h(`${o}CONTEXT-GETTING KEY: (${this.name}) ${e}=${this.active[e]} currentUid:${l} asyncHooksCurrentId:${t} triggerId:${r} len:${this._set.length} active:${n.inspect(this.active)}`)
                        }
                        return this.active[e]
                    }
                    if (c) {
                        const t = s.currentId(),
                            r = s.triggerAsyncId();
                        h(`${" ".repeat(this._indent<0?0:this._indent)}CONTEXT-GETTING KEY NO ACTIVE NS: (${this.name}) ${e}=undefined currentUid:${l} asyncHooksCurrentId:${t} triggerId:${r} len:${this._set.length}`)
                    }
                }, u.prototype.createContext = function() {
                    let e = Object.create(this.active ? this.active : Object.prototype);
                    if (e._ns_name = this.name, e.id = l, c) {
                        const t = s.executionAsyncId(),
                            r = s.triggerAsyncId();
                        h(`${" ".repeat(this._indent<0?0:this._indent)}CONTEXT-CREATED Context: (${this.name}) currentUid:${l} asyncHooksCurrentId:${t} triggerId:${r} len:${this._set.length} context:${n.inspect(e,{showHidden:!0,depth:2,colors:!0})}`)
                    }
                    return e
                }, u.prototype.run = function(e) {
                    let t = this.createContext();
                    this.enter(t);
                    try {
                        if (c) {
                            const e = s.triggerAsyncId(),
                                r = s.executionAsyncId();
                            h(`${" ".repeat(this._indent<0?0:this._indent)}CONTEXT-RUN BEGIN: (${this.name}) currentUid:${l} triggerId:${e} asyncHooksCurrentId:${r} len:${this._set.length} context:${n.inspect(t)}`)
                        }
                        return e(t), t
                    } catch (e) {
                        throw e && (e[a] = t), e
                    } finally {
                        if (c) {
                            const e = s.triggerAsyncId(),
                                r = s.executionAsyncId();
                            h(`${" ".repeat(this._indent<0?0:this._indent)}CONTEXT-RUN END: (${this.name}) currentUid:${l} triggerId:${e} asyncHooksCurrentId:${r} len:${this._set.length} ${n.inspect(t)}`)
                        }
                        this.exit(t)
                    }
                }, u.prototype.runAndReturn = function(e) {
                    let t;
                    return this.run((function(r) {
                        t = e(r)
                    })), t
                }, u.prototype.runPromise = function(e) {
                    let t = this.createContext();
                    this.enter(t);
                    let r = e(t);
                    if (!r || !r.then || !r.catch) throw new Error("fn must return a promise.");
                    return c && h("CONTEXT-runPromise BEFORE: (" + this.name + ") currentUid:" + l + " len:" + this._set.length + " " + n.inspect(t)), r.then((e => (c && h("CONTEXT-runPromise AFTER then: (" + this.name + ") currentUid:" + l + " len:" + this._set.length + " " + n.inspect(t)), this.exit(t), e))).catch((e => {
                        throw e[a] = t, c && h("CONTEXT-runPromise AFTER catch: (" + this.name + ") currentUid:" + l + " len:" + this._set.length + " " + n.inspect(t)), this.exit(t), e
                    }))
                }, u.prototype.bind = function(e, t) {
                    t || (t = this.active ? this.active : this.createContext());
                    let r = this;
                    return function() {
                        r.enter(t);
                        try {
                            return e.apply(this, arguments)
                        } catch (e) {
                            throw e && (e[a] = t), e
                        } finally {
                            r.exit(t)
                        }
                    }
                }, u.prototype.enter = function(e) {
                    if (o.ok(e, "context must be provided for entering"), c) {
                        const t = s.executionAsyncId(),
                            r = s.triggerAsyncId();
                        h(`${" ".repeat(this._indent<0?0:this._indent)}CONTEXT-ENTER: (${this.name}) currentUid:${l} triggerId:${r} asyncHooksCurrentId:${t} len:${this._set.length} ${n.inspect(e)}`)
                    }
                    this._set.push(this.active), this.active = e
                }, u.prototype.exit = function(e) {
                    if (o.ok(e, "context must be provided for exiting"), c) {
                        const t = s.executionAsyncId(),
                            r = s.triggerAsyncId();
                        h(`${" ".repeat(this._indent<0?0:this._indent)}CONTEXT-EXIT: (${this.name}) currentUid:${l} triggerId:${r} asyncHooksCurrentId:${t} len:${this._set.length} ${n.inspect(e)}`)
                    }
                    if (this.active === e) return o.ok(this._set.length, "can't remove top context"), void(this.active = this._set.pop());
                    let t = this._set.lastIndexOf(e);
                    t < 0 ? (c && h("??ERROR?? context exiting but not entered - ignoring: " + n.inspect(e)), o.ok(t >= 0, "context not currently entered; can't exit. \n" + n.inspect(this) + "\n" + n.inspect(e))) : (o.ok(t, "can't remove top context"), this._set.splice(t, 1))
                }, u.prototype.bindEmitter = function(e) {
                    o.ok(e.on && e.addListener && e.emit, "can only bind real EEs");
                    let t = this,
                        r = "context@" + this.name;
                    i(e, (function(e) {
                        e && (e["cls@contexts"] || (e["cls@contexts"] = Object.create(null)), e["cls@contexts"][r] = {
                            namespace: t,
                            context: t.active
                        })
                    }), (function(e) {
                        if (!e || !e["cls@contexts"]) return e;
                        let t = e,
                            r = e["cls@contexts"];
                        return Object.keys(r).forEach((function(e) {
                            let n = r[e];
                            t = n.namespace.bind(t, n.context)
                        })), t
                    }))
                }, u.prototype.fromException = function(e) {
                    return e[a]
                }, process.namespaces = {}
            },
            9562: (e, t, r) => {
                "use strict";
                const n = r(9012);
                process && n.gte(process.versions.node, "8.0.0") ? e.exports = r(3964) : e.exports = r(4046)
            },
            9012: (e, t) => {
                var r;
                t = e.exports = V, r = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
                    var e = Array.prototype.slice.call(arguments, 0);
                    e.unshift("SEMVER"), console.log.apply(console, e)
                } : function() {}, t.SEMVER_SPEC_VERSION = "2.0.0";
                var n = Number.MAX_SAFE_INTEGER || 9007199254740991,
                    o = t.re = [],
                    i = t.src = [],
                    s = 0,
                    a = s++;
                i[a] = "0|[1-9]\\d*";
                var c = s++;
                i[c] = "[0-9]+";
                var l = s++;
                i[l] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
                var u = s++;
                i[u] = "(" + i[a] + ")\\.(" + i[a] + ")\\.(" + i[a] + ")";
                var d = s++;
                i[d] = "(" + i[c] + ")\\.(" + i[c] + ")\\.(" + i[c] + ")";
                var p = s++;
                i[p] = "(?:" + i[a] + "|" + i[l] + ")";
                var h = s++;
                i[h] = "(?:" + i[c] + "|" + i[l] + ")";
                var f = s++;
                i[f] = "(?:-(" + i[p] + "(?:\\." + i[p] + ")*))";
                var m = s++;
                i[m] = "(?:-?(" + i[h] + "(?:\\." + i[h] + ")*))";
                var g = s++;
                i[g] = "[0-9A-Za-z-]+";
                var _ = s++;
                i[_] = "(?:\\+(" + i[g] + "(?:\\." + i[g] + ")*))";
                var y = s++,
                    v = "v?" + i[u] + i[f] + "?" + i[_] + "?";
                i[y] = "^" + v + "$";
                var b = "[v=\\s]*" + i[d] + i[m] + "?" + i[_] + "?",
                    w = s++;
                i[w] = "^" + b + "$";
                var x = s++;
                i[x] = "((?:<|>)?=?)";
                var E = s++;
                i[E] = i[c] + "|x|X|\\*";
                var C = s++;
                i[C] = i[a] + "|x|X|\\*";
                var S = s++;
                i[S] = "[v=\\s]*(" + i[C] + ")(?:\\.(" + i[C] + ")(?:\\.(" + i[C] + ")(?:" + i[f] + ")?" + i[_] + "?)?)?";
                var T = s++;
                i[T] = "[v=\\s]*(" + i[E] + ")(?:\\.(" + i[E] + ")(?:\\.(" + i[E] + ")(?:" + i[m] + ")?" + i[_] + "?)?)?";
                var k = s++;
                i[k] = "^" + i[x] + "\\s*" + i[S] + "$";
                var I = s++;
                i[I] = "^" + i[x] + "\\s*" + i[T] + "$";
                var P = s++;
                i[P] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
                var A = s++;
                i[A] = "(?:~>?)";
                var O = s++;
                i[O] = "(\\s*)" + i[A] + "\\s+", o[O] = new RegExp(i[O], "g");
                var N = s++;
                i[N] = "^" + i[A] + i[S] + "$";
                var R = s++;
                i[R] = "^" + i[A] + i[T] + "$";
                var $ = s++;
                i[$] = "(?:\\^)";
                var M = s++;
                i[M] = "(\\s*)" + i[$] + "\\s+", o[M] = new RegExp(i[M], "g");
                var D = s++;
                i[D] = "^" + i[$] + i[S] + "$";
                var L = s++;
                i[L] = "^" + i[$] + i[T] + "$";
                var F = s++;
                i[F] = "^" + i[x] + "\\s*(" + b + ")$|^$";
                var j = s++;
                i[j] = "^" + i[x] + "\\s*(" + v + ")$|^$";
                var B = s++;
                i[B] = "(\\s*)" + i[x] + "\\s*(" + b + "|" + i[S] + ")", o[B] = new RegExp(i[B], "g");
                var q = s++;
                i[q] = "^\\s*(" + i[S] + ")\\s+-\\s+(" + i[S] + ")\\s*$";
                var U = s++;
                i[U] = "^\\s*(" + i[T] + ")\\s+-\\s+(" + i[T] + ")\\s*$";
                var H = s++;
                i[H] = "(<|>)?=?\\s*\\*";
                for (var G = 0; G < 35; G++) r(G, i[G]), o[G] || (o[G] = new RegExp(i[G]));

                function z(e, t) {
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), e instanceof V) return e;
                    if ("string" != typeof e) return null;
                    if (e.length > 256) return null;
                    if (!(t.loose ? o[w] : o[y]).test(e)) return null;
                    try {
                        return new V(e, t)
                    } catch (e) {
                        return null
                    }
                }

                function V(e, t) {
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), e instanceof V) {
                        if (e.loose === t.loose) return e;
                        e = e.version
                    } else if ("string" != typeof e) throw new TypeError("Invalid Version: " + e);
                    if (e.length > 256) throw new TypeError("version is longer than 256 characters");
                    if (!(this instanceof V)) return new V(e, t);
                    r("SemVer", e, t), this.options = t, this.loose = !!t.loose;
                    var i = e.trim().match(t.loose ? o[w] : o[y]);
                    if (!i) throw new TypeError("Invalid Version: " + e);
                    if (this.raw = e, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > n || this.major < 0) throw new TypeError("Invalid major version");
                    if (this.minor > n || this.minor < 0) throw new TypeError("Invalid minor version");
                    if (this.patch > n || this.patch < 0) throw new TypeError("Invalid patch version");
                    i[4] ? this.prerelease = i[4].split(".").map((function(e) {
                        if (/^[0-9]+$/.test(e)) {
                            var t = +e;
                            if (t >= 0 && t < n) return t
                        }
                        return e
                    })) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format()
                }
                t.parse = z, t.valid = function(e, t) {
                    var r = z(e, t);
                    return r ? r.version : null
                }, t.clean = function(e, t) {
                    var r = z(e.trim().replace(/^[=v]+/, ""), t);
                    return r ? r.version : null
                }, t.SemVer = V, V.prototype.format = function() {
                    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version
                }, V.prototype.toString = function() {
                    return this.version
                }, V.prototype.compare = function(e) {
                    return r("SemVer.compare", this.version, this.options, e), e instanceof V || (e = new V(e, this.options)), this.compareMain(e) || this.comparePre(e)
                }, V.prototype.compareMain = function(e) {
                    return e instanceof V || (e = new V(e, this.options)), K(this.major, e.major) || K(this.minor, e.minor) || K(this.patch, e.patch)
                }, V.prototype.comparePre = function(e) {
                    if (e instanceof V || (e = new V(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
                    if (!this.prerelease.length && e.prerelease.length) return 1;
                    if (!this.prerelease.length && !e.prerelease.length) return 0;
                    var t = 0;
                    do {
                        var n = this.prerelease[t],
                            o = e.prerelease[t];
                        if (r("prerelease compare", t, n, o), void 0 === n && void 0 === o) return 0;
                        if (void 0 === o) return 1;
                        if (void 0 === n) return -1;
                        if (n !== o) return K(n, o)
                    } while (++t)
                }, V.prototype.inc = function(e, t) {
                    switch (e) {
                        case "premajor":
                            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
                            break;
                        case "preminor":
                            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
                            break;
                        case "prepatch":
                            this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
                            break;
                        case "prerelease":
                            0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t);
                            break;
                        case "major":
                            0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                            break;
                        case "minor":
                            0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                            break;
                        case "patch":
                            0 === this.prerelease.length && this.patch++, this.prerelease = [];
                            break;
                        case "pre":
                            if (0 === this.prerelease.length) this.prerelease = [0];
                            else {
                                for (var r = this.prerelease.length; --r >= 0;) "number" == typeof this.prerelease[r] && (this.prerelease[r]++, r = -2); - 1 === r && this.prerelease.push(0)
                            }
                            t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);
                            break;
                        default:
                            throw new Error("invalid increment argument: " + e)
                    }
                    return this.format(), this.raw = this.version, this
                }, t.inc = function(e, t, r, n) {
                    "string" == typeof r && (n = r, r = void 0);
                    try {
                        return new V(e, r).inc(t, n).version
                    } catch (e) {
                        return null
                    }
                }, t.diff = function(e, t) {
                    if (Y(e, t)) return null;
                    var r = z(e),
                        n = z(t),
                        o = "";
                    if (r.prerelease.length || n.prerelease.length) {
                        o = "pre";
                        var i = "prerelease"
                    }
                    for (var s in r)
                        if (("major" === s || "minor" === s || "patch" === s) && r[s] !== n[s]) return o + s;
                    return i
                }, t.compareIdentifiers = K;
                var W = /^[0-9]+$/;

                function K(e, t) {
                    var r = W.test(e),
                        n = W.test(t);
                    return r && n && (e = +e, t = +t), e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1
                }

                function J(e, t, r) {
                    return new V(e, r).compare(new V(t, r))
                }

                function X(e, t, r) {
                    return J(e, t, r) > 0
                }

                function Q(e, t, r) {
                    return J(e, t, r) < 0
                }

                function Y(e, t, r) {
                    return 0 === J(e, t, r)
                }

                function Z(e, t, r) {
                    return 0 !== J(e, t, r)
                }

                function ee(e, t, r) {
                    return J(e, t, r) >= 0
                }

                function te(e, t, r) {
                    return J(e, t, r) <= 0
                }

                function re(e, t, r, n) {
                    switch (t) {
                        case "===":
                            return "object" == typeof e && (e = e.version), "object" == typeof r && (r = r.version), e === r;
                        case "!==":
                            return "object" == typeof e && (e = e.version), "object" == typeof r && (r = r.version), e !== r;
                        case "":
                        case "=":
                        case "==":
                            return Y(e, r, n);
                        case "!=":
                            return Z(e, r, n);
                        case ">":
                            return X(e, r, n);
                        case ">=":
                            return ee(e, r, n);
                        case "<":
                            return Q(e, r, n);
                        case "<=":
                            return te(e, r, n);
                        default:
                            throw new TypeError("Invalid operator: " + t)
                    }
                }

                function ne(e, t) {
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), e instanceof ne) {
                        if (e.loose === !!t.loose) return e;
                        e = e.value
                    }
                    if (!(this instanceof ne)) return new ne(e, t);
                    r("comparator", e, t), this.options = t, this.loose = !!t.loose, this.parse(e), this.semver === oe ? this.value = "" : this.value = this.operator + this.semver.version, r("comp", this)
                }
                t.rcompareIdentifiers = function(e, t) {
                    return K(t, e)
                }, t.major = function(e, t) {
                    return new V(e, t).major
                }, t.minor = function(e, t) {
                    return new V(e, t).minor
                }, t.patch = function(e, t) {
                    return new V(e, t).patch
                }, t.compare = J, t.compareLoose = function(e, t) {
                    return J(e, t, !0)
                }, t.rcompare = function(e, t, r) {
                    return J(t, e, r)
                }, t.sort = function(e, r) {
                    return e.sort((function(e, n) {
                        return t.compare(e, n, r)
                    }))
                }, t.rsort = function(e, r) {
                    return e.sort((function(e, n) {
                        return t.rcompare(e, n, r)
                    }))
                }, t.gt = X, t.lt = Q, t.eq = Y, t.neq = Z, t.gte = ee, t.lte = te, t.cmp = re, t.Comparator = ne;
                var oe = {};

                function ie(e, t) {
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), e instanceof ie) return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new ie(e.raw, t);
                    if (e instanceof ne) return new ie(e.value, t);
                    if (!(this instanceof ie)) return new ie(e, t);
                    if (this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease, this.raw = e, this.set = e.split(/\s*\|\|\s*/).map((function(e) {
                            return this.parseRange(e.trim())
                        }), this).filter((function(e) {
                            return e.length
                        })), !this.set.length) throw new TypeError("Invalid SemVer Range: " + e);
                    this.format()
                }

                function se(e) {
                    return !e || "x" === e.toLowerCase() || "*" === e
                }

                function ae(e, t, r, n, o, i, s, a, c, l, u, d, p) {
                    return ((t = se(r) ? "" : se(n) ? ">=" + r + ".0.0" : se(o) ? ">=" + r + "." + n + ".0" : ">=" + t) + " " + (a = se(c) ? "" : se(l) ? "<" + (+c + 1) + ".0.0" : se(u) ? "<" + c + "." + (+l + 1) + ".0" : d ? "<=" + c + "." + l + "." + u + "-" + d : "<=" + a)).trim()
                }

                function ce(e, t, n) {
                    for (var o = 0; o < e.length; o++)
                        if (!e[o].test(t)) return !1;
                    if (t.prerelease.length && !n.includePrerelease) {
                        for (o = 0; o < e.length; o++)
                            if (r(e[o].semver), e[o].semver !== oe && e[o].semver.prerelease.length > 0) {
                                var i = e[o].semver;
                                if (i.major === t.major && i.minor === t.minor && i.patch === t.patch) return !0
                            }
                        return !1
                    }
                    return !0
                }

                function le(e, t, r) {
                    try {
                        t = new ie(t, r)
                    } catch (e) {
                        return !1
                    }
                    return t.test(e)
                }

                function ue(e, t, r, n) {
                    var o, i, s, a, c;
                    switch (e = new V(e, n), t = new ie(t, n), r) {
                        case ">":
                            o = X, i = te, s = Q, a = ">", c = ">=";
                            break;
                        case "<":
                            o = Q, i = ee, s = X, a = "<", c = "<=";
                            break;
                        default:
                            throw new TypeError('Must provide a hilo val of "<" or ">"')
                    }
                    if (le(e, t, n)) return !1;
                    for (var l = 0; l < t.set.length; ++l) {
                        var u = t.set[l],
                            d = null,
                            p = null;
                        if (u.forEach((function(e) {
                                e.semver === oe && (e = new ne(">=0.0.0")), d = d || e, p = p || e, o(e.semver, d.semver, n) ? d = e : s(e.semver, p.semver, n) && (p = e)
                            })), d.operator === a || d.operator === c) return !1;
                        if ((!p.operator || p.operator === a) && i(e, p.semver)) return !1;
                        if (p.operator === c && s(e, p.semver)) return !1
                    }
                    return !0
                }
                ne.prototype.parse = function(e) {
                    var t = this.options.loose ? o[F] : o[j],
                        r = e.match(t);
                    if (!r) throw new TypeError("Invalid comparator: " + e);
                    this.operator = r[1], "=" === this.operator && (this.operator = ""), r[2] ? this.semver = new V(r[2], this.options.loose) : this.semver = oe
                }, ne.prototype.toString = function() {
                    return this.value
                }, ne.prototype.test = function(e) {
                    return r("Comparator.test", e, this.options.loose), this.semver === oe || ("string" == typeof e && (e = new V(e, this.options)), re(e, this.operator, this.semver, this.options))
                }, ne.prototype.intersects = function(e, t) {
                    if (!(e instanceof ne)) throw new TypeError("a Comparator is required");
                    var r;
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), "" === this.operator) return r = new ie(e.value, t), le(this.value, r, t);
                    if ("" === e.operator) return r = new ie(this.value, t), le(e.semver, r, t);
                    var n = !(">=" !== this.operator && ">" !== this.operator || ">=" !== e.operator && ">" !== e.operator),
                        o = !("<=" !== this.operator && "<" !== this.operator || "<=" !== e.operator && "<" !== e.operator),
                        i = this.semver.version === e.semver.version,
                        s = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== e.operator && "<=" !== e.operator),
                        a = re(this.semver, "<", e.semver, t) && (">=" === this.operator || ">" === this.operator) && ("<=" === e.operator || "<" === e.operator),
                        c = re(this.semver, ">", e.semver, t) && ("<=" === this.operator || "<" === this.operator) && (">=" === e.operator || ">" === e.operator);
                    return n || o || i && s || a || c
                }, t.Range = ie, ie.prototype.format = function() {
                    return this.range = this.set.map((function(e) {
                        return e.join(" ").trim()
                    })).join("||").trim(), this.range
                }, ie.prototype.toString = function() {
                    return this.range
                }, ie.prototype.parseRange = function(e) {
                    var t = this.options.loose;
                    e = e.trim();
                    var n = t ? o[U] : o[q];
                    e = e.replace(n, ae), r("hyphen replace", e), e = e.replace(o[B], "$1$2$3"), r("comparator trim", e, o[B]), e = (e = (e = e.replace(o[O], "$1~")).replace(o[M], "$1^")).split(/\s+/).join(" ");
                    var i = t ? o[F] : o[j],
                        s = e.split(" ").map((function(e) {
                            return function(e, t) {
                                return r("comp", e, t), e = function(e, t) {
                                    return e.trim().split(/\s+/).map((function(e) {
                                        return function(e, t) {
                                            r("caret", e, t);
                                            var n = t.loose ? o[L] : o[D];
                                            return e.replace(n, (function(t, n, o, i, s) {
                                                var a;
                                                return r("caret", e, t, n, o, i, s), se(n) ? a = "" : se(o) ? a = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : se(i) ? a = "0" === n ? ">=" + n + "." + o + ".0 <" + n + "." + (+o + 1) + ".0" : ">=" + n + "." + o + ".0 <" + (+n + 1) + ".0.0" : s ? (r("replaceCaret pr", s), a = "0" === n ? "0" === o ? ">=" + n + "." + o + "." + i + "-" + s + " <" + n + "." + o + "." + (+i + 1) : ">=" + n + "." + o + "." + i + "-" + s + " <" + n + "." + (+o + 1) + ".0" : ">=" + n + "." + o + "." + i + "-" + s + " <" + (+n + 1) + ".0.0") : (r("no pr"), a = "0" === n ? "0" === o ? ">=" + n + "." + o + "." + i + " <" + n + "." + o + "." + (+i + 1) : ">=" + n + "." + o + "." + i + " <" + n + "." + (+o + 1) + ".0" : ">=" + n + "." + o + "." + i + " <" + (+n + 1) + ".0.0"), r("caret return", a), a
                                            }))
                                        }(e, t)
                                    })).join(" ")
                                }(e, t), r("caret", e), e = function(e, t) {
                                    return e.trim().split(/\s+/).map((function(e) {
                                        return function(e, t) {
                                            var n = t.loose ? o[R] : o[N];
                                            return e.replace(n, (function(t, n, o, i, s) {
                                                var a;
                                                return r("tilde", e, t, n, o, i, s), se(n) ? a = "" : se(o) ? a = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : se(i) ? a = ">=" + n + "." + o + ".0 <" + n + "." + (+o + 1) + ".0" : s ? (r("replaceTilde pr", s), a = ">=" + n + "." + o + "." + i + "-" + s + " <" + n + "." + (+o + 1) + ".0") : a = ">=" + n + "." + o + "." + i + " <" + n + "." + (+o + 1) + ".0", r("tilde return", a), a
                                            }))
                                        }(e, t)
                                    })).join(" ")
                                }(e, t), r("tildes", e), e = function(e, t) {
                                    return r("replaceXRanges", e, t), e.split(/\s+/).map((function(e) {
                                        return function(e, t) {
                                            e = e.trim();
                                            var n = t.loose ? o[I] : o[k];
                                            return e.replace(n, (function(t, n, o, i, s, a) {
                                                r("xRange", e, t, n, o, i, s, a);
                                                var c = se(o),
                                                    l = c || se(i),
                                                    u = l || se(s);
                                                return "=" === n && u && (n = ""), c ? t = ">" === n || "<" === n ? "<0.0.0" : "*" : n && u ? (l && (i = 0), s = 0, ">" === n ? (n = ">=", l ? (o = +o + 1, i = 0, s = 0) : (i = +i + 1, s = 0)) : "<=" === n && (n = "<", l ? o = +o + 1 : i = +i + 1), t = n + o + "." + i + "." + s) : l ? t = ">=" + o + ".0.0 <" + (+o + 1) + ".0.0" : u && (t = ">=" + o + "." + i + ".0 <" + o + "." + (+i + 1) + ".0"), r("xRange return", t), t
                                            }))
                                        }(e, t)
                                    })).join(" ")
                                }(e, t), r("xrange", e), e = function(e, t) {
                                    return r("replaceStars", e, t), e.trim().replace(o[H], "")
                                }(e, t), r("stars", e), e
                            }(e, this.options)
                        }), this).join(" ").split(/\s+/);
                    return this.options.loose && (s = s.filter((function(e) {
                        return !!e.match(i)
                    }))), s.map((function(e) {
                        return new ne(e, this.options)
                    }), this)
                }, ie.prototype.intersects = function(e, t) {
                    if (!(e instanceof ie)) throw new TypeError("a Range is required");
                    return this.set.some((function(r) {
                        return r.every((function(r) {
                            return e.set.some((function(e) {
                                return e.every((function(e) {
                                    return r.intersects(e, t)
                                }))
                            }))
                        }))
                    }))
                }, t.toComparators = function(e, t) {
                    return new ie(e, t).set.map((function(e) {
                        return e.map((function(e) {
                            return e.value
                        })).join(" ").trim().split(" ")
                    }))
                }, ie.prototype.test = function(e) {
                    if (!e) return !1;
                    "string" == typeof e && (e = new V(e, this.options));
                    for (var t = 0; t < this.set.length; t++)
                        if (ce(this.set[t], e, this.options)) return !0;
                    return !1
                }, t.satisfies = le, t.maxSatisfying = function(e, t, r) {
                    var n = null,
                        o = null;
                    try {
                        var i = new ie(t, r)
                    } catch (e) {
                        return null
                    }
                    return e.forEach((function(e) {
                        i.test(e) && (n && -1 !== o.compare(e) || (o = new V(n = e, r)))
                    })), n
                }, t.minSatisfying = function(e, t, r) {
                    var n = null,
                        o = null;
                    try {
                        var i = new ie(t, r)
                    } catch (e) {
                        return null
                    }
                    return e.forEach((function(e) {
                        i.test(e) && (n && 1 !== o.compare(e) || (o = new V(n = e, r)))
                    })), n
                }, t.minVersion = function(e, t) {
                    e = new ie(e, t);
                    var r = new V("0.0.0");
                    if (e.test(r)) return r;
                    if (r = new V("0.0.0-0"), e.test(r)) return r;
                    r = null;
                    for (var n = 0; n < e.set.length; ++n) e.set[n].forEach((function(e) {
                        var t = new V(e.semver.version);
                        switch (e.operator) {
                            case ">":
                                0 === t.prerelease.length ? t.patch++ : t.prerelease.push(0), t.raw = t.format();
                            case "":
                            case ">=":
                                r && !X(r, t) || (r = t);
                                break;
                            case "<":
                            case "<=":
                                break;
                            default:
                                throw new Error("Unexpected operation: " + e.operator)
                        }
                    }));
                    return r && e.test(r) ? r : null
                }, t.validRange = function(e, t) {
                    try {
                        return new ie(e, t).range || "*"
                    } catch (e) {
                        return null
                    }
                }, t.ltr = function(e, t, r) {
                    return ue(e, t, "<", r)
                }, t.gtr = function(e, t, r) {
                    return ue(e, t, ">", r)
                }, t.outside = ue, t.prerelease = function(e, t) {
                    var r = z(e, t);
                    return r && r.prerelease.length ? r.prerelease : null
                }, t.intersects = function(e, t, r) {
                    return e = new ie(e, r), t = new ie(t, r), e.intersects(t)
                }, t.coerce = function(e) {
                    if (e instanceof V) return e;
                    if ("string" != typeof e) return null;
                    var t = e.match(o[P]);
                    return null == t ? null : z(t[1] + "." + (t[2] || "0") + "." + (t[3] || "0"))
                }
            },
            3057: (e, t, r) => {
                "use strict";
                var n = r(9491),
                    o = r(9867),
                    i = "error@context";

                function s(e) {
                    this.name = e, this.active = null, this._set = [], this.id = null
                }

                function a(e) {
                    return process.namespaces[e]
                }

                function c(e) {
                    var t = a(e);
                    n.ok(t, "can't delete nonexistent namespace!"), n.ok(t.id, "don't assign to process.namespaces directly!"), process.removeAsyncListener(t.id), process.namespaces[e] = null
                }

                function l() {
                    process.namespaces && Object.keys(process.namespaces).forEach((function(e) {
                        c(e)
                    })), process.namespaces = Object.create(null)
                }
                process.addAsyncListener || r(7645), s.prototype.set = function(e, t) {
                    if (!this.active) throw new Error("No context available. ns.run() or ns.bind() must be called first.");
                    return this.active[e] = t, t
                }, s.prototype.get = function(e) {
                    if (this.active) return this.active[e]
                }, s.prototype.createContext = function() {
                    return Object.create(this.active)
                }, s.prototype.run = function(e) {
                    var t = this.createContext();
                    this.enter(t);
                    try {
                        return e(t), t
                    } catch (e) {
                        throw e && (e[i] = t), e
                    } finally {
                        this.exit(t)
                    }
                }, s.prototype.runAndReturn = function(e) {
                    var t;
                    return this.run((function(r) {
                        t = e(r)
                    })), t
                }, s.prototype.bind = function(e, t) {
                    t || (t = this.active ? this.active : this.createContext());
                    var r = this;
                    return function() {
                        r.enter(t);
                        try {
                            return e.apply(this, arguments)
                        } catch (e) {
                            throw e && (e[i] = t), e
                        } finally {
                            r.exit(t)
                        }
                    }
                }, s.prototype.enter = function(e) {
                    n.ok(e, "context must be provided for entering"), this._set.push(this.active), this.active = e
                }, s.prototype.exit = function(e) {
                    if (n.ok(e, "context must be provided for exiting"), this.active === e) return n.ok(this._set.length, "can't remove top context"), void(this.active = this._set.pop());
                    var t = this._set.lastIndexOf(e);
                    n.ok(t >= 0, "context not currently entered; can't exit"), n.ok(t, "can't remove top context"), this._set.splice(t, 1)
                }, s.prototype.bindEmitter = function(e) {
                    n.ok(e.on && e.addListener && e.emit, "can only bind real EEs");
                    var t = this,
                        r = "context@" + this.name;
                    o(e, (function(e) {
                        e && (e["cls@contexts"] || (e["cls@contexts"] = Object.create(null)), e["cls@contexts"][r] = {
                            namespace: t,
                            context: t.active
                        })
                    }), (function(e) {
                        if (!e || !e["cls@contexts"]) return e;
                        var t = e,
                            r = e["cls@contexts"];
                        return Object.keys(r).forEach((function(e) {
                            var n = r[e];
                            t = n.namespace.bind(t, n.context)
                        })), t
                    }))
                }, s.prototype.fromException = function(e) {
                    return e[i]
                }, process.namespaces || l(), e.exports = {
                    getNamespace: a,
                    createNamespace: function(e) {
                        n.ok(e, "namespace must be given a name!");
                        var t = new s(e);
                        return t.id = process.addAsyncListener({
                            create: function() {
                                return t.active
                            },
                            before: function(e, r) {
                                r && t.enter(r)
                            },
                            after: function(e, r) {
                                r && t.exit(r)
                            },
                            error: function(e) {
                                e && t.exit(e)
                            }
                        }), process.namespaces[e] = t, t
                    },
                    destroyNamespace: c,
                    reset: l
                }
            },
            452: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(8269), r(8214), r(888), r(5109), function() {
                    var e = n,
                        t = e.lib.BlockCipher,
                        r = e.algo,
                        o = [],
                        i = [],
                        s = [],
                        a = [],
                        c = [],
                        l = [],
                        u = [],
                        d = [],
                        p = [],
                        h = [];
                    ! function() {
                        for (var e = [], t = 0; t < 256; t++) e[t] = t < 128 ? t << 1 : t << 1 ^ 283;
                        var r = 0,
                            n = 0;
                        for (t = 0; t < 256; t++) {
                            var f = n ^ n << 1 ^ n << 2 ^ n << 3 ^ n << 4;
                            f = f >>> 8 ^ 255 & f ^ 99, o[r] = f, i[f] = r;
                            var m = e[r],
                                g = e[m],
                                _ = e[g],
                                y = 257 * e[f] ^ 16843008 * f;
                            s[r] = y << 24 | y >>> 8, a[r] = y << 16 | y >>> 16, c[r] = y << 8 | y >>> 24, l[r] = y, y = 16843009 * _ ^ 65537 * g ^ 257 * m ^ 16843008 * r, u[f] = y << 24 | y >>> 8, d[f] = y << 16 | y >>> 16, p[f] = y << 8 | y >>> 24, h[f] = y, r ? (r = m ^ e[e[e[_ ^ m]]], n ^= e[e[n]]) : r = n = 1
                        }
                    }();
                    var f = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
                        m = r.AES = t.extend({
                            _doReset: function() {
                                if (!this._nRounds || this._keyPriorReset !== this._key) {
                                    for (var e = this._keyPriorReset = this._key, t = e.words, r = e.sigBytes / 4, n = 4 * ((this._nRounds = r + 6) + 1), i = this._keySchedule = [], s = 0; s < n; s++) s < r ? i[s] = t[s] : (l = i[s - 1], s % r ? r > 6 && s % r == 4 && (l = o[l >>> 24] << 24 | o[l >>> 16 & 255] << 16 | o[l >>> 8 & 255] << 8 | o[255 & l]) : (l = o[(l = l << 8 | l >>> 24) >>> 24] << 24 | o[l >>> 16 & 255] << 16 | o[l >>> 8 & 255] << 8 | o[255 & l], l ^= f[s / r | 0] << 24), i[s] = i[s - r] ^ l);
                                    for (var a = this._invKeySchedule = [], c = 0; c < n; c++) {
                                        if (s = n - c, c % 4) var l = i[s];
                                        else l = i[s - 4];
                                        a[c] = c < 4 || s <= 4 ? l : u[o[l >>> 24]] ^ d[o[l >>> 16 & 255]] ^ p[o[l >>> 8 & 255]] ^ h[o[255 & l]]
                                    }
                                }
                            },
                            encryptBlock: function(e, t) {
                                this._doCryptBlock(e, t, this._keySchedule, s, a, c, l, o)
                            },
                            decryptBlock: function(e, t) {
                                var r = e[t + 1];
                                e[t + 1] = e[t + 3], e[t + 3] = r, this._doCryptBlock(e, t, this._invKeySchedule, u, d, p, h, i), r = e[t + 1], e[t + 1] = e[t + 3], e[t + 3] = r
                            },
                            _doCryptBlock: function(e, t, r, n, o, i, s, a) {
                                for (var c = this._nRounds, l = e[t] ^ r[0], u = e[t + 1] ^ r[1], d = e[t + 2] ^ r[2], p = e[t + 3] ^ r[3], h = 4, f = 1; f < c; f++) {
                                    var m = n[l >>> 24] ^ o[u >>> 16 & 255] ^ i[d >>> 8 & 255] ^ s[255 & p] ^ r[h++],
                                        g = n[u >>> 24] ^ o[d >>> 16 & 255] ^ i[p >>> 8 & 255] ^ s[255 & l] ^ r[h++],
                                        _ = n[d >>> 24] ^ o[p >>> 16 & 255] ^ i[l >>> 8 & 255] ^ s[255 & u] ^ r[h++],
                                        y = n[p >>> 24] ^ o[l >>> 16 & 255] ^ i[u >>> 8 & 255] ^ s[255 & d] ^ r[h++];
                                    l = m, u = g, d = _, p = y
                                }
                                m = (a[l >>> 24] << 24 | a[u >>> 16 & 255] << 16 | a[d >>> 8 & 255] << 8 | a[255 & p]) ^ r[h++], g = (a[u >>> 24] << 24 | a[d >>> 16 & 255] << 16 | a[p >>> 8 & 255] << 8 | a[255 & l]) ^ r[h++], _ = (a[d >>> 24] << 24 | a[p >>> 16 & 255] << 16 | a[l >>> 8 & 255] << 8 | a[255 & u]) ^ r[h++], y = (a[p >>> 24] << 24 | a[l >>> 16 & 255] << 16 | a[u >>> 8 & 255] << 8 | a[255 & d]) ^ r[h++], e[t] = m, e[t + 1] = g, e[t + 2] = _, e[t + 3] = y
                            },
                            keySize: 8
                        });
                    e.AES = t._createHelper(m)
                }(), n.AES)
            },
            5109: function(e, t, r) {
                var n, o, i, s, a, c, l, u, d, p, h, f, m, g, _, y, v, b, w;
                e.exports = (n = r(8249), r(888), void(n.lib.Cipher || (o = n, i = o.lib, s = i.Base, a = i.WordArray, c = i.BufferedBlockAlgorithm, l = o.enc, l.Utf8, u = l.Base64, d = o.algo.EvpKDF, p = i.Cipher = c.extend({
                    cfg: s.extend(),
                    createEncryptor: function(e, t) {
                        return this.create(this._ENC_XFORM_MODE, e, t)
                    },
                    createDecryptor: function(e, t) {
                        return this.create(this._DEC_XFORM_MODE, e, t)
                    },
                    init: function(e, t, r) {
                        this.cfg = this.cfg.extend(r), this._xformMode = e, this._key = t, this.reset()
                    },
                    reset: function() {
                        c.reset.call(this), this._doReset()
                    },
                    process: function(e) {
                        return this._append(e), this._process()
                    },
                    finalize: function(e) {
                        return e && this._append(e), this._doFinalize()
                    },
                    keySize: 4,
                    ivSize: 4,
                    _ENC_XFORM_MODE: 1,
                    _DEC_XFORM_MODE: 2,
                    _createHelper: function() {
                        function e(e) {
                            return "string" == typeof e ? w : v
                        }
                        return function(t) {
                            return {
                                encrypt: function(r, n, o) {
                                    return e(n).encrypt(t, r, n, o)
                                },
                                decrypt: function(r, n, o) {
                                    return e(n).decrypt(t, r, n, o)
                                }
                            }
                        }
                    }()
                }), i.StreamCipher = p.extend({
                    _doFinalize: function() {
                        return this._process(!0)
                    },
                    blockSize: 1
                }), h = o.mode = {}, f = i.BlockCipherMode = s.extend({
                    createEncryptor: function(e, t) {
                        return this.Encryptor.create(e, t)
                    },
                    createDecryptor: function(e, t) {
                        return this.Decryptor.create(e, t)
                    },
                    init: function(e, t) {
                        this._cipher = e, this._iv = t
                    }
                }), m = h.CBC = function() {
                    var e = f.extend();

                    function t(e, t, r) {
                        var n, o = this._iv;
                        o ? (n = o, this._iv = void 0) : n = this._prevBlock;
                        for (var i = 0; i < r; i++) e[t + i] ^= n[i]
                    }
                    return e.Encryptor = e.extend({
                        processBlock: function(e, r) {
                            var n = this._cipher,
                                o = n.blockSize;
                            t.call(this, e, r, o), n.encryptBlock(e, r), this._prevBlock = e.slice(r, r + o)
                        }
                    }), e.Decryptor = e.extend({
                        processBlock: function(e, r) {
                            var n = this._cipher,
                                o = n.blockSize,
                                i = e.slice(r, r + o);
                            n.decryptBlock(e, r), t.call(this, e, r, o), this._prevBlock = i
                        }
                    }), e
                }(), g = (o.pad = {}).Pkcs7 = {
                    pad: function(e, t) {
                        for (var r = 4 * t, n = r - e.sigBytes % r, o = n << 24 | n << 16 | n << 8 | n, i = [], s = 0; s < n; s += 4) i.push(o);
                        var c = a.create(i, n);
                        e.concat(c)
                    },
                    unpad: function(e) {
                        var t = 255 & e.words[e.sigBytes - 1 >>> 2];
                        e.sigBytes -= t
                    }
                }, i.BlockCipher = p.extend({
                    cfg: p.cfg.extend({
                        mode: m,
                        padding: g
                    }),
                    reset: function() {
                        var e;
                        p.reset.call(this);
                        var t = this.cfg,
                            r = t.iv,
                            n = t.mode;
                        this._xformMode == this._ENC_XFORM_MODE ? e = n.createEncryptor : (e = n.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == e ? this._mode.init(this, r && r.words) : (this._mode = e.call(n, this, r && r.words), this._mode.__creator = e)
                    },
                    _doProcessBlock: function(e, t) {
                        this._mode.processBlock(e, t)
                    },
                    _doFinalize: function() {
                        var e, t = this.cfg.padding;
                        return this._xformMode == this._ENC_XFORM_MODE ? (t.pad(this._data, this.blockSize), e = this._process(!0)) : (e = this._process(!0), t.unpad(e)), e
                    },
                    blockSize: 4
                }), _ = i.CipherParams = s.extend({
                    init: function(e) {
                        this.mixIn(e)
                    },
                    toString: function(e) {
                        return (e || this.formatter).stringify(this)
                    }
                }), y = (o.format = {}).OpenSSL = {
                    stringify: function(e) {
                        var t = e.ciphertext,
                            r = e.salt;
                        return (r ? a.create([1398893684, 1701076831]).concat(r).concat(t) : t).toString(u)
                    },
                    parse: function(e) {
                        var t, r = u.parse(e),
                            n = r.words;
                        return 1398893684 == n[0] && 1701076831 == n[1] && (t = a.create(n.slice(2, 4)), n.splice(0, 4), r.sigBytes -= 16), _.create({
                            ciphertext: r,
                            salt: t
                        })
                    }
                }, v = i.SerializableCipher = s.extend({
                    cfg: s.extend({
                        format: y
                    }),
                    encrypt: function(e, t, r, n) {
                        n = this.cfg.extend(n);
                        var o = e.createEncryptor(r, n),
                            i = o.finalize(t),
                            s = o.cfg;
                        return _.create({
                            ciphertext: i,
                            key: r,
                            iv: s.iv,
                            algorithm: e,
                            mode: s.mode,
                            padding: s.padding,
                            blockSize: e.blockSize,
                            formatter: n.format
                        })
                    },
                    decrypt: function(e, t, r, n) {
                        return n = this.cfg.extend(n), t = this._parse(t, n.format), e.createDecryptor(r, n).finalize(t.ciphertext)
                    },
                    _parse: function(e, t) {
                        return "string" == typeof e ? t.parse(e, this) : e
                    }
                }), b = (o.kdf = {}).OpenSSL = {
                    execute: function(e, t, r, n) {
                        n || (n = a.random(8));
                        var o = d.create({
                                keySize: t + r
                            }).compute(e, n),
                            i = a.create(o.words.slice(t), 4 * r);
                        return o.sigBytes = 4 * t, _.create({
                            key: o,
                            iv: i,
                            salt: n
                        })
                    }
                }, w = i.PasswordBasedCipher = v.extend({
                    cfg: v.cfg.extend({
                        kdf: b
                    }),
                    encrypt: function(e, t, r, n) {
                        var o = (n = this.cfg.extend(n)).kdf.execute(r, e.keySize, e.ivSize);
                        n.iv = o.iv;
                        var i = v.encrypt.call(this, e, t, o.key, n);
                        return i.mixIn(o), i
                    },
                    decrypt: function(e, t, r, n) {
                        n = this.cfg.extend(n), t = this._parse(t, n.format);
                        var o = n.kdf.execute(r, e.keySize, e.ivSize, t.salt);
                        return n.iv = o.iv, v.decrypt.call(this, e, t, o.key, n)
                    }
                }))))
            },
            8249: function(e, t, r) {
                var n;
                e.exports = (n = n || function(e, t) {
                    var n;
                    if ("undefined" != typeof window && window.crypto && (n = window.crypto), !n && "undefined" != typeof window && window.msCrypto && (n = window.msCrypto), !n && "undefined" != typeof global && global.crypto && (n = global.crypto), !n) try {
                        n = r(6113)
                    } catch (e) {}
                    var o = function() {
                            if (n) {
                                if ("function" == typeof n.getRandomValues) try {
                                    return n.getRandomValues(new Uint32Array(1))[0]
                                } catch (e) {}
                                if ("function" == typeof n.randomBytes) try {
                                    return n.randomBytes(4).readInt32LE()
                                } catch (e) {}
                            }
                            throw new Error("Native crypto module could not be used to get secure random number.")
                        },
                        i = Object.create || function() {
                            function e() {}
                            return function(t) {
                                var r;
                                return e.prototype = t, r = new e, e.prototype = null, r
                            }
                        }(),
                        s = {},
                        a = s.lib = {},
                        c = a.Base = {
                            extend: function(e) {
                                var t = i(this);
                                return e && t.mixIn(e), t.hasOwnProperty("init") && this.init !== t.init || (t.init = function() {
                                    t.$super.init.apply(this, arguments)
                                }), t.init.prototype = t, t.$super = this, t
                            },
                            create: function() {
                                var e = this.extend();
                                return e.init.apply(e, arguments), e
                            },
                            init: function() {},
                            mixIn: function(e) {
                                for (var t in e) e.hasOwnProperty(t) && (this[t] = e[t]);
                                e.hasOwnProperty("toString") && (this.toString = e.toString)
                            },
                            clone: function() {
                                return this.init.prototype.extend(this)
                            }
                        },
                        l = a.WordArray = c.extend({
                            init: function(e, t) {
                                e = this.words = e || [], this.sigBytes = null != t ? t : 4 * e.length
                            },
                            toString: function(e) {
                                return (e || d).stringify(this)
                            },
                            concat: function(e) {
                                var t = this.words,
                                    r = e.words,
                                    n = this.sigBytes,
                                    o = e.sigBytes;
                                if (this.clamp(), n % 4)
                                    for (var i = 0; i < o; i++) {
                                        var s = r[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                                        t[n + i >>> 2] |= s << 24 - (n + i) % 4 * 8
                                    } else
                                        for (i = 0; i < o; i += 4) t[n + i >>> 2] = r[i >>> 2];
                                return this.sigBytes += o, this
                            },
                            clamp: function() {
                                var t = this.words,
                                    r = this.sigBytes;
                                t[r >>> 2] &= 4294967295 << 32 - r % 4 * 8, t.length = e.ceil(r / 4)
                            },
                            clone: function() {
                                var e = c.clone.call(this);
                                return e.words = this.words.slice(0), e
                            },
                            random: function(e) {
                                for (var t = [], r = 0; r < e; r += 4) t.push(o());
                                return new l.init(t, e)
                            }
                        }),
                        u = s.enc = {},
                        d = u.Hex = {
                            stringify: function(e) {
                                for (var t = e.words, r = e.sigBytes, n = [], o = 0; o < r; o++) {
                                    var i = t[o >>> 2] >>> 24 - o % 4 * 8 & 255;
                                    n.push((i >>> 4).toString(16)), n.push((15 & i).toString(16))
                                }
                                return n.join("")
                            },
                            parse: function(e) {
                                for (var t = e.length, r = [], n = 0; n < t; n += 2) r[n >>> 3] |= parseInt(e.substr(n, 2), 16) << 24 - n % 8 * 4;
                                return new l.init(r, t / 2)
                            }
                        },
                        p = u.Latin1 = {
                            stringify: function(e) {
                                for (var t = e.words, r = e.sigBytes, n = [], o = 0; o < r; o++) {
                                    var i = t[o >>> 2] >>> 24 - o % 4 * 8 & 255;
                                    n.push(String.fromCharCode(i))
                                }
                                return n.join("")
                            },
                            parse: function(e) {
                                for (var t = e.length, r = [], n = 0; n < t; n++) r[n >>> 2] |= (255 & e.charCodeAt(n)) << 24 - n % 4 * 8;
                                return new l.init(r, t)
                            }
                        },
                        h = u.Utf8 = {
                            stringify: function(e) {
                                try {
                                    return decodeURIComponent(escape(p.stringify(e)))
                                } catch (e) {
                                    throw new Error("Malformed UTF-8 data")
                                }
                            },
                            parse: function(e) {
                                return p.parse(unescape(encodeURIComponent(e)))
                            }
                        },
                        f = a.BufferedBlockAlgorithm = c.extend({
                            reset: function() {
                                this._data = new l.init, this._nDataBytes = 0
                            },
                            _append: function(e) {
                                "string" == typeof e && (e = h.parse(e)), this._data.concat(e), this._nDataBytes += e.sigBytes
                            },
                            _process: function(t) {
                                var r, n = this._data,
                                    o = n.words,
                                    i = n.sigBytes,
                                    s = this.blockSize,
                                    a = i / (4 * s),
                                    c = (a = t ? e.ceil(a) : e.max((0 | a) - this._minBufferSize, 0)) * s,
                                    u = e.min(4 * c, i);
                                if (c) {
                                    for (var d = 0; d < c; d += s) this._doProcessBlock(o, d);
                                    r = o.splice(0, c), n.sigBytes -= u
                                }
                                return new l.init(r, u)
                            },
                            clone: function() {
                                var e = c.clone.call(this);
                                return e._data = this._data.clone(), e
                            },
                            _minBufferSize: 0
                        }),
                        m = (a.Hasher = f.extend({
                            cfg: c.extend(),
                            init: function(e) {
                                this.cfg = this.cfg.extend(e), this.reset()
                            },
                            reset: function() {
                                f.reset.call(this), this._doReset()
                            },
                            update: function(e) {
                                return this._append(e), this._process(), this
                            },
                            finalize: function(e) {
                                return e && this._append(e), this._doFinalize()
                            },
                            blockSize: 16,
                            _createHelper: function(e) {
                                return function(t, r) {
                                    return new e.init(r).finalize(t)
                                }
                            },
                            _createHmacHelper: function(e) {
                                return function(t, r) {
                                    return new m.HMAC.init(e, r).finalize(t)
                                }
                            }
                        }), s.algo = {});
                    return s
                }(Math), n)
            },
            8269: function(e, t, r) {
                var n, o, i;
                e.exports = (n = r(8249), i = (o = n).lib.WordArray, o.enc.Base64 = {
                    stringify: function(e) {
                        var t = e.words,
                            r = e.sigBytes,
                            n = this._map;
                        e.clamp();
                        for (var o = [], i = 0; i < r; i += 3)
                            for (var s = (t[i >>> 2] >>> 24 - i % 4 * 8 & 255) << 16 | (t[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255) << 8 | t[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255, a = 0; a < 4 && i + .75 * a < r; a++) o.push(n.charAt(s >>> 6 * (3 - a) & 63));
                        var c = n.charAt(64);
                        if (c)
                            for (; o.length % 4;) o.push(c);
                        return o.join("")
                    },
                    parse: function(e) {
                        var t = e.length,
                            r = this._map,
                            n = this._reverseMap;
                        if (!n) {
                            n = this._reverseMap = [];
                            for (var o = 0; o < r.length; o++) n[r.charCodeAt(o)] = o
                        }
                        var s = r.charAt(64);
                        if (s) {
                            var a = e.indexOf(s); - 1 !== a && (t = a)
                        }
                        return function(e, t, r) {
                            for (var n = [], o = 0, s = 0; s < t; s++)
                                if (s % 4) {
                                    var a = r[e.charCodeAt(s - 1)] << s % 4 * 2 | r[e.charCodeAt(s)] >>> 6 - s % 4 * 2;
                                    n[o >>> 2] |= a << 24 - o % 4 * 8, o++
                                }
                            return i.create(n, o)
                        }(e, t, n)
                    },
                    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                }, n.enc.Base64)
            },
            298: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), function() {
                    var e = n,
                        t = e.lib.WordArray,
                        r = e.enc;

                    function o(e) {
                        return e << 8 & 4278255360 | e >>> 8 & 16711935
                    }
                    r.Utf16 = r.Utf16BE = {
                        stringify: function(e) {
                            for (var t = e.words, r = e.sigBytes, n = [], o = 0; o < r; o += 2) {
                                var i = t[o >>> 2] >>> 16 - o % 4 * 8 & 65535;
                                n.push(String.fromCharCode(i))
                            }
                            return n.join("")
                        },
                        parse: function(e) {
                            for (var r = e.length, n = [], o = 0; o < r; o++) n[o >>> 1] |= e.charCodeAt(o) << 16 - o % 2 * 16;
                            return t.create(n, 2 * r)
                        }
                    }, r.Utf16LE = {
                        stringify: function(e) {
                            for (var t = e.words, r = e.sigBytes, n = [], i = 0; i < r; i += 2) {
                                var s = o(t[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
                                n.push(String.fromCharCode(s))
                            }
                            return n.join("")
                        },
                        parse: function(e) {
                            for (var r = e.length, n = [], i = 0; i < r; i++) n[i >>> 1] |= o(e.charCodeAt(i) << 16 - i % 2 * 16);
                            return t.create(n, 2 * r)
                        }
                    }
                }(), n.enc.Utf16)
            },
            888: function(e, t, r) {
                var n, o, i, s, a, c, l, u;
                e.exports = (u = r(8249), r(2783), r(9824), i = (o = (n = u).lib).Base, s = o.WordArray, c = (a = n.algo).MD5, l = a.EvpKDF = i.extend({
                    cfg: i.extend({
                        keySize: 4,
                        hasher: c,
                        iterations: 1
                    }),
                    init: function(e) {
                        this.cfg = this.cfg.extend(e)
                    },
                    compute: function(e, t) {
                        for (var r, n = this.cfg, o = n.hasher.create(), i = s.create(), a = i.words, c = n.keySize, l = n.iterations; a.length < c;) {
                            r && o.update(r), r = o.update(e).finalize(t), o.reset();
                            for (var u = 1; u < l; u++) r = o.finalize(r), o.reset();
                            i.concat(r)
                        }
                        return i.sigBytes = 4 * c, i
                    }
                }), n.EvpKDF = function(e, t, r) {
                    return l.create(r).compute(e, t)
                }, u.EvpKDF)
            },
            2209: function(e, t, r) {
                var n, o, i, s;
                e.exports = (s = r(8249), r(5109), o = (n = s).lib.CipherParams, i = n.enc.Hex, n.format.Hex = {
                    stringify: function(e) {
                        return e.ciphertext.toString(i)
                    },
                    parse: function(e) {
                        var t = i.parse(e);
                        return o.create({
                            ciphertext: t
                        })
                    }
                }, s.format.Hex)
            },
            9824: function(e, t, r) {
                var n, o, i;
                e.exports = (o = (n = r(8249)).lib.Base, i = n.enc.Utf8, void(n.algo.HMAC = o.extend({
                    init: function(e, t) {
                        e = this._hasher = new e.init, "string" == typeof t && (t = i.parse(t));
                        var r = e.blockSize,
                            n = 4 * r;
                        t.sigBytes > n && (t = e.finalize(t)), t.clamp();
                        for (var o = this._oKey = t.clone(), s = this._iKey = t.clone(), a = o.words, c = s.words, l = 0; l < r; l++) a[l] ^= 1549556828, c[l] ^= 909522486;
                        o.sigBytes = s.sigBytes = n, this.reset()
                    },
                    reset: function() {
                        var e = this._hasher;
                        e.reset(), e.update(this._iKey)
                    },
                    update: function(e) {
                        return this._hasher.update(e), this
                    },
                    finalize: function(e) {
                        var t = this._hasher,
                            r = t.finalize(e);
                        return t.reset(), t.finalize(this._oKey.clone().concat(r))
                    }
                })))
            },
            1354: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(4938), r(2422), r(298), r(8269), r(8214), r(2783), r(2153), r(7792), r(34), r(7460), r(3327), r(706), r(9824), r(2112), r(888), r(5109), r(8568), r(4242), r(9968), r(7660), r(1148), r(3615), r(2807), r(1077), r(6475), r(6991), r(2209), r(452), r(4253), r(1857), r(4454), r(3974), n)
            },
            2422: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), function() {
                    if ("function" == typeof ArrayBuffer) {
                        var e = n.lib.WordArray,
                            t = e.init,
                            r = e.init = function(e) {
                                if (e instanceof ArrayBuffer && (e = new Uint8Array(e)), (e instanceof Int8Array || "undefined" != typeof Uint8ClampedArray && e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array || e instanceof Float64Array) && (e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength)), e instanceof Uint8Array) {
                                    for (var r = e.byteLength, n = [], o = 0; o < r; o++) n[o >>> 2] |= e[o] << 24 - o % 4 * 8;
                                    t.call(this, n, r)
                                } else t.apply(this, arguments)
                            };
                        r.prototype = e
                    }
                }(), n.lib.WordArray)
            },
            8214: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), function(e) {
                    var t = n,
                        r = t.lib,
                        o = r.WordArray,
                        i = r.Hasher,
                        s = t.algo,
                        a = [];
                    ! function() {
                        for (var t = 0; t < 64; t++) a[t] = 4294967296 * e.abs(e.sin(t + 1)) | 0
                    }();
                    var c = s.MD5 = i.extend({
                        _doReset: function() {
                            this._hash = new o.init([1732584193, 4023233417, 2562383102, 271733878])
                        },
                        _doProcessBlock: function(e, t) {
                            for (var r = 0; r < 16; r++) {
                                var n = t + r,
                                    o = e[n];
                                e[n] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8)
                            }
                            var i = this._hash.words,
                                s = e[t + 0],
                                c = e[t + 1],
                                h = e[t + 2],
                                f = e[t + 3],
                                m = e[t + 4],
                                g = e[t + 5],
                                _ = e[t + 6],
                                y = e[t + 7],
                                v = e[t + 8],
                                b = e[t + 9],
                                w = e[t + 10],
                                x = e[t + 11],
                                E = e[t + 12],
                                C = e[t + 13],
                                S = e[t + 14],
                                T = e[t + 15],
                                k = i[0],
                                I = i[1],
                                P = i[2],
                                A = i[3];
                            k = l(k, I, P, A, s, 7, a[0]), A = l(A, k, I, P, c, 12, a[1]), P = l(P, A, k, I, h, 17, a[2]), I = l(I, P, A, k, f, 22, a[3]), k = l(k, I, P, A, m, 7, a[4]), A = l(A, k, I, P, g, 12, a[5]), P = l(P, A, k, I, _, 17, a[6]), I = l(I, P, A, k, y, 22, a[7]), k = l(k, I, P, A, v, 7, a[8]), A = l(A, k, I, P, b, 12, a[9]), P = l(P, A, k, I, w, 17, a[10]), I = l(I, P, A, k, x, 22, a[11]), k = l(k, I, P, A, E, 7, a[12]), A = l(A, k, I, P, C, 12, a[13]), P = l(P, A, k, I, S, 17, a[14]), k = u(k, I = l(I, P, A, k, T, 22, a[15]), P, A, c, 5, a[16]), A = u(A, k, I, P, _, 9, a[17]), P = u(P, A, k, I, x, 14, a[18]), I = u(I, P, A, k, s, 20, a[19]), k = u(k, I, P, A, g, 5, a[20]), A = u(A, k, I, P, w, 9, a[21]), P = u(P, A, k, I, T, 14, a[22]), I = u(I, P, A, k, m, 20, a[23]), k = u(k, I, P, A, b, 5, a[24]), A = u(A, k, I, P, S, 9, a[25]), P = u(P, A, k, I, f, 14, a[26]), I = u(I, P, A, k, v, 20, a[27]), k = u(k, I, P, A, C, 5, a[28]), A = u(A, k, I, P, h, 9, a[29]), P = u(P, A, k, I, y, 14, a[30]), k = d(k, I = u(I, P, A, k, E, 20, a[31]), P, A, g, 4, a[32]), A = d(A, k, I, P, v, 11, a[33]), P = d(P, A, k, I, x, 16, a[34]), I = d(I, P, A, k, S, 23, a[35]), k = d(k, I, P, A, c, 4, a[36]), A = d(A, k, I, P, m, 11, a[37]), P = d(P, A, k, I, y, 16, a[38]), I = d(I, P, A, k, w, 23, a[39]), k = d(k, I, P, A, C, 4, a[40]), A = d(A, k, I, P, s, 11, a[41]), P = d(P, A, k, I, f, 16, a[42]), I = d(I, P, A, k, _, 23, a[43]), k = d(k, I, P, A, b, 4, a[44]), A = d(A, k, I, P, E, 11, a[45]), P = d(P, A, k, I, T, 16, a[46]), k = p(k, I = d(I, P, A, k, h, 23, a[47]), P, A, s, 6, a[48]), A = p(A, k, I, P, y, 10, a[49]), P = p(P, A, k, I, S, 15, a[50]), I = p(I, P, A, k, g, 21, a[51]), k = p(k, I, P, A, E, 6, a[52]), A = p(A, k, I, P, f, 10, a[53]), P = p(P, A, k, I, w, 15, a[54]), I = p(I, P, A, k, c, 21, a[55]), k = p(k, I, P, A, v, 6, a[56]), A = p(A, k, I, P, T, 10, a[57]), P = p(P, A, k, I, _, 15, a[58]), I = p(I, P, A, k, C, 21, a[59]), k = p(k, I, P, A, m, 6, a[60]), A = p(A, k, I, P, x, 10, a[61]), P = p(P, A, k, I, h, 15, a[62]), I = p(I, P, A, k, b, 21, a[63]), i[0] = i[0] + k | 0, i[1] = i[1] + I | 0, i[2] = i[2] + P | 0, i[3] = i[3] + A | 0
                        },
                        _doFinalize: function() {
                            var t = this._data,
                                r = t.words,
                                n = 8 * this._nDataBytes,
                                o = 8 * t.sigBytes;
                            r[o >>> 5] |= 128 << 24 - o % 32;
                            var i = e.floor(n / 4294967296),
                                s = n;
                            r[15 + (o + 64 >>> 9 << 4)] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8), r[14 + (o + 64 >>> 9 << 4)] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8), t.sigBytes = 4 * (r.length + 1), this._process();
                            for (var a = this._hash, c = a.words, l = 0; l < 4; l++) {
                                var u = c[l];
                                c[l] = 16711935 & (u << 8 | u >>> 24) | 4278255360 & (u << 24 | u >>> 8)
                            }
                            return a
                        },
                        clone: function() {
                            var e = i.clone.call(this);
                            return e._hash = this._hash.clone(), e
                        }
                    });

                    function l(e, t, r, n, o, i, s) {
                        var a = e + (t & r | ~t & n) + o + s;
                        return (a << i | a >>> 32 - i) + t
                    }

                    function u(e, t, r, n, o, i, s) {
                        var a = e + (t & n | r & ~n) + o + s;
                        return (a << i | a >>> 32 - i) + t
                    }

                    function d(e, t, r, n, o, i, s) {
                        var a = e + (t ^ r ^ n) + o + s;
                        return (a << i | a >>> 32 - i) + t
                    }

                    function p(e, t, r, n, o, i, s) {
                        var a = e + (r ^ (t | ~n)) + o + s;
                        return (a << i | a >>> 32 - i) + t
                    }
                    t.MD5 = i._createHelper(c), t.HmacMD5 = i._createHmacHelper(c)
                }(Math), n.MD5)
            },
            8568: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(5109), n.mode.CFB = function() {
                    var e = n.lib.BlockCipherMode.extend();

                    function t(e, t, r, n) {
                        var o, i = this._iv;
                        i ? (o = i.slice(0), this._iv = void 0) : o = this._prevBlock, n.encryptBlock(o, 0);
                        for (var s = 0; s < r; s++) e[t + s] ^= o[s]
                    }
                    return e.Encryptor = e.extend({
                        processBlock: function(e, r) {
                            var n = this._cipher,
                                o = n.blockSize;
                            t.call(this, e, r, o, n), this._prevBlock = e.slice(r, r + o)
                        }
                    }), e.Decryptor = e.extend({
                        processBlock: function(e, r) {
                            var n = this._cipher,
                                o = n.blockSize,
                                i = e.slice(r, r + o);
                            t.call(this, e, r, o, n), this._prevBlock = i
                        }
                    }), e
                }(), n.mode.CFB)
            },
            9968: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(5109), n.mode.CTRGladman = function() {
                    var e = n.lib.BlockCipherMode.extend();

                    function t(e) {
                        if (255 == (e >> 24 & 255)) {
                            var t = e >> 16 & 255,
                                r = e >> 8 & 255,
                                n = 255 & e;
                            255 === t ? (t = 0, 255 === r ? (r = 0, 255 === n ? n = 0 : ++n) : ++r) : ++t, e = 0, e += t << 16, e += r << 8, e += n
                        } else e += 1 << 24;
                        return e
                    }
                    var r = e.Encryptor = e.extend({
                        processBlock: function(e, r) {
                            var n = this._cipher,
                                o = n.blockSize,
                                i = this._iv,
                                s = this._counter;
                            i && (s = this._counter = i.slice(0), this._iv = void 0),
                                function(e) {
                                    0 === (e[0] = t(e[0])) && (e[1] = t(e[1]))
                                }(s);
                            var a = s.slice(0);
                            n.encryptBlock(a, 0);
                            for (var c = 0; c < o; c++) e[r + c] ^= a[c]
                        }
                    });
                    return e.Decryptor = r, e
                }(), n.mode.CTRGladman)
            },
            4242: function(e, t, r) {
                var n, o, i;
                e.exports = (i = r(8249), r(5109), i.mode.CTR = (o = (n = i.lib.BlockCipherMode.extend()).Encryptor = n.extend({
                    processBlock: function(e, t) {
                        var r = this._cipher,
                            n = r.blockSize,
                            o = this._iv,
                            i = this._counter;
                        o && (i = this._counter = o.slice(0), this._iv = void 0);
                        var s = i.slice(0);
                        r.encryptBlock(s, 0), i[n - 1] = i[n - 1] + 1 | 0;
                        for (var a = 0; a < n; a++) e[t + a] ^= s[a]
                    }
                }), n.Decryptor = o, n), i.mode.CTR)
            },
            1148: function(e, t, r) {
                var n, o;
                e.exports = (o = r(8249), r(5109), o.mode.ECB = ((n = o.lib.BlockCipherMode.extend()).Encryptor = n.extend({
                    processBlock: function(e, t) {
                        this._cipher.encryptBlock(e, t)
                    }
                }), n.Decryptor = n.extend({
                    processBlock: function(e, t) {
                        this._cipher.decryptBlock(e, t)
                    }
                }), n), o.mode.ECB)
            },
            7660: function(e, t, r) {
                var n, o, i;
                e.exports = (i = r(8249), r(5109), i.mode.OFB = (o = (n = i.lib.BlockCipherMode.extend()).Encryptor = n.extend({
                    processBlock: function(e, t) {
                        var r = this._cipher,
                            n = r.blockSize,
                            o = this._iv,
                            i = this._keystream;
                        o && (i = this._keystream = o.slice(0), this._iv = void 0), r.encryptBlock(i, 0);
                        for (var s = 0; s < n; s++) e[t + s] ^= i[s]
                    }
                }), n.Decryptor = o, n), i.mode.OFB)
            },
            3615: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(5109), n.pad.AnsiX923 = {
                    pad: function(e, t) {
                        var r = e.sigBytes,
                            n = 4 * t,
                            o = n - r % n,
                            i = r + o - 1;
                        e.clamp(), e.words[i >>> 2] |= o << 24 - i % 4 * 8, e.sigBytes += o
                    },
                    unpad: function(e) {
                        var t = 255 & e.words[e.sigBytes - 1 >>> 2];
                        e.sigBytes -= t
                    }
                }, n.pad.Ansix923)
            },
            2807: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(5109), n.pad.Iso10126 = {
                    pad: function(e, t) {
                        var r = 4 * t,
                            o = r - e.sigBytes % r;
                        e.concat(n.lib.WordArray.random(o - 1)).concat(n.lib.WordArray.create([o << 24], 1))
                    },
                    unpad: function(e) {
                        var t = 255 & e.words[e.sigBytes - 1 >>> 2];
                        e.sigBytes -= t
                    }
                }, n.pad.Iso10126)
            },
            1077: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(5109), n.pad.Iso97971 = {
                    pad: function(e, t) {
                        e.concat(n.lib.WordArray.create([2147483648], 1)), n.pad.ZeroPadding.pad(e, t)
                    },
                    unpad: function(e) {
                        n.pad.ZeroPadding.unpad(e), e.sigBytes--
                    }
                }, n.pad.Iso97971)
            },
            6991: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(5109), n.pad.NoPadding = {
                    pad: function() {},
                    unpad: function() {}
                }, n.pad.NoPadding)
            },
            6475: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(5109), n.pad.ZeroPadding = {
                    pad: function(e, t) {
                        var r = 4 * t;
                        e.clamp(), e.sigBytes += r - (e.sigBytes % r || r)
                    },
                    unpad: function(e) {
                        var t = e.words,
                            r = e.sigBytes - 1;
                        for (r = e.sigBytes - 1; r >= 0; r--)
                            if (t[r >>> 2] >>> 24 - r % 4 * 8 & 255) {
                                e.sigBytes = r + 1;
                                break
                            }
                    }
                }, n.pad.ZeroPadding)
            },
            2112: function(e, t, r) {
                var n, o, i, s, a, c, l, u, d;
                e.exports = (d = r(8249), r(2783), r(9824), i = (o = (n = d).lib).Base, s = o.WordArray, c = (a = n.algo).SHA1, l = a.HMAC, u = a.PBKDF2 = i.extend({
                    cfg: i.extend({
                        keySize: 4,
                        hasher: c,
                        iterations: 1
                    }),
                    init: function(e) {
                        this.cfg = this.cfg.extend(e)
                    },
                    compute: function(e, t) {
                        for (var r = this.cfg, n = l.create(r.hasher, e), o = s.create(), i = s.create([1]), a = o.words, c = i.words, u = r.keySize, d = r.iterations; a.length < u;) {
                            var p = n.update(t).finalize(i);
                            n.reset();
                            for (var h = p.words, f = h.length, m = p, g = 1; g < d; g++) {
                                m = n.finalize(m), n.reset();
                                for (var _ = m.words, y = 0; y < f; y++) h[y] ^= _[y]
                            }
                            o.concat(p), c[0]++
                        }
                        return o.sigBytes = 4 * u, o
                    }
                }), n.PBKDF2 = function(e, t, r) {
                    return u.create(r).compute(e, t)
                }, d.PBKDF2)
            },
            3974: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(8269), r(8214), r(888), r(5109), function() {
                    var e = n,
                        t = e.lib.StreamCipher,
                        r = e.algo,
                        o = [],
                        i = [],
                        s = [],
                        a = r.RabbitLegacy = t.extend({
                            _doReset: function() {
                                var e = this._key.words,
                                    t = this.cfg.iv,
                                    r = this._X = [e[0], e[3] << 16 | e[2] >>> 16, e[1], e[0] << 16 | e[3] >>> 16, e[2], e[1] << 16 | e[0] >>> 16, e[3], e[2] << 16 | e[1] >>> 16],
                                    n = this._C = [e[2] << 16 | e[2] >>> 16, 4294901760 & e[0] | 65535 & e[1], e[3] << 16 | e[3] >>> 16, 4294901760 & e[1] | 65535 & e[2], e[0] << 16 | e[0] >>> 16, 4294901760 & e[2] | 65535 & e[3], e[1] << 16 | e[1] >>> 16, 4294901760 & e[3] | 65535 & e[0]];
                                this._b = 0;
                                for (var o = 0; o < 4; o++) c.call(this);
                                for (o = 0; o < 8; o++) n[o] ^= r[o + 4 & 7];
                                if (t) {
                                    var i = t.words,
                                        s = i[0],
                                        a = i[1],
                                        l = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8),
                                        u = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8),
                                        d = l >>> 16 | 4294901760 & u,
                                        p = u << 16 | 65535 & l;
                                    for (n[0] ^= l, n[1] ^= d, n[2] ^= u, n[3] ^= p, n[4] ^= l, n[5] ^= d, n[6] ^= u, n[7] ^= p, o = 0; o < 4; o++) c.call(this)
                                }
                            },
                            _doProcessBlock: function(e, t) {
                                var r = this._X;
                                c.call(this), o[0] = r[0] ^ r[5] >>> 16 ^ r[3] << 16, o[1] = r[2] ^ r[7] >>> 16 ^ r[5] << 16, o[2] = r[4] ^ r[1] >>> 16 ^ r[7] << 16, o[3] = r[6] ^ r[3] >>> 16 ^ r[1] << 16;
                                for (var n = 0; n < 4; n++) o[n] = 16711935 & (o[n] << 8 | o[n] >>> 24) | 4278255360 & (o[n] << 24 | o[n] >>> 8), e[t + n] ^= o[n]
                            },
                            blockSize: 4,
                            ivSize: 2
                        });

                    function c() {
                        for (var e = this._X, t = this._C, r = 0; r < 8; r++) i[r] = t[r];
                        for (t[0] = t[0] + 1295307597 + this._b | 0, t[1] = t[1] + 3545052371 + (t[0] >>> 0 < i[0] >>> 0 ? 1 : 0) | 0, t[2] = t[2] + 886263092 + (t[1] >>> 0 < i[1] >>> 0 ? 1 : 0) | 0, t[3] = t[3] + 1295307597 + (t[2] >>> 0 < i[2] >>> 0 ? 1 : 0) | 0, t[4] = t[4] + 3545052371 + (t[3] >>> 0 < i[3] >>> 0 ? 1 : 0) | 0, t[5] = t[5] + 886263092 + (t[4] >>> 0 < i[4] >>> 0 ? 1 : 0) | 0, t[6] = t[6] + 1295307597 + (t[5] >>> 0 < i[5] >>> 0 ? 1 : 0) | 0, t[7] = t[7] + 3545052371 + (t[6] >>> 0 < i[6] >>> 0 ? 1 : 0) | 0, this._b = t[7] >>> 0 < i[7] >>> 0 ? 1 : 0, r = 0; r < 8; r++) {
                            var n = e[r] + t[r],
                                o = 65535 & n,
                                a = n >>> 16,
                                c = ((o * o >>> 17) + o * a >>> 15) + a * a,
                                l = ((4294901760 & n) * n | 0) + ((65535 & n) * n | 0);
                            s[r] = c ^ l
                        }
                        e[0] = s[0] + (s[7] << 16 | s[7] >>> 16) + (s[6] << 16 | s[6] >>> 16) | 0, e[1] = s[1] + (s[0] << 8 | s[0] >>> 24) + s[7] | 0, e[2] = s[2] + (s[1] << 16 | s[1] >>> 16) + (s[0] << 16 | s[0] >>> 16) | 0, e[3] = s[3] + (s[2] << 8 | s[2] >>> 24) + s[1] | 0, e[4] = s[4] + (s[3] << 16 | s[3] >>> 16) + (s[2] << 16 | s[2] >>> 16) | 0, e[5] = s[5] + (s[4] << 8 | s[4] >>> 24) + s[3] | 0, e[6] = s[6] + (s[5] << 16 | s[5] >>> 16) + (s[4] << 16 | s[4] >>> 16) | 0, e[7] = s[7] + (s[6] << 8 | s[6] >>> 24) + s[5] | 0
                    }
                    e.RabbitLegacy = t._createHelper(a)
                }(), n.RabbitLegacy)
            },
            4454: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(8269), r(8214), r(888), r(5109), function() {
                    var e = n,
                        t = e.lib.StreamCipher,
                        r = e.algo,
                        o = [],
                        i = [],
                        s = [],
                        a = r.Rabbit = t.extend({
                            _doReset: function() {
                                for (var e = this._key.words, t = this.cfg.iv, r = 0; r < 4; r++) e[r] = 16711935 & (e[r] << 8 | e[r] >>> 24) | 4278255360 & (e[r] << 24 | e[r] >>> 8);
                                var n = this._X = [e[0], e[3] << 16 | e[2] >>> 16, e[1], e[0] << 16 | e[3] >>> 16, e[2], e[1] << 16 | e[0] >>> 16, e[3], e[2] << 16 | e[1] >>> 16],
                                    o = this._C = [e[2] << 16 | e[2] >>> 16, 4294901760 & e[0] | 65535 & e[1], e[3] << 16 | e[3] >>> 16, 4294901760 & e[1] | 65535 & e[2], e[0] << 16 | e[0] >>> 16, 4294901760 & e[2] | 65535 & e[3], e[1] << 16 | e[1] >>> 16, 4294901760 & e[3] | 65535 & e[0]];
                                for (this._b = 0, r = 0; r < 4; r++) c.call(this);
                                for (r = 0; r < 8; r++) o[r] ^= n[r + 4 & 7];
                                if (t) {
                                    var i = t.words,
                                        s = i[0],
                                        a = i[1],
                                        l = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8),
                                        u = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8),
                                        d = l >>> 16 | 4294901760 & u,
                                        p = u << 16 | 65535 & l;
                                    for (o[0] ^= l, o[1] ^= d, o[2] ^= u, o[3] ^= p, o[4] ^= l, o[5] ^= d, o[6] ^= u, o[7] ^= p, r = 0; r < 4; r++) c.call(this)
                                }
                            },
                            _doProcessBlock: function(e, t) {
                                var r = this._X;
                                c.call(this), o[0] = r[0] ^ r[5] >>> 16 ^ r[3] << 16, o[1] = r[2] ^ r[7] >>> 16 ^ r[5] << 16, o[2] = r[4] ^ r[1] >>> 16 ^ r[7] << 16, o[3] = r[6] ^ r[3] >>> 16 ^ r[1] << 16;
                                for (var n = 0; n < 4; n++) o[n] = 16711935 & (o[n] << 8 | o[n] >>> 24) | 4278255360 & (o[n] << 24 | o[n] >>> 8), e[t + n] ^= o[n]
                            },
                            blockSize: 4,
                            ivSize: 2
                        });

                    function c() {
                        for (var e = this._X, t = this._C, r = 0; r < 8; r++) i[r] = t[r];
                        for (t[0] = t[0] + 1295307597 + this._b | 0, t[1] = t[1] + 3545052371 + (t[0] >>> 0 < i[0] >>> 0 ? 1 : 0) | 0, t[2] = t[2] + 886263092 + (t[1] >>> 0 < i[1] >>> 0 ? 1 : 0) | 0, t[3] = t[3] + 1295307597 + (t[2] >>> 0 < i[2] >>> 0 ? 1 : 0) | 0, t[4] = t[4] + 3545052371 + (t[3] >>> 0 < i[3] >>> 0 ? 1 : 0) | 0, t[5] = t[5] + 886263092 + (t[4] >>> 0 < i[4] >>> 0 ? 1 : 0) | 0, t[6] = t[6] + 1295307597 + (t[5] >>> 0 < i[5] >>> 0 ? 1 : 0) | 0, t[7] = t[7] + 3545052371 + (t[6] >>> 0 < i[6] >>> 0 ? 1 : 0) | 0, this._b = t[7] >>> 0 < i[7] >>> 0 ? 1 : 0, r = 0; r < 8; r++) {
                            var n = e[r] + t[r],
                                o = 65535 & n,
                                a = n >>> 16,
                                c = ((o * o >>> 17) + o * a >>> 15) + a * a,
                                l = ((4294901760 & n) * n | 0) + ((65535 & n) * n | 0);
                            s[r] = c ^ l
                        }
                        e[0] = s[0] + (s[7] << 16 | s[7] >>> 16) + (s[6] << 16 | s[6] >>> 16) | 0, e[1] = s[1] + (s[0] << 8 | s[0] >>> 24) + s[7] | 0, e[2] = s[2] + (s[1] << 16 | s[1] >>> 16) + (s[0] << 16 | s[0] >>> 16) | 0, e[3] = s[3] + (s[2] << 8 | s[2] >>> 24) + s[1] | 0, e[4] = s[4] + (s[3] << 16 | s[3] >>> 16) + (s[2] << 16 | s[2] >>> 16) | 0, e[5] = s[5] + (s[4] << 8 | s[4] >>> 24) + s[3] | 0, e[6] = s[6] + (s[5] << 16 | s[5] >>> 16) + (s[4] << 16 | s[4] >>> 16) | 0, e[7] = s[7] + (s[6] << 8 | s[6] >>> 24) + s[5] | 0
                    }
                    e.Rabbit = t._createHelper(a)
                }(), n.Rabbit)
            },
            1857: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(8269), r(8214), r(888), r(5109), function() {
                    var e = n,
                        t = e.lib.StreamCipher,
                        r = e.algo,
                        o = r.RC4 = t.extend({
                            _doReset: function() {
                                for (var e = this._key, t = e.words, r = e.sigBytes, n = this._S = [], o = 0; o < 256; o++) n[o] = o;
                                o = 0;
                                for (var i = 0; o < 256; o++) {
                                    var s = o % r,
                                        a = t[s >>> 2] >>> 24 - s % 4 * 8 & 255;
                                    i = (i + n[o] + a) % 256;
                                    var c = n[o];
                                    n[o] = n[i], n[i] = c
                                }
                                this._i = this._j = 0
                            },
                            _doProcessBlock: function(e, t) {
                                e[t] ^= i.call(this)
                            },
                            keySize: 8,
                            ivSize: 0
                        });

                    function i() {
                        for (var e = this._S, t = this._i, r = this._j, n = 0, o = 0; o < 4; o++) {
                            r = (r + e[t = (t + 1) % 256]) % 256;
                            var i = e[t];
                            e[t] = e[r], e[r] = i, n |= e[(e[t] + e[r]) % 256] << 24 - 8 * o
                        }
                        return this._i = t, this._j = r, n
                    }
                    e.RC4 = t._createHelper(o);
                    var s = r.RC4Drop = o.extend({
                        cfg: o.cfg.extend({
                            drop: 192
                        }),
                        _doReset: function() {
                            o._doReset.call(this);
                            for (var e = this.cfg.drop; e > 0; e--) i.call(this)
                        }
                    });
                    e.RC4Drop = t._createHelper(s)
                }(), n.RC4)
            },
            706: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), function(e) {
                    var t = n,
                        r = t.lib,
                        o = r.WordArray,
                        i = r.Hasher,
                        s = t.algo,
                        a = o.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]),
                        c = o.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]),
                        l = o.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]),
                        u = o.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]),
                        d = o.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),
                        p = o.create([1352829926, 1548603684, 1836072691, 2053994217, 0]),
                        h = s.RIPEMD160 = i.extend({
                            _doReset: function() {
                                this._hash = o.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                            },
                            _doProcessBlock: function(e, t) {
                                for (var r = 0; r < 16; r++) {
                                    var n = t + r,
                                        o = e[n];
                                    e[n] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8)
                                }
                                var i, s, h, b, w, x, E, C, S, T, k, I = this._hash.words,
                                    P = d.words,
                                    A = p.words,
                                    O = a.words,
                                    N = c.words,
                                    R = l.words,
                                    $ = u.words;
                                for (x = i = I[0], E = s = I[1], C = h = I[2], S = b = I[3], T = w = I[4], r = 0; r < 80; r += 1) k = i + e[t + O[r]] | 0, k += r < 16 ? f(s, h, b) + P[0] : r < 32 ? m(s, h, b) + P[1] : r < 48 ? g(s, h, b) + P[2] : r < 64 ? _(s, h, b) + P[3] : y(s, h, b) + P[4], k = (k = v(k |= 0, R[r])) + w | 0, i = w, w = b, b = v(h, 10), h = s, s = k, k = x + e[t + N[r]] | 0, k += r < 16 ? y(E, C, S) + A[0] : r < 32 ? _(E, C, S) + A[1] : r < 48 ? g(E, C, S) + A[2] : r < 64 ? m(E, C, S) + A[3] : f(E, C, S) + A[4], k = (k = v(k |= 0, $[r])) + T | 0, x = T, T = S, S = v(C, 10), C = E, E = k;
                                k = I[1] + h + S | 0, I[1] = I[2] + b + T | 0, I[2] = I[3] + w + x | 0, I[3] = I[4] + i + E | 0, I[4] = I[0] + s + C | 0, I[0] = k
                            },
                            _doFinalize: function() {
                                var e = this._data,
                                    t = e.words,
                                    r = 8 * this._nDataBytes,
                                    n = 8 * e.sigBytes;
                                t[n >>> 5] |= 128 << 24 - n % 32, t[14 + (n + 64 >>> 9 << 4)] = 16711935 & (r << 8 | r >>> 24) | 4278255360 & (r << 24 | r >>> 8), e.sigBytes = 4 * (t.length + 1), this._process();
                                for (var o = this._hash, i = o.words, s = 0; s < 5; s++) {
                                    var a = i[s];
                                    i[s] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8)
                                }
                                return o
                            },
                            clone: function() {
                                var e = i.clone.call(this);
                                return e._hash = this._hash.clone(), e
                            }
                        });

                    function f(e, t, r) {
                        return e ^ t ^ r
                    }

                    function m(e, t, r) {
                        return e & t | ~e & r
                    }

                    function g(e, t, r) {
                        return (e | ~t) ^ r
                    }

                    function _(e, t, r) {
                        return e & r | t & ~r
                    }

                    function y(e, t, r) {
                        return e ^ (t | ~r)
                    }

                    function v(e, t) {
                        return e << t | e >>> 32 - t
                    }
                    t.RIPEMD160 = i._createHelper(h), t.HmacRIPEMD160 = i._createHmacHelper(h)
                }(Math), n.RIPEMD160)
            },
            2783: function(e, t, r) {
                var n, o, i, s, a, c, l, u;
                e.exports = (o = (n = u = r(8249)).lib, i = o.WordArray, s = o.Hasher, a = n.algo, c = [], l = a.SHA1 = s.extend({
                    _doReset: function() {
                        this._hash = new i.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                    },
                    _doProcessBlock: function(e, t) {
                        for (var r = this._hash.words, n = r[0], o = r[1], i = r[2], s = r[3], a = r[4], l = 0; l < 80; l++) {
                            if (l < 16) c[l] = 0 | e[t + l];
                            else {
                                var u = c[l - 3] ^ c[l - 8] ^ c[l - 14] ^ c[l - 16];
                                c[l] = u << 1 | u >>> 31
                            }
                            var d = (n << 5 | n >>> 27) + a + c[l];
                            d += l < 20 ? 1518500249 + (o & i | ~o & s) : l < 40 ? 1859775393 + (o ^ i ^ s) : l < 60 ? (o & i | o & s | i & s) - 1894007588 : (o ^ i ^ s) - 899497514, a = s, s = i, i = o << 30 | o >>> 2, o = n, n = d
                        }
                        r[0] = r[0] + n | 0, r[1] = r[1] + o | 0, r[2] = r[2] + i | 0, r[3] = r[3] + s | 0, r[4] = r[4] + a | 0
                    },
                    _doFinalize: function() {
                        var e = this._data,
                            t = e.words,
                            r = 8 * this._nDataBytes,
                            n = 8 * e.sigBytes;
                        return t[n >>> 5] |= 128 << 24 - n % 32, t[14 + (n + 64 >>> 9 << 4)] = Math.floor(r / 4294967296), t[15 + (n + 64 >>> 9 << 4)] = r, e.sigBytes = 4 * t.length, this._process(), this._hash
                    },
                    clone: function() {
                        var e = s.clone.call(this);
                        return e._hash = this._hash.clone(), e
                    }
                }), n.SHA1 = s._createHelper(l), n.HmacSHA1 = s._createHmacHelper(l), u.SHA1)
            },
            7792: function(e, t, r) {
                var n, o, i, s, a, c;
                e.exports = (c = r(8249), r(2153), o = (n = c).lib.WordArray, i = n.algo, s = i.SHA256, a = i.SHA224 = s.extend({
                    _doReset: function() {
                        this._hash = new o.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
                    },
                    _doFinalize: function() {
                        var e = s._doFinalize.call(this);
                        return e.sigBytes -= 4, e
                    }
                }), n.SHA224 = s._createHelper(a), n.HmacSHA224 = s._createHmacHelper(a), c.SHA224)
            },
            2153: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), function(e) {
                    var t = n,
                        r = t.lib,
                        o = r.WordArray,
                        i = r.Hasher,
                        s = t.algo,
                        a = [],
                        c = [];
                    ! function() {
                        function t(t) {
                            for (var r = e.sqrt(t), n = 2; n <= r; n++)
                                if (!(t % n)) return !1;
                            return !0
                        }

                        function r(e) {
                            return 4294967296 * (e - (0 | e)) | 0
                        }
                        for (var n = 2, o = 0; o < 64;) t(n) && (o < 8 && (a[o] = r(e.pow(n, .5))), c[o] = r(e.pow(n, 1 / 3)), o++), n++
                    }();
                    var l = [],
                        u = s.SHA256 = i.extend({
                            _doReset: function() {
                                this._hash = new o.init(a.slice(0))
                            },
                            _doProcessBlock: function(e, t) {
                                for (var r = this._hash.words, n = r[0], o = r[1], i = r[2], s = r[3], a = r[4], u = r[5], d = r[6], p = r[7], h = 0; h < 64; h++) {
                                    if (h < 16) l[h] = 0 | e[t + h];
                                    else {
                                        var f = l[h - 15],
                                            m = (f << 25 | f >>> 7) ^ (f << 14 | f >>> 18) ^ f >>> 3,
                                            g = l[h - 2],
                                            _ = (g << 15 | g >>> 17) ^ (g << 13 | g >>> 19) ^ g >>> 10;
                                        l[h] = m + l[h - 7] + _ + l[h - 16]
                                    }
                                    var y = n & o ^ n & i ^ o & i,
                                        v = (n << 30 | n >>> 2) ^ (n << 19 | n >>> 13) ^ (n << 10 | n >>> 22),
                                        b = p + ((a << 26 | a >>> 6) ^ (a << 21 | a >>> 11) ^ (a << 7 | a >>> 25)) + (a & u ^ ~a & d) + c[h] + l[h];
                                    p = d, d = u, u = a, a = s + b | 0, s = i, i = o, o = n, n = b + (v + y) | 0
                                }
                                r[0] = r[0] + n | 0, r[1] = r[1] + o | 0, r[2] = r[2] + i | 0, r[3] = r[3] + s | 0, r[4] = r[4] + a | 0, r[5] = r[5] + u | 0, r[6] = r[6] + d | 0, r[7] = r[7] + p | 0
                            },
                            _doFinalize: function() {
                                var t = this._data,
                                    r = t.words,
                                    n = 8 * this._nDataBytes,
                                    o = 8 * t.sigBytes;
                                return r[o >>> 5] |= 128 << 24 - o % 32, r[14 + (o + 64 >>> 9 << 4)] = e.floor(n / 4294967296), r[15 + (o + 64 >>> 9 << 4)] = n, t.sigBytes = 4 * r.length, this._process(), this._hash
                            },
                            clone: function() {
                                var e = i.clone.call(this);
                                return e._hash = this._hash.clone(), e
                            }
                        });
                    t.SHA256 = i._createHelper(u), t.HmacSHA256 = i._createHmacHelper(u)
                }(Math), n.SHA256)
            },
            3327: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(4938), function(e) {
                    var t = n,
                        r = t.lib,
                        o = r.WordArray,
                        i = r.Hasher,
                        s = t.x64.Word,
                        a = t.algo,
                        c = [],
                        l = [],
                        u = [];
                    ! function() {
                        for (var e = 1, t = 0, r = 0; r < 24; r++) {
                            c[e + 5 * t] = (r + 1) * (r + 2) / 2 % 64;
                            var n = (2 * e + 3 * t) % 5;
                            e = t % 5, t = n
                        }
                        for (e = 0; e < 5; e++)
                            for (t = 0; t < 5; t++) l[e + 5 * t] = t + (2 * e + 3 * t) % 5 * 5;
                        for (var o = 1, i = 0; i < 24; i++) {
                            for (var a = 0, d = 0, p = 0; p < 7; p++) {
                                if (1 & o) {
                                    var h = (1 << p) - 1;
                                    h < 32 ? d ^= 1 << h : a ^= 1 << h - 32
                                }
                                128 & o ? o = o << 1 ^ 113 : o <<= 1
                            }
                            u[i] = s.create(a, d)
                        }
                    }();
                    var d = [];
                    ! function() {
                        for (var e = 0; e < 25; e++) d[e] = s.create()
                    }();
                    var p = a.SHA3 = i.extend({
                        cfg: i.cfg.extend({
                            outputLength: 512
                        }),
                        _doReset: function() {
                            for (var e = this._state = [], t = 0; t < 25; t++) e[t] = new s.init;
                            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32
                        },
                        _doProcessBlock: function(e, t) {
                            for (var r = this._state, n = this.blockSize / 2, o = 0; o < n; o++) {
                                var i = e[t + 2 * o],
                                    s = e[t + 2 * o + 1];
                                i = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8), s = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8), (I = r[o]).high ^= s, I.low ^= i
                            }
                            for (var a = 0; a < 24; a++) {
                                for (var p = 0; p < 5; p++) {
                                    for (var h = 0, f = 0, m = 0; m < 5; m++) h ^= (I = r[p + 5 * m]).high, f ^= I.low;
                                    var g = d[p];
                                    g.high = h, g.low = f
                                }
                                for (p = 0; p < 5; p++) {
                                    var _ = d[(p + 4) % 5],
                                        y = d[(p + 1) % 5],
                                        v = y.high,
                                        b = y.low;
                                    for (h = _.high ^ (v << 1 | b >>> 31), f = _.low ^ (b << 1 | v >>> 31), m = 0; m < 5; m++)(I = r[p + 5 * m]).high ^= h, I.low ^= f
                                }
                                for (var w = 1; w < 25; w++) {
                                    var x = (I = r[w]).high,
                                        E = I.low,
                                        C = c[w];
                                    C < 32 ? (h = x << C | E >>> 32 - C, f = E << C | x >>> 32 - C) : (h = E << C - 32 | x >>> 64 - C, f = x << C - 32 | E >>> 64 - C);
                                    var S = d[l[w]];
                                    S.high = h, S.low = f
                                }
                                var T = d[0],
                                    k = r[0];
                                for (T.high = k.high, T.low = k.low, p = 0; p < 5; p++)
                                    for (m = 0; m < 5; m++) {
                                        var I = r[w = p + 5 * m],
                                            P = d[w],
                                            A = d[(p + 1) % 5 + 5 * m],
                                            O = d[(p + 2) % 5 + 5 * m];
                                        I.high = P.high ^ ~A.high & O.high, I.low = P.low ^ ~A.low & O.low
                                    }
                                I = r[0];
                                var N = u[a];
                                I.high ^= N.high, I.low ^= N.low
                            }
                        },
                        _doFinalize: function() {
                            var t = this._data,
                                r = t.words,
                                n = (this._nDataBytes, 8 * t.sigBytes),
                                i = 32 * this.blockSize;
                            r[n >>> 5] |= 1 << 24 - n % 32, r[(e.ceil((n + 1) / i) * i >>> 5) - 1] |= 128, t.sigBytes = 4 * r.length, this._process();
                            for (var s = this._state, a = this.cfg.outputLength / 8, c = a / 8, l = [], u = 0; u < c; u++) {
                                var d = s[u],
                                    p = d.high,
                                    h = d.low;
                                p = 16711935 & (p << 8 | p >>> 24) | 4278255360 & (p << 24 | p >>> 8), h = 16711935 & (h << 8 | h >>> 24) | 4278255360 & (h << 24 | h >>> 8), l.push(h), l.push(p)
                            }
                            return new o.init(l, a)
                        },
                        clone: function() {
                            for (var e = i.clone.call(this), t = e._state = this._state.slice(0), r = 0; r < 25; r++) t[r] = t[r].clone();
                            return e
                        }
                    });
                    t.SHA3 = i._createHelper(p), t.HmacSHA3 = i._createHmacHelper(p)
                }(Math), n.SHA3)
            },
            7460: function(e, t, r) {
                var n, o, i, s, a, c, l, u;
                e.exports = (u = r(8249), r(4938), r(34), o = (n = u).x64, i = o.Word, s = o.WordArray, a = n.algo, c = a.SHA512, l = a.SHA384 = c.extend({
                    _doReset: function() {
                        this._hash = new s.init([new i.init(3418070365, 3238371032), new i.init(1654270250, 914150663), new i.init(2438529370, 812702999), new i.init(355462360, 4144912697), new i.init(1731405415, 4290775857), new i.init(2394180231, 1750603025), new i.init(3675008525, 1694076839), new i.init(1203062813, 3204075428)])
                    },
                    _doFinalize: function() {
                        var e = c._doFinalize.call(this);
                        return e.sigBytes -= 16, e
                    }
                }), n.SHA384 = c._createHelper(l), n.HmacSHA384 = c._createHmacHelper(l), u.SHA384)
            },
            34: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(4938), function() {
                    var e = n,
                        t = e.lib.Hasher,
                        r = e.x64,
                        o = r.Word,
                        i = r.WordArray,
                        s = e.algo;

                    function a() {
                        return o.create.apply(o, arguments)
                    }
                    var c = [a(1116352408, 3609767458), a(1899447441, 602891725), a(3049323471, 3964484399), a(3921009573, 2173295548), a(961987163, 4081628472), a(1508970993, 3053834265), a(2453635748, 2937671579), a(2870763221, 3664609560), a(3624381080, 2734883394), a(310598401, 1164996542), a(607225278, 1323610764), a(1426881987, 3590304994), a(1925078388, 4068182383), a(2162078206, 991336113), a(2614888103, 633803317), a(3248222580, 3479774868), a(3835390401, 2666613458), a(4022224774, 944711139), a(264347078, 2341262773), a(604807628, 2007800933), a(770255983, 1495990901), a(1249150122, 1856431235), a(1555081692, 3175218132), a(1996064986, 2198950837), a(2554220882, 3999719339), a(2821834349, 766784016), a(2952996808, 2566594879), a(3210313671, 3203337956), a(3336571891, 1034457026), a(3584528711, 2466948901), a(113926993, 3758326383), a(338241895, 168717936), a(666307205, 1188179964), a(773529912, 1546045734), a(1294757372, 1522805485), a(1396182291, 2643833823), a(1695183700, 2343527390), a(1986661051, 1014477480), a(2177026350, 1206759142), a(2456956037, 344077627), a(2730485921, 1290863460), a(2820302411, 3158454273), a(3259730800, 3505952657), a(3345764771, 106217008), a(3516065817, 3606008344), a(3600352804, 1432725776), a(4094571909, 1467031594), a(275423344, 851169720), a(430227734, 3100823752), a(506948616, 1363258195), a(659060556, 3750685593), a(883997877, 3785050280), a(958139571, 3318307427), a(1322822218, 3812723403), a(1537002063, 2003034995), a(1747873779, 3602036899), a(1955562222, 1575990012), a(2024104815, 1125592928), a(2227730452, 2716904306), a(2361852424, 442776044), a(2428436474, 593698344), a(2756734187, 3733110249), a(3204031479, 2999351573), a(3329325298, 3815920427), a(3391569614, 3928383900), a(3515267271, 566280711), a(3940187606, 3454069534), a(4118630271, 4000239992), a(116418474, 1914138554), a(174292421, 2731055270), a(289380356, 3203993006), a(460393269, 320620315), a(685471733, 587496836), a(852142971, 1086792851), a(1017036298, 365543100), a(1126000580, 2618297676), a(1288033470, 3409855158), a(1501505948, 4234509866), a(1607167915, 987167468), a(1816402316, 1246189591)],
                        l = [];
                    ! function() {
                        for (var e = 0; e < 80; e++) l[e] = a()
                    }();
                    var u = s.SHA512 = t.extend({
                        _doReset: function() {
                            this._hash = new i.init([new o.init(1779033703, 4089235720), new o.init(3144134277, 2227873595), new o.init(1013904242, 4271175723), new o.init(2773480762, 1595750129), new o.init(1359893119, 2917565137), new o.init(2600822924, 725511199), new o.init(528734635, 4215389547), new o.init(1541459225, 327033209)])
                        },
                        _doProcessBlock: function(e, t) {
                            for (var r = this._hash.words, n = r[0], o = r[1], i = r[2], s = r[3], a = r[4], u = r[5], d = r[6], p = r[7], h = n.high, f = n.low, m = o.high, g = o.low, _ = i.high, y = i.low, v = s.high, b = s.low, w = a.high, x = a.low, E = u.high, C = u.low, S = d.high, T = d.low, k = p.high, I = p.low, P = h, A = f, O = m, N = g, R = _, $ = y, M = v, D = b, L = w, F = x, j = E, B = C, q = S, U = T, H = k, G = I, z = 0; z < 80; z++) {
                                var V, W, K = l[z];
                                if (z < 16) W = K.high = 0 | e[t + 2 * z], V = K.low = 0 | e[t + 2 * z + 1];
                                else {
                                    var J = l[z - 15],
                                        X = J.high,
                                        Q = J.low,
                                        Y = (X >>> 1 | Q << 31) ^ (X >>> 8 | Q << 24) ^ X >>> 7,
                                        Z = (Q >>> 1 | X << 31) ^ (Q >>> 8 | X << 24) ^ (Q >>> 7 | X << 25),
                                        ee = l[z - 2],
                                        te = ee.high,
                                        re = ee.low,
                                        ne = (te >>> 19 | re << 13) ^ (te << 3 | re >>> 29) ^ te >>> 6,
                                        oe = (re >>> 19 | te << 13) ^ (re << 3 | te >>> 29) ^ (re >>> 6 | te << 26),
                                        ie = l[z - 7],
                                        se = ie.high,
                                        ae = ie.low,
                                        ce = l[z - 16],
                                        le = ce.high,
                                        ue = ce.low;
                                    W = (W = (W = Y + se + ((V = Z + ae) >>> 0 < Z >>> 0 ? 1 : 0)) + ne + ((V += oe) >>> 0 < oe >>> 0 ? 1 : 0)) + le + ((V += ue) >>> 0 < ue >>> 0 ? 1 : 0), K.high = W, K.low = V
                                }
                                var de, pe = L & j ^ ~L & q,
                                    he = F & B ^ ~F & U,
                                    fe = P & O ^ P & R ^ O & R,
                                    me = A & N ^ A & $ ^ N & $,
                                    ge = (P >>> 28 | A << 4) ^ (P << 30 | A >>> 2) ^ (P << 25 | A >>> 7),
                                    _e = (A >>> 28 | P << 4) ^ (A << 30 | P >>> 2) ^ (A << 25 | P >>> 7),
                                    ye = (L >>> 14 | F << 18) ^ (L >>> 18 | F << 14) ^ (L << 23 | F >>> 9),
                                    ve = (F >>> 14 | L << 18) ^ (F >>> 18 | L << 14) ^ (F << 23 | L >>> 9),
                                    be = c[z],
                                    we = be.high,
                                    xe = be.low,
                                    Ee = H + ye + ((de = G + ve) >>> 0 < G >>> 0 ? 1 : 0),
                                    Ce = _e + me;
                                H = q, G = U, q = j, U = B, j = L, B = F, L = M + (Ee = (Ee = (Ee = Ee + pe + ((de += he) >>> 0 < he >>> 0 ? 1 : 0)) + we + ((de += xe) >>> 0 < xe >>> 0 ? 1 : 0)) + W + ((de += V) >>> 0 < V >>> 0 ? 1 : 0)) + ((F = D + de | 0) >>> 0 < D >>> 0 ? 1 : 0) | 0, M = R, D = $, R = O, $ = N, O = P, N = A, P = Ee + (ge + fe + (Ce >>> 0 < _e >>> 0 ? 1 : 0)) + ((A = de + Ce | 0) >>> 0 < de >>> 0 ? 1 : 0) | 0
                            }
                            f = n.low = f + A, n.high = h + P + (f >>> 0 < A >>> 0 ? 1 : 0), g = o.low = g + N, o.high = m + O + (g >>> 0 < N >>> 0 ? 1 : 0), y = i.low = y + $, i.high = _ + R + (y >>> 0 < $ >>> 0 ? 1 : 0), b = s.low = b + D, s.high = v + M + (b >>> 0 < D >>> 0 ? 1 : 0), x = a.low = x + F, a.high = w + L + (x >>> 0 < F >>> 0 ? 1 : 0), C = u.low = C + B, u.high = E + j + (C >>> 0 < B >>> 0 ? 1 : 0), T = d.low = T + U, d.high = S + q + (T >>> 0 < U >>> 0 ? 1 : 0), I = p.low = I + G, p.high = k + H + (I >>> 0 < G >>> 0 ? 1 : 0)
                        },
                        _doFinalize: function() {
                            var e = this._data,
                                t = e.words,
                                r = 8 * this._nDataBytes,
                                n = 8 * e.sigBytes;
                            return t[n >>> 5] |= 128 << 24 - n % 32, t[30 + (n + 128 >>> 10 << 5)] = Math.floor(r / 4294967296), t[31 + (n + 128 >>> 10 << 5)] = r, e.sigBytes = 4 * t.length, this._process(), this._hash.toX32()
                        },
                        clone: function() {
                            var e = t.clone.call(this);
                            return e._hash = this._hash.clone(), e
                        },
                        blockSize: 32
                    });
                    e.SHA512 = t._createHelper(u), e.HmacSHA512 = t._createHmacHelper(u)
                }(), n.SHA512)
            },
            4253: function(e, t, r) {
                var n;
                e.exports = (n = r(8249), r(8269), r(8214), r(888), r(5109), function() {
                    var e = n,
                        t = e.lib,
                        r = t.WordArray,
                        o = t.BlockCipher,
                        i = e.algo,
                        s = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4],
                        a = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32],
                        c = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],
                        l = [{
                            0: 8421888,
                            268435456: 32768,
                            536870912: 8421378,
                            805306368: 2,
                            1073741824: 512,
                            1342177280: 8421890,
                            1610612736: 8389122,
                            1879048192: 8388608,
                            2147483648: 514,
                            2415919104: 8389120,
                            2684354560: 33280,
                            2952790016: 8421376,
                            3221225472: 32770,
                            3489660928: 8388610,
                            3758096384: 0,
                            4026531840: 33282,
                            134217728: 0,
                            402653184: 8421890,
                            671088640: 33282,
                            939524096: 32768,
                            1207959552: 8421888,
                            1476395008: 512,
                            1744830464: 8421378,
                            2013265920: 2,
                            2281701376: 8389120,
                            2550136832: 33280,
                            2818572288: 8421376,
                            3087007744: 8389122,
                            3355443200: 8388610,
                            3623878656: 32770,
                            3892314112: 514,
                            4160749568: 8388608,
                            1: 32768,
                            268435457: 2,
                            536870913: 8421888,
                            805306369: 8388608,
                            1073741825: 8421378,
                            1342177281: 33280,
                            1610612737: 512,
                            1879048193: 8389122,
                            2147483649: 8421890,
                            2415919105: 8421376,
                            2684354561: 8388610,
                            2952790017: 33282,
                            3221225473: 514,
                            3489660929: 8389120,
                            3758096385: 32770,
                            4026531841: 0,
                            134217729: 8421890,
                            402653185: 8421376,
                            671088641: 8388608,
                            939524097: 512,
                            1207959553: 32768,
                            1476395009: 8388610,
                            1744830465: 2,
                            2013265921: 33282,
                            2281701377: 32770,
                            2550136833: 8389122,
                            2818572289: 514,
                            3087007745: 8421888,
                            3355443201: 8389120,
                            3623878657: 0,
                            3892314113: 33280,
                            4160749569: 8421378
                        }, {
                            0: 1074282512,
                            16777216: 16384,
                            33554432: 524288,
                            50331648: 1074266128,
                            67108864: 1073741840,
                            83886080: 1074282496,
                            100663296: 1073758208,
                            117440512: 16,
                            134217728: 540672,
                            150994944: 1073758224,
                            167772160: 1073741824,
                            184549376: 540688,
                            201326592: 524304,
                            218103808: 0,
                            234881024: 16400,
                            251658240: 1074266112,
                            8388608: 1073758208,
                            25165824: 540688,
                            41943040: 16,
                            58720256: 1073758224,
                            75497472: 1074282512,
                            92274688: 1073741824,
                            109051904: 524288,
                            125829120: 1074266128,
                            142606336: 524304,
                            159383552: 0,
                            176160768: 16384,
                            192937984: 1074266112,
                            209715200: 1073741840,
                            226492416: 540672,
                            243269632: 1074282496,
                            260046848: 16400,
                            268435456: 0,
                            285212672: 1074266128,
                            301989888: 1073758224,
                            318767104: 1074282496,
                            335544320: 1074266112,
                            352321536: 16,
                            369098752: 540688,
                            385875968: 16384,
                            402653184: 16400,
                            419430400: 524288,
                            436207616: 524304,
                            452984832: 1073741840,
                            469762048: 540672,
                            486539264: 1073758208,
                            503316480: 1073741824,
                            520093696: 1074282512,
                            276824064: 540688,
                            293601280: 524288,
                            310378496: 1074266112,
                            327155712: 16384,
                            343932928: 1073758208,
                            360710144: 1074282512,
                            377487360: 16,
                            394264576: 1073741824,
                            411041792: 1074282496,
                            427819008: 1073741840,
                            444596224: 1073758224,
                            461373440: 524304,
                            478150656: 0,
                            494927872: 16400,
                            511705088: 1074266128,
                            528482304: 540672
                        }, {
                            0: 260,
                            1048576: 0,
                            2097152: 67109120,
                            3145728: 65796,
                            4194304: 65540,
                            5242880: 67108868,
                            6291456: 67174660,
                            7340032: 67174400,
                            8388608: 67108864,
                            9437184: 67174656,
                            10485760: 65792,
                            11534336: 67174404,
                            12582912: 67109124,
                            13631488: 65536,
                            14680064: 4,
                            15728640: 256,
                            524288: 67174656,
                            1572864: 67174404,
                            2621440: 0,
                            3670016: 67109120,
                            4718592: 67108868,
                            5767168: 65536,
                            6815744: 65540,
                            7864320: 260,
                            8912896: 4,
                            9961472: 256,
                            11010048: 67174400,
                            12058624: 65796,
                            13107200: 65792,
                            14155776: 67109124,
                            15204352: 67174660,
                            16252928: 67108864,
                            16777216: 67174656,
                            17825792: 65540,
                            18874368: 65536,
                            19922944: 67109120,
                            20971520: 256,
                            22020096: 67174660,
                            23068672: 67108868,
                            24117248: 0,
                            25165824: 67109124,
                            26214400: 67108864,
                            27262976: 4,
                            28311552: 65792,
                            29360128: 67174400,
                            30408704: 260,
                            31457280: 65796,
                            32505856: 67174404,
                            17301504: 67108864,
                            18350080: 260,
                            19398656: 67174656,
                            20447232: 0,
                            21495808: 65540,
                            22544384: 67109120,
                            23592960: 256,
                            24641536: 67174404,
                            25690112: 65536,
                            26738688: 67174660,
                            27787264: 65796,
                            28835840: 67108868,
                            29884416: 67109124,
                            30932992: 67174400,
                            31981568: 4,
                            33030144: 65792
                        }, {
                            0: 2151682048,
                            65536: 2147487808,
                            131072: 4198464,
                            196608: 2151677952,
                            262144: 0,
                            327680: 4198400,
                            393216: 2147483712,
                            458752: 4194368,
                            524288: 2147483648,
                            589824: 4194304,
                            655360: 64,
                            720896: 2147487744,
                            786432: 2151678016,
                            851968: 4160,
                            917504: 4096,
                            983040: 2151682112,
                            32768: 2147487808,
                            98304: 64,
                            163840: 2151678016,
                            229376: 2147487744,
                            294912: 4198400,
                            360448: 2151682112,
                            425984: 0,
                            491520: 2151677952,
                            557056: 4096,
                            622592: 2151682048,
                            688128: 4194304,
                            753664: 4160,
                            819200: 2147483648,
                            884736: 4194368,
                            950272: 4198464,
                            1015808: 2147483712,
                            1048576: 4194368,
                            1114112: 4198400,
                            1179648: 2147483712,
                            1245184: 0,
                            1310720: 4160,
                            1376256: 2151678016,
                            1441792: 2151682048,
                            1507328: 2147487808,
                            1572864: 2151682112,
                            1638400: 2147483648,
                            1703936: 2151677952,
                            1769472: 4198464,
                            1835008: 2147487744,
                            1900544: 4194304,
                            1966080: 64,
                            2031616: 4096,
                            1081344: 2151677952,
                            1146880: 2151682112,
                            1212416: 0,
                            1277952: 4198400,
                            1343488: 4194368,
                            1409024: 2147483648,
                            1474560: 2147487808,
                            1540096: 64,
                            1605632: 2147483712,
                            1671168: 4096,
                            1736704: 2147487744,
                            1802240: 2151678016,
                            1867776: 4160,
                            1933312: 2151682048,
                            1998848: 4194304,
                            2064384: 4198464
                        }, {
                            0: 128,
                            4096: 17039360,
                            8192: 262144,
                            12288: 536870912,
                            16384: 537133184,
                            20480: 16777344,
                            24576: 553648256,
                            28672: 262272,
                            32768: 16777216,
                            36864: 537133056,
                            40960: 536871040,
                            45056: 553910400,
                            49152: 553910272,
                            53248: 0,
                            57344: 17039488,
                            61440: 553648128,
                            2048: 17039488,
                            6144: 553648256,
                            10240: 128,
                            14336: 17039360,
                            18432: 262144,
                            22528: 537133184,
                            26624: 553910272,
                            30720: 536870912,
                            34816: 537133056,
                            38912: 0,
                            43008: 553910400,
                            47104: 16777344,
                            51200: 536871040,
                            55296: 553648128,
                            59392: 16777216,
                            63488: 262272,
                            65536: 262144,
                            69632: 128,
                            73728: 536870912,
                            77824: 553648256,
                            81920: 16777344,
                            86016: 553910272,
                            90112: 537133184,
                            94208: 16777216,
                            98304: 553910400,
                            102400: 553648128,
                            106496: 17039360,
                            110592: 537133056,
                            114688: 262272,
                            118784: 536871040,
                            122880: 0,
                            126976: 17039488,
                            67584: 553648256,
                            71680: 16777216,
                            75776: 17039360,
                            79872: 537133184,
                            83968: 536870912,
                            88064: 17039488,
                            92160: 128,
                            96256: 553910272,
                            100352: 262272,
                            104448: 553910400,
                            108544: 0,
                            112640: 553648128,
                            116736: 16777344,
                            120832: 262144,
                            124928: 537133056,
                            129024: 536871040
                        }, {
                            0: 268435464,
                            256: 8192,
                            512: 270532608,
                            768: 270540808,
                            1024: 268443648,
                            1280: 2097152,
                            1536: 2097160,
                            1792: 268435456,
                            2048: 0,
                            2304: 268443656,
                            2560: 2105344,
                            2816: 8,
                            3072: 270532616,
                            3328: 2105352,
                            3584: 8200,
                            3840: 270540800,
                            128: 270532608,
                            384: 270540808,
                            640: 8,
                            896: 2097152,
                            1152: 2105352,
                            1408: 268435464,
                            1664: 268443648,
                            1920: 8200,
                            2176: 2097160,
                            2432: 8192,
                            2688: 268443656,
                            2944: 270532616,
                            3200: 0,
                            3456: 270540800,
                            3712: 2105344,
                            3968: 268435456,
                            4096: 268443648,
                            4352: 270532616,
                            4608: 270540808,
                            4864: 8200,
                            5120: 2097152,
                            5376: 268435456,
                            5632: 268435464,
                            5888: 2105344,
                            6144: 2105352,
                            6400: 0,
                            6656: 8,
                            6912: 270532608,
                            7168: 8192,
                            7424: 268443656,
                            7680: 270540800,
                            7936: 2097160,
                            4224: 8,
                            4480: 2105344,
                            4736: 2097152,
                            4992: 268435464,
                            5248: 268443648,
                            5504: 8200,
                            5760: 270540808,
                            6016: 270532608,
                            6272: 270540800,
                            6528: 270532616,
                            6784: 8192,
                            7040: 2105352,
                            7296: 2097160,
                            7552: 0,
                            7808: 268435456,
                            8064: 268443656
                        }, {
                            0: 1048576,
                            16: 33555457,
                            32: 1024,
                            48: 1049601,
                            64: 34604033,
                            80: 0,
                            96: 1,
                            112: 34603009,
                            128: 33555456,
                            144: 1048577,
                            160: 33554433,
                            176: 34604032,
                            192: 34603008,
                            208: 1025,
                            224: 1049600,
                            240: 33554432,
                            8: 34603009,
                            24: 0,
                            40: 33555457,
                            56: 34604032,
                            72: 1048576,
                            88: 33554433,
                            104: 33554432,
                            120: 1025,
                            136: 1049601,
                            152: 33555456,
                            168: 34603008,
                            184: 1048577,
                            200: 1024,
                            216: 34604033,
                            232: 1,
                            248: 1049600,
                            256: 33554432,
                            272: 1048576,
                            288: 33555457,
                            304: 34603009,
                            320: 1048577,
                            336: 33555456,
                            352: 34604032,
                            368: 1049601,
                            384: 1025,
                            400: 34604033,
                            416: 1049600,
                            432: 1,
                            448: 0,
                            464: 34603008,
                            480: 33554433,
                            496: 1024,
                            264: 1049600,
                            280: 33555457,
                            296: 34603009,
                            312: 1,
                            328: 33554432,
                            344: 1048576,
                            360: 1025,
                            376: 34604032,
                            392: 33554433,
                            408: 34603008,
                            424: 0,
                            440: 34604033,
                            456: 1049601,
                            472: 1024,
                            488: 33555456,
                            504: 1048577
                        }, {
                            0: 134219808,
                            1: 131072,
                            2: 134217728,
                            3: 32,
                            4: 131104,
                            5: 134350880,
                            6: 134350848,
                            7: 2048,
                            8: 134348800,
                            9: 134219776,
                            10: 133120,
                            11: 134348832,
                            12: 2080,
                            13: 0,
                            14: 134217760,
                            15: 133152,
                            2147483648: 2048,
                            2147483649: 134350880,
                            2147483650: 134219808,
                            2147483651: 134217728,
                            2147483652: 134348800,
                            2147483653: 133120,
                            2147483654: 133152,
                            2147483655: 32,
                            2147483656: 134217760,
                            2147483657: 2080,
                            2147483658: 131104,
                            2147483659: 134350848,
                            2147483660: 0,
                            2147483661: 134348832,
                            2147483662: 134219776,
                            2147483663: 131072,
                            16: 133152,
                            17: 134350848,
                            18: 32,
                            19: 2048,
                            20: 134219776,
                            21: 134217760,
                            22: 134348832,
                            23: 131072,
                            24: 0,
                            25: 131104,
                            26: 134348800,
                            27: 134219808,
                            28: 134350880,
                            29: 133120,
                            30: 2080,
                            31: 134217728,
                            2147483664: 131072,
                            2147483665: 2048,
                            2147483666: 134348832,
                            2147483667: 133152,
                            2147483668: 32,
                            2147483669: 134348800,
                            2147483670: 134217728,
                            2147483671: 134219808,
                            2147483672: 134350880,
                            2147483673: 134217760,
                            2147483674: 134219776,
                            2147483675: 0,
                            2147483676: 133120,
                            2147483677: 2080,
                            2147483678: 131104,
                            2147483679: 134350848
                        }],
                        u = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679],
                        d = i.DES = o.extend({
                            _doReset: function() {
                                for (var e = this._key.words, t = [], r = 0; r < 56; r++) {
                                    var n = s[r] - 1;
                                    t[r] = e[n >>> 5] >>> 31 - n % 32 & 1
                                }
                                for (var o = this._subKeys = [], i = 0; i < 16; i++) {
                                    var l = o[i] = [],
                                        u = c[i];
                                    for (r = 0; r < 24; r++) l[r / 6 | 0] |= t[(a[r] - 1 + u) % 28] << 31 - r % 6, l[4 + (r / 6 | 0)] |= t[28 + (a[r + 24] - 1 + u) % 28] << 31 - r % 6;
                                    for (l[0] = l[0] << 1 | l[0] >>> 31, r = 1; r < 7; r++) l[r] = l[r] >>> 4 * (r - 1) + 3;
                                    l[7] = l[7] << 5 | l[7] >>> 27
                                }
                                var d = this._invSubKeys = [];
                                for (r = 0; r < 16; r++) d[r] = o[15 - r]
                            },
                            encryptBlock: function(e, t) {
                                this._doCryptBlock(e, t, this._subKeys)
                            },
                            decryptBlock: function(e, t) {
                                this._doCryptBlock(e, t, this._invSubKeys)
                            },
                            _doCryptBlock: function(e, t, r) {
                                this._lBlock = e[t], this._rBlock = e[t + 1], p.call(this, 4, 252645135), p.call(this, 16, 65535), h.call(this, 2, 858993459), h.call(this, 8, 16711935), p.call(this, 1, 1431655765);
                                for (var n = 0; n < 16; n++) {
                                    for (var o = r[n], i = this._lBlock, s = this._rBlock, a = 0, c = 0; c < 8; c++) a |= l[c][((s ^ o[c]) & u[c]) >>> 0];
                                    this._lBlock = s, this._rBlock = i ^ a
                                }
                                var d = this._lBlock;
                                this._lBlock = this._rBlock, this._rBlock = d, p.call(this, 1, 1431655765), h.call(this, 8, 16711935), h.call(this, 2, 858993459), p.call(this, 16, 65535), p.call(this, 4, 252645135), e[t] = this._lBlock, e[t + 1] = this._rBlock
                            },
                            keySize: 2,
                            ivSize: 2,
                            blockSize: 2
                        });

                    function p(e, t) {
                        var r = (this._lBlock >>> e ^ this._rBlock) & t;
                        this._rBlock ^= r, this._lBlock ^= r << e
                    }

                    function h(e, t) {
                        var r = (this._rBlock >>> e ^ this._lBlock) & t;
                        this._lBlock ^= r, this._rBlock ^= r << e
                    }
                    e.DES = o._createHelper(d);
                    var f = i.TripleDES = o.extend({
                        _doReset: function() {
                            var e = this._key.words;
                            if (2 !== e.length && 4 !== e.length && e.length < 6) throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                            var t = e.slice(0, 2),
                                n = e.length < 4 ? e.slice(0, 2) : e.slice(2, 4),
                                o = e.length < 6 ? e.slice(0, 2) : e.slice(4, 6);
                            this._des1 = d.createEncryptor(r.create(t)), this._des2 = d.createEncryptor(r.create(n)), this._des3 = d.createEncryptor(r.create(o))
                        },
                        encryptBlock: function(e, t) {
                            this._des1.encryptBlock(e, t), this._des2.decryptBlock(e, t), this._des3.encryptBlock(e, t)
                        },
                        decryptBlock: function(e, t) {
                            this._des3.decryptBlock(e, t), this._des2.encryptBlock(e, t), this._des1.decryptBlock(e, t)
                        },
                        keySize: 6,
                        ivSize: 2,
                        blockSize: 2
                    });
                    e.TripleDES = o._createHelper(f)
                }(), n.TripleDES)
            },
            4938: function(e, t, r) {
                var n, o, i, s, a, c;
                e.exports = (n = r(8249), i = (o = n).lib, s = i.Base, a = i.WordArray, (c = o.x64 = {}).Word = s.extend({
                    init: function(e, t) {
                        this.high = e, this.low = t
                    }
                }), c.WordArray = s.extend({
                    init: function(e, t) {
                        e = this.words = e || [], this.sigBytes = null != t ? t : 8 * e.length
                    },
                    toX32: function() {
                        for (var e = this.words, t = e.length, r = [], n = 0; n < t; n++) {
                            var o = e[n];
                            r.push(o.high), r.push(o.low)
                        }
                        return a.create(r, this.sigBytes)
                    },
                    clone: function() {
                        for (var e = s.clone.call(this), t = e.words = this.words.slice(0), r = t.length, n = 0; n < r; n++) t[n] = t[n].clone();
                        return e
                    }
                }), n)
            },
            1758: (e, t, r) => {
                t.formatArgs = function(t) {
                    if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors) return;
                    const r = "color: " + this.color;
                    t.splice(1, 0, r, "color: inherit");
                    let n = 0,
                        o = 0;
                    t[0].replace(/%[a-zA-Z%]/g, (e => {
                        "%%" !== e && (n++, "%c" === e && (o = n))
                    })), t.splice(o, 0, r)
                }, t.save = function(e) {
                    try {
                        e ? t.storage.setItem("debug", e) : t.storage.removeItem("debug")
                    } catch (e) {}
                }, t.load = function() {
                    let e;
                    try {
                        e = t.storage.getItem("debug")
                    } catch (e) {}
                    return !e && "undefined" != typeof process && "env" in process && (e = process.env.DEBUG), e
                }, t.useColors = function() {
                    return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type && !window.process.__nwjs) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
                }, t.storage = function() {
                    try {
                        return localStorage
                    } catch (e) {}
                }(), t.destroy = (() => {
                    let e = !1;
                    return () => {
                        e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))
                    }
                })(), t.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t.log = console.debug || console.log || (() => {}), e.exports = r(2447)(t);
                const {
                    formatters: n
                } = e.exports;
                n.j = function(e) {
                    try {
                        return JSON.stringify(e)
                    } catch (e) {
                        return "[UnexpectedJSONParseError]: " + e.message
                    }
                }
            },
            2447: (e, t, r) => {
                e.exports = function(e) {
                    function t(e) {
                        let r, o, i, s = null;

                        function a(...e) {
                            if (!a.enabled) return;
                            const n = a,
                                o = Number(new Date),
                                i = o - (r || o);
                            n.diff = i, n.prev = r, n.curr = o, r = o, e[0] = t.coerce(e[0]), "string" != typeof e[0] && e.unshift("%O");
                            let s = 0;
                            e[0] = e[0].replace(/%([a-zA-Z%])/g, ((r, o) => {
                                if ("%%" === r) return "%";
                                s++;
                                const i = t.formatters[o];
                                if ("function" == typeof i) {
                                    const t = e[s];
                                    r = i.call(n, t), e.splice(s, 1), s--
                                }
                                return r
                            })), t.formatArgs.call(n, e), (n.log || t.log).apply(n, e)
                        }
                        return a.namespace = e, a.useColors = t.useColors(), a.color = t.selectColor(e), a.extend = n, a.destroy = t.destroy, Object.defineProperty(a, "enabled", {
                            enumerable: !0,
                            configurable: !1,
                            get: () => null !== s ? s : (o !== t.namespaces && (o = t.namespaces, i = t.enabled(e)), i),
                            set: e => {
                                s = e
                            }
                        }), "function" == typeof t.init && t.init(a), a
                    }

                    function n(e, r) {
                        const n = t(this.namespace + (void 0 === r ? ":" : r) + e);
                        return n.log = this.log, n
                    }

                    function o(e) {
                        return e.toString().substring(2, e.toString().length - 2).replace(/\.\*\?$/, "*")
                    }
                    return t.debug = t, t.default = t, t.coerce = function(e) {
                        return e instanceof Error ? e.stack || e.message : e
                    }, t.disable = function() {
                        const e = [...t.names.map(o), ...t.skips.map(o).map((e => "-" + e))].join(",");
                        return t.enable(""), e
                    }, t.enable = function(e) {
                        let r;
                        t.save(e), t.namespaces = e, t.names = [], t.skips = [];
                        const n = ("string" == typeof e ? e : "").split(/[\s,]+/),
                            o = n.length;
                        for (r = 0; r < o; r++) n[r] && ("-" === (e = n[r].replace(/\*/g, ".*?"))[0] ? t.skips.push(new RegExp("^" + e.substr(1) + "$")) : t.names.push(new RegExp("^" + e + "$")))
                    }, t.enabled = function(e) {
                        if ("*" === e[e.length - 1]) return !0;
                        let r, n;
                        for (r = 0, n = t.skips.length; r < n; r++)
                            if (t.skips[r].test(e)) return !1;
                        for (r = 0, n = t.names.length; r < n; r++)
                            if (t.names[r].test(e)) return !0;
                        return !1
                    }, t.humanize = r(7824), t.destroy = function() {
                        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
                    }, Object.keys(e).forEach((r => {
                        t[r] = e[r]
                    })), t.names = [], t.skips = [], t.formatters = {}, t.selectColor = function(e) {
                        let r = 0;
                        for (let t = 0; t < e.length; t++) r = (r << 5) - r + e.charCodeAt(t), r |= 0;
                        return t.colors[Math.abs(r) % t.colors.length]
                    }, t.enable(t.load()), t
                }
            },
            8104: (e, t, r) => {
                "undefined" == typeof process || "renderer" === process.type || !0 === process.browser || process.__nwjs ? e.exports = r(1758) : e.exports = r(39)
            },
            39: (e, t, r) => {
                const n = r(6224),
                    o = r(3837);
                t.init = function(e) {
                    e.inspectOpts = {};
                    const r = Object.keys(t.inspectOpts);
                    for (let n = 0; n < r.length; n++) e.inspectOpts[r[n]] = t.inspectOpts[r[n]]
                }, t.log = function(...e) {
                    return process.stderr.write(o.format(...e) + "\n")
                }, t.formatArgs = function(r) {
                    const {
                        namespace: n,
                        useColors: o
                    } = this;
                    if (o) {
                        const t = this.color,
                            o = "[3" + (t < 8 ? t : "8;5;" + t),
                            i = `  ${o};1m${n} [0m`;
                        r[0] = i + r[0].split("\n").join("\n" + i), r.push(o + "m+" + e.exports.humanize(this.diff) + "[0m")
                    } else r[0] = (t.inspectOpts.hideDate ? "" : (new Date).toISOString() + " ") + n + " " + r[0]
                }, t.save = function(e) {
                    e ? process.env.DEBUG = e : delete process.env.DEBUG
                }, t.load = function() {
                    return process.env.DEBUG
                }, t.useColors = function() {
                    return "colors" in t.inspectOpts ? Boolean(t.inspectOpts.colors) : n.isatty(process.stderr.fd)
                }, t.destroy = o.deprecate((() => {}), "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."), t.colors = [6, 2, 3, 4, 5, 1];
                try {
                    const e = r(2130);
                    e && (e.stderr || e).level >= 2 && (t.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221])
                } catch (e) {}
                t.inspectOpts = Object.keys(process.env).filter((e => /^debug_/i.test(e))).reduce(((e, t) => {
                    const r = t.substring(6).toLowerCase().replace(/_([a-z])/g, ((e, t) => t.toUpperCase()));
                    let n = process.env[t];
                    return n = !!/^(yes|on|true|enabled)$/i.test(n) || !/^(no|off|false|disabled)$/i.test(n) && ("null" === n ? null : Number(n)), e[r] = n, e
                }), {}), e.exports = r(2447)(t);
                const {
                    formatters: i
                } = e.exports;
                i.o = function(e) {
                    return this.inspectOpts.colors = this.useColors, o.inspect(e, this.inspectOpts).split("\n").map((e => e.trim())).join(" ")
                }, i.O = function(e) {
                    return this.inspectOpts.colors = this.useColors, o.inspect(e, this.inspectOpts)
                }
            },
            1906: e => {
                "use strict";
                e.exports = (e, t, r) => {
                    const n = r => Object.defineProperty(e, t, {
                        value: r,
                        enumerable: !0,
                        writable: !0
                    });
                    return Object.defineProperty(e, t, {
                        configurable: !0,
                        enumerable: !0,
                        get() {
                            const e = r();
                            return n(e), e
                        },
                        set(e) {
                            n(e)
                        }
                    }), e
                }
            },
            8604: function(e, t, r) {
                "use strict";
                var n = this && this.__assign || Object.assign || function(e) {
                    for (var t, r = 1, n = arguments.length; r < n; r++)
                        for (var o in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
                    return e
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var o = r(4953);
                t.AzureMonitorSymbol = "Azure_Monitor_Tracer";
                var i = function() {
                    function e() {}
                    return e.prototype.onStart = function(e) {}, e.prototype.onEnd = function(e) {
                        o.channel.publish("azure-coretracing", e)
                    }, e.prototype.shutdown = function() {}, e
                }();
                t.azureCoreTracing = {
                    versionSpecifier: ">= 1.0.0 < 2.0.0",
                    patch: function(e) {
                        try {
                            var s = new(0, r(8028).BasicTracer)(o.channel.spanContextPropagator ? {
                                    scopeManager: o.channel.spanContextPropagator
                                } : void 0),
                                a = s.startSpan;
                            s.startSpan = function(e, t) {
                                if (!t || !t.parent) {
                                    var r = s.getCurrentSpan();
                                    r && r.operation && r.operation.traceparent && (t = n({}, t, {
                                        parent: {
                                            traceId: r.operation.traceparent.traceId,
                                            spanId: r.operation.traceparent.spanId
                                        }
                                    }))
                                }
                                var o = a.call(this, e, t);
                                return o.addEvent("Application Insights Integration enabled"), o
                            }, s.addSpanProcessor(new i), s[t.AzureMonitorSymbol] = !0, e.setTracer(s)
                        } catch (e) {}
                        return e
                    }
                }, t.enable = function() {
                    o.channel.registerMonkeyPatch("@azure/core-tracing", t.azureCoreTracing)
                }
            },
            8859: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(4953);
                t.bunyan = {
                    versionSpecifier: ">= 1.0.0 < 2.0.0",
                    patch: function(e) {
                        var t = e.prototype._emit;
                        return e.prototype._emit = function(e, r) {
                            var o = t.apply(this, arguments);
                            if (!r) {
                                var i = o;
                                i || (i = t.call(this, e, !0)), n.channel.publish("bunyan", {
                                    level: e.level,
                                    result: i
                                })
                            }
                            return o
                        }, e
                    }
                }, t.enable = function() {
                    n.channel.registerMonkeyPatch("bunyan", t.bunyan)
                }
            },
            2495: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(4953),
                    o = r(2781);
                t.console = {
                    versionSpecifier: ">= 4.0.0",
                    patch: function(e) {
                        var t = new o.Writable,
                            r = new o.Writable;
                        t.write = function(e) {
                            if (!e) return !0;
                            var t = e.toString();
                            return n.channel.publish("console", {
                                message: t
                            }), !0
                        }, r.write = function(e) {
                            if (!e) return !0;
                            var t = e.toString();
                            return n.channel.publish("console", {
                                message: t,
                                stderr: !0
                            }), !0
                        };
                        for (var i = new e.Console(t, r), s = function(t) {
                                var r = e[t];
                                r && (e[t] = function() {
                                    if (i[t]) try {
                                        i[t].apply(i, arguments)
                                    } catch (e) {}
                                    return r.apply(e, arguments)
                                })
                            }, a = 0, c = ["log", "info", "warn", "error", "dir", "time", "timeEnd", "trace", "assert"]; a < c.length; a++) s(c[a]);
                        return e
                    }
                }, t.enable = function() {
                    n.channel.registerMonkeyPatch("console", t.console), r(6206)
                }
            },
            4106: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(8604);
                t.azuresdk = n;
                var o = r(8859);
                t.bunyan = o;
                var i = r(2495);
                t.console = i;
                var s = r(2028);
                t.mongodbCore = s;
                var a = r(8436);
                t.mongodb = a;
                var c = r(8002);
                t.mysql = c;
                var l = r(9024);
                t.pgPool = l;
                var u = r(8060);
                t.pg = u;
                var d = r(4487);
                t.redis = d;
                var p = r(6661);
                t.tedious = p;
                var h = r(4650);
                t.winston = h, t.enable = function() {
                    o.enable(), i.enable(), s.enable(), a.enable(), c.enable(), u.enable(), l.enable(), d.enable(), h.enable(), n.enable(), p.enable()
                }
            },
            2028: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(4953);
                t.mongoCore = {
                    versionSpecifier: ">= 2.0.0 < 4.0.0",
                    patch: function(e) {
                        var t = e.Server.prototype.connect;
                        return e.Server.prototype.connect = function() {
                            var e = t.apply(this, arguments),
                                r = this.s.pool.write;
                            this.s.pool.write = function() {
                                var e = "function" == typeof arguments[1] ? 1 : 2;
                                return "function" == typeof arguments[e] && (arguments[e] = n.channel.bindToContext(arguments[e])), r.apply(this, arguments)
                            };
                            var o = this.s.pool.logout;
                            return this.s.pool.logout = function() {
                                return "function" == typeof arguments[1] && (arguments[1] = n.channel.bindToContext(arguments[1])), o.apply(this, arguments)
                            }, e
                        }, e
                    }
                }, t.enable = function() {
                    n.channel.registerMonkeyPatch("mongodb-core", t.mongoCore)
                }
            },
            8436: function(e, t, r) {
                "use strict";
                var n = this && this.__assign || Object.assign || function(e) {
                    for (var t, r = 1, n = arguments.length; r < n; r++)
                        for (var o in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
                    return e
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var o = r(4953);
                t.mongo2 = {
                    versionSpecifier: ">= 2.0.0 <= 3.0.5",
                    patch: function(e) {
                        var t = e.instrument({
                                operationIdGenerator: {
                                    next: function() {
                                        return o.channel.bindToContext((function(e) {
                                            return e()
                                        }))
                                    }
                                }
                            }),
                            r = {};
                        return t.on("started", (function(e) {
                            r[e.requestId] || (r[e.requestId] = n({}, e, {
                                time: new Date
                            }))
                        })), t.on("succeeded", (function(e) {
                            var t = r[e.requestId];
                            t && delete r[e.requestId], "function" == typeof e.operationId ? e.operationId((function() {
                                return o.channel.publish("mongodb", {
                                    startedData: t,
                                    event: e,
                                    succeeded: !0
                                })
                            })) : o.channel.publish("mongodb", {
                                startedData: t,
                                event: e,
                                succeeded: !0
                            })
                        })), t.on("failed", (function(e) {
                            var t = r[e.requestId];
                            t && delete r[e.requestId], "function" == typeof e.operationId ? e.operationId((function() {
                                return o.channel.publish("mongodb", {
                                    startedData: t,
                                    event: e,
                                    succeeded: !1
                                })
                            })) : o.channel.publish("mongodb", {
                                startedData: t,
                                event: e,
                                succeeded: !1
                            })
                        })), e
                    }
                }, t.mongo3 = {
                    versionSpecifier: "> 3.0.5 < 3.3.0",
                    patch: function(e) {
                        var t = e.instrument(),
                            r = {},
                            i = {};
                        return t.on("started", (function(e) {
                            r[e.requestId] || (i[e.requestId] = o.channel.bindToContext((function(e) {
                                return e()
                            })), r[e.requestId] = n({}, e, {
                                time: new Date
                            }))
                        })), t.on("succeeded", (function(e) {
                            var t = r[e.requestId];
                            t && delete r[e.requestId], "object" == typeof e && "function" == typeof i[e.requestId] && (i[e.requestId]((function() {
                                return o.channel.publish("mongodb", {
                                    startedData: t,
                                    event: e,
                                    succeeded: !0
                                })
                            })), delete i[e.requestId])
                        })), t.on("failed", (function(e) {
                            var t = r[e.requestId];
                            t && delete r[e.requestId], "object" == typeof e && "function" == typeof i[e.requestId] && (i[e.requestId]((function() {
                                return o.channel.publish("mongodb", {
                                    startedData: t,
                                    event: e,
                                    succeeded: !1
                                })
                            })), delete i[e.requestId])
                        })), e
                    }
                }, t.mongo330 = {
                    versionSpecifier: ">= 3.3.0 < 4.0.0",
                    patch: function(e) {
                        ! function(e) {
                            var t = e.Server.prototype.connect;
                            e.Server.prototype.connect = function() {
                                var e = t.apply(this, arguments),
                                    r = this.s.coreTopology.s.pool.write;
                                this.s.coreTopology.s.pool.write = function() {
                                    var e = "function" == typeof arguments[1] ? 1 : 2;
                                    return "function" == typeof arguments[e] && (arguments[e] = o.channel.bindToContext(arguments[e])), r.apply(this, arguments)
                                };
                                var n = this.s.coreTopology.s.pool.logout;
                                return this.s.coreTopology.s.pool.logout = function() {
                                    return "function" == typeof arguments[1] && (arguments[1] = o.channel.bindToContext(arguments[1])), n.apply(this, arguments)
                                }, e
                            }
                        }(e);
                        var t = e.instrument(),
                            r = {},
                            n = {};
                        return t.on("started", (function(e) {
                            r[e.requestId] || (n[e.requestId] = o.channel.bindToContext((function(e) {
                                return e()
                            })), r[e.requestId] = e)
                        })), t.on("succeeded", (function(e) {
                            var t = r[e.requestId];
                            t && delete r[e.requestId], "object" == typeof e && "function" == typeof n[e.requestId] && (n[e.requestId]((function() {
                                return o.channel.publish("mongodb", {
                                    startedData: t,
                                    event: e,
                                    succeeded: !0
                                })
                            })), delete n[e.requestId])
                        })), t.on("failed", (function(e) {
                            var t = r[e.requestId];
                            t && delete r[e.requestId], "object" == typeof e && "function" == typeof n[e.requestId] && (n[e.requestId]((function() {
                                return o.channel.publish("mongodb", {
                                    startedData: t,
                                    event: e,
                                    succeeded: !1
                                })
                            })), delete n[e.requestId])
                        })), e
                    }
                }, t.enable = function() {
                    o.channel.registerMonkeyPatch("mongodb", t.mongo2), o.channel.registerMonkeyPatch("mongodb", t.mongo3), o.channel.registerMonkeyPatch("mongodb", t.mongo330)
                }
            },
            8002: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(4953),
                    o = r(1017);
                t.mysql = {
                    versionSpecifier: ">= 2.0.0 < 3.0.0",
                    patch: function(e, t) {
                        var i = function(e, t) {
                                return function(t, r) {
                                    var o = e[t];
                                    o && (e[t] = function() {
                                        for (var e = arguments.length - 1, t = arguments.length - 1; t >= 0; --t) {
                                            if ("function" == typeof arguments[t]) {
                                                e = t;
                                                break
                                            }
                                            if (void 0 !== arguments[t]) break
                                        }
                                        var i = arguments[e],
                                            s = {
                                                result: null,
                                                startTime: null,
                                                startDate: null
                                            };
                                        "function" == typeof i && (r ? (s.startTime = process.hrtime(), s.startDate = new Date, arguments[e] = n.channel.bindToContext(r(s, i))) : arguments[e] = n.channel.bindToContext(i));
                                        var a = o.apply(this, arguments);
                                        return s.result = a, a
                                    })
                                }
                            },
                            s = function(e, t) {
                                return i(e.prototype)
                            },
                            a = r(4694)(o.dirname(t) + "/lib/Connection");
                        ["connect", "changeUser", "ping", "statistics", "end"].forEach((function(e) {
                            return s(a)(e)
                        })), i(a)("createQuery", (function(e, t) {
                            return function(r) {
                                var o = process.hrtime(e.startTime),
                                    i = 1e3 * o[0] + o[1] / 1e6 | 0;
                                n.channel.publish("mysql", {
                                    query: e.result,
                                    callbackArgs: arguments,
                                    err: r,
                                    duration: i,
                                    time: e.startDate
                                }), t.apply(this, arguments)
                            }
                        }));
                        var c = r(420)(o.dirname(t) + "/lib/Pool");
                        return ["_enqueueCallback"].forEach((function(e) {
                            return s(c)(e)
                        })), e
                    }
                }, t.enable = function() {
                    n.channel.registerMonkeyPatch("mysql", t.mysql)
                }
            },
            9024: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(4953);
                t.postgresPool1 = {
                    versionSpecifier: ">= 1.0.0 < 3.0.0",
                    patch: function(e) {
                        var t = e.prototype.connect;
                        return e.prototype.connect = function(e) {
                            return e && (arguments[0] = n.channel.bindToContext(e)), t.apply(this, arguments)
                        }, e
                    }
                }, t.enable = function() {
                    n.channel.registerMonkeyPatch("pg-pool", t.postgresPool1)
                }
            },
            8060: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(4953),
                    o = r(2361);
                t.postgres6 = {
                    versionSpecifier: "6.*",
                    patch: function(e, t) {
                        var r = e.Client.prototype.query,
                            i = "__diagnosticOriginalFunc";
                        return e.Client.prototype.query = function(e, t, s) {
                            var a, c = {
                                    query: {},
                                    database: {
                                        host: this.connectionParameters.host,
                                        port: this.connectionParameters.port
                                    },
                                    result: null,
                                    error: null,
                                    duration: 0,
                                    time: new Date
                                },
                                l = process.hrtime();

                            function u(e) {
                                e && e[i] && (e = e[i]);
                                var t = n.channel.bindToContext((function(t, r) {
                                    var i = process.hrtime(l);
                                    if (c.result = r && {
                                            rowCount: r.rowCount,
                                            command: r.command
                                        }, c.error = t, c.duration = Math.ceil(1e3 * i[0] + i[1] / 1e6), n.channel.publish("postgres", c), t) {
                                        if (e) return e.apply(this, arguments);
                                        a && a instanceof o.EventEmitter && a.emit("error", t)
                                    } else e && e.apply(this, arguments)
                                }));
                                try {
                                    return Object.defineProperty(t, i, {
                                        value: e
                                    }), t
                                } catch (t) {
                                    return e
                                }
                            }
                            try {
                                "string" == typeof e ? t instanceof Array ? (c.query.preparable = {
                                    text: e,
                                    args: t
                                }, s = u(s)) : (c.query.text = e, s ? s = u(s) : t = u(t)) : ("string" == typeof e.name ? c.query.plan = e.name : e.values instanceof Array ? c.query.preparable = {
                                    text: e.text,
                                    args: e.values
                                } : c.query.text = e.text, s ? s = u(s) : t ? t = u(t) : e.callback = u(e.callback))
                            } catch (e) {
                                return r.apply(this, arguments)
                            }
                            return arguments[0] = e, arguments[1] = t, arguments[2] = s, arguments.length = arguments.length > 3 ? arguments.length : 3, a = r.apply(this, arguments)
                        }, e
                    }
                }, t.postgres7 = {
                    versionSpecifier: ">=7.* <=8.*",
                    patch: function(e, t) {
                        var r = e.Client.prototype.query,
                            i = "__diagnosticOriginalFunc";
                        return e.Client.prototype.query = function(e, t, s) {
                            var a, c = this,
                                l = !!s,
                                u = {
                                    query: {},
                                    database: {
                                        host: this.connectionParameters.host,
                                        port: this.connectionParameters.port
                                    },
                                    result: null,
                                    error: null,
                                    duration: 0,
                                    time: new Date
                                },
                                d = process.hrtime();

                            function p(e) {
                                e && e[i] && (e = e[i]);
                                var t = n.channel.bindToContext((function(t, r) {
                                    var i = process.hrtime(d);
                                    if (u.result = r && {
                                            rowCount: r.rowCount,
                                            command: r.command
                                        }, u.error = t, u.duration = Math.ceil(1e3 * i[0] + i[1] / 1e6), n.channel.publish("postgres", u), t) {
                                        if (e) return e.apply(this, arguments);
                                        a && a instanceof o.EventEmitter && a.emit("error", t)
                                    } else e && e.apply(this, arguments)
                                }));
                                try {
                                    return Object.defineProperty(t, i, {
                                        value: e
                                    }), t
                                } catch (t) {
                                    return e
                                }
                            }
                            try {
                                "string" == typeof e ? t instanceof Array ? (u.query.preparable = {
                                    text: e,
                                    args: t
                                }, s = (l = "function" == typeof s) ? p(s) : s) : (u.query.text = e, s ? s = (l = "function" == typeof s) ? p(s) : s : t = (l = "function" == typeof t) ? p(t) : t) : ("string" == typeof e.name ? u.query.plan = e.name : e.values instanceof Array ? u.query.preparable = {
                                    text: e.text,
                                    args: e.values
                                } : u.query.text = e.text, s ? (l = "function" == typeof s, s = p(s)) : t ? t = (l = "function" == typeof t) ? p(t) : t : (l = "function" == typeof e.callback, e.callback = l ? p(e.callback) : e.callback))
                            } catch (e) {
                                return r.apply(this, arguments)
                            }
                            return arguments[0] = e, arguments[1] = t, arguments[2] = s, arguments.length = arguments.length > 3 ? arguments.length : 3, a = r.apply(this, arguments), l ? a : a.then((function(e) {
                                return p()(void 0, e), new c._Promise((function(t, r) {
                                    t(e)
                                }))
                            })).catch((function(e) {
                                return p()(e, void 0), new c._Promise((function(t, r) {
                                    r(e)
                                }))
                            }))
                        }, e
                    }
                }, t.enable = function() {
                    n.channel.registerMonkeyPatch("pg", t.postgres6), n.channel.registerMonkeyPatch("pg", t.postgres7)
                }
            },
            4487: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(4953);
                t.redis = {
                    versionSpecifier: ">= 2.0.0 < 4.0.0",
                    patch: function(e) {
                        var t = e.RedisClient.prototype.internal_send_command;
                        return e.RedisClient.prototype.internal_send_command = function(e) {
                            if (e) {
                                var r = e.callback;
                                if (!r || !r.pubsubBound) {
                                    var o = this.address,
                                        i = process.hrtime(),
                                        s = new Date;
                                    e.callback = n.channel.bindToContext((function(t, a) {
                                        var c = process.hrtime(i),
                                            l = 1e3 * c[0] + c[1] / 1e6 | 0;
                                        n.channel.publish("redis", {
                                            duration: l,
                                            address: o,
                                            commandObj: e,
                                            err: t,
                                            result: a,
                                            time: s
                                        }), "function" == typeof r && r.apply(this, arguments)
                                    })), e.callback.pubsubBound = !0
                                }
                            }
                            return t.call(this, e)
                        }, e
                    }
                }, t.enable = function() {
                    n.channel.registerMonkeyPatch("redis", t.redis)
                }
            },
            6661: function(e, t, r) {
                "use strict";
                var n = this && this.__assign || Object.assign || function(e) {
                    for (var t, r = 1, n = arguments.length; r < n; r++)
                        for (var o in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
                    return e
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var o = r(4953);
                t.tedious = {
                    versionSpecifier: ">= 6.0.0 < 9.0.0",
                    patch: function(e) {
                        var t = e.Connection.prototype.makeRequest;
                        return e.Connection.prototype.makeRequest = function() {
                            function e(e) {
                                var t = process.hrtime(),
                                    r = {
                                        query: {},
                                        database: {
                                            host: null,
                                            port: null
                                        },
                                        result: null,
                                        error: null,
                                        duration: 0
                                    };
                                return o.channel.bindToContext((function(i, s, a) {
                                    var c = process.hrtime(t);
                                    r = n({}, r, {
                                        database: {
                                            host: this.connection.config.server,
                                            port: this.connection.config.options.port
                                        },
                                        result: !i && {
                                            rowCount: s,
                                            rows: a
                                        },
                                        query: {
                                            text: this.parametersByName.statement.value
                                        },
                                        error: i,
                                        duration: Math.ceil(1e3 * c[0] + c[1] / 1e6)
                                    }), o.channel.publish("tedious", r), e.call(this, i, s, a)
                                }))
                            }
                            var r = arguments[0];
                            arguments[0].callback = e(r.callback), t.apply(this, arguments)
                        }, e
                    }
                }, t.enable = function() {
                    o.channel.registerMonkeyPatch("tedious", t.tedious)
                }
            },
            4650: function(e, t, r) {
                "use strict";
                var n, o = this && this.__extends || (n = Object.setPrototypeOf || {
                            __proto__: []
                        }
                        instanceof Array && function(e, t) {
                            e.__proto__ = t
                        } || function(e, t) {
                            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                        },
                        function(e, t) {
                            function r() {
                                this.constructor = e
                            }
                            n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                        }),
                    i = this && this.__rest || function(e, t) {
                        var r = {};
                        for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
                        if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                            var o = 0;
                            for (n = Object.getOwnPropertySymbols(e); o < n.length; o++) t.indexOf(n[o]) < 0 && (r[n[o]] = e[n[o]])
                        }
                        return r
                    };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var s = r(4953);
                t.winston3 = {
                    versionSpecifier: "3.x",
                    patch: function(e) {
                        var t = function(e) {
                            function t(t, r) {
                                var n = e.call(this, r) || this;
                                return n.winston = t, n
                            }
                            return o(t, e), t.prototype.log = function(e, t) {
                                var r = e.message,
                                    n = e.level,
                                    o = e.meta,
                                    a = i(e, ["message", "level", "meta"]);
                                n = "function" == typeof Symbol.for ? e[Symbol.for("level")] : n, r = e instanceof Error ? e : r;
                                var c = function(e, t) {
                                    return null != e.config.npm.levels[t] ? "npm" : null != e.config.syslog.levels[t] ? "syslog" : "unknown"
                                }(this.winston, n);
                                for (var l in o = o || {}, a) a.hasOwnProperty(l) && (o[l] = a[l]);
                                s.channel.publish("winston", {
                                    message: r,
                                    level: n,
                                    levelKind: c,
                                    meta: o
                                }), t()
                            }, t
                        }(e.Transport);

                        function r() {
                            var r, n = arguments[0].levels || e.config.npm.levels;
                            for (var o in n) n.hasOwnProperty(o) && (r = void 0 === r || n[o] > n[r] ? o : r);
                            this.add(new t(e, {
                                level: r
                            }))
                        }
                        var n = e.createLogger;
                        e.createLogger = function() {
                            var o, i = arguments[0].levels || e.config.npm.levels;
                            for (var s in i) i.hasOwnProperty(s) && (o = void 0 === o || i[s] > i[o] ? s : o);
                            var a = n.apply(this, arguments);
                            a.add(new t(e, {
                                level: o
                            }));
                            var c = a.configure;
                            return a.configure = function() {
                                c.apply(this, arguments), r.apply(this, arguments)
                            }, a
                        };
                        var a = e.createLogger;
                        return e.configure = function() {
                            a.apply(this, arguments), r.apply(this, arguments)
                        }, e.add(new t(e)), e
                    }
                }, t.winston2 = {
                    versionSpecifier: "2.x",
                    patch: function(e) {
                        var t, r = e.Logger.prototype.log,
                            n = function(r, n, o) {
                                var i;
                                return i = t === e.config.npm.levels ? "npm" : t === e.config.syslog.levels ? "syslog" : "unknown", s.channel.publish("winston", {
                                    level: r,
                                    message: n,
                                    meta: o,
                                    levelKind: i
                                }), n
                            };
                        return e.Logger.prototype.log = function() {
                            return t = this.levels, this.filters && 0 !== this.filters.length ? this.filters[this.filters.length - 1] !== n && (this.filters = this.filters.filter((function(e) {
                                return e !== n
                            })), this.filters.push(n)) : this.filters = [n], r.apply(this, arguments)
                        }, e
                    }
                }, t.enable = function() {
                    s.channel.registerMonkeyPatch("winston", t.winston2), s.channel.registerMonkeyPatch("winston", t.winston3)
                }
            },
            4694: e => {
                function t(e) {
                    var t = new Error("Cannot find module '" + e + "'");
                    throw t.code = "MODULE_NOT_FOUND", t
                }
                t.keys = () => [], t.resolve = t, t.id = 4694, e.exports = t
            },
            420: e => {
                function t(e) {
                    var t = new Error("Cannot find module '" + e + "'");
                    throw t.code = "MODULE_NOT_FOUND", t
                }
                t.keys = () => [], t.resolve = t, t.id = 420, e.exports = t
            },
            4953: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(7424),
                    o = r(7424);
                t.makePatchingRequire = o.makePatchingRequire;
                var i = function(e) {
                        return !0
                    },
                    s = function() {
                        function e() {
                            this.version = r(130).i8, this.subscribers = {}, this.contextPreservationFunction = function(e) {
                                return e
                            }, this.knownPatches = {}, this.currentlyPublishing = !1
                        }
                        return e.prototype.shouldPublish = function(e) {
                            var t = this.subscribers[e];
                            return !!t && t.some((function(e) {
                                var t = e.filter;
                                return !t || t(!1)
                            }))
                        }, e.prototype.publish = function(e, t) {
                            if (!this.currentlyPublishing) {
                                var r = this.subscribers[e];
                                if (r) {
                                    var n = {
                                        timestamp: Date.now(),
                                        data: t
                                    };
                                    this.currentlyPublishing = !0, r.forEach((function(e) {
                                        var t = e.listener,
                                            r = e.filter;
                                        try {
                                            r && r(!0) && t(n)
                                        } catch (e) {}
                                    })), this.currentlyPublishing = !1
                                }
                            }
                        }, e.prototype.subscribe = function(e, t, r) {
                            void 0 === r && (r = i), this.subscribers[e] || (this.subscribers[e] = []), this.subscribers[e].push({
                                listener: t,
                                filter: r
                            })
                        }, e.prototype.unsubscribe = function(e, t, r) {
                            void 0 === r && (r = i);
                            var n = this.subscribers[e];
                            if (n)
                                for (var o = 0; o < n.length; ++o)
                                    if (n[o].listener === t && n[o].filter === r) return n.splice(o, 1), !0;
                            return !1
                        }, e.prototype.reset = function() {
                            var e = this;
                            this.subscribers = {}, this.contextPreservationFunction = function(e) {
                                return e
                            }, Object.getOwnPropertyNames(this.knownPatches).forEach((function(t) {
                                return delete e.knownPatches[t]
                            }))
                        }, e.prototype.bindToContext = function(e) {
                            return this.contextPreservationFunction(e)
                        }, e.prototype.addContextPreservation = function(e) {
                            var t = this.contextPreservationFunction;
                            this.contextPreservationFunction = function(r) {
                                return e(t(r))
                            }
                        }, e.prototype.registerMonkeyPatch = function(e, t) {
                            this.knownPatches[e] || (this.knownPatches[e] = []), this.knownPatches[e].push(t)
                        }, e.prototype.getPatchesObject = function() {
                            return this.knownPatches
                        }, e
                    }();
                global.diagnosticsSource || (global.diagnosticsSource = new s, r(8188).prototype.require = n.makePatchingRequire(global.diagnosticsSource.getPatchesObject())), t.channel = global.diagnosticsSource
            },
            7424: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var n = r(1017),
                    o = r(4014),
                    i = r(8188),
                    s = Object.keys(process.binding("natives")),
                    a = i.prototype.require;
                t.makePatchingRequire = function(e) {
                    var t = {};
                    return function(r) {
                        var c = a.apply(this, arguments);
                        if (e[r]) {
                            var l = i._resolveFilename(r, this);
                            if (t.hasOwnProperty(l)) return t[l];
                            var u = void 0;
                            if (s.indexOf(r) < 0) try {
                                u = a.call(this, n.join(r, "package.json")).version
                            } catch (e) {
                                return c
                            } else u = process.version.substring(1);
                            var d = u.indexOf("-");
                            d >= 0 && (u = u.substring(0, d));
                            for (var p = c, h = 0, f = e[r]; h < f.length; h++) {
                                var m = f[h];
                                o.satisfies(u, m.versionSpecifier) && (p = m.patch(p, l))
                            }
                            return t[l] = p
                        }
                        return c
                    }
                }
            },
            4014: (e, t) => {
                var r;
                t = e.exports = V, r = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
                    var e = Array.prototype.slice.call(arguments, 0);
                    e.unshift("SEMVER"), console.log.apply(console, e)
                } : function() {}, t.SEMVER_SPEC_VERSION = "2.0.0";
                var n = Number.MAX_SAFE_INTEGER || 9007199254740991,
                    o = t.re = [],
                    i = t.src = [],
                    s = 0,
                    a = s++;
                i[a] = "0|[1-9]\\d*";
                var c = s++;
                i[c] = "[0-9]+";
                var l = s++;
                i[l] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
                var u = s++;
                i[u] = "(" + i[a] + ")\\.(" + i[a] + ")\\.(" + i[a] + ")";
                var d = s++;
                i[d] = "(" + i[c] + ")\\.(" + i[c] + ")\\.(" + i[c] + ")";
                var p = s++;
                i[p] = "(?:" + i[a] + "|" + i[l] + ")";
                var h = s++;
                i[h] = "(?:" + i[c] + "|" + i[l] + ")";
                var f = s++;
                i[f] = "(?:-(" + i[p] + "(?:\\." + i[p] + ")*))";
                var m = s++;
                i[m] = "(?:-?(" + i[h] + "(?:\\." + i[h] + ")*))";
                var g = s++;
                i[g] = "[0-9A-Za-z-]+";
                var _ = s++;
                i[_] = "(?:\\+(" + i[g] + "(?:\\." + i[g] + ")*))";
                var y = s++,
                    v = "v?" + i[u] + i[f] + "?" + i[_] + "?";
                i[y] = "^" + v + "$";
                var b = "[v=\\s]*" + i[d] + i[m] + "?" + i[_] + "?",
                    w = s++;
                i[w] = "^" + b + "$";
                var x = s++;
                i[x] = "((?:<|>)?=?)";
                var E = s++;
                i[E] = i[c] + "|x|X|\\*";
                var C = s++;
                i[C] = i[a] + "|x|X|\\*";
                var S = s++;
                i[S] = "[v=\\s]*(" + i[C] + ")(?:\\.(" + i[C] + ")(?:\\.(" + i[C] + ")(?:" + i[f] + ")?" + i[_] + "?)?)?";
                var T = s++;
                i[T] = "[v=\\s]*(" + i[E] + ")(?:\\.(" + i[E] + ")(?:\\.(" + i[E] + ")(?:" + i[m] + ")?" + i[_] + "?)?)?";
                var k = s++;
                i[k] = "^" + i[x] + "\\s*" + i[S] + "$";
                var I = s++;
                i[I] = "^" + i[x] + "\\s*" + i[T] + "$";
                var P = s++;
                i[P] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
                var A = s++;
                i[A] = "(?:~>?)";
                var O = s++;
                i[O] = "(\\s*)" + i[A] + "\\s+", o[O] = new RegExp(i[O], "g");
                var N = s++;
                i[N] = "^" + i[A] + i[S] + "$";
                var R = s++;
                i[R] = "^" + i[A] + i[T] + "$";
                var $ = s++;
                i[$] = "(?:\\^)";
                var M = s++;
                i[M] = "(\\s*)" + i[$] + "\\s+", o[M] = new RegExp(i[M], "g");
                var D = s++;
                i[D] = "^" + i[$] + i[S] + "$";
                var L = s++;
                i[L] = "^" + i[$] + i[T] + "$";
                var F = s++;
                i[F] = "^" + i[x] + "\\s*(" + b + ")$|^$";
                var j = s++;
                i[j] = "^" + i[x] + "\\s*(" + v + ")$|^$";
                var B = s++;
                i[B] = "(\\s*)" + i[x] + "\\s*(" + b + "|" + i[S] + ")", o[B] = new RegExp(i[B], "g");
                var q = s++;
                i[q] = "^\\s*(" + i[S] + ")\\s+-\\s+(" + i[S] + ")\\s*$";
                var U = s++;
                i[U] = "^\\s*(" + i[T] + ")\\s+-\\s+(" + i[T] + ")\\s*$";
                var H = s++;
                i[H] = "(<|>)?=?\\s*\\*";
                for (var G = 0; G < 35; G++) r(G, i[G]), o[G] || (o[G] = new RegExp(i[G]));

                function z(e, t) {
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), e instanceof V) return e;
                    if ("string" != typeof e) return null;
                    if (e.length > 256) return null;
                    if (!(t.loose ? o[w] : o[y]).test(e)) return null;
                    try {
                        return new V(e, t)
                    } catch (e) {
                        return null
                    }
                }

                function V(e, t) {
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), e instanceof V) {
                        if (e.loose === t.loose) return e;
                        e = e.version
                    } else if ("string" != typeof e) throw new TypeError("Invalid Version: " + e);
                    if (e.length > 256) throw new TypeError("version is longer than 256 characters");
                    if (!(this instanceof V)) return new V(e, t);
                    r("SemVer", e, t), this.options = t, this.loose = !!t.loose;
                    var i = e.trim().match(t.loose ? o[w] : o[y]);
                    if (!i) throw new TypeError("Invalid Version: " + e);
                    if (this.raw = e, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > n || this.major < 0) throw new TypeError("Invalid major version");
                    if (this.minor > n || this.minor < 0) throw new TypeError("Invalid minor version");
                    if (this.patch > n || this.patch < 0) throw new TypeError("Invalid patch version");
                    i[4] ? this.prerelease = i[4].split(".").map((function(e) {
                        if (/^[0-9]+$/.test(e)) {
                            var t = +e;
                            if (t >= 0 && t < n) return t
                        }
                        return e
                    })) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format()
                }
                t.parse = z, t.valid = function(e, t) {
                    var r = z(e, t);
                    return r ? r.version : null
                }, t.clean = function(e, t) {
                    var r = z(e.trim().replace(/^[=v]+/, ""), t);
                    return r ? r.version : null
                }, t.SemVer = V, V.prototype.format = function() {
                    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version
                }, V.prototype.toString = function() {
                    return this.version
                }, V.prototype.compare = function(e) {
                    return r("SemVer.compare", this.version, this.options, e), e instanceof V || (e = new V(e, this.options)), this.compareMain(e) || this.comparePre(e)
                }, V.prototype.compareMain = function(e) {
                    return e instanceof V || (e = new V(e, this.options)), K(this.major, e.major) || K(this.minor, e.minor) || K(this.patch, e.patch)
                }, V.prototype.comparePre = function(e) {
                    if (e instanceof V || (e = new V(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
                    if (!this.prerelease.length && e.prerelease.length) return 1;
                    if (!this.prerelease.length && !e.prerelease.length) return 0;
                    var t = 0;
                    do {
                        var n = this.prerelease[t],
                            o = e.prerelease[t];
                        if (r("prerelease compare", t, n, o), void 0 === n && void 0 === o) return 0;
                        if (void 0 === o) return 1;
                        if (void 0 === n) return -1;
                        if (n !== o) return K(n, o)
                    } while (++t)
                }, V.prototype.inc = function(e, t) {
                    switch (e) {
                        case "premajor":
                            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
                            break;
                        case "preminor":
                            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
                            break;
                        case "prepatch":
                            this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
                            break;
                        case "prerelease":
                            0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t);
                            break;
                        case "major":
                            0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                            break;
                        case "minor":
                            0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                            break;
                        case "patch":
                            0 === this.prerelease.length && this.patch++, this.prerelease = [];
                            break;
                        case "pre":
                            if (0 === this.prerelease.length) this.prerelease = [0];
                            else {
                                for (var r = this.prerelease.length; --r >= 0;) "number" == typeof this.prerelease[r] && (this.prerelease[r]++, r = -2); - 1 === r && this.prerelease.push(0)
                            }
                            t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);
                            break;
                        default:
                            throw new Error("invalid increment argument: " + e)
                    }
                    return this.format(), this.raw = this.version, this
                }, t.inc = function(e, t, r, n) {
                    "string" == typeof r && (n = r, r = void 0);
                    try {
                        return new V(e, r).inc(t, n).version
                    } catch (e) {
                        return null
                    }
                }, t.diff = function(e, t) {
                    if (Y(e, t)) return null;
                    var r = z(e),
                        n = z(t),
                        o = "";
                    if (r.prerelease.length || n.prerelease.length) {
                        o = "pre";
                        var i = "prerelease"
                    }
                    for (var s in r)
                        if (("major" === s || "minor" === s || "patch" === s) && r[s] !== n[s]) return o + s;
                    return i
                }, t.compareIdentifiers = K;
                var W = /^[0-9]+$/;

                function K(e, t) {
                    var r = W.test(e),
                        n = W.test(t);
                    return r && n && (e = +e, t = +t), e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1
                }

                function J(e, t, r) {
                    return new V(e, r).compare(new V(t, r))
                }

                function X(e, t, r) {
                    return J(e, t, r) > 0
                }

                function Q(e, t, r) {
                    return J(e, t, r) < 0
                }

                function Y(e, t, r) {
                    return 0 === J(e, t, r)
                }

                function Z(e, t, r) {
                    return 0 !== J(e, t, r)
                }

                function ee(e, t, r) {
                    return J(e, t, r) >= 0
                }

                function te(e, t, r) {
                    return J(e, t, r) <= 0
                }

                function re(e, t, r, n) {
                    switch (t) {
                        case "===":
                            return "object" == typeof e && (e = e.version), "object" == typeof r && (r = r.version), e === r;
                        case "!==":
                            return "object" == typeof e && (e = e.version), "object" == typeof r && (r = r.version), e !== r;
                        case "":
                        case "=":
                        case "==":
                            return Y(e, r, n);
                        case "!=":
                            return Z(e, r, n);
                        case ">":
                            return X(e, r, n);
                        case ">=":
                            return ee(e, r, n);
                        case "<":
                            return Q(e, r, n);
                        case "<=":
                            return te(e, r, n);
                        default:
                            throw new TypeError("Invalid operator: " + t)
                    }
                }

                function ne(e, t) {
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), e instanceof ne) {
                        if (e.loose === !!t.loose) return e;
                        e = e.value
                    }
                    if (!(this instanceof ne)) return new ne(e, t);
                    r("comparator", e, t), this.options = t, this.loose = !!t.loose, this.parse(e), this.semver === oe ? this.value = "" : this.value = this.operator + this.semver.version, r("comp", this)
                }
                t.rcompareIdentifiers = function(e, t) {
                    return K(t, e)
                }, t.major = function(e, t) {
                    return new V(e, t).major
                }, t.minor = function(e, t) {
                    return new V(e, t).minor
                }, t.patch = function(e, t) {
                    return new V(e, t).patch
                }, t.compare = J, t.compareLoose = function(e, t) {
                    return J(e, t, !0)
                }, t.rcompare = function(e, t, r) {
                    return J(t, e, r)
                }, t.sort = function(e, r) {
                    return e.sort((function(e, n) {
                        return t.compare(e, n, r)
                    }))
                }, t.rsort = function(e, r) {
                    return e.sort((function(e, n) {
                        return t.rcompare(e, n, r)
                    }))
                }, t.gt = X, t.lt = Q, t.eq = Y, t.neq = Z, t.gte = ee, t.lte = te, t.cmp = re, t.Comparator = ne;
                var oe = {};

                function ie(e, t) {
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), e instanceof ie) return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new ie(e.raw, t);
                    if (e instanceof ne) return new ie(e.value, t);
                    if (!(this instanceof ie)) return new ie(e, t);
                    if (this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease, this.raw = e, this.set = e.split(/\s*\|\|\s*/).map((function(e) {
                            return this.parseRange(e.trim())
                        }), this).filter((function(e) {
                            return e.length
                        })), !this.set.length) throw new TypeError("Invalid SemVer Range: " + e);
                    this.format()
                }

                function se(e) {
                    return !e || "x" === e.toLowerCase() || "*" === e
                }

                function ae(e, t, r, n, o, i, s, a, c, l, u, d, p) {
                    return ((t = se(r) ? "" : se(n) ? ">=" + r + ".0.0" : se(o) ? ">=" + r + "." + n + ".0" : ">=" + t) + " " + (a = se(c) ? "" : se(l) ? "<" + (+c + 1) + ".0.0" : se(u) ? "<" + c + "." + (+l + 1) + ".0" : d ? "<=" + c + "." + l + "." + u + "-" + d : "<=" + a)).trim()
                }

                function ce(e, t, n) {
                    for (var o = 0; o < e.length; o++)
                        if (!e[o].test(t)) return !1;
                    if (t.prerelease.length && !n.includePrerelease) {
                        for (o = 0; o < e.length; o++)
                            if (r(e[o].semver), e[o].semver !== oe && e[o].semver.prerelease.length > 0) {
                                var i = e[o].semver;
                                if (i.major === t.major && i.minor === t.minor && i.patch === t.patch) return !0
                            }
                        return !1
                    }
                    return !0
                }

                function le(e, t, r) {
                    try {
                        t = new ie(t, r)
                    } catch (e) {
                        return !1
                    }
                    return t.test(e)
                }

                function ue(e, t, r, n) {
                    var o, i, s, a, c;
                    switch (e = new V(e, n), t = new ie(t, n), r) {
                        case ">":
                            o = X, i = te, s = Q, a = ">", c = ">=";
                            break;
                        case "<":
                            o = Q, i = ee, s = X, a = "<", c = "<=";
                            break;
                        default:
                            throw new TypeError('Must provide a hilo val of "<" or ">"')
                    }
                    if (le(e, t, n)) return !1;
                    for (var l = 0; l < t.set.length; ++l) {
                        var u = t.set[l],
                            d = null,
                            p = null;
                        if (u.forEach((function(e) {
                                e.semver === oe && (e = new ne(">=0.0.0")), d = d || e, p = p || e, o(e.semver, d.semver, n) ? d = e : s(e.semver, p.semver, n) && (p = e)
                            })), d.operator === a || d.operator === c) return !1;
                        if ((!p.operator || p.operator === a) && i(e, p.semver)) return !1;
                        if (p.operator === c && s(e, p.semver)) return !1
                    }
                    return !0
                }
                ne.prototype.parse = function(e) {
                    var t = this.options.loose ? o[F] : o[j],
                        r = e.match(t);
                    if (!r) throw new TypeError("Invalid comparator: " + e);
                    this.operator = r[1], "=" === this.operator && (this.operator = ""), r[2] ? this.semver = new V(r[2], this.options.loose) : this.semver = oe
                }, ne.prototype.toString = function() {
                    return this.value
                }, ne.prototype.test = function(e) {
                    return r("Comparator.test", e, this.options.loose), this.semver === oe || ("string" == typeof e && (e = new V(e, this.options)), re(e, this.operator, this.semver, this.options))
                }, ne.prototype.intersects = function(e, t) {
                    if (!(e instanceof ne)) throw new TypeError("a Comparator is required");
                    var r;
                    if (t && "object" == typeof t || (t = {
                            loose: !!t,
                            includePrerelease: !1
                        }), "" === this.operator) return r = new ie(e.value, t), le(this.value, r, t);
                    if ("" === e.operator) return r = new ie(this.value, t), le(e.semver, r, t);
                    var n = !(">=" !== this.operator && ">" !== this.operator || ">=" !== e.operator && ">" !== e.operator),
                        o = !("<=" !== this.operator && "<" !== this.operator || "<=" !== e.operator && "<" !== e.operator),
                        i = this.semver.version === e.semver.version,
                        s = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== e.operator && "<=" !== e.operator),
                        a = re(this.semver, "<", e.semver, t) && (">=" === this.operator || ">" === this.operator) && ("<=" === e.operator || "<" === e.operator),
                        c = re(this.semver, ">", e.semver, t) && ("<=" === this.operator || "<" === this.operator) && (">=" === e.operator || ">" === e.operator);
                    return n || o || i && s || a || c
                }, t.Range = ie, ie.prototype.format = function() {
                    return this.range = this.set.map((function(e) {
                        return e.join(" ").trim()
                    })).join("||").trim(), this.range
                }, ie.prototype.toString = function() {
                    return this.range
                }, ie.prototype.parseRange = function(e) {
                    var t = this.options.loose;
                    e = e.trim();
                    var n = t ? o[U] : o[q];
                    e = e.replace(n, ae), r("hyphen replace", e), e = e.replace(o[B], "$1$2$3"), r("comparator trim", e, o[B]), e = (e = (e = e.replace(o[O], "$1~")).replace(o[M], "$1^")).split(/\s+/).join(" ");
                    var i = t ? o[F] : o[j],
                        s = e.split(" ").map((function(e) {
                            return function(e, t) {
                                return r("comp", e, t), e = function(e, t) {
                                    return e.trim().split(/\s+/).map((function(e) {
                                        return function(e, t) {
                                            r("caret", e, t);
                                            var n = t.loose ? o[L] : o[D];
                                            return e.replace(n, (function(t, n, o, i, s) {
                                                var a;
                                                return r("caret", e, t, n, o, i, s), se(n) ? a = "" : se(o) ? a = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : se(i) ? a = "0" === n ? ">=" + n + "." + o + ".0 <" + n + "." + (+o + 1) + ".0" : ">=" + n + "." + o + ".0 <" + (+n + 1) + ".0.0" : s ? (r("replaceCaret pr", s), a = "0" === n ? "0" === o ? ">=" + n + "." + o + "." + i + "-" + s + " <" + n + "." + o + "." + (+i + 1) : ">=" + n + "." + o + "." + i + "-" + s + " <" + n + "." + (+o + 1) + ".0" : ">=" + n + "." + o + "." + i + "-" + s + " <" + (+n + 1) + ".0.0") : (r("no pr"), a = "0" === n ? "0" === o ? ">=" + n + "." + o + "." + i + " <" + n + "." + o + "." + (+i + 1) : ">=" + n + "." + o + "." + i + " <" + n + "." + (+o + 1) + ".0" : ">=" + n + "." + o + "." + i + " <" + (+n + 1) + ".0.0"), r("caret return", a), a
                                            }))
                                        }(e, t)
                                    })).join(" ")
                                }(e, t), r("caret", e), e = function(e, t) {
                                    return e.trim().split(/\s+/).map((function(e) {
                                        return function(e, t) {
                                            var n = t.loose ? o[R] : o[N];
                                            return e.replace(n, (function(t, n, o, i, s) {
                                                var a;
                                                return r("tilde", e, t, n, o, i, s), se(n) ? a = "" : se(o) ? a = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : se(i) ? a = ">=" + n + "." + o + ".0 <" + n + "." + (+o + 1) + ".0" : s ? (r("replaceTilde pr", s), a = ">=" + n + "." + o + "." + i + "-" + s + " <" + n + "." + (+o + 1) + ".0") : a = ">=" + n + "." + o + "." + i + " <" + n + "." + (+o + 1) + ".0", r("tilde return", a), a
                                            }))
                                        }(e, t)
                                    })).join(" ")
                                }(e, t), r("tildes", e), e = function(e, t) {
                                    return r("replaceXRanges", e, t), e.split(/\s+/).map((function(e) {
                                        return function(e, t) {
                                            e = e.trim();
                                            var n = t.loose ? o[I] : o[k];
                                            return e.replace(n, (function(t, n, o, i, s, a) {
                                                r("xRange", e, t, n, o, i, s, a);
                                                var c = se(o),
                                                    l = c || se(i),
                                                    u = l || se(s);
                                                return "=" === n && u && (n = ""), c ? t = ">" === n || "<" === n ? "<0.0.0" : "*" : n && u ? (l && (i = 0), s = 0, ">" === n ? (n = ">=", l ? (o = +o + 1, i = 0, s = 0) : (i = +i + 1, s = 0)) : "<=" === n && (n = "<", l ? o = +o + 1 : i = +i + 1), t = n + o + "." + i + "." + s) : l ? t = ">=" + o + ".0.0 <" + (+o + 1) + ".0.0" : u && (t = ">=" + o + "." + i + ".0 <" + o + "." + (+i + 1) + ".0"), r("xRange return", t), t
                                            }))
                                        }(e, t)
                                    })).join(" ")
                                }(e, t), r("xrange", e), e = function(e, t) {
                                    return r("replaceStars", e, t), e.trim().replace(o[H], "")
                                }(e, t), r("stars", e), e
                            }(e, this.options)
                        }), this).join(" ").split(/\s+/);
                    return this.options.loose && (s = s.filter((function(e) {
                        return !!e.match(i)
                    }))), s.map((function(e) {
                        return new ne(e, this.options)
                    }), this)
                }, ie.prototype.intersects = function(e, t) {
                    if (!(e instanceof ie)) throw new TypeError("a Range is required");
                    return this.set.some((function(r) {
                        return r.every((function(r) {
                            return e.set.some((function(e) {
                                return e.every((function(e) {
                                    return r.intersects(e, t)
                                }))
                            }))
                        }))
                    }))
                }, t.toComparators = function(e, t) {
                    return new ie(e, t).set.map((function(e) {
                        return e.map((function(e) {
                            return e.value
                        })).join(" ").trim().split(" ")
                    }))
                }, ie.prototype.test = function(e) {
                    if (!e) return !1;
                    "string" == typeof e && (e = new V(e, this.options));
                    for (var t = 0; t < this.set.length; t++)
                        if (ce(this.set[t], e, this.options)) return !0;
                    return !1
                }, t.satisfies = le, t.maxSatisfying = function(e, t, r) {
                    var n = null,
                        o = null;
                    try {
                        var i = new ie(t, r)
                    } catch (e) {
                        return null
                    }
                    return e.forEach((function(e) {
                        i.test(e) && (n && -1 !== o.compare(e) || (o = new V(n = e, r)))
                    })), n
                }, t.minSatisfying = function(e, t, r) {
                    var n = null,
                        o = null;
                    try {
                        var i = new ie(t, r)
                    } catch (e) {
                        return null
                    }
                    return e.forEach((function(e) {
                        i.test(e) && (n && 1 !== o.compare(e) || (o = new V(n = e, r)))
                    })), n
                }, t.minVersion = function(e, t) {
                    e = new ie(e, t);
                    var r = new V("0.0.0");
                    if (e.test(r)) return r;
                    if (r = new V("0.0.0-0"), e.test(r)) return r;
                    r = null;
                    for (var n = 0; n < e.set.length; ++n) e.set[n].forEach((function(e) {
                        var t = new V(e.semver.version);
                        switch (e.operator) {
                            case ">":
                                0 === t.prerelease.length ? t.patch++ : t.prerelease.push(0), t.raw = t.format();
                            case "":
                            case ">=":
                                r && !X(r, t) || (r = t);
                                break;
                            case "<":
                            case "<=":
                                break;
                            default:
                                throw new Error("Unexpected operation: " + e.operator)
                        }
                    }));
                    return r && e.test(r) ? r : null
                }, t.validRange = function(e, t) {
                    try {
                        return new ie(e, t).range || "*"
                    } catch (e) {
                        return null
                    }
                }, t.ltr = function(e, t, r) {
                    return ue(e, t, "<", r)
                }, t.gtr = function(e, t, r) {
                    return ue(e, t, ">", r)
                }, t.outside = ue, t.prerelease = function(e, t) {
                    var r = z(e, t);
                    return r && r.prerelease.length ? r.prerelease : null
                }, t.intersects = function(e, t, r) {
                    return e = new ie(e, r), t = new ie(t, r), e.intersects(t)
                }, t.coerce = function(e) {
                    if (e instanceof V) return e;
                    if ("string" != typeof e) return null;
                    var t = e.match(o[P]);
                    return null == t ? null : z(t[1] + "." + (t[2] || "0") + "." + (t[3] || "0"))
                }
            },
            9867: (e, t, r) => {
                "use strict";
                var n = r(6372),
                    o = n.wrap,
                    i = n.unwrap,
                    s = "wrap@before";

                function a(e, t, r) {
                    var n = !!e[t] && e.propertyIsEnumerable(t);
                    Object.defineProperty(e, t, {
                        configurable: !0,
                        enumerable: n,
                        writable: !0,
                        value: r
                    })
                }

                function c(e, t) {
                    var r;
                    return r = e._events && e._events[t], Array.isArray(r) || (r = r ? [r] : []), r
                }

                function l(e, t) {
                    if (e) {
                        var r = e;
                        if ("function" == typeof e) r = t(e);
                        else if (Array.isArray(e)) {
                            r = [];
                            for (var n = 0; n < e.length; n++) r[n] = t(e[n])
                        }
                        return r
                    }
                }
                e.exports = function(e, t, r) {
                    if (!(e && e.on && e.addListener && e.removeListener && e.emit)) throw new Error("can only wrap real EEs");
                    if (!t) throw new Error("must have function to run on listener addition");
                    if (!r) throw new Error("must have function to wrap listeners when emitting");

                    function n(e) {
                        return function(t, r) {
                            var i = c(this, t).slice();
                            try {
                                var a = e.call(this, t, r);
                                return function(e, t, r) {
                                    var n = c(e, t).filter((function(e) {
                                        return -1 === r.indexOf(e)
                                    }));
                                    n.length > 0 && function(e, t) {
                                        for (var r = t.length, n = 0; n < r; n++) {
                                            var o = t[n],
                                                i = e[s];
                                            if ("function" == typeof i) i(o);
                                            else if (Array.isArray(i))
                                                for (var a = i.length, c = 0; c < a; c++) i[c](o)
                                        }
                                    }(e, n)
                                }(this, t, i), a
                            } finally {
                                this.on.__wrapped || o(this, "on", n), this.addListener.__wrapped || o(this, "addListener", n)
                            }
                        }
                    }
                    e[s] ? "function" == typeof e[s] ? a(e, s, [e[s], t]) : Array.isArray(e[s]) && e[s].push(t) : a(e, s, t), e.__wrapped || (o(e, "addListener", n), o(e, "on", n), o(e, "emit", (function(e) {
                        return function(t) {
                            if (!this._events || !this._events[t]) return e.apply(this, arguments);
                            var n = this._events[t];

                            function s(e) {
                                return function() {
                                    this._events[t] = n;
                                    try {
                                        return e.apply(this, arguments)
                                    } finally {
                                        n = this._events[t], this._events[t] = l(n, r)
                                    }
                                }
                            }
                            o(this, "removeListener", s);
                            try {
                                return this._events[t] = l(n, r), e.apply(this, arguments)
                            } finally {
                                i(this, "removeListener"), this._events[t] = n
                            }
                        }
                    })), a(e, "__unwrap", (function() {
                        i(e, "addListener"), i(e, "on"), i(e, "emit"), delete e[s], delete e.__wrapped
                    })), a(e, "__wrapped", !0))
                }
            },
            4063: e => {
                "use strict";
                e.exports = function e(t, r) {
                    if (t === r) return !0;
                    if (t && r && "object" == typeof t && "object" == typeof r) {
                        if (t.constructor !== r.constructor) return !1;
                        var n, o, i;
                        if (Array.isArray(t)) {
                            if ((n = t.length) != r.length) return !1;
                            for (o = n; 0 != o--;)
                                if (!e(t[o], r[o])) return !1;
                            return !0
                        }
                        if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags;
                        if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf();
                        if (t.toString !== Object.prototype.toString) return t.toString() === r.toString();
                        if ((n = (i = Object.keys(t)).length) !== Object.keys(r).length) return !1;
                        for (o = n; 0 != o--;)
                            if (!Object.prototype.hasOwnProperty.call(r, i[o])) return !1;
                        for (o = n; 0 != o--;) {
                            var s = i[o];
                            if (!e(t[s], r[s])) return !1
                        }
                        return !0
                    }
                    return t != t && r != r
                }
            },
            6560: e => {
                "use strict";
                e.exports = (e, t) => {
                    t = t || process.argv;
                    const r = e.startsWith("-") ? "" : 1 === e.length ? "-" : "--",
                        n = t.indexOf(r + e),
                        o = t.indexOf("--");
                    return -1 !== n && (-1 === o || n < o)
                }
            },
            6214: e => {
                "use strict";
                const t = new Set([200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501]),
                    r = new Set([200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501]),
                    n = new Set([500, 502, 503, 504]),
                    o = {
                        date: !0,
                        connection: !0,
                        "keep-alive": !0,
                        "proxy-authenticate": !0,
                        "proxy-authorization": !0,
                        te: !0,
                        trailer: !0,
                        "transfer-encoding": !0,
                        upgrade: !0
                    },
                    i = {
                        "content-length": !0,
                        "content-encoding": !0,
                        "transfer-encoding": !0,
                        "content-range": !0
                    };

                function s(e) {
                    const t = parseInt(e, 10);
                    return isFinite(t) ? t : 0
                }

                function a(e) {
                    const t = {};
                    if (!e) return t;
                    const r = e.trim().split(/\s*,\s*/);
                    for (const e of r) {
                        const [r, n] = e.split(/\s*=\s*/, 2);
                        t[r] = void 0 === n || n.replace(/^"|"$/g, "")
                    }
                    return t
                }

                function c(e) {
                    let t = [];
                    for (const r in e) {
                        const n = e[r];
                        t.push(!0 === n ? r : r + "=" + n)
                    }
                    if (t.length) return t.join(", ")
                }
                e.exports = class {
                    constructor(e, t, {
                        shared: r,
                        cacheHeuristic: n,
                        immutableMinTimeToLive: o,
                        ignoreCargoCult: i,
                        _fromObject: s
                    } = {}) {
                        if (s) this._fromObject(s);
                        else {
                            if (!t || !t.headers) throw Error("Response headers missing");
                            this._assertRequestHasHeaders(e), this._responseTime = this.now(), this._isShared = !1 !== r, this._cacheHeuristic = void 0 !== n ? n : .1, this._immutableMinTtl = void 0 !== o ? o : 864e5, this._status = "status" in t ? t.status : 200, this._resHeaders = t.headers, this._rescc = a(t.headers["cache-control"]), this._method = "method" in e ? e.method : "GET", this._url = e.url, this._host = e.headers.host, this._noAuthorization = !e.headers.authorization, this._reqHeaders = t.headers.vary ? e.headers : null, this._reqcc = a(e.headers["cache-control"]), i && "pre-check" in this._rescc && "post-check" in this._rescc && (delete this._rescc["pre-check"], delete this._rescc["post-check"], delete this._rescc["no-cache"], delete this._rescc["no-store"], delete this._rescc["must-revalidate"], this._resHeaders = Object.assign({}, this._resHeaders, {
                                "cache-control": c(this._rescc)
                            }), delete this._resHeaders.expires, delete this._resHeaders.pragma), null == t.headers["cache-control"] && /no-cache/.test(t.headers.pragma) && (this._rescc["no-cache"] = !0)
                        }
                    }
                    now() {
                        return Date.now()
                    }
                    storable() {
                        return !(this._reqcc["no-store"] || !("GET" === this._method || "HEAD" === this._method || "POST" === this._method && this._hasExplicitExpiration()) || !r.has(this._status) || this._rescc["no-store"] || this._isShared && this._rescc.private || this._isShared && !this._noAuthorization && !this._allowsStoringAuthenticated() || !(this._resHeaders.expires || this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || t.has(this._status)))
                    }
                    _hasExplicitExpiration() {
                        return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires
                    }
                    _assertRequestHasHeaders(e) {
                        if (!e || !e.headers) throw Error("Request headers missing")
                    }
                    satisfiesWithoutRevalidation(e) {
                        this._assertRequestHasHeaders(e);
                        const t = a(e.headers["cache-control"]);
                        return !t["no-cache"] && !/no-cache/.test(e.headers.pragma) && (!(t["max-age"] && this.age() > t["max-age"]) && (!(t["min-fresh"] && this.timeToLive() < 1e3 * t["min-fresh"]) && (!(this.stale() && (!t["max-stale"] || this._rescc["must-revalidate"] || !(!0 === t["max-stale"] || t["max-stale"] > this.age() - this.maxAge()))) && this._requestMatches(e, !1))))
                    }
                    _requestMatches(e, t) {
                        return (!this._url || this._url === e.url) && this._host === e.headers.host && (!e.method || this._method === e.method || t && "HEAD" === e.method) && this._varyMatches(e)
                    }
                    _allowsStoringAuthenticated() {
                        return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"]
                    }
                    _varyMatches(e) {
                        if (!this._resHeaders.vary) return !0;
                        if ("*" === this._resHeaders.vary) return !1;
                        const t = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
                        for (const r of t)
                            if (e.headers[r] !== this._reqHeaders[r]) return !1;
                        return !0
                    }
                    _copyWithoutHopByHopHeaders(e) {
                        const t = {};
                        for (const r in e) o[r] || (t[r] = e[r]);
                        if (e.connection) {
                            const r = e.connection.trim().split(/\s*,\s*/);
                            for (const e of r) delete t[e]
                        }
                        if (t.warning) {
                            const e = t.warning.split(/,/).filter((e => !/^\s*1[0-9][0-9]/.test(e)));
                            e.length ? t.warning = e.join(",").trim() : delete t.warning
                        }
                        return t
                    }
                    responseHeaders() {
                        const e = this._copyWithoutHopByHopHeaders(this._resHeaders),
                            t = this.age();
                        return t > 86400 && !this._hasExplicitExpiration() && this.maxAge() > 86400 && (e.warning = (e.warning ? `${e.warning}, ` : "") + '113 - "rfc7234 5.5.4"'), e.age = `${Math.round(t)}`, e.date = new Date(this.now()).toUTCString(), e
                    }
                    date() {
                        const e = Date.parse(this._resHeaders.date);
                        return isFinite(e) ? e : this._responseTime
                    }
                    age() {
                        return this._ageValue() + (this.now() - this._responseTime) / 1e3
                    }
                    _ageValue() {
                        return s(this._resHeaders.age)
                    }
                    maxAge() {
                        if (!this.storable() || this._rescc["no-cache"]) return 0;
                        if (this._isShared && this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable) return 0;
                        if ("*" === this._resHeaders.vary) return 0;
                        if (this._isShared) {
                            if (this._rescc["proxy-revalidate"]) return 0;
                            if (this._rescc["s-maxage"]) return s(this._rescc["s-maxage"])
                        }
                        if (this._rescc["max-age"]) return s(this._rescc["max-age"]);
                        const e = this._rescc.immutable ? this._immutableMinTtl : 0,
                            t = this.date();
                        if (this._resHeaders.expires) {
                            const r = Date.parse(this._resHeaders.expires);
                            return Number.isNaN(r) || r < t ? 0 : Math.max(e, (r - t) / 1e3)
                        }
                        if (this._resHeaders["last-modified"]) {
                            const r = Date.parse(this._resHeaders["last-modified"]);
                            if (isFinite(r) && t > r) return Math.max(e, (t - r) / 1e3 * this._cacheHeuristic)
                        }
                        return e
                    }
                    timeToLive() {
                        const e = this.maxAge() - this.age(),
                            t = e + s(this._rescc["stale-if-error"]),
                            r = e + s(this._rescc["stale-while-revalidate"]);
                        return 1e3 * Math.max(0, e, t, r)
                    }
                    stale() {
                        return this.maxAge() <= this.age()
                    }
                    _useStaleIfError() {
                        return this.maxAge() + s(this._rescc["stale-if-error"]) > this.age()
                    }
                    useStaleWhileRevalidate() {
                        return this.maxAge() + s(this._rescc["stale-while-revalidate"]) > this.age()
                    }
                    static fromObject(e) {
                        return new this(void 0, void 0, {
                            _fromObject: e
                        })
                    }
                    _fromObject(e) {
                        if (this._responseTime) throw Error("Reinitialized");
                        if (!e || 1 !== e.v) throw Error("Invalid serialization");
                        this._responseTime = e.t, this._isShared = e.sh, this._cacheHeuristic = e.ch, this._immutableMinTtl = void 0 !== e.imm ? e.imm : 864e5, this._status = e.st, this._resHeaders = e.resh, this._rescc = e.rescc, this._method = e.m, this._url = e.u, this._host = e.h, this._noAuthorization = e.a, this._reqHeaders = e.reqh, this._reqcc = e.reqcc
                    }
                    toObject() {
                        return {
                            v: 1,
                            t: this._responseTime,
                            sh: this._isShared,
                            ch: this._cacheHeuristic,
                            imm: this._immutableMinTtl,
                            st: this._status,
                            resh: this._resHeaders,
                            rescc: this._rescc,
                            m: this._method,
                            u: this._url,
                            h: this._host,
                            a: this._noAuthorization,
                            reqh: this._reqHeaders,
                            reqcc: this._reqcc
                        }
                    }
                    revalidationHeaders(e) {
                        this._assertRequestHasHeaders(e);
                        const t = this._copyWithoutHopByHopHeaders(e.headers);
                        if (delete t["if-range"], !this._requestMatches(e, !0) || !this.storable()) return delete t["if-none-match"], delete t["if-modified-since"], t;
                        if (this._resHeaders.etag && (t["if-none-match"] = t["if-none-match"] ? `${t["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag), t["accept-ranges"] || t["if-match"] || t["if-unmodified-since"] || this._method && "GET" != this._method) {
                            if (delete t["if-modified-since"], t["if-none-match"]) {
                                const e = t["if-none-match"].split(/,/).filter((e => !/^\s*W\//.test(e)));
                                e.length ? t["if-none-match"] = e.join(",").trim() : delete t["if-none-match"]
                            }
                        } else this._resHeaders["last-modified"] && !t["if-modified-since"] && (t["if-modified-since"] = this._resHeaders["last-modified"]);
                        return t
                    }
                    revalidatedPolicy(e, t) {
                        if (this._assertRequestHasHeaders(e), this._useStaleIfError() && function(e) {
                                return !e || n.has(e.status)
                            }(t)) return {
                            modified: !1,
                            matches: !1,
                            policy: this
                        };
                        if (!t || !t.headers) throw Error("Response headers missing");
                        let r = !1;
                        if (void 0 !== t.status && 304 != t.status ? r = !1 : t.headers.etag && !/^\s*W\//.test(t.headers.etag) ? r = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === t.headers.etag : this._resHeaders.etag && t.headers.etag ? r = this._resHeaders.etag.replace(/^\s*W\//, "") === t.headers.etag.replace(/^\s*W\//, "") : this._resHeaders["last-modified"] ? r = this._resHeaders["last-modified"] === t.headers["last-modified"] : this._resHeaders.etag || this._resHeaders["last-modified"] || t.headers.etag || t.headers["last-modified"] || (r = !0), !r) return {
                            policy: new this.constructor(e, t),
                            modified: 304 != t.status,
                            matches: !1
                        };
                        const o = {};
                        for (const e in this._resHeaders) o[e] = e in t.headers && !i[e] ? t.headers[e] : this._resHeaders[e];
                        const s = Object.assign({}, t, {
                            status: this._status,
                            method: this._method,
                            headers: o
                        });
                        return {
                            policy: new this.constructor(e, s, {
                                shared: this._isShared,
                                cacheHeuristic: this._cacheHeuristic,
                                immutableMinTimeToLive: this._immutableMinTtl
                            }),
                            modified: !1,
                            matches: !0
                        }
                    }
                }
            },
            1595: (e, t, r) => {
                "use strict";
                const n = r(7147);
                let o;
                e.exports = () => (void 0 === o && (o = function() {
                    try {
                        return n.statSync("/.dockerenv"), !0
                    } catch (e) {
                        return !1
                    }
                }() || function() {
                    try {
                        return n.readFileSync("/proc/self/cgroup", "utf8").includes("docker")
                    } catch (e) {
                        return !1
                    }
                }()), o)
            },
            2818: (e, t, r) => {
                "use strict";
                const n = r(2037),
                    o = r(7147),
                    i = r(1595),
                    s = () => {
                        if ("linux" !== process.platform) return !1;
                        if (n.release().toLowerCase().includes("microsoft")) return !i();
                        try {
                            return !!o.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") && !i()
                        } catch (e) {
                            return !1
                        }
                    };
                process.env.__IS_WSL_TEST__ ? e.exports = s : e.exports = s()
            },
            9461: e => {
                "use strict";
                var t = e.exports = function(e, t, n) {
                    "function" == typeof t && (n = t, t = {}), r(t, "function" == typeof(n = t.cb || n) ? n : n.pre || function() {}, n.post || function() {}, e, "", e)
                };

                function r(e, n, o, i, s, a, c, l, u, d) {
                    if (i && "object" == typeof i && !Array.isArray(i)) {
                        for (var p in n(i, s, a, c, l, u, d), i) {
                            var h = i[p];
                            if (Array.isArray(h)) {
                                if (p in t.arrayKeywords)
                                    for (var f = 0; f < h.length; f++) r(e, n, o, h[f], s + "/" + p + "/" + f, a, s, p, i, f)
                            } else if (p in t.propsKeywords) {
                                if (h && "object" == typeof h)
                                    for (var m in h) r(e, n, o, h[m], s + "/" + p + "/" + m.replace(/~/g, "~0").replace(/\//g, "~1"), a, s, p, i, m)
                            } else(p in t.keywords || e.allKeys && !(p in t.skipKeywords)) && r(e, n, o, h, s + "/" + p, a, s, p, i)
                        }
                        o(i, s, a, c, l, u, d)
                    }
                }
                t.keywords = {
                    additionalItems: !0,
                    items: !0,
                    contains: !0,
                    additionalProperties: !0,
                    propertyNames: !0,
                    not: !0,
                    if: !0,
                    then: !0,
                    else: !0
                }, t.arrayKeywords = {
                    items: !0,
                    allOf: !0,
                    anyOf: !0,
                    oneOf: !0
                }, t.propsKeywords = {
                    $defs: !0,
                    definitions: !0,
                    properties: !0,
                    patternProperties: !0,
                    dependencies: !0
                }, t.skipKeywords = {
                    default: !0,
                    enum: !0,
                    const: !0,
                    required: !0,
                    maximum: !0,
                    minimum: !0,
                    exclusiveMaximum: !0,
                    exclusiveMinimum: !0,
                    multipleOf: !0,
                    maxLength: !0,
                    minLength: !0,
                    pattern: !0,
                    format: !0,
                    maxItems: !0,
                    minItems: !0,
                    uniqueItems: !0,
                    maxProperties: !0,
                    minProperties: !0
                }
            },
            9593: (e, t, r) => {
                "use strict";
                const n = r(4411),
                    o = Symbol("max"),
                    i = Symbol("length"),
                    s = Symbol("lengthCalculator"),
                    a = Symbol("allowStale"),
                    c = Symbol("maxAge"),
                    l = Symbol("dispose"),
                    u = Symbol("noDisposeOnSet"),
                    d = Symbol("lruList"),
                    p = Symbol("cache"),
                    h = Symbol("updateAgeOnGet"),
                    f = () => 1,
                    m = (e, t, r) => {
                        const n = e[p].get(t);
                        if (n) {
                            const t = n.value;
                            if (g(e, t)) {
                                if (y(e, n), !e[a]) return
                            } else r && (e[h] && (n.value.now = Date.now()), e[d].unshiftNode(n));
                            return t.value
                        }
                    },
                    g = (e, t) => {
                        if (!t || !t.maxAge && !e[c]) return !1;
                        const r = Date.now() - t.now;
                        return t.maxAge ? r > t.maxAge : e[c] && r > e[c]
                    },
                    _ = e => {
                        if (e[i] > e[o])
                            for (let t = e[d].tail; e[i] > e[o] && null !== t;) {
                                const r = t.prev;
                                y(e, t), t = r
                            }
                    },
                    y = (e, t) => {
                        if (t) {
                            const r = t.value;
                            e[l] && e[l](r.key, r.value), e[i] -= r.length, e[p].delete(r.key), e[d].removeNode(t)
                        }
                    };
                class v {
                    constructor(e, t, r, n, o) {
                        this.key = e, this.value = t, this.length = r, this.now = n, this.maxAge = o || 0
                    }
                }
                const b = (e, t, r, n) => {
                    let o = r.value;
                    g(e, o) && (y(e, r), e[a] || (o = void 0)), o && t.call(n, o.value, o.key, e)
                };
                e.exports = class {
                    constructor(e) {
                        if ("number" == typeof e && (e = {
                                max: e
                            }), e || (e = {}), e.max && ("number" != typeof e.max || e.max < 0)) throw new TypeError("max must be a non-negative number");
                        this[o] = e.max || 1 / 0;
                        const t = e.length || f;
                        if (this[s] = "function" != typeof t ? f : t, this[a] = e.stale || !1, e.maxAge && "number" != typeof e.maxAge) throw new TypeError("maxAge must be a number");
                        this[c] = e.maxAge || 0, this[l] = e.dispose, this[u] = e.noDisposeOnSet || !1, this[h] = e.updateAgeOnGet || !1, this.reset()
                    }
                    set max(e) {
                        if ("number" != typeof e || e < 0) throw new TypeError("max must be a non-negative number");
                        this[o] = e || 1 / 0, _(this)
                    }
                    get max() {
                        return this[o]
                    }
                    set allowStale(e) {
                        this[a] = !!e
                    }
                    get allowStale() {
                        return this[a]
                    }
                    set maxAge(e) {
                        if ("number" != typeof e) throw new TypeError("maxAge must be a non-negative number");
                        this[c] = e, _(this)
                    }
                    get maxAge() {
                        return this[c]
                    }
                    set lengthCalculator(e) {
                        "function" != typeof e && (e = f), e !== this[s] && (this[s] = e, this[i] = 0, this[d].forEach((e => {
                            e.length = this[s](e.value, e.key), this[i] += e.length
                        }))), _(this)
                    }
                    get lengthCalculator() {
                        return this[s]
                    }
                    get length() {
                        return this[i]
                    }
                    get itemCount() {
                        return this[d].length
                    }
                    rforEach(e, t) {
                        t = t || this;
                        for (let r = this[d].tail; null !== r;) {
                            const n = r.prev;
                            b(this, e, r, t), r = n
                        }
                    }
                    forEach(e, t) {
                        t = t || this;
                        for (let r = this[d].head; null !== r;) {
                            const n = r.next;
                            b(this, e, r, t), r = n
                        }
                    }
                    keys() {
                        return this[d].toArray().map((e => e.key))
                    }
                    values() {
                        return this[d].toArray().map((e => e.value))
                    }
                    reset() {
                        this[l] && this[d] && this[d].length && this[d].forEach((e => this[l](e.key, e.value))), this[p] = new Map, this[d] = new n, this[i] = 0
                    }
                    dump() {
                        return this[d].map((e => !g(this, e) && {
                            k: e.key,
                            v: e.value,
                            e: e.now + (e.maxAge || 0)
                        })).toArray().filter((e => e))
                    }
                    dumpLru() {
                        return this[d]
                    }
                    set(e, t, r) {
                        if ((r = r || this[c]) && "number" != typeof r) throw new TypeError("maxAge must be a number");
                        const n = r ? Date.now() : 0,
                            a = this[s](t, e);
                        if (this[p].has(e)) {
                            if (a > this[o]) return y(this, this[p].get(e)), !1;
                            const s = this[p].get(e).value;
                            return this[l] && (this[u] || this[l](e, s.value)), s.now = n, s.maxAge = r, s.value = t, this[i] += a - s.length, s.length = a, this.get(e), _(this), !0
                        }
                        const h = new v(e, t, a, n, r);
                        return h.length > this[o] ? (this[l] && this[l](e, t), !1) : (this[i] += h.length, this[d].unshift(h), this[p].set(e, this[d].head), _(this), !0)
                    }
                    has(e) {
                        if (!this[p].has(e)) return !1;
                        const t = this[p].get(e).value;
                        return !g(this, t)
                    }
                    get(e) {
                        return m(this, e, !0)
                    }
                    peek(e) {
                        return m(this, e, !1)
                    }
                    pop() {
                        const e = this[d].tail;
                        return e ? (y(this, e), e.value) : null
                    }
                    del(e) {
                        y(this, this[p].get(e))
                    }
                    load(e) {
                        this.reset();
                        const t = Date.now();
                        for (let r = e.length - 1; r >= 0; r--) {
                            const n = e[r],
                                o = n.e || 0;
                            if (0 === o) this.set(n.k, n.v);
                            else {
                                const e = o - t;
                                e > 0 && this.set(n.k, n.v, e)
                            }
                        }
                    }
                    prune() {
                        this[p].forEach(((e, t) => m(this, t, !1)))
                    }
                }
            },
            7824: e => {
                var t = 1e3,
                    r = 60 * t,
                    n = 60 * r,
                    o = 24 * n;

                function i(e, t, r, n) {
                    var o = t >= 1.5 * r;
                    return Math.round(e / r) + " " + n + (o ? "s" : "")
                }
                e.exports = function(e, s) {
                    s = s || {};
                    var a, c, l = typeof e;
                    if ("string" === l && e.length > 0) return function(e) {
                        if (!((e = String(e)).length > 100)) {
                            var i = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
                            if (i) {
                                var s = parseFloat(i[1]);
                                switch ((i[2] || "ms").toLowerCase()) {
                                    case "years":
                                    case "year":
                                    case "yrs":
                                    case "yr":
                                    case "y":
                                        return 315576e5 * s;
                                    case "weeks":
                                    case "week":
                                    case "w":
                                        return 6048e5 * s;
                                    case "days":
                                    case "day":
                                    case "d":
                                        return s * o;
                                    case "hours":
                                    case "hour":
                                    case "hrs":
                                    case "hr":
                                    case "h":
                                        return s * n;
                                    case "minutes":
                                    case "minute":
                                    case "mins":
                                    case "min":
                                    case "m":
                                        return s * r;
                                    case "seconds":
                                    case "second":
                                    case "secs":
                                    case "sec":
                                    case "s":
                                        return s * t;
                                    case "milliseconds":
                                    case "millisecond":
                                    case "msecs":
                                    case "msec":
                                    case "ms":
                                        return s;
                                    default:
                                        return
                                }
                            }
                        }
                    }(e);
                    if ("number" === l && isFinite(e)) return s.long ? (a = e, (c = Math.abs(a)) >= o ? i(a, c, o, "day") : c >= n ? i(a, c, n, "hour") : c >= r ? i(a, c, r, "minute") : c >= t ? i(a, c, t, "second") : a + " ms") : function(e) {
                        var i = Math.abs(e);
                        return i >= o ? Math.round(e / o) + "d" : i >= n ? Math.round(e / n) + "h" : i >= r ? Math.round(e / r) + "m" : i >= t ? Math.round(e / t) + "s" : e + "ms"
                    }(e);
                    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e))
                }
            },
            8318: (e, t, r) => {
                const n = r(1017),
                    o = r(2081),
                    {
                        promises: i,
                        constants: s
                    } = r(7147),
                    a = r(2818),
                    c = r(1595),
                    l = r(1906),
                    u = n.join(__dirname, "xdg-open"),
                    {
                        platform: d,
                        arch: p
                    } = process,
                    h = (() => {
                        const e = "/mnt/";
                        let t;
                        return async function() {
                            if (t) return t;
                            const r = "/etc/wsl.conf";
                            let n = !1;
                            try {
                                await i.access(r, s.F_OK), n = !0
                            } catch {}
                            if (!n) return e;
                            const o = await i.readFile(r, {
                                    encoding: "utf8"
                                }),
                                a = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(o);
                            return a ? (t = a.groups.mountPoint.trim(), t = t.endsWith("/") ? t : `${t}/`, t) : e
                        }
                    })(),
                    f = async (e, t) => {
                        let r;
                        for (const n of e) try {
                            return await t(n)
                        } catch (e) {
                            r = e
                        }
                        throw r
                    },
                    m = async e => {
                        if (e = {
                                wait: !1,
                                background: !1,
                                newInstance: !1,
                                allowNonzeroExitCode: !1,
                                ...e
                            }, Array.isArray(e.app)) return f(e.app, (t => m({ ...e,
                            app: t
                        })));
                        let t, {
                            name: r,
                            arguments: n = []
                        } = e.app || {};
                        if (n = [...n], Array.isArray(r)) return f(r, (t => m({ ...e,
                            app: {
                                name: t,
                                arguments: n
                            }
                        })));
                        const l = [],
                            p = {};
                        if ("darwin" === d) t = "open", e.wait && l.push("--wait-apps"), e.background && l.push("--background"), e.newInstance && l.push("--new"), r && l.push("-a", r);
                        else if ("win32" === d || a && !c()) {
                            const o = await h();
                            t = a ? `${o}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`, l.push("-NoProfile", "-NonInteractive", "ExecutionPolicy", "Bypass", "-EncodedCommand"), a || (p.windowsVerbatimArguments = !0);
                            const i = ["Start"];
                            e.wait && i.push("-Wait"), r ? (i.push(`"\`"${r}\`""`, "-ArgumentList"), e.target && n.unshift(e.target)) : e.target && i.push(`"${e.target}"`), n.length > 0 && (n = n.map((e => `"\`"${e}\`""`)), i.push(n.join(","))), e.target = Buffer.from(i.join(" "), "utf16le").toString("base64")
                        } else {
                            if (r) t = r;
                            else {
                                const e = "/" === __dirname;
                                let r = !1;
                                try {
                                    await i.access(u, s.X_OK), r = !0
                                } catch {}
                                t = process.versions.electron || "android" === d || e || !r ? "xdg-open" : u
                            }
                            n.length > 0 && l.push(...n), e.wait || (p.stdio = "ignore", p.detached = !0)
                        }
                        e.target && l.push(e.target), "darwin" === d && n.length > 0 && l.push("--args", ...n);
                        const g = o.spawn(t, l, p);
                        return e.wait ? new Promise(((t, r) => {
                            g.once("error", r), g.once("close", (n => {
                                e.allowNonzeroExitCode && n > 0 ? r(new Error(`Exited with code ${n}`)) : t(g)
                            }))
                        })) : (g.unref(), g)
                    },
                    g = (e, t) => {
                        if ("string" != typeof e) throw new TypeError("Expected a `target`");
                        return m({ ...t,
                            target: e
                        })
                    };

                function _(e) {
                    if ("string" == typeof e || Array.isArray(e)) return e;
                    const {
                        [p]: t
                    } = e;
                    if (!t) throw new Error(`${p} is not supported`);
                    return t
                }

                function y({
                    [d]: e
                }, {
                    wsl: t
                }) {
                    if (t && a) return _(t);
                    if (!e) throw new Error(`${d} is not supported`);
                    return _(e)
                }
                const v = {};
                l(v, "chrome", (() => y({
                    darwin: "google chrome",
                    win32: "chrome",
                    linux: ["google-chrome", "google-chrome-stable", "chromium"]
                }, {
                    wsl: {
                        ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
                        x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
                    }
                }))), l(v, "firefox", (() => y({
                    darwin: "firefox",
                    win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
                    linux: "firefox"
                }, {
                    wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
                }))), l(v, "edge", (() => y({
                    darwin: "microsoft edge",
                    win32: "msedge",
                    linux: ["microsoft-edge", "microsoft-edge-dev"]
                }, {
                    wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
                }))), g.apps = v, g.openApp = (e, t) => {
                    if ("string" != typeof e) throw new TypeError("Expected a `name`");
                    const {
                        arguments: r = []
                    } = t || {};
                    if (null != r && !Array.isArray(r)) throw new TypeError("Expected `appArguments` as Array type");
                    return m({ ...t,
                        app: {
                            name: e,
                            arguments: r
                        }
                    })
                }, e.exports = g
            },
            6372: e => {
                "use strict";

                function t(e) {
                    return "function" == typeof e
                }
                var r = console.error.bind(console);

                function n(e, t, r) {
                    var n = !!e[t] && e.propertyIsEnumerable(t);
                    Object.defineProperty(e, t, {
                        configurable: !0,
                        enumerable: n,
                        writable: !0,
                        value: r
                    })
                }

                function o(e) {
                    e && e.logger && (t(e.logger) ? r = e.logger : r("new logger isn't a function, not replacing"))
                }

                function i(e, o, i) {
                    if (e && e[o]) {
                        if (!i) return r("no wrapper function"), void r((new Error).stack);
                        if (t(e[o]) && t(i)) {
                            var s = e[o],
                                a = i(s, o);
                            return n(a, "__original", s), n(a, "__unwrap", (function() {
                                e[o] === a && n(e, o, s)
                            })), n(a, "__wrapped", !0), n(e, o, a), a
                        }
                        r("original object and wrapper must be functions")
                    } else r("no original function " + o + " to wrap")
                }

                function s(e, t) {
                    return e && e[t] ? e[t].__unwrap ? e[t].__unwrap() : void r("no original to unwrap to -- has " + t + " already been unwrapped?") : (r("no function to unwrap."), void r((new Error).stack))
                }
                o.wrap = i, o.massWrap = function(e, t, n) {
                    if (!e) return r("must provide one or more modules to patch"), void r((new Error).stack);
                    Array.isArray(e) || (e = [e]), t && Array.isArray(t) ? e.forEach((function(e) {
                        t.forEach((function(t) {
                            i(e, t, n)
                        }))
                    })) : r("must provide one or more functions to wrap on modules")
                }, o.unwrap = s, o.massUnwrap = function(e, t) {
                    if (!e) return r("must provide one or more modules to patch"), void r((new Error).stack);
                    Array.isArray(e) || (e = [e]), t && Array.isArray(t) ? e.forEach((function(e) {
                        t.forEach((function(t) {
                            s(e, t)
                        }))
                    })) : r("must provide one or more functions to unwrap on modules")
                }, e.exports = o
            },
            406: (e, t, r) => {
                r(6252).install()
            },
            6252: (e, t, r) => {
                e = r.nmd(e);
                var n, o = r(9125).SourceMapConsumer,
                    i = r(1017);
                try {
                    (n = r(7147)).existsSync && n.readFileSync || (n = null)
                } catch (e) {}
                var s = r(5420);

                function a(e, t) {
                    return e.require(t)
                }
                var c = !1,
                    l = !1,
                    u = !1,
                    d = "auto",
                    p = {},
                    h = {},
                    f = /^data:application\/json[^,]+base64,/,
                    m = [],
                    g = [];

                function _() {
                    return "browser" === d || "node" !== d && "undefined" != typeof window && "function" == typeof XMLHttpRequest && !(window.require && window.module && window.process && "renderer" === window.process.type)
                }

                function y(e) {
                    return function(t) {
                        for (var r = 0; r < e.length; r++) {
                            var n = e[r](t);
                            if (n) return n
                        }
                        return null
                    }
                }
                var v = y(m);

                function b(e, t) {
                    if (!e) return t;
                    var r = i.dirname(e),
                        n = /^\w+:\/\/[^\/]*/.exec(r),
                        o = n ? n[0] : "",
                        s = r.slice(o.length);
                    return o && /^\/\w\:/.test(s) ? (o += "/") + i.resolve(r.slice(o.length), t).replace(/\\/g, "/") : o + i.resolve(r.slice(o.length), t)
                }
                m.push((function(e) {
                    if (e = e.trim(), /^file:/.test(e) && (e = e.replace(/file:\/\/\/(\w:)?/, (function(e, t) {
                            return t ? "" : "/"
                        }))), e in p) return p[e];
                    var t = "";
                    try {
                        if (n) n.existsSync(e) && (t = n.readFileSync(e, "utf8"));
                        else {
                            var r = new XMLHttpRequest;
                            r.open("GET", e, !1), r.send(null), 4 === r.readyState && 200 === r.status && (t = r.responseText)
                        }
                    } catch (e) {}
                    return p[e] = t
                }));
                var w = y(g);

                function x(e) {
                    var t = h[e.source];
                    if (!t) {
                        var r = w(e.source);
                        r ? (t = h[e.source] = {
                            url: r.url,
                            map: new o(r.map)
                        }).map.sourcesContent && t.map.sources.forEach((function(e, r) {
                            var n = t.map.sourcesContent[r];
                            if (n) {
                                var o = b(t.url, e);
                                p[o] = n
                            }
                        })) : t = h[e.source] = {
                            url: null,
                            map: null
                        }
                    }
                    if (t && t.map && "function" == typeof t.map.originalPositionFor) {
                        var n = t.map.originalPositionFor(e);
                        if (null !== n.source) return n.source = b(t.url, n.source), n
                    }
                    return e
                }

                function E(e) {
                    var t = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(e);
                    if (t) {
                        var r = x({
                            source: t[2],
                            line: +t[3],
                            column: t[4] - 1
                        });
                        return "eval at " + t[1] + " (" + r.source + ":" + r.line + ":" + (r.column + 1) + ")"
                    }
                    return (t = /^eval at ([^(]+) \((.+)\)$/.exec(e)) ? "eval at " + t[1] + " (" + E(t[2]) + ")" : e
                }

                function C() {
                    var e, t = "";
                    if (this.isNative()) t = "native";
                    else {
                        !(e = this.getScriptNameOrSourceURL()) && this.isEval() && (t = this.getEvalOrigin(), t += ", "), t += e || "<anonymous>";
                        var r = this.getLineNumber();
                        if (null != r) {
                            t += ":" + r;
                            var n = this.getColumnNumber();
                            n && (t += ":" + n)
                        }
                    }
                    var o = "",
                        i = this.getFunctionName(),
                        s = !0,
                        a = this.isConstructor();
                    if (this.isToplevel() || a) a ? o += "new " + (i || "<anonymous>") : i ? o += i : (o += t, s = !1);
                    else {
                        var c = this.getTypeName();
                        "[object Object]" === c && (c = "null");
                        var l = this.getMethodName();
                        i ? (c && 0 != i.indexOf(c) && (o += c + "."), o += i, l && i.indexOf("." + l) != i.length - l.length - 1 && (o += " [as " + l + "]")) : o += c + "." + (l || "<anonymous>")
                    }
                    return s && (o += " (" + t + ")"), o
                }

                function S(e) {
                    var t = {};
                    return Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(r) {
                        t[r] = /^(?:is|get)/.test(r) ? function() {
                            return e[r].call(e)
                        } : e[r]
                    })), t.toString = C, t
                }

                function T(e, t) {
                    if (void 0 === t && (t = {
                            nextPosition: null,
                            curPosition: null
                        }), e.isNative()) return t.curPosition = null, e;
                    var r = e.getFileName() || e.getScriptNameOrSourceURL();
                    if (r) {
                        var n = e.getLineNumber(),
                            o = e.getColumnNumber() - 1,
                            i = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/.test("object" == typeof process && null !== process ? process.version : "") ? 0 : 62;
                        1 === n && o > i && !_() && !e.isEval() && (o -= i);
                        var s = x({
                            source: r,
                            line: n,
                            column: o
                        });
                        t.curPosition = s;
                        var a = (e = S(e)).getFunctionName;
                        return e.getFunctionName = function() {
                            return null == t.nextPosition ? a() : t.nextPosition.name || a()
                        }, e.getFileName = function() {
                            return s.source
                        }, e.getLineNumber = function() {
                            return s.line
                        }, e.getColumnNumber = function() {
                            return s.column + 1
                        }, e.getScriptNameOrSourceURL = function() {
                            return s.source
                        }, e
                    }
                    var c = e.isEval() && e.getEvalOrigin();
                    return c ? (c = E(c), (e = S(e)).getEvalOrigin = function() {
                        return c
                    }, e) : e
                }

                function k(e, t) {
                    u && (p = {}, h = {});
                    for (var r = (e.name || "Error") + ": " + (e.message || ""), n = {
                            nextPosition: null,
                            curPosition: null
                        }, o = [], i = t.length - 1; i >= 0; i--) o.push("\n    at " + T(t[i], n)), n.nextPosition = n.curPosition;
                    return n.curPosition = n.nextPosition = null, r + o.reverse().join("")
                }

                function I(e) {
                    var t = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(e.stack);
                    if (t) {
                        var r = t[1],
                            o = +t[2],
                            i = +t[3],
                            s = p[r];
                        if (!s && n && n.existsSync(r)) try {
                            s = n.readFileSync(r, "utf8")
                        } catch (e) {
                            s = ""
                        }
                        if (s) {
                            var a = s.split(/(?:\r\n|\r|\n)/)[o - 1];
                            if (a) return r + ":" + o + "\n" + a + "\n" + new Array(i).join(" ") + "^"
                        }
                    }
                    return null
                }

                function P(e) {
                    var t = I(e),
                        r = function() {
                            if ("object" == typeof process && null !== process) return process.stderr
                        }();
                    r && r._handle && r._handle.setBlocking && r._handle.setBlocking(!0), t && (console.error(), console.error(t)), console.error(e.stack), "object" == typeof process && null !== process && "function" == typeof process.exit && process.exit(1)
                }
                g.push((function(e) {
                    var t, r = function(e) {
                        var t;
                        if (_()) try {
                            var r = new XMLHttpRequest;
                            r.open("GET", e, !1), r.send(null), t = 4 === r.readyState ? r.responseText : null;
                            var n = r.getResponseHeader("SourceMap") || r.getResponseHeader("X-SourceMap");
                            if (n) return n
                        } catch (e) {}
                        t = v(e);
                        for (var o, i, s = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/gm; i = s.exec(t);) o = i;
                        return o ? o[1] : null
                    }(e);
                    if (!r) return null;
                    if (f.test(r)) {
                        var n = r.slice(r.indexOf(",") + 1);
                        t = s(n, "base64").toString(), r = e
                    } else r = b(e, r), t = v(r);
                    return t ? {
                        url: r,
                        map: t
                    } : null
                }));
                var A = m.slice(0),
                    O = g.slice(0);
                t.wrapCallSite = T, t.getErrorSource = I, t.mapSourcePosition = x, t.retrieveSourceMap = w, t.install = function(t) {
                    if ((t = t || {}).environment && (d = t.environment, -1 === ["node", "browser", "auto"].indexOf(d))) throw new Error("environment " + d + " was unknown. Available options are {auto, browser, node}");
                    if (t.retrieveFile && (t.overrideRetrieveFile && (m.length = 0), m.unshift(t.retrieveFile)), t.retrieveSourceMap && (t.overrideRetrieveSourceMap && (g.length = 0), g.unshift(t.retrieveSourceMap)), t.hookRequire && !_()) {
                        var r = a(e, "module"),
                            n = r.prototype._compile;
                        n.__sourceMapSupport || (r.prototype._compile = function(e, t) {
                            return p[t] = e, h[t] = void 0, n.call(this, e, t)
                        }, r.prototype._compile.__sourceMapSupport = !0)
                    }
                    if (u || (u = "emptyCacheBetweenOperations" in t && t.emptyCacheBetweenOperations), c || (c = !0, Error.prepareStackTrace = k), !l) {
                        var o = !("handleUncaughtExceptions" in t) || t.handleUncaughtExceptions;
                        try {
                            !1 === a(e, "worker_threads").isMainThread && (o = !1)
                        } catch (e) {}
                        o && "object" == typeof process && null !== process && "function" == typeof process.on && (l = !0, i = process.emit, process.emit = function(e) {
                            if ("uncaughtException" === e) {
                                var t = arguments[1] && arguments[1].stack,
                                    r = this.listeners(e).length > 0;
                                if (t && !r) return P(arguments[1])
                            }
                            return i.apply(this, arguments)
                        })
                    }
                    var i
                }, t.resetRetrieveHandlers = function() {
                    m.length = 0, g.length = 0, m = A.slice(0), g = O.slice(0), w = y(g), v = y(m)
                }
            },
            8213: (e, t, r) => {
                var n = r(2728),
                    o = Object.prototype.hasOwnProperty,
                    i = "undefined" != typeof Map;

                function s() {
                    this._array = [], this._set = i ? new Map : Object.create(null)
                }
                s.fromArray = function(e, t) {
                    for (var r = new s, n = 0, o = e.length; n < o; n++) r.add(e[n], t);
                    return r
                }, s.prototype.size = function() {
                    return i ? this._set.size : Object.getOwnPropertyNames(this._set).length
                }, s.prototype.add = function(e, t) {
                    var r = i ? e : n.toSetString(e),
                        s = i ? this.has(e) : o.call(this._set, r),
                        a = this._array.length;
                    s && !t || this._array.push(e), s || (i ? this._set.set(e, a) : this._set[r] = a)
                }, s.prototype.has = function(e) {
                    if (i) return this._set.has(e);
                    var t = n.toSetString(e);
                    return o.call(this._set, t)
                }, s.prototype.indexOf = function(e) {
                    if (i) {
                        var t = this._set.get(e);
                        if (t >= 0) return t
                    } else {
                        var r = n.toSetString(e);
                        if (o.call(this._set, r)) return this._set[r]
                    }
                    throw new Error('"' + e + '" is not in the set.')
                }, s.prototype.at = function(e) {
                    if (e >= 0 && e < this._array.length) return this._array[e];
                    throw new Error("No element indexed by " + e)
                }, s.prototype.toArray = function() {
                    return this._array.slice()
                }, t.I = s
            },
            6400: (e, t, r) => {
                var n = r(7923);
                t.encode = function(e) {
                    var t, r = "",
                        o = function(e) {
                            return e < 0 ? 1 + (-e << 1) : 0 + (e << 1)
                        }(e);
                    do {
                        t = 31 & o, (o >>>= 5) > 0 && (t |= 32), r += n.encode(t)
                    } while (o > 0);
                    return r
                }, t.decode = function(e, t, r) {
                    var o, i, s, a, c = e.length,
                        l = 0,
                        u = 0;
                    do {
                        if (t >= c) throw new Error("Expected more digits in base 64 VLQ value.");
                        if (-1 === (i = n.decode(e.charCodeAt(t++)))) throw new Error("Invalid base64 digit: " + e.charAt(t - 1));
                        o = !!(32 & i), l += (i &= 31) << u, u += 5
                    } while (o);
                    r.value = (a = (s = l) >> 1, 1 == (1 & s) ? -a : a), r.rest = t
                }
            },
            7923: (e, t) => {
                var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
                t.encode = function(e) {
                    if (0 <= e && e < r.length) return r[e];
                    throw new TypeError("Must be between 0 and 63: " + e)
                }, t.decode = function(e) {
                    return 65 <= e && e <= 90 ? e - 65 : 97 <= e && e <= 122 ? e - 97 + 26 : 48 <= e && e <= 57 ? e - 48 + 52 : 43 == e ? 62 : 47 == e ? 63 : -1
                }
            },
            9216: (e, t) => {
                function r(e, n, o, i, s, a) {
                    var c = Math.floor((n - e) / 2) + e,
                        l = s(o, i[c], !0);
                    return 0 === l ? c : l > 0 ? n - c > 1 ? r(c, n, o, i, s, a) : a == t.LEAST_UPPER_BOUND ? n < i.length ? n : -1 : c : c - e > 1 ? r(e, c, o, i, s, a) : a == t.LEAST_UPPER_BOUND ? c : e < 0 ? -1 : e
                }
                t.GREATEST_LOWER_BOUND = 1, t.LEAST_UPPER_BOUND = 2, t.search = function(e, n, o, i) {
                    if (0 === n.length) return -1;
                    var s = r(-1, n.length, e, n, o, i || t.GREATEST_LOWER_BOUND);
                    if (s < 0) return -1;
                    for (; s - 1 >= 0 && 0 === o(n[s], n[s - 1], !0);) --s;
                    return s
                }
            },
            1188: (e, t, r) => {
                var n = r(2728);

                function o() {
                    this._array = [], this._sorted = !0, this._last = {
                        generatedLine: -1,
                        generatedColumn: 0
                    }
                }
                o.prototype.unsortedForEach = function(e, t) {
                    this._array.forEach(e, t)
                }, o.prototype.add = function(e) {
                    var t, r, o, i, s, a;
                    r = e, o = (t = this._last).generatedLine, i = r.generatedLine, s = t.generatedColumn, a = r.generatedColumn, i > o || i == o && a >= s || n.compareByGeneratedPositionsInflated(t, r) <= 0 ? (this._last = e, this._array.push(e)) : (this._sorted = !1, this._array.push(e))
                }, o.prototype.toArray = function() {
                    return this._sorted || (this._array.sort(n.compareByGeneratedPositionsInflated), this._sorted = !0), this._array
                }, t.H = o
            },
            2826: (e, t) => {
                function r(e, t, r) {
                    var n = e[t];
                    e[t] = e[r], e[r] = n
                }

                function n(e, t, o, i) {
                    if (o < i) {
                        var s = o - 1;
                        r(e, (u = o, d = i, Math.round(u + Math.random() * (d - u))), i);
                        for (var a = e[i], c = o; c < i; c++) t(e[c], a) <= 0 && r(e, s += 1, c);
                        r(e, s + 1, c);
                        var l = s + 1;
                        n(e, t, o, l - 1), n(e, t, l + 1, i)
                    }
                    var u, d
                }
                t.U = function(e, t) {
                    n(e, t, 0, e.length - 1)
                }
            },
            6771: (e, t, r) => {
                var n = r(2728),
                    o = r(9216),
                    i = r(8213).I,
                    s = r(6400),
                    a = r(2826).U;

                function c(e, t) {
                    var r = e;
                    return "string" == typeof e && (r = n.parseSourceMapInput(e)), null != r.sections ? new d(r, t) : new l(r, t)
                }

                function l(e, t) {
                    var r = e;
                    "string" == typeof e && (r = n.parseSourceMapInput(e));
                    var o = n.getArg(r, "version"),
                        s = n.getArg(r, "sources"),
                        a = n.getArg(r, "names", []),
                        c = n.getArg(r, "sourceRoot", null),
                        l = n.getArg(r, "sourcesContent", null),
                        u = n.getArg(r, "mappings"),
                        d = n.getArg(r, "file", null);
                    if (o != this._version) throw new Error("Unsupported version: " + o);
                    c && (c = n.normalize(c)), s = s.map(String).map(n.normalize).map((function(e) {
                        return c && n.isAbsolute(c) && n.isAbsolute(e) ? n.relative(c, e) : e
                    })), this._names = i.fromArray(a.map(String), !0), this._sources = i.fromArray(s, !0), this._absoluteSources = this._sources.toArray().map((function(e) {
                        return n.computeSourceURL(c, e, t)
                    })), this.sourceRoot = c, this.sourcesContent = l, this._mappings = u, this._sourceMapURL = t, this.file = d
                }

                function u() {
                    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null
                }

                function d(e, t) {
                    var r = e;
                    "string" == typeof e && (r = n.parseSourceMapInput(e));
                    var o = n.getArg(r, "version"),
                        s = n.getArg(r, "sections");
                    if (o != this._version) throw new Error("Unsupported version: " + o);
                    this._sources = new i, this._names = new i;
                    var a = {
                        line: -1,
                        column: 0
                    };
                    this._sections = s.map((function(e) {
                        if (e.url) throw new Error("Support for url field in sections not implemented.");
                        var r = n.getArg(e, "offset"),
                            o = n.getArg(r, "line"),
                            i = n.getArg(r, "column");
                        if (o < a.line || o === a.line && i < a.column) throw new Error("Section offsets must be ordered and non-overlapping.");
                        return a = r, {
                            generatedOffset: {
                                generatedLine: o + 1,
                                generatedColumn: i + 1
                            },
                            consumer: new c(n.getArg(e, "map"), t)
                        }
                    }))
                }
                c.fromSourceMap = function(e, t) {
                    return l.fromSourceMap(e, t)
                }, c.prototype._version = 3, c.prototype.__generatedMappings = null, Object.defineProperty(c.prototype, "_generatedMappings", {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings
                    }
                }), c.prototype.__originalMappings = null, Object.defineProperty(c.prototype, "_originalMappings", {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings
                    }
                }), c.prototype._charIsMappingSeparator = function(e, t) {
                    var r = e.charAt(t);
                    return ";" === r || "," === r
                }, c.prototype._parseMappings = function(e, t) {
                    throw new Error("Subclasses must implement _parseMappings")
                }, c.GENERATED_ORDER = 1, c.ORIGINAL_ORDER = 2, c.GREATEST_LOWER_BOUND = 1, c.LEAST_UPPER_BOUND = 2, c.prototype.eachMapping = function(e, t, r) {
                    var o, i = t || null;
                    switch (r || c.GENERATED_ORDER) {
                        case c.GENERATED_ORDER:
                            o = this._generatedMappings;
                            break;
                        case c.ORIGINAL_ORDER:
                            o = this._originalMappings;
                            break;
                        default:
                            throw new Error("Unknown order of iteration.")
                    }
                    var s = this.sourceRoot;
                    o.map((function(e) {
                        var t = null === e.source ? null : this._sources.at(e.source);
                        return {
                            source: t = n.computeSourceURL(s, t, this._sourceMapURL),
                            generatedLine: e.generatedLine,
                            generatedColumn: e.generatedColumn,
                            originalLine: e.originalLine,
                            originalColumn: e.originalColumn,
                            name: null === e.name ? null : this._names.at(e.name)
                        }
                    }), this).forEach(e, i)
                }, c.prototype.allGeneratedPositionsFor = function(e) {
                    var t = n.getArg(e, "line"),
                        r = {
                            source: n.getArg(e, "source"),
                            originalLine: t,
                            originalColumn: n.getArg(e, "column", 0)
                        };
                    if (r.source = this._findSourceIndex(r.source), r.source < 0) return [];
                    var i = [],
                        s = this._findMapping(r, this._originalMappings, "originalLine", "originalColumn", n.compareByOriginalPositions, o.LEAST_UPPER_BOUND);
                    if (s >= 0) {
                        var a = this._originalMappings[s];
                        if (void 0 === e.column)
                            for (var c = a.originalLine; a && a.originalLine === c;) i.push({
                                line: n.getArg(a, "generatedLine", null),
                                column: n.getArg(a, "generatedColumn", null),
                                lastColumn: n.getArg(a, "lastGeneratedColumn", null)
                            }), a = this._originalMappings[++s];
                        else
                            for (var l = a.originalColumn; a && a.originalLine === t && a.originalColumn == l;) i.push({
                                line: n.getArg(a, "generatedLine", null),
                                column: n.getArg(a, "generatedColumn", null),
                                lastColumn: n.getArg(a, "lastGeneratedColumn", null)
                            }), a = this._originalMappings[++s]
                    }
                    return i
                }, t.SourceMapConsumer = c, l.prototype = Object.create(c.prototype), l.prototype.consumer = c, l.prototype._findSourceIndex = function(e) {
                    var t, r = e;
                    if (null != this.sourceRoot && (r = n.relative(this.sourceRoot, r)), this._sources.has(r)) return this._sources.indexOf(r);
                    for (t = 0; t < this._absoluteSources.length; ++t)
                        if (this._absoluteSources[t] == e) return t;
                    return -1
                }, l.fromSourceMap = function(e, t) {
                    var r = Object.create(l.prototype),
                        o = r._names = i.fromArray(e._names.toArray(), !0),
                        s = r._sources = i.fromArray(e._sources.toArray(), !0);
                    r.sourceRoot = e._sourceRoot, r.sourcesContent = e._generateSourcesContent(r._sources.toArray(), r.sourceRoot), r.file = e._file, r._sourceMapURL = t, r._absoluteSources = r._sources.toArray().map((function(e) {
                        return n.computeSourceURL(r.sourceRoot, e, t)
                    }));
                    for (var c = e._mappings.toArray().slice(), d = r.__generatedMappings = [], p = r.__originalMappings = [], h = 0, f = c.length; h < f; h++) {
                        var m = c[h],
                            g = new u;
                        g.generatedLine = m.generatedLine, g.generatedColumn = m.generatedColumn, m.source && (g.source = s.indexOf(m.source), g.originalLine = m.originalLine, g.originalColumn = m.originalColumn, m.name && (g.name = o.indexOf(m.name)), p.push(g)), d.push(g)
                    }
                    return a(r.__originalMappings, n.compareByOriginalPositions), r
                }, l.prototype._version = 3, Object.defineProperty(l.prototype, "sources", {
                    get: function() {
                        return this._absoluteSources.slice()
                    }
                }), l.prototype._parseMappings = function(e, t) {
                    for (var r, o, i, c, l, d = 1, p = 0, h = 0, f = 0, m = 0, g = 0, _ = e.length, y = 0, v = {}, b = {}, w = [], x = []; y < _;)
                        if (";" === e.charAt(y)) d++, y++, p = 0;
                        else if ("," === e.charAt(y)) y++;
                    else {
                        for ((r = new u).generatedLine = d, c = y; c < _ && !this._charIsMappingSeparator(e, c); c++);
                        if (i = v[o = e.slice(y, c)]) y += o.length;
                        else {
                            for (i = []; y < c;) s.decode(e, y, b), l = b.value, y = b.rest, i.push(l);
                            if (2 === i.length) throw new Error("Found a source, but no line and column");
                            if (3 === i.length) throw new Error("Found a source and line, but no column");
                            v[o] = i
                        }
                        r.generatedColumn = p + i[0], p = r.generatedColumn, i.length > 1 && (r.source = m + i[1], m += i[1], r.originalLine = h + i[2], h = r.originalLine, r.originalLine += 1, r.originalColumn = f + i[3], f = r.originalColumn, i.length > 4 && (r.name = g + i[4], g += i[4])), x.push(r), "number" == typeof r.originalLine && w.push(r)
                    }
                    a(x, n.compareByGeneratedPositionsDeflated), this.__generatedMappings = x, a(w, n.compareByOriginalPositions), this.__originalMappings = w
                }, l.prototype._findMapping = function(e, t, r, n, i, s) {
                    if (e[r] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + e[r]);
                    if (e[n] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + e[n]);
                    return o.search(e, t, i, s)
                }, l.prototype.computeColumnSpans = function() {
                    for (var e = 0; e < this._generatedMappings.length; ++e) {
                        var t = this._generatedMappings[e];
                        if (e + 1 < this._generatedMappings.length) {
                            var r = this._generatedMappings[e + 1];
                            if (t.generatedLine === r.generatedLine) {
                                t.lastGeneratedColumn = r.generatedColumn - 1;
                                continue
                            }
                        }
                        t.lastGeneratedColumn = 1 / 0
                    }
                }, l.prototype.originalPositionFor = function(e) {
                    var t = {
                            generatedLine: n.getArg(e, "line"),
                            generatedColumn: n.getArg(e, "column")
                        },
                        r = this._findMapping(t, this._generatedMappings, "generatedLine", "generatedColumn", n.compareByGeneratedPositionsDeflated, n.getArg(e, "bias", c.GREATEST_LOWER_BOUND));
                    if (r >= 0) {
                        var o = this._generatedMappings[r];
                        if (o.generatedLine === t.generatedLine) {
                            var i = n.getArg(o, "source", null);
                            null !== i && (i = this._sources.at(i), i = n.computeSourceURL(this.sourceRoot, i, this._sourceMapURL));
                            var s = n.getArg(o, "name", null);
                            return null !== s && (s = this._names.at(s)), {
                                source: i,
                                line: n.getArg(o, "originalLine", null),
                                column: n.getArg(o, "originalColumn", null),
                                name: s
                            }
                        }
                    }
                    return {
                        source: null,
                        line: null,
                        column: null,
                        name: null
                    }
                }, l.prototype.hasContentsOfAllSources = function() {
                    return !!this.sourcesContent && this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some((function(e) {
                        return null == e
                    }))
                }, l.prototype.sourceContentFor = function(e, t) {
                    if (!this.sourcesContent) return null;
                    var r = this._findSourceIndex(e);
                    if (r >= 0) return this.sourcesContent[r];
                    var o, i = e;
                    if (null != this.sourceRoot && (i = n.relative(this.sourceRoot, i)), null != this.sourceRoot && (o = n.urlParse(this.sourceRoot))) {
                        var s = i.replace(/^file:\/\//, "");
                        if ("file" == o.scheme && this._sources.has(s)) return this.sourcesContent[this._sources.indexOf(s)];
                        if ((!o.path || "/" == o.path) && this._sources.has("/" + i)) return this.sourcesContent[this._sources.indexOf("/" + i)]
                    }
                    if (t) return null;
                    throw new Error('"' + i + '" is not in the SourceMap.')
                }, l.prototype.generatedPositionFor = function(e) {
                    var t = n.getArg(e, "source");
                    if ((t = this._findSourceIndex(t)) < 0) return {
                        line: null,
                        column: null,
                        lastColumn: null
                    };
                    var r = {
                            source: t,
                            originalLine: n.getArg(e, "line"),
                            originalColumn: n.getArg(e, "column")
                        },
                        o = this._findMapping(r, this._originalMappings, "originalLine", "originalColumn", n.compareByOriginalPositions, n.getArg(e, "bias", c.GREATEST_LOWER_BOUND));
                    if (o >= 0) {
                        var i = this._originalMappings[o];
                        if (i.source === r.source) return {
                            line: n.getArg(i, "generatedLine", null),
                            column: n.getArg(i, "generatedColumn", null),
                            lastColumn: n.getArg(i, "lastGeneratedColumn", null)
                        }
                    }
                    return {
                        line: null,
                        column: null,
                        lastColumn: null
                    }
                }, d.prototype = Object.create(c.prototype), d.prototype.constructor = c, d.prototype._version = 3, Object.defineProperty(d.prototype, "sources", {
                    get: function() {
                        for (var e = [], t = 0; t < this._sections.length; t++)
                            for (var r = 0; r < this._sections[t].consumer.sources.length; r++) e.push(this._sections[t].consumer.sources[r]);
                        return e
                    }
                }), d.prototype.originalPositionFor = function(e) {
                    var t = {
                            generatedLine: n.getArg(e, "line"),
                            generatedColumn: n.getArg(e, "column")
                        },
                        r = o.search(t, this._sections, (function(e, t) {
                            return e.generatedLine - t.generatedOffset.generatedLine || e.generatedColumn - t.generatedOffset.generatedColumn
                        })),
                        i = this._sections[r];
                    return i ? i.consumer.originalPositionFor({
                        line: t.generatedLine - (i.generatedOffset.generatedLine - 1),
                        column: t.generatedColumn - (i.generatedOffset.generatedLine === t.generatedLine ? i.generatedOffset.generatedColumn - 1 : 0),
                        bias: e.bias
                    }) : {
                        source: null,
                        line: null,
                        column: null,
                        name: null
                    }
                }, d.prototype.hasContentsOfAllSources = function() {
                    return this._sections.every((function(e) {
                        return e.consumer.hasContentsOfAllSources()
                    }))
                }, d.prototype.sourceContentFor = function(e, t) {
                    for (var r = 0; r < this._sections.length; r++) {
                        var n = this._sections[r].consumer.sourceContentFor(e, !0);
                        if (n) return n
                    }
                    if (t) return null;
                    throw new Error('"' + e + '" is not in the SourceMap.')
                }, d.prototype.generatedPositionFor = function(e) {
                    for (var t = 0; t < this._sections.length; t++) {
                        var r = this._sections[t];
                        if (-1 !== r.consumer._findSourceIndex(n.getArg(e, "source"))) {
                            var o = r.consumer.generatedPositionFor(e);
                            if (o) return {
                                line: o.line + (r.generatedOffset.generatedLine - 1),
                                column: o.column + (r.generatedOffset.generatedLine === o.line ? r.generatedOffset.generatedColumn - 1 : 0)
                            }
                        }
                    }
                    return {
                        line: null,
                        column: null
                    }
                }, d.prototype._parseMappings = function(e, t) {
                    this.__generatedMappings = [], this.__originalMappings = [];
                    for (var r = 0; r < this._sections.length; r++)
                        for (var o = this._sections[r], i = o.consumer._generatedMappings, s = 0; s < i.length; s++) {
                            var c = i[s],
                                l = o.consumer._sources.at(c.source);
                            l = n.computeSourceURL(o.consumer.sourceRoot, l, this._sourceMapURL), this._sources.add(l), l = this._sources.indexOf(l);
                            var u = null;
                            c.name && (u = o.consumer._names.at(c.name), this._names.add(u), u = this._names.indexOf(u));
                            var d = {
                                source: l,
                                generatedLine: c.generatedLine + (o.generatedOffset.generatedLine - 1),
                                generatedColumn: c.generatedColumn + (o.generatedOffset.generatedLine === c.generatedLine ? o.generatedOffset.generatedColumn - 1 : 0),
                                originalLine: c.originalLine,
                                originalColumn: c.originalColumn,
                                name: u
                            };
                            this.__generatedMappings.push(d), "number" == typeof d.originalLine && this.__originalMappings.push(d)
                        }
                    a(this.__generatedMappings, n.compareByGeneratedPositionsDeflated), a(this.__originalMappings, n.compareByOriginalPositions)
                }
            },
            4433: (e, t, r) => {
                var n = r(6400),
                    o = r(2728),
                    i = r(8213).I,
                    s = r(1188).H;

                function a(e) {
                    e || (e = {}), this._file = o.getArg(e, "file", null), this._sourceRoot = o.getArg(e, "sourceRoot", null), this._skipValidation = o.getArg(e, "skipValidation", !1), this._sources = new i, this._names = new i, this._mappings = new s, this._sourcesContents = null
                }
                a.prototype._version = 3, a.fromSourceMap = function(e) {
                    var t = e.sourceRoot,
                        r = new a({
                            file: e.file,
                            sourceRoot: t
                        });
                    return e.eachMapping((function(e) {
                        var n = {
                            generated: {
                                line: e.generatedLine,
                                column: e.generatedColumn
                            }
                        };
                        null != e.source && (n.source = e.source, null != t && (n.source = o.relative(t, n.source)), n.original = {
                            line: e.originalLine,
                            column: e.originalColumn
                        }, null != e.name && (n.name = e.name)), r.addMapping(n)
                    })), e.sources.forEach((function(n) {
                        var i = n;
                        null !== t && (i = o.relative(t, n)), r._sources.has(i) || r._sources.add(i);
                        var s = e.sourceContentFor(n);
                        null != s && r.setSourceContent(n, s)
                    })), r
                }, a.prototype.addMapping = function(e) {
                    var t = o.getArg(e, "generated"),
                        r = o.getArg(e, "original", null),
                        n = o.getArg(e, "source", null),
                        i = o.getArg(e, "name", null);
                    this._skipValidation || this._validateMapping(t, r, n, i), null != n && (n = String(n), this._sources.has(n) || this._sources.add(n)), null != i && (i = String(i), this._names.has(i) || this._names.add(i)), this._mappings.add({
                        generatedLine: t.line,
                        generatedColumn: t.column,
                        originalLine: null != r && r.line,
                        originalColumn: null != r && r.column,
                        source: n,
                        name: i
                    })
                }, a.prototype.setSourceContent = function(e, t) {
                    var r = e;
                    null != this._sourceRoot && (r = o.relative(this._sourceRoot, r)), null != t ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), this._sourcesContents[o.toSetString(r)] = t) : this._sourcesContents && (delete this._sourcesContents[o.toSetString(r)], 0 === Object.keys(this._sourcesContents).length && (this._sourcesContents = null))
                }, a.prototype.applySourceMap = function(e, t, r) {
                    var n = t;
                    if (null == t) {
                        if (null == e.file) throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');
                        n = e.file
                    }
                    var s = this._sourceRoot;
                    null != s && (n = o.relative(s, n));
                    var a = new i,
                        c = new i;
                    this._mappings.unsortedForEach((function(t) {
                        if (t.source === n && null != t.originalLine) {
                            var i = e.originalPositionFor({
                                line: t.originalLine,
                                column: t.originalColumn
                            });
                            null != i.source && (t.source = i.source, null != r && (t.source = o.join(r, t.source)), null != s && (t.source = o.relative(s, t.source)), t.originalLine = i.line, t.originalColumn = i.column, null != i.name && (t.name = i.name))
                        }
                        var l = t.source;
                        null == l || a.has(l) || a.add(l);
                        var u = t.name;
                        null == u || c.has(u) || c.add(u)
                    }), this), this._sources = a, this._names = c, e.sources.forEach((function(t) {
                        var n = e.sourceContentFor(t);
                        null != n && (null != r && (t = o.join(r, t)), null != s && (t = o.relative(s, t)), this.setSourceContent(t, n))
                    }), this)
                }, a.prototype._validateMapping = function(e, t, r, n) {
                    if (t && "number" != typeof t.line && "number" != typeof t.column) throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
                    if ((!(e && "line" in e && "column" in e && e.line > 0 && e.column >= 0) || t || r || n) && !(e && "line" in e && "column" in e && t && "line" in t && "column" in t && e.line > 0 && e.column >= 0 && t.line > 0 && t.column >= 0 && r)) throw new Error("Invalid mapping: " + JSON.stringify({
                        generated: e,
                        source: r,
                        original: t,
                        name: n
                    }))
                }, a.prototype._serializeMappings = function() {
                    for (var e, t, r, i, s = 0, a = 1, c = 0, l = 0, u = 0, d = 0, p = "", h = this._mappings.toArray(), f = 0, m = h.length; f < m; f++) {
                        if (e = "", (t = h[f]).generatedLine !== a)
                            for (s = 0; t.generatedLine !== a;) e += ";", a++;
                        else if (f > 0) {
                            if (!o.compareByGeneratedPositionsInflated(t, h[f - 1])) continue;
                            e += ","
                        }
                        e += n.encode(t.generatedColumn - s), s = t.generatedColumn, null != t.source && (i = this._sources.indexOf(t.source), e += n.encode(i - d), d = i, e += n.encode(t.originalLine - 1 - l), l = t.originalLine - 1, e += n.encode(t.originalColumn - c), c = t.originalColumn, null != t.name && (r = this._names.indexOf(t.name), e += n.encode(r - u), u = r)), p += e
                    }
                    return p
                }, a.prototype._generateSourcesContent = function(e, t) {
                    return e.map((function(e) {
                        if (!this._sourcesContents) return null;
                        null != t && (e = o.relative(t, e));
                        var r = o.toSetString(e);
                        return Object.prototype.hasOwnProperty.call(this._sourcesContents, r) ? this._sourcesContents[r] : null
                    }), this)
                }, a.prototype.toJSON = function() {
                    var e = {
                        version: this._version,
                        sources: this._sources.toArray(),
                        names: this._names.toArray(),
                        mappings: this._serializeMappings()
                    };
                    return null != this._file && (e.file = this._file), null != this._sourceRoot && (e.sourceRoot = this._sourceRoot), this._sourcesContents && (e.sourcesContent = this._generateSourcesContent(e.sources, e.sourceRoot)), e
                }, a.prototype.toString = function() {
                    return JSON.stringify(this.toJSON())
                }, t.h = a
            },
            7085: (e, t, r) => {
                var n = r(4433).h,
                    o = r(2728),
                    i = /(\r?\n)/,
                    s = "$$$isSourceNode$$$";

                function a(e, t, r, n, o) {
                    this.children = [], this.sourceContents = {}, this.line = null == e ? null : e, this.column = null == t ? null : t, this.source = null == r ? null : r, this.name = null == o ? null : o, this[s] = !0, null != n && this.add(n)
                }
                a.fromStringWithSourceMap = function(e, t, r) {
                    var n = new a,
                        s = e.split(i),
                        c = 0,
                        l = function() {
                            return e() + (e() || "");

                            function e() {
                                return c < s.length ? s[c++] : void 0
                            }
                        },
                        u = 1,
                        d = 0,
                        p = null;
                    return t.eachMapping((function(e) {
                        if (null !== p) {
                            if (!(u < e.generatedLine)) {
                                var t = (r = s[c] || "").substr(0, e.generatedColumn - d);
                                return s[c] = r.substr(e.generatedColumn - d), d = e.generatedColumn, h(p, t), void(p = e)
                            }
                            h(p, l()), u++, d = 0
                        }
                        for (; u < e.generatedLine;) n.add(l()), u++;
                        if (d < e.generatedColumn) {
                            var r = s[c] || "";
                            n.add(r.substr(0, e.generatedColumn)), s[c] = r.substr(e.generatedColumn), d = e.generatedColumn
                        }
                        p = e
                    }), this), c < s.length && (p && h(p, l()), n.add(s.splice(c).join(""))), t.sources.forEach((function(e) {
                        var i = t.sourceContentFor(e);
                        null != i && (null != r && (e = o.join(r, e)), n.setSourceContent(e, i))
                    })), n;

                    function h(e, t) {
                        if (null === e || void 0 === e.source) n.add(t);
                        else {
                            var i = r ? o.join(r, e.source) : e.source;
                            n.add(new a(e.originalLine, e.originalColumn, i, t, e.name))
                        }
                    }
                }, a.prototype.add = function(e) {
                    if (Array.isArray(e)) e.forEach((function(e) {
                        this.add(e)
                    }), this);
                    else {
                        if (!e[s] && "string" != typeof e) throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e);
                        e && this.children.push(e)
                    }
                    return this
                }, a.prototype.prepend = function(e) {
                    if (Array.isArray(e))
                        for (var t = e.length - 1; t >= 0; t--) this.prepend(e[t]);
                    else {
                        if (!e[s] && "string" != typeof e) throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e);
                        this.children.unshift(e)
                    }
                    return this
                }, a.prototype.walk = function(e) {
                    for (var t, r = 0, n = this.children.length; r < n; r++)(t = this.children[r])[s] ? t.walk(e) : "" !== t && e(t, {
                        source: this.source,
                        line: this.line,
                        column: this.column,
                        name: this.name
                    })
                }, a.prototype.join = function(e) {
                    var t, r, n = this.children.length;
                    if (n > 0) {
                        for (t = [], r = 0; r < n - 1; r++) t.push(this.children[r]), t.push(e);
                        t.push(this.children[r]), this.children = t
                    }
                    return this
                }, a.prototype.replaceRight = function(e, t) {
                    var r = this.children[this.children.length - 1];
                    return r[s] ? r.replaceRight(e, t) : "string" == typeof r ? this.children[this.children.length - 1] = r.replace(e, t) : this.children.push("".replace(e, t)), this
                }, a.prototype.setSourceContent = function(e, t) {
                    this.sourceContents[o.toSetString(e)] = t
                }, a.prototype.walkSourceContents = function(e) {
                    for (var t = 0, r = this.children.length; t < r; t++) this.children[t][s] && this.children[t].walkSourceContents(e);
                    var n = Object.keys(this.sourceContents);
                    for (t = 0, r = n.length; t < r; t++) e(o.fromSetString(n[t]), this.sourceContents[n[t]])
                }, a.prototype.toString = function() {
                    var e = "";
                    return this.walk((function(t) {
                        e += t
                    })), e
                }, a.prototype.toStringWithSourceMap = function(e) {
                    var t = {
                            code: "",
                            line: 1,
                            column: 0
                        },
                        r = new n(e),
                        o = !1,
                        i = null,
                        s = null,
                        a = null,
                        c = null;
                    return this.walk((function(e, n) {
                        t.code += e, null !== n.source && null !== n.line && null !== n.column ? (i === n.source && s === n.line && a === n.column && c === n.name || r.addMapping({
                            source: n.source,
                            original: {
                                line: n.line,
                                column: n.column
                            },
                            generated: {
                                line: t.line,
                                column: t.column
                            },
                            name: n.name
                        }), i = n.source, s = n.line, a = n.column, c = n.name, o = !0) : o && (r.addMapping({
                            generated: {
                                line: t.line,
                                column: t.column
                            }
                        }), i = null, o = !1);
                        for (var l = 0, u = e.length; l < u; l++) 10 === e.charCodeAt(l) ? (t.line++, t.column = 0, l + 1 === u ? (i = null, o = !1) : o && r.addMapping({
                            source: n.source,
                            original: {
                                line: n.line,
                                column: n.column
                            },
                            generated: {
                                line: t.line,
                                column: t.column
                            },
                            name: n.name
                        })) : t.column++
                    })), this.walkSourceContents((function(e, t) {
                        r.setSourceContent(e, t)
                    })), {
                        code: t.code,
                        map: r
                    }
                }
            },
            2728: (e, t) => {
                t.getArg = function(e, t, r) {
                    if (t in e) return e[t];
                    if (3 === arguments.length) return r;
                    throw new Error('"' + t + '" is a required argument.')
                };
                var r = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/,
                    n = /^data:.+\,.+$/;

                function o(e) {
                    var t = e.match(r);
                    return t ? {
                        scheme: t[1],
                        auth: t[2],
                        host: t[3],
                        port: t[4],
                        path: t[5]
                    } : null
                }

                function i(e) {
                    var t = "";
                    return e.scheme && (t += e.scheme + ":"), t += "//", e.auth && (t += e.auth + "@"), e.host && (t += e.host), e.port && (t += ":" + e.port), e.path && (t += e.path), t
                }

                function s(e) {
                    var r = e,
                        n = o(e);
                    if (n) {
                        if (!n.path) return e;
                        r = n.path
                    }
                    for (var s, a = t.isAbsolute(r), c = r.split(/\/+/), l = 0, u = c.length - 1; u >= 0; u--) "." === (s = c[u]) ? c.splice(u, 1) : ".." === s ? l++ : l > 0 && ("" === s ? (c.splice(u + 1, l), l = 0) : (c.splice(u, 2), l--));
                    return "" === (r = c.join("/")) && (r = a ? "/" : "."), n ? (n.path = r, i(n)) : r
                }

                function a(e, t) {
                    "" === e && (e = "."), "" === t && (t = ".");
                    var r = o(t),
                        a = o(e);
                    if (a && (e = a.path || "/"), r && !r.scheme) return a && (r.scheme = a.scheme), i(r);
                    if (r || t.match(n)) return t;
                    if (a && !a.host && !a.path) return a.host = t, i(a);
                    var c = "/" === t.charAt(0) ? t : s(e.replace(/\/+$/, "") + "/" + t);
                    return a ? (a.path = c, i(a)) : c
                }
                t.urlParse = o, t.urlGenerate = i, t.normalize = s, t.join = a, t.isAbsolute = function(e) {
                    return "/" === e.charAt(0) || r.test(e)
                }, t.relative = function(e, t) {
                    "" === e && (e = "."), e = e.replace(/\/$/, "");
                    for (var r = 0; 0 !== t.indexOf(e + "/");) {
                        var n = e.lastIndexOf("/");
                        if (n < 0) return t;
                        if ((e = e.slice(0, n)).match(/^([^\/]+:\/)?\/*$/)) return t;
                        ++r
                    }
                    return Array(r + 1).join("../") + t.substr(e.length + 1)
                };
                var c = !("__proto__" in Object.create(null));

                function l(e) {
                    return e
                }

                function u(e) {
                    if (!e) return !1;
                    var t = e.length;
                    if (t < 9) return !1;
                    if (95 !== e.charCodeAt(t - 1) || 95 !== e.charCodeAt(t - 2) || 111 !== e.charCodeAt(t - 3) || 116 !== e.charCodeAt(t - 4) || 111 !== e.charCodeAt(t - 5) || 114 !== e.charCodeAt(t - 6) || 112 !== e.charCodeAt(t - 7) || 95 !== e.charCodeAt(t - 8) || 95 !== e.charCodeAt(t - 9)) return !1;
                    for (var r = t - 10; r >= 0; r--)
                        if (36 !== e.charCodeAt(r)) return !1;
                    return !0
                }

                function d(e, t) {
                    return e === t ? 0 : null === e ? 1 : null === t ? -1 : e > t ? 1 : -1
                }
                t.toSetString = c ? l : function(e) {
                    return u(e) ? "$" + e : e
                }, t.fromSetString = c ? l : function(e) {
                    return u(e) ? e.slice(1) : e
                }, t.compareByOriginalPositions = function(e, t, r) {
                    var n = d(e.source, t.source);
                    return 0 !== n || 0 != (n = e.originalLine - t.originalLine) || 0 != (n = e.originalColumn - t.originalColumn) || r || 0 != (n = e.generatedColumn - t.generatedColumn) || 0 != (n = e.generatedLine - t.generatedLine) ? n : d(e.name, t.name)
                }, t.compareByGeneratedPositionsDeflated = function(e, t, r) {
                    var n = e.generatedLine - t.generatedLine;
                    return 0 !== n || 0 != (n = e.generatedColumn - t.generatedColumn) || r || 0 !== (n = d(e.source, t.source)) || 0 != (n = e.originalLine - t.originalLine) || 0 != (n = e.originalColumn - t.originalColumn) ? n : d(e.name, t.name)
                }, t.compareByGeneratedPositionsInflated = function(e, t) {
                    var r = e.generatedLine - t.generatedLine;
                    return 0 !== r || 0 != (r = e.generatedColumn - t.generatedColumn) || 0 !== (r = d(e.source, t.source)) || 0 != (r = e.originalLine - t.originalLine) || 0 != (r = e.originalColumn - t.originalColumn) ? r : d(e.name, t.name)
                }, t.parseSourceMapInput = function(e) {
                    return JSON.parse(e.replace(/^\)]}'[^\n]*\n/, ""))
                }, t.computeSourceURL = function(e, t, r) {
                    if (t = t || "", e && ("/" !== e[e.length - 1] && "/" !== t[0] && (e += "/"), t = e + t), r) {
                        var n = o(r);
                        if (!n) throw new Error("sourceMapURL could not be parsed");
                        if (n.path) {
                            var c = n.path.lastIndexOf("/");
                            c >= 0 && (n.path = n.path.substring(0, c + 1))
                        }
                        t = a(i(n), t)
                    }
                    return s(t)
                }
            },
            9125: (e, t, r) => {
                r(4433).h, t.SourceMapConsumer = r(6771).SourceMapConsumer, r(7085)
            },
            465: e => {
                e.exports = function(e, t) {
                    var r = [];
                    r.push(function(e) {
                        try {
                            return Error.prototype.toString.call(e)
                        } catch (e) {
                            try {
                                return "<error: " + e + ">"
                            } catch (e) {
                                return "<error>"
                            }
                        }
                    }(e));
                    for (var n = 0; n < t.length; n++) {
                        var o, i = t[n];
                        try {
                            o = i.toString()
                        } catch (e) {
                            try {
                                o = "<error: " + e + ">"
                            } catch (e) {
                                o = "<error>"
                            }
                        }
                        r.push("    at " + o)
                    }
                    return r.join("\n")
                }
            },
            2512: (e, t, r) => {
                if (global._stackChain) {
                    if (global._stackChain.version !== r(2301).i8) throw new Error("Conflicting version of stack-chain found");
                    e.exports = global._stackChain
                } else e.exports = global._stackChain = r(7898)
            },
            7898: (e, t, r) => {
                var n = r(465);

                function o() {
                    this.extend = new a, this.filter = new a, this.format = new c, this.version = r(2301).i8
                }
                var i = !1;
                o.prototype.callSite = function e(t) {
                    t || (t = {}), i = !0;
                    var r = {};
                    Error.captureStackTrace(r, e);
                    var n = r.stack;
                    return i = !1, n = n.slice(t.slice || 0), t.extend && (n = this.extend._modify(r, n)), t.filter && (n = this.filter._modify(r, n)), n
                };
                var s = new o;

                function a() {
                    this._modifiers = []
                }

                function c() {
                    this._formater = n, this._previous = void 0
                }
                a.prototype._modify = function(e, t) {
                    for (var r = 0, n = this._modifiers.length; r < n; r++) t = this._modifiers[r](e, t);
                    return t
                }, a.prototype.attach = function(e) {
                    this._modifiers.push(e)
                }, a.prototype.deattach = function(e) {
                    var t = this._modifiers.indexOf(e);
                    return -1 !== t && (this._modifiers.splice(t, 1), !0)
                }, c.prototype.replace = function(e) {
                    e ? this._formater = e : this.restore()
                }, c.prototype.restore = function() {
                    this._formater = n, this._previous = void 0
                }, c.prototype._backup = function() {
                    this._previous = this._formater
                }, c.prototype._roolback = function() {
                    this._previous === n ? this.replace(void 0) : this.replace(this._previous), this._previous = void 0
                }, Error.prepareStackTrace && s.format.replace(Error.prepareStackTrace);
                var l = !1;

                function u(e, t) {
                    if (i) return t;
                    if (l) return n(e, t);
                    var r = t.concat();
                    r = s.extend._modify(e, r), r = (r = s.filter._modify(e, r)).slice(0, Error.stackTraceLimit), Object.isExtensible(e) && void 0 === Object.getOwnPropertyDescriptor(e, "callSite") && (e.callSite = {
                        original: t,
                        mutated: r
                    }), l = !0;
                    var o = s.format._formater(e, r);
                    return l = !1, o
                }
                Object.defineProperty(Error, "prepareStackTrace", {
                    get: function() {
                        return u
                    },
                    set: function(e) {
                        e === u ? s.format._roolback() : (s.format._backup(), s.format.replace(e))
                    }
                }), Object.defineProperty(Error.prototype, "callSite", {
                    get: function() {
                        return this.stack, this.callSite
                    },
                    set: function(e) {
                        Object.defineProperty(this, "callSite", {
                            value: e,
                            writable: !0,
                            configurable: !0
                        })
                    },
                    configurable: !0
                }), e.exports = s
            },
            2130: (e, t, r) => {
                "use strict";
                const n = r(2037),
                    o = r(6560),
                    i = process.env;
                let s;

                function a(e) {
                    const t = function(e) {
                        if (!1 === s) return 0;
                        if (o("color=16m") || o("color=full") || o("color=truecolor")) return 3;
                        if (o("color=256")) return 2;
                        if (e && !e.isTTY && !0 !== s) return 0;
                        const t = s ? 1 : 0;
                        if ("win32" === process.platform) {
                            const e = n.release().split(".");
                            return Number(process.versions.node.split(".")[0]) >= 8 && Number(e[0]) >= 10 && Number(e[2]) >= 10586 ? Number(e[2]) >= 14931 ? 3 : 2 : 1
                        }
                        if ("CI" in i) return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e => e in i)) || "codeship" === i.CI_NAME ? 1 : t;
                        if ("TEAMCITY_VERSION" in i) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(i.TEAMCITY_VERSION) ? 1 : 0;
                        if ("truecolor" === i.COLORTERM) return 3;
                        if ("TERM_PROGRAM" in i) {
                            const e = parseInt((i.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
                            switch (i.TERM_PROGRAM) {
                                case "iTerm.app":
                                    return e >= 3 ? 3 : 2;
                                case "Apple_Terminal":
                                    return 2
                            }
                        }
                        return /-256(color)?$/i.test(i.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(i.TERM) || "COLORTERM" in i ? 1 : (i.TERM, t)
                    }(e);
                    return function(e) {
                        return 0 !== e && {
                            level: e,
                            hasBasic: !0,
                            has256: e >= 2,
                            has16m: e >= 3
                        }
                    }(t)
                }
                o("no-color") || o("no-colors") || o("color=false") ? s = !1 : (o("color") || o("colors") || o("color=true") || o("color=always")) && (s = !0), "FORCE_COLOR" in i && (s = 0 === i.FORCE_COLOR.length || 0 !== parseInt(i.FORCE_COLOR, 10)), e.exports = {
                    supportsColor: a,
                    stdout: a(process.stdout),
                    stderr: a(process.stderr)
                }
            },
            1862: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.VSCodeCopilotTokenManager = t.ExtensionNotificationSender = t.setExtensionContext = t.telemetryAcceptanceKey = void 0;
                const n = r(9496),
                    o = r(362),
                    i = r(6794),
                    s = r(9899),
                    a = r(6333),
                    c = r(47);
                t.telemetryAcceptanceKey = `github.copilot.telemetryAccepted.${i.LAST_TELEMETRY_TERMS_UPDATE}`;
                const l = new s.Logger(s.LogLevel.INFO, "auth");
                let u, d = !1;
                t.setExtensionContext = function(e) {
                    u = e
                }, t.ExtensionNotificationSender = class {
                    async showWarningMessage(e, ...t) {
                        return {
                            title: await n.window.showWarningMessage(e, ...t.map((e => e.title)))
                        }
                    }
                };
                class p extends o.CopilotTokenManager {
                    constructor() {
                        super(), this.copilotToken = void 0
                    }
                    async getCopilotToken(e, r) {
                        return (!this.copilotToken || this.copilotToken.expires_at < (0, o.nowSeconds)() || r) && (this.copilotToken = await async function(e) {
                            const r = await async function(e) {
                                const t = await (0, c.getSession)();
                                if (!t) return l.info(e, "GitHub login failed"), (0, a.telemetryError)(e, "auth.github_login_failed"), {
                                    kind: "failure",
                                    reason: "GitHubLoginFailed"
                                };
                                l.debug(e, `Logged in as ${t.account.label}, oauth token ${t.accessToken}`);
                                const r = await (0, o.authFromGitHubToken)(e, t.accessToken);
                                if ("success" == r.kind) {
                                    const n = r.token;
                                    l.debug(e, `Copilot HMAC for ${t.account.label}: ${n}`)
                                }
                                return r
                            }(e);
                            if ("failure" === r.kind && "NotAuthorized" === r.reason) throw Error("User not authorized");
                            if ("failure" === r.kind && "HTTP401" === r.reason) throw d || (d = !0, n.window.showWarningMessage("Your GitHub token is invalid. Please sign out from your GitHub account using VSCode UI and try again.")), Error("User not authorized");
                            if ("failure" === r.kind) throw Error("Failed to get copilot token");
                            if ("unconfigured" === r.telemetry && !await async function(e) {
                                    var r;
                                    const o = null == u ? void 0 : u.globalState;
                                    if (!o) return !1;
                                    const s = null === (r = (0, c.getGithubAccount)()) || void 0 === r ? void 0 : r.label;
                                    if (!s) return !1;
                                    const l = s,
                                        d = o.get(t.telemetryAcceptanceKey, void 0);
                                    if (d && d === s) return !0;
                                    const p = await n.window.showWarningMessage(`I agree to these [telemetry terms](${i.TELEMETRY_TERMS_URL}) as part of the GitHub Copilot technical preview.`, "Cancel", "Agree");
                                    if ("Agree" !== p) {
                                        const t = a.TelemetryData.createAndMarkAsIssued({
                                            choice: null != p ? p : "undefined"
                                        });
                                        return (0, a.telemetry)(e, "auth.telemetry_terms_rejected", t), !1
                                    }
                                    o.update(t.telemetryAcceptanceKey, l);
                                    const h = a.TelemetryData.createAndMarkAsIssued({
                                        terms_date: i.LAST_TELEMETRY_TERMS_UPDATE
                                    });
                                    return (0, a.telemetry)(e, "auth.telemetry_terms_accepted", h), !0
                                }(e)) throw Error("User did not agree to telemetry");
                            return r
                        }(e), (0, o.refreshToken)(e, this, this.copilotToken.refresh_in)), this.copilotToken.token
                    }
                    resetCopilotToken(e, t) {
                        void 0 !== t && (0, a.telemetry)(e, "auth.reset_token_" + t), l.debug(e, `Resetting copilot token on HTTP error ${t||"unknown"}`), this.copilotToken = void 0
                    }
                }
                t.VSCodeCopilotTokenManager = p
            },
            9425: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.VSCodeEditorInfo = t.makeVscInfo = t.getExtension = t.setExtension = t.VSCodeConfigProvider = void 0;
                const n = r(9496),
                    o = r(1133),
                    i = r(4197),
                    s = r(70),
                    a = r(4147);

                function c(e) {
                    return "string" == typeof e ? e : JSON.stringify(e)
                }
                class l extends o.ConfigProvider {
                    constructor() {
                        super(), this.config = n.workspace.getConfiguration(i.CopilotConfigPrefix), n.workspace.onDidChangeConfiguration((e => {
                            e.affectsConfiguration(i.CopilotConfigPrefix) && (this.config = n.workspace.getConfiguration(i.CopilotConfigPrefix))
                        }))
                    }
                    getConfigKeyFromObject(e, t) {
                        const r = this.config[e][t];
                        return void 0 === r ? (0, o.getConfigDefaultForObjectKey)(e, t) : r
                    }
                    getConfig(e) {
                        if (Array.isArray(e)) return this.getConfigKeyFromObject(e[0], e[1]);
                        const t = this.config.get(e);
                        if (void 0 === t) throw new Error(`Missing config default value: ${i.CopilotConfigPrefix}.${e}`);
                        return t
                    }
                    isDefaultSettingOverwritten(e) {
                        if (Array.isArray(e)) return void 0 !== this.config[e[0]][e[1]];
                        const t = this.config.inspect(e);
                        return !!t && !!(t.globalValue || t.workspaceValue || t.workspaceFolderValue || t.defaultLanguageValue || t.globalLanguageValue || t.workspaceLanguageValue || t.workspaceFolderLanguageValue)
                    }
                    dumpConfig() {
                        const e = {};
                        try {
                            const t = a.contributes.configuration[0].properties;
                            for (const r in t) {
                                const t = r.replace(`${i.CopilotConfigPrefix}.`, "").split(".").reduce(((e, t) => e[t]), this.config);
                                "object" == typeof t && null !== t ? Object.keys(t).filter((e => "secret_key" !== e)).forEach((n => e[`${r}.${n}`] = c(t[n]))) : e[r] = c(t)
                            }
                        } catch (e) {
                            console.error(`Failed to retrieve configuration properties ${e}`)
                        }
                        return e
                    }
                    getLanguageConfig(e, t) {
                        const r = this.getConfig(e);
                        if (void 0 === t) {
                            const e = n.window.activeTextEditor;
                            t = e && e.document.languageId
                        }
                        return t && t in r ? r[t] : r["*"]
                    }
                    updateEnabledConfig(e, t, r, n) {
                        const i = e.get(o.ConfigProvider).getConfig(o.ConfigKey.Enable) || {};
                        return (r && t in i || !r) && (i[t] = n), r && (i["*"] = n), this.config.update(o.ConfigKey.Enable, i, !0)
                    }
                }
                let u;
                t.VSCodeConfigProvider = l, t.setExtension = function(e) {
                    u = e
                }, t.getExtension = function(e) {
                    if (!u && (0, s.isRunningInTest)(e) && (u = n.extensions.all.find((e => e.id.startsWith("GitHub.copilot")))), !u) throw new Error("No GitHub.copilot extension found");
                    return u
                }, t.makeVscInfo = function() {
                    return new o.VscInfo(n.env.sessionId, n.env.machineId, n.version)
                };
                class d extends o.EditorAndPluginInfo {
                    getEditorInfo(e) {
                        return {
                            name: "vscode",
                            version: n.version
                        }
                    }
                    getEditorPluginInfo(e) {
                        return {
                            name: "copilot",
                            version: (0, o.getVersion)(e)
                        }
                    }
                }
                t.VSCodeEditorInfo = d
            },
            3060: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CopilotLabelPrefix = t.CMDSendFeedback = t.CMDShowActivationErrors = t.CMDToggleCopilot = t.CMDAcceptPanelSolution = t.CMDOpenPanelForRange = t.CMDOpenPanel = void 0, t.CMDOpenPanel = "github.copilot.generate", t.CMDOpenPanelForRange = "github.copilot.openPanelForRange", t.CMDAcceptPanelSolution = "github.copilot.acceptPanelSolution", t.CMDToggleCopilot = "github.copilot.toggleCopilot", t.CMDShowActivationErrors = "github.copilot.showActivationErrors", t.CMDSendFeedback = "github.copilot.sendFeedback", t.CopilotLabelPrefix = "$(copilot-logo) "
            },
            1929: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.OpenCopilotActionProvider = void 0;
                const n = r(9496),
                    o = r(256),
                    i = r(6333),
                    s = r(3060),
                    a = r(4540);
                t.OpenCopilotActionProvider = class {
                    constructor(e) {
                        this.ctx = e, this.lastVersion = 0, this.lastRange = void 0
                    }
                    indexOfGroup(e, t) {
                        let r = e.index;
                        for (let n = 1; n < t; n++) r += e[n].length;
                        return r
                    }
                    telemetryCodeAction(e, t) {
                        const r = {
                            languageId: e.languageId,
                            codeActionType: (0, o.completionTypeToString)(t)
                        };
                        (0, i.telemetry)(this.ctx, "codeAction.displayed", i.TelemetryData.createAndMarkAsIssued(r))
                    }
                    async provideCodeActions(e, t, r, i) {
                        var c;
                        if ((0, a.ignoreDocument)(this.ctx, e)) return;
                        const l = e.lineAt(t.start);
                        if (e.version === this.lastVersion && this.lastRange && this.lastRange.isEqual(t)) return;
                        this.lastVersion = e.version, this.lastRange = t;
                        const u = /^(\W+)(todo)/i.exec(l.text);
                        if (u) {
                            const r = u[u.length - 1],
                                i = this.indexOfGroup(u, u.length - 1);
                            if (new n.Range(new n.Position(t.start.line, i), new n.Position(t.start.line, i + r.length)).contains(t.start)) {
                                const t = new n.CodeAction("Implement with GitHub Copilot", n.CodeActionKind.QuickFix),
                                    r = {
                                        title: "Implement with GitHub Copilot",
                                        command: s.CMDOpenPanelForRange,
                                        arguments: [new o.CompletionContext(this.ctx, l.rangeIncludingLineBreak.end, o.CompletionType.TODO_QUICK_FIX)]
                                    };
                                return t.command = r, this.telemetryCodeAction(e, o.CompletionType.TODO_QUICK_FIX), [t]
                            }
                        }
                        const d = r.diagnostics.find((e => "ts" === e.source && 2304 === e.code));
                        if (d) {
                            const t = await n.commands.executeCommand("vscode.executeCodeActionProvider", e.uri, d.range),
                                r = null == t ? void 0 : t.find((e => e.title.startsWith("Add missing function declaration"))),
                                i = null === (c = null == r ? void 0 : r.edit) || void 0 === c ? void 0 : c.get(e.uri).pop();
                            if (i) {
                                const t = new n.CodeAction("Implement with GitHub Copilot", n.CodeActionKind.QuickFix),
                                    r = new o.CompletionContext(this.ctx, i.range.start, o.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX),
                                    a = i.newText.trim().split("\n")[0];
                                r.prependToCompletion = "\n" + a;
                                const c = {
                                    title: "Implement with GitHub Copilot",
                                    command: s.CMDOpenPanelForRange,
                                    arguments: [r]
                                };
                                return t.command = c, this.telemetryCodeAction(e, o.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX), [t]
                            }
                        }
                    }
                }
            },
            6267: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.commandOpenPanel = t.completionContextForEditor = void 0;
                const n = r(9496),
                    o = r(256);

                function i(e, t, r) {
                    return r || (0, o.completionContextForDocument)(e, t.document, t.selection.active)
                }
                t.completionContextForEditor = i, t.commandOpenPanel = function(e, t) {
                    const r = n.window.activeTextEditor;
                    if (!r) return;
                    if (!n.workspace.getConfiguration("editor", r.document.uri).get("codeLens")) return void n.window.showInformationMessage("GitHub Copilot Panel requires having Code Lens enabled. Please update your settings and then try again.", "Open Settings").then((e => {
                        "Open Settings" === e && n.commands.executeCommand("workbench.action.openSettings", "editor.codeLens")
                    }));
                    t = i(e, r, t);
                    const s = (0, o.encodeLocation)(r.document.uri, t),
                        a = r.document.languageId;
                    n.workspace.openTextDocument(s).then((e => {
                        n.languages.setTextDocumentLanguage(e, a), n.window.showTextDocument(e, n.ViewColumn.Beside)
                    }))
                }
            },
            2990: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CopilotPanel = void 0;
                const n = r(9496),
                    o = r(1133),
                    i = r(4197),
                    s = r(256),
                    a = r(893),
                    c = r(7017),
                    l = r(3060);
                t.CopilotPanel = class {
                    constructor(e) {
                        this._onDidChange = new n.EventEmitter, this._documents = new Map, this._editorDecoration = n.window.createTextEditorDecorationType({
                            textDecoration: "underline"
                        }), this._ctx = e, this._subscriptions = n.workspace.onDidCloseTextDocument((e => {
                            e.isClosed && e.uri.scheme == i.CopilotScheme && this._documents.delete(e.uri.toString())
                        }))
                    }
                    dispose() {
                        this._subscriptions.dispose(), this._documents.clear(), this._editorDecoration.dispose(), this._onDidChange.dispose()
                    }
                    get onDidChange() {
                        return this._onDidChange.event
                    }
                    async provideTextDocumentContent(e) {
                        var t;
                        let r = null === (t = this._documents.get(e.toString())) || void 0 === t ? void 0 : t.model;
                        if (r) return r.value;
                        const i = new n.CancellationTokenSource,
                            [c, l] = (0, s.decodeLocation)(this._ctx, e),
                            u = await n.workspace.openTextDocument(c);
                        return r = new a.CopilotListDocument(this._ctx, e, u, l, (0, o.getConfig)(this._ctx, o.ConfigKey.ListCount), i.token), r.onDidResultUpdated((e => this._onDidChange.fire(e))), this._documents.set(e.toString(), {
                            model: r,
                            cts: i
                        }), r.runQuery(), r.value
                    }
                    getCodeLens(e) {
                        const t = e.model;
                        let r = t.numberHeaderLines;
                        const o = t.completionContext.insertPosition,
                            i = a.CopilotListDocument.separator.split("\n").length - 1;
                        return t.solutions().map(((a, u) => {
                            const d = new n.Position(r + i, 0),
                                p = new n.Position(r + a.displayLines.length - 1, 0),
                                h = t.savedTelemetryData.extendedBy({
                                    choiceIndex: a.choiceIndex.toString()
                                }, {
                                    compCharLen: a.completionText.length,
                                    meanProb: a.meanProb,
                                    rank: u
                                });
                            h.extendWithRequestId(a.requestId), h.markAsDisplayed();
                            const f = new n.CodeLens(new n.Range(d, p), {
                                title: "Accept Solution",
                                tooltip: "Replace code with this solution",
                                command: l.CMDAcceptPanelSolution,
                                arguments: [t.targetUri, o, a.completionText, t.completionContext.completionType === s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX, async () => {
                                    const r = (await n.workspace.openTextDocument(t.targetUri)).offsetAt(o);
                                    e.cts.cancel(), await (0, c.postInsertionTasks)(this._ctx, "solution", a.completionText, r, t.targetUri, h)
                                }]
                            });
                            return r += a.displayLines.length, f
                        }))
                    }
                    provideCodeLenses(e, t) {
                        const r = this._documents.get(e.uri.toString());
                        if (r) return this.getCodeLens(r)
                    }
                }
            },
            9380: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.setupExperimentationService = t.logger = void 0;
                const n = r(9496),
                    o = r(1133),
                    i = r(9189),
                    s = r(8142),
                    a = r(9899);

                function c(e) {
                    return e.split("-")[0]
                }
                t.logger = new a.Logger(a.LogLevel.INFO, "Exp"), t.setupExperimentationService = function(e) {
                    const t = e.get(i.Features);
                    t.setPrefix(n.env.machineId), t.registerStaticFilters(function(e) {
                        const t = e.get(o.BuildInfo);
                        return {
                            [s.Filter.ApplicationVersion]: c(n.version),
                            [s.Filter.Build]: n.env.appName,
                            [s.Filter.ClientId]: n.env.machineId,
                            [s.Filter.ExtensionName]: t.getName(),
                            [s.Filter.ExtensionVersion]: c(t.getVersion()),
                            [s.Filter.Language]: n.env.language,
                            [s.Filter.TargetPopulation]: s.TargetPopulation.Public
                        }
                    }(e)), t.registerDynamicFilter(s.Filter.CopilotOverrideEngine, (() => (0, o.getConfig)(e, o.ConfigKey.DebugOverrideEngine)))
                }
            },
            6857: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.extensionFileSystem = void 0;
                const n = r(9496);
                t.extensionFileSystem = {
                    readFile: async function(e) {
                        return await n.workspace.fs.readFile(n.Uri.parse(e))
                    },
                    mtime: async function(e) {
                        return (await n.workspace.fs.stat(n.Uri.parse(e))).mtime
                    },
                    stat: async function(e) {
                        return await n.workspace.fs.stat(n.Uri.parse(e))
                    }
                }
            },
            3197: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.registerGhostText = t.handleGhostTextPostInsert = t.handleGhostTextShown = t.provideInlineCompletions = t.ghostTextLogger = t.getInsertionTextFromCompletion = void 0;
                const n = r(9496),
                    o = r(1133),
                    i = r(2218),
                    s = r(9334),
                    a = r(750),
                    c = r(9899),
                    l = r(7017),
                    u = r(4540),
                    d = "_ghostTextPostInsert";

                function p(e) {
                    return e.insertText
                }
                let h, f;
                t.getInsertionTextFromCompletion = p, t.ghostTextLogger = new c.Logger(c.LogLevel.INFO, "ghostText");
                let m, g = [];
                async function _(e, r, c, p, _) {
                    const y = await async function(e, r, a, c, p) {
                        if (! function(e) {
                                return (0, o.getConfig)(e, o.ConfigKey.InlineSuggestEnable)
                            }(e)) return {
                            type: "abortedBeforeIssued",
                            reason: "ghost text is disabled"
                        };
                        if ((0, u.ignoreDocument)(e, r)) return {
                            type: "abortedBeforeIssued",
                            reason: "document is ignored"
                        };
                        if (t.ghostTextLogger.debug(e, `Ghost text called at [${a.line}, ${a.character}], with triggerKind ${c.triggerKind}`), p.isCancellationRequested) return t.ghostTextLogger.info(e, "Cancelled before extractPrompt"), {
                            type: "abortedBeforeIssued",
                            reason: "cancelled before extractPrompt"
                        };
                        if (c.selectedCompletionInfo) return t.ghostTextLogger.debug(e, "Not showing ghost text because autocomplete widget is displayed"), {
                            type: "abortedBeforeIssued",
                            reason: "autocomplete widget is displayed"
                        };
                        const _ = await (0, s.getGhostText)(e, r, a, c.triggerKind === n.InlineCompletionTriggerKindNew.Invoke, p);
                        if ("success" !== _.type) return t.ghostTextLogger.debug(e, "Breaking, no results from getGhostText"), _;
                        const [y, v] = _.value;
                        if (h && f && (!h.isEqual(a) || f !== r.uri) && v !== s.ResultType.TypingAsSuggested) {
                            const t = g.flatMap((e => e.displayText && e.telemetry ? [{
                                completionText: e.displayText,
                                completionTelemetryData: e.telemetry
                            }] : []));
                            t.length > 0 && (0, l.postRejectionTasks)(e, "ghostText", r.offsetAt(h), f, t)
                        }
                        if (h = a, f = r.uri, g = [], p.isCancellationRequested) return t.ghostTextLogger.info(e, "Cancelled after getGhostText"), {
                            type: "canceled",
                            reason: "after getGhostText",
                            telemetryData: {
                                telemetryBlob: _.telemetryBlob
                            }
                        };
                        const b = (0, i.completionsFromGhostTextResults)(e, y, v, r, a, function(e) {
                            const t = n.window.visibleTextEditors.find((t => t.document === e));
                            return null == t ? void 0 : t.options
                        }(r), m);
                        t.ghostTextLogger.debug(e, "Completions", b);
                        const w = b.map((e => {
                            const {
                                text: t,
                                range: o
                            } = e, i = new n.Range(new n.Position(o.start.line, o.start.character), new n.Position(o.end.line, o.end.character)), s = new n.InlineCompletionItemNew(t, i);
                            return s.index = e.index, s.telemetry = e.telemetry, s.displayText = e.displayText, s.resultType = e.resultType, s.uri = r.uri, s.insertOffset = r.offsetAt(new n.Position(e.position.line, e.position.character)), s.command = {
                                title: "PostInsertTask",
                                command: d,
                                arguments: [s]
                            }, s
                        }));
                        return 0 === w.length ? {
                            type: "empty",
                            reason: "no completions in final result",
                            telemetryData: _.telemetryData
                        } : { ..._,
                            value: w
                        }
                    }(e, r, c, p, _);
                    return await (0, a.handleGhostTextResultTelemetry)(e, y)
                }
                t.provideInlineCompletions = _;
                class y {
                    constructor(e) {
                        this.ctx = e
                    }
                    async provideInlineCompletionItems(e, t, r, n) {
                        return _(this.ctx, e, t, r, n)
                    }
                    handleDidShowCompletionItem(e) {
                        v(this.ctx, e)
                    }
                }

                function v(e, r) {
                    if (m = r.index, !g.find((e => e.index === r.index)) && (g.push(r), r.telemetry)) {
                        const n = !(r.resultType === s.ResultType.Network);
                        t.ghostTextLogger.debug(e, `[${r.telemetry.properties.headerRequestId}] shown choiceIndex: ${r.telemetry.properties.choiceIndex}, fromCache ${n}`), (0, a.telemetryShown)(e, "ghostText", r.telemetry, n)
                    }
                }
                async function b(e, r) {
                    g = [], f = void 0, h = void 0, t.ghostTextLogger.debug(e, "Ghost text post insert"), r.telemetry && r.uri && r.displayText && void 0 !== r.insertOffset && r.range && (r.telemetry.measurements.compCharLen = p(r).length, await (0, l.postInsertionTasks)(e, "ghostText", r.displayText, r.insertOffset, r.uri, r.telemetry))
                }
                t.handleGhostTextShown = v, t.handleGhostTextPostInsert = b, t.registerGhostText = function(e) {
                    const t = new y(e);
                    return [n.languages.registerInlineCompletionItemProviderNew({
                        pattern: "**"
                    }, t), n.commands.registerCommand(d, (async t => b(e, t)))]
                }
            },
            47: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getGithubAccount = t.getSession = void 0;
                const n = r(9496),
                    o = ["read:user"];
                let i, s = !1;

                function a(e) {
                    if ("true" === process.env.CODESPACES && process.env.GITHUB_TOKEN) {
                        const e = process.env.GITHUB_USER || "codespace-user",
                            t = {
                                accessToken: process.env.GITHUB_TOKEN,
                                account: {
                                    label: e
                                }
                            };
                        return Promise.resolve(t)
                    }
                    return n.authentication.getSession("github", o, {
                        createIfNone: e
                    })
                }
                t.getSession = async function() {
                    let e = await a(!1);
                    return e || s || (s = !0, "Sign in to GitHub" === await n.window.showInformationMessage("Sign in to access GitHub Copilot.", "Sign in to GitHub") && (e = await a(!0))), e && (i = e.account), e
                }, t.getGithubAccount = function() {
                    return i
                }
            },
            7254: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CopilotStatusBar = void 0;
                const n = r(9496),
                    o = r(106),
                    i = r(1133),
                    s = r(6333),
                    a = r(3060);
                t.CopilotStatusBar = class {
                    constructor(e) {
                        this.ctx = e, this.showingMessage = !1, this.status = "Normal", this.errorMessage = "", this.disabledColor = new n.ThemeColor("statusBarItem.warningBackground"), this.delayedUpdateDisplay = (0, o.debounce)(100, (() => {
                            this.updateDisplay()
                        })), this.enabled = this.checkEnabledForLanguage(), this.item = n.window.createStatusBarItem(n.StatusBarAlignment.Right, 0), this.updateDisplay(), this.item.show(), n.window.onDidChangeActiveTextEditor((() => {
                            this.updateStatusBarIndicator()
                        })), n.workspace.onDidCloseTextDocument((() => {
                            this.updateStatusBarIndicator()
                        })), n.workspace.onDidOpenTextDocument((() => {
                            this.updateStatusBarIndicator()
                        }))
                    }
                    updateStatusBarIndicator() {
                        this.enabled = this.checkEnabledForLanguage(), this.updateDisplay()
                    }
                    checkEnabledForLanguage() {
                        return (0, i.getEnabledConfig)(this.ctx) || !1
                    }
                    updateDisplay() {
                        switch (this.status) {
                            case "Error":
                                this.item.text = "$(copilot-notconnected)", this.item.command = a.CMDShowActivationErrors, this.item.tooltip = "Copilot activation failed";
                                break;
                            case "Warning":
                                this.item.text = "$(copilot-warning)", this.item.command = void 0, this.item.tooltip = "Copilot is encountering temporary issues";
                                break;
                            case "InProgress":
                                this.item.text = "$(loading~spin)";
                                break;
                            case "Normal":
                                this.item.text = "$(copilot-logo)", this.item.command = a.CMDToggleCopilot, this.item.tooltip = this.enabled ? "Deactivate Copilot" : "Activate Copilot", this.item.backgroundColor = this.enabled ? void 0 : this.disabledColor
                        }
                    }
                    getStatusBarItem() {
                        return this.item
                    }
                    setProgress() {
                        "Error" !== this.status && (this.status = "InProgress", this.delayedUpdateDisplay())
                    }
                    removeProgress() {
                        "Error" !== this.status && "Warning" !== this.status && (this.status = "Normal", this.delayedUpdateDisplay())
                    }
                    setWarning() {
                        "Error" !== this.status && (this.status = "Warning", this.updateDisplay())
                    }
                    setError(e) {
                        this.status = "Error", this.errorMessage = e, this.updateDisplay()
                    }
                    toggleStatusBar() {
                        var e;
                        const t = this.ctx.get(i.ConfigProvider),
                            r = this.enabled,
                            o = null === (e = n.window.activeTextEditor) || void 0 === e ? void 0 : e.document.languageId,
                            a = "editor.action.inlineSuggest.hide";
                        if (this.showingMessage) return;
                        const c = s.TelemetryData.createAndMarkAsIssued({
                            languageId: o || "*"
                        });
                        if ((0, i.getEnabledConfig)(this.ctx, "*") == (0, i.getEnabledConfig)(this.ctx, o)) {
                            this.showingMessage = !0, setTimeout((() => {
                                this.showingMessage = !1
                            }), 15e3);
                            const e = r ? "Disable" : "Enable",
                                i = o ? [e + " Globally", e + ` for ${o}`] : [e + " Globally"];
                            n.window.showInformationMessage(`Would you like to ${r?"disable":"enable"} Copilot?`, ...i).then((e => {
                                const i = "Globally" === e;
                                this.showingMessage = !1, void 0 !== e ? ((0, s.telemetry)(this.ctx, "statusBar" + (i ? ".global" : ".language") + (r ? "Off" : "On"), c), r && n.commands.executeCommand(a), t.updateEnabledConfig(this.ctx, o || "*", i, !r).then((() => {
                                    this.enabled = !r, this.updateDisplay()
                                }))) : (0, s.telemetry)(this.ctx, "statusBar.cancelToggle")
                            }))
                        } else(0, s.telemetry)(this.ctx, "statusBar.language" + (r ? "Off" : "On"), c), r && n.commands.executeCommand(a), t.updateEnabledConfig(this.ctx, o || "*", !1, !r).then((() => {
                            this.enabled = !r, this.updateDisplay()
                        }));
                        this.updateDisplay()
                    }
                    showActivationErrors(e) {
                        this.showingMessage || (this.showingMessage = !0, n.window.showWarningMessage(this.errorMessage, "Show Output log").then((t => {
                            this.showingMessage = !1, "Show Output log" === t && e.show()
                        })))
                    }
                }
            },
            4540: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ignoreDocument = void 0;
                const n = r(1133),
                    o = r(4197);
                t.ignoreDocument = function(e, t) {
                    const r = t.languageId;
                    return !(0, n.getEnabledConfig)(e, r) || !![o.CopilotScheme, "output", "search-editor"].includes(t.uri.scheme)
                }
            },
            4428: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.activate = void 0;
                const n = r(4398),
                    o = r(1133),
                    i = r(6333),
                    s = r(9380);

                function a(e, t, r, o, a) {
                    const c = new n.default(t, r, o);
                    return (0, s.setupExperimentationService)(e), (0, i.configureReporter)(e, c, o), c
                }
                t.activate = function(e, t) {
                    const r = t.extension.packageJSON.name,
                        n = (0, o.getVersion)(e),
                        s = a(e, r, n, i.APP_INSIGHTS_KEY, t.globalState),
                        c = a(e, r, n, i.APP_INSIGHTS_KEY_SECURE, t.globalState);
                    return t.subscriptions.push(s), t.subscriptions.push(c), new i.TelemetryReporters(s, c)
                }
            },
            8129: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ExtensionLocationFactory = void 0;
                const n = r(9496),
                    o = r(6403);
                class i extends o.LocationFactory {
                    range(e, t, r, o) {
                        return void 0 !== r && void 0 !== o ? new n.Range(e, t, r, o) : new n.Range(e, t)
                    }
                    position(e, t) {
                        return new n.Position(e, t)
                    }
                }
                t.ExtensionLocationFactory = i
            },
            385: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ExtensionTextDocumentManager = void 0;
                const n = r(1017),
                    o = r(9496),
                    i = r(3136);
                class s extends i.TextDocumentManager {
                    constructor() {
                        super(...arguments), this.onDidFocusTextDocument = o.window.onDidChangeActiveTextEditor, this.onDidChangeTextDocument = o.workspace.onDidChangeTextDocument
                    }
                    get textDocuments() {
                        return o.workspace.textDocuments
                    }
                    async getTextDocument(e) {
                        return o.workspace.openTextDocument(e)
                    }
                    async getRelativePath(e) {
                        var t, r, s;
                        const a = e;
                        if (a) {
                            if (a.isUntitled) return;
                            return null !== (s = (0, i.getRelativePath)(null !== (r = null === (t = o.workspace.workspaceFolders) || void 0 === t ? void 0 : t.map((e => e.uri))) && void 0 !== r ? r : [], a.fileName)) && void 0 !== s ? s : n.basename(a.fileName)
                        }
                    }
                    findNotebook(e) {
                        const t = e;
                        return o.workspace.notebookDocuments.find((e => e.getCells().some((e => e.document === t))))
                    }
                }
                t.ExtensionTextDocumentManager = s
            },
            362: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.refreshToken = t.CopilotTokenManagerFromGitHubToken = t.FixedCopilotTokenManager = t.CopilotTokenManager = t.setTelemetryConfigFromTokenInfo = t.extractTrackingIdFromToken = t.authFromGitHubToken = t.nowSeconds = void 0;
                const n = r(1133),
                    o = r(9899),
                    i = r(2279),
                    s = r(1547),
                    a = r(6333),
                    c = r(7057),
                    l = new o.Logger(o.LogLevel.INFO, "auth");

                function u() {
                    return Math.floor(Date.now() / 1e3)
                }
                async function d(e, t) {
                    (0, a.telemetry)(e, "auth.new_login");
                    const r = await e.get(i.Fetcher).fetch("https://api.github.com/copilot_internal/v2/token", {
                        headers: {
                            Authorization: `token ${t}`
                        }
                    });
                    if (!r) return l.info(e, "Failed to get copilot token"), (0, a.telemetryError)(e, "auth.request_failed"), {
                        kind: "failure",
                        reason: "FailedToGetToken"
                    };
                    const n = await r.json();
                    return n ? (h(e, n.user_notification, t), 401 === r.status ? (l.info(e, "Failed to get copilot token due to 401 status"), (0, a.telemetryError)(e, "auth.unknown_401"), {
                        kind: "failure",
                        reason: "HTTP401"
                    }) : r.ok && n.token ? (e.get(a.TelemetryReporters).setToken(n), m(n), (0, a.telemetry)(e, "auth.new_token"), {
                        kind: "success",
                        ...n
                    }) : (l.info(e, `Invalid copilot token: missing token: ${r.status} ${r.statusText}`), (0, a.telemetryError)(e, "auth.invalid_token", a.TelemetryData.createAndMarkAsIssued({
                        status: r.status.toString(),
                        status_text: r.statusText
                    })), h(e, n.error_details, t), {
                        kind: "failure",
                        reason: "NotAuthorized"
                    })) : (l.info(e, "Failed to get copilot token"), (0, a.telemetryError)(e, "auth.request_read_failed"), {
                        kind: "failure",
                        reason: "FailedToGetToken"
                    })
                }
                t.nowSeconds = u, t.authFromGitHubToken = d;
                const p = new Map;

                function h(e, t, r) {
                    if (!t) return;
                    const o = u(),
                        a = p.get(t.message);
                    a && a > o - 5 || (p.set(t.message, o), e.get(s.NotificationSender).showWarningMessage(t.message, {
                        title: t.title
                    }, {
                        title: "Dismiss"
                    }).catch((t => {
                        console.error(t), l.error(e, `Error while sending notification: ${t.message}`)
                    })).then((async o => {
                        const s = (null == o ? void 0 : o.title) === t.title,
                            a = s || "Dismiss" === (null == o ? void 0 : o.title);
                        if (s) {
                            const r = e.get(n.EditorAndPluginInfo).getEditorPluginInfo(e),
                                o = t.url.replace("{EDITOR}", encodeURIComponent(r.name + "_" + r.version));
                            await e.get(c.UrlOpener).open(o)
                        }
                        "notification_id" in t && a && await async function(e, t, r) {
                            const n = await e.get(i.Fetcher).fetch("https://api.github.com/copilot_internal/notification", {
                                headers: {
                                    Authorization: `token ${r}`
                                },
                                method: "POST",
                                body: JSON.stringify({
                                    notification_id: t
                                })
                            });
                            n && n.ok || l.error(e, `Failed to send notification result to GitHub: ${null==n?void 0:n.status} ${null==n?void 0:n.statusText}`)
                        }(e, t.notification_id, r)
                    })))
                }

                function f(e) {
                    const t = null == e ? void 0 : e.split(":")[0],
                        r = null == t ? void 0 : t.split(";");
                    for (const e of r) {
                        const [t, r] = e.split("=");
                        if ("tid" === t) return r
                    }
                }

                function m(e) {
                    const t = f(e.token);
                    void 0 !== t && (0, a.setTelemetryConfig)({
                        trackingId: t,
                        optedIn: "enabled" === e.telemetry || "unconfigured" === e.telemetry
                    })
                }
                t.extractTrackingIdFromToken = f, t.setTelemetryConfigFromTokenInfo = m;
                class g {}

                function _(e, t, r) {
                    const n = u();
                    setTimeout((async () => {
                        let r, o = "";
                        try {
                            await t.getCopilotToken(e, !0), r = "success"
                        } catch (n) {
                            r = "failure", o = n.toString(), t.resetCopilotToken(e)
                        }
                        const i = a.TelemetryData.createAndMarkAsIssued({
                            result: r
                        }, {
                            timeTaken: u() - n
                        });
                        o && (i.properties.reason = o), (0, a.telemetry)(e, "auth.token_refresh", i)
                    }), 1e3 * r)
                }
                t.CopilotTokenManager = g, t.FixedCopilotTokenManager = class extends g {
                    constructor(e) {
                        super(), this.tokenInfo = e, this.wasReset = !1, m(e)
                    }
                    async getCopilotToken(e, t) {
                        return this.tokenInfo.token
                    }
                    resetCopilotToken(e, t) {
                        this.wasReset = !0
                    }
                    async checkCopilotToken(e) {
                        return {
                            status: "OK",
                            telemetry: this.tokenInfo.telemetry
                        }
                    }
                }, t.CopilotTokenManagerFromGitHubToken = class extends g {
                    constructor(e) {
                        super(), this.githubToken = e, this.copilotToken = void 0
                    }
                    async getCopilotToken(e, t) {
                        var r;
                        if (!this.copilotToken || this.copilotToken.expires_at < u() || t) {
                            const t = await d(e, this.githubToken);
                            if ("failure" === t.kind) throw Error(`Failed to get copilot token: ${t.reason.toString()} ${null!==(r=t.message)&&void 0!==r?r:""}`);
                            this.copilotToken = { ...t
                            }, _(e, this, t.refresh_in)
                        }
                        return this.copilotToken.token
                    }
                    async checkCopilotToken(e) {
                        if (!this.copilotToken || this.copilotToken.expires_at < u()) {
                            const t = await d(e, this.githubToken);
                            if ("failure" === t.kind) return t;
                            this.copilotToken = { ...t
                            }, _(e, this, t.refresh_in)
                        }
                        return {
                            status: "OK",
                            telemetry: this.copilotToken.telemetry
                        }
                    }
                    resetCopilotToken(e, t) {
                        void 0 !== t && (0, a.telemetry)(e, "auth.reset_token_" + t), l.debug(e, `Resetting copilot token on HTTP error ${t||"unknown"}`), this.copilotToken = void 0
                    }
                }, t.refreshToken = _
            },
            6794: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TELEMETRY_TERMS_URL = t.LAST_TELEMETRY_TERMS_UPDATE = void 0, t.LAST_TELEMETRY_TERMS_UPDATE = "2021-10-14", t.TELEMETRY_TERMS_URL = "https://github.co/copilot-telemetry-terms"
            },
            6881: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ChangeTracker = void 0;
                const n = r(3136);
                t.ChangeTracker = class {
                    constructor(e, t, r) {
                        this._referenceCount = 0, this._isDisposed = !1, this._offset = r;
                        const o = e.get(n.TextDocumentManager);
                        this._tracker = o.onDidChangeTextDocument((async e => {
                            if (e.document.uri === t)
                                for (const t of e.contentChanges)
                                    if (t.rangeOffset + t.rangeLength <= this.offset) {
                                        const e = t.text.length - t.rangeLength;
                                        this._offset = this._offset + e
                                    }
                        }))
                    }
                    get offset() {
                        return this._offset
                    }
                    push(e, t) {
                        if (this._isDisposed) throw new Error("Unable to push new actions to a disposed ChangeTracker");
                        this._referenceCount++, setTimeout((() => {
                            e(), this._referenceCount--, 0 === this._referenceCount && (this._tracker.dispose(), this._isDisposed = !0)
                        }), t)
                    }
                }
            },
            299: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Clock = void 0, t.Clock = class {
                    now() {
                        return new Date
                    }
                }
            },
            3076: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.LRUCache = t.keyForPrompt = void 0;
                const n = r(1354);
                t.keyForPrompt = function(e) {
                    return (0, n.SHA256)(e.prefix + e.suffix).toString()
                }, t.LRUCache = class {
                    constructor(e = 10) {
                        this.values = new Map, this.lruKeys = [], this.size = e
                    }
                    removeKeyFromLRU(e) {
                        const t = this.lruKeys.indexOf(e); - 1 !== t && this.lruKeys.splice(t, 1)
                    }
                    touchKeyInLRU(e) {
                        this.removeKeyFromLRU(e), this.lruKeys.push(e)
                    }
                    clear() {
                        this.values.clear(), this.lruKeys = []
                    }
                    deleteKey(e) {
                        this.removeKeyFromLRU(e), void 0 !== this.values.get(e) && this.values.delete(e)
                    }
                    get(e) {
                        if (this.values.has(e)) {
                            const t = this.values.get(e);
                            return this.touchKeyInLRU(e), t
                        }
                    }
                    put(e, t) {
                        let r = [];
                        this.values.has(e) ? r = [e] : this.lruKeys.length >= this.size && (r = this.lruKeys.splice(0, 1));
                        for (const e of r) this.deleteKey(e);
                        this.values.set(e, t), this.touchKeyInLRU(e)
                    }
                }
            },
            106: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.debounce = t.Debouncer = void 0, t.Debouncer = class {
                    async debounce(e) {
                        return this.state && (clearTimeout(this.state.timer), this.state.reject(), this.state = void 0), new Promise(((t, r) => {
                            this.state = {
                                timer: setTimeout((() => t()), e),
                                reject: r
                            }
                        }))
                    }
                }, t.debounce = function(e, t) {
                    let r;
                    return (...n) => (r && clearTimeout(r), new Promise((o => {
                        r = setTimeout((() => {
                            const e = t(...n);
                            o(e)
                        }), e)
                    })))
                }
            },
            6932: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.asyncIterableFromArray = t.asyncIterableMapFilter = t.asyncIterableFilter = t.asyncIterableMap = void 0, t.asyncIterableMap = async function*(e, t) {
                    for await (const r of e) yield t(r)
                }, t.asyncIterableFilter = async function*(e, t) {
                    for await (const r of e) await t(r) && (yield r)
                }, t.asyncIterableMapFilter = async function*(e, t) {
                    for await (const r of e) {
                        const e = await t(r);
                        void 0 !== e && (yield e)
                    }
                }, t.asyncIterableFromArray = async function*(e) {
                    for (const t of e) yield t
                }
            },
            1133: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.EditorAndPluginInfo = t.formatNameAndVersion = t.getTestVscInfo = t.VscInfo = t.getVersion = t.getBuild = t.getBuildType = t.isProduction = t.BuildInfo = t.suffixPercent = t.getEnabledConfig = t.getLanguageConfig = t.dumpConfig = t.getHiddenConfig = t.isDefaultSettingOverwritten = t.getConfig = t.getConfigDefaultForObjectKey = t.getConfigDefaultForKey = t.InMemoryConfigProvider = t.DefaultsOnlyConfigProvider = t.ConfigProvider = t.ConfigBlockModeConfig = t.BlockModeConfig = t.BuildType = t.BlockMode = t.ConfigKey = void 0;
                const n = r(3055),
                    o = r(4197),
                    i = r(9189),
                    s = r(4147);
                var a, c;
                t.ConfigKey = {
                        Enable: "enable",
                        InlineSuggestEnable: "inlineSuggest.enable",
                        ShowEditorCompletions: ["editor", "showEditorCompletions"],
                        EnableAutoCompletions: ["editor", "enableAutoCompletions"],
                        DelayCompletions: ["editor", "delayCompletions"],
                        FilterCompletions: ["editor", "filterCompletions"],
                        DisplayStyle: ["advanced", "displayStyle"],
                        SecretKey: ["advanced", "secret_key"],
                        SolutionLength: ["advanced", "length"],
                        Stops: ["advanced", "stops"],
                        Temperature: ["advanced", "temperature"],
                        TopP: ["advanced", "top_p"],
                        IndentationMode: ["advanced", "indentationMode"],
                        InlineSuggestCount: ["advanced", "inlineSuggestCount"],
                        ListCount: ["advanced", "listCount"],
                        DebugOverrideProxyUrl: ["advanced", "debug.overrideProxyUrl"],
                        DebugTestOverrideProxyUrl: ["advanced", "debug.testOverrideProxyUrl"],
                        DebugOverrideEngine: ["advanced", "debug.overrideEngine"],
                        DebugShowScores: ["advanced", "debug.showScores"],
                        DebugOverrideLogLevels: ["advanced", "debug.overrideLogLevels"],
                        DebugFilterLogCategories: ["advanced", "debug.filterLogCategories"],
                        DebugUseSuffix: ["advanced", "debug.useSuffix"],
                        DebugAcceptSelfSignedCertificate: ["advanced", "debug.acceptSelfSignedCertificate"]
                    },
                    function(e) {
                        e.Parsing = "parsing", e.Server = "server"
                    }(a = t.BlockMode || (t.BlockMode = {})), (c = t.BuildType || (t.BuildType = {})).DEV = "dev", c.PROD = "prod", c.NIGHTLY = "nightly";
                class l {}
                t.BlockModeConfig = l, t.ConfigBlockModeConfig = class extends l {
                    async forLanguage(e, r) {
                        if (e.get(u).isDefaultSettingOverwritten(t.ConfigKey.IndentationMode)) switch (e.get(u).getLanguageConfig(t.ConfigKey.IndentationMode, r)) {
                            case "client":
                            case !0:
                            case "server":
                                return a.Server;
                            default:
                                return a.Parsing
                        }
                        return await e.get(i.Features).overrideBlockMode() || ((0, n.isSupportedLanguageId)(r) ? a.Parsing : a.Server)
                    }
                };
                class u {}

                function d(e) {
                    try {
                        const t = s.contributes.configuration[0].properties[`${o.CopilotConfigPrefix}.${e}`].default;
                        if (void 0 === t) throw new Error(`Missing config default value: ${o.CopilotConfigPrefix}.${e}`);
                        return t
                    } catch (t) {
                        throw new Error(`Error inspecting config default value ${o.CopilotConfigPrefix}.${e}: ${t}`)
                    }
                }

                function p(e, t) {
                    try {
                        const r = s.contributes.configuration[0].properties[`${o.CopilotConfigPrefix}.${e}`].properties[t].default;
                        if (void 0 === r) throw new Error(`Missing config default value: ${o.CopilotConfigPrefix}.${e}`);
                        return r
                    } catch (r) {
                        throw new Error(`Error inspecting config default value ${o.CopilotConfigPrefix}.${e}.${t}: ${r}`)
                    }
                }

                function h(e, t) {
                    return e.get(u).getConfig(t)
                }

                function f(e, t) {
                    return e.get(u).isDefaultSettingOverwritten(t)
                }

                function m(e, t, r) {
                    return f(e, t) ? h(e, t) : r.default
                }

                function g(e, t, r) {
                    return e.get(u).getLanguageConfig(t, r)
                }
                t.ConfigProvider = u, t.DefaultsOnlyConfigProvider = class extends u {
                    getConfig(e) {
                        return Array.isArray(e) ? p(e[0], e[1]) : d(e)
                    }
                    isDefaultSettingOverwritten(e) {
                        return !1
                    }
                    dumpConfig() {
                        return {}
                    }
                    getLanguageConfig(e, t) {
                        const r = this.getConfig(e);
                        return t && t in r ? r[t] : r["*"]
                    }
                }, t.InMemoryConfigProvider = class {
                    constructor(e, t) {
                        this.baseConfigProvider = e, this.overrides = t
                    }
                    getConfig(e) {
                        const t = this.overrides.get(e);
                        return void 0 !== t ? t : this.baseConfigProvider.getConfig(e)
                    }
                    setConfig(e, t) {
                        void 0 !== t ? this.overrides.set(e, t) : this.overrides.delete(e)
                    }
                    setLanguageEnablement(e, r) {
                        this.overrides.set(t.ConfigKey.Enable, {
                            [e]: r
                        })
                    }
                    isDefaultSettingOverwritten(e) {
                        return !!this.overrides.has(e) || this.baseConfigProvider.isDefaultSettingOverwritten(e)
                    }
                    keyAsString(e) {
                        return Array.isArray(e) ? e.join(".") : e
                    }
                    dumpConfig() {
                        const e = this.baseConfigProvider.dumpConfig();
                        return this.overrides.forEach(((t, r) => {
                            e[this.keyAsString(r)] = JSON.stringify(t)
                        })), e
                    }
                    getLanguageConfig(e, t) {
                        const r = this.overrides.get(e);
                        return void 0 !== r ? void 0 !== t ? r[t] : r["*"] : this.baseConfigProvider.getLanguageConfig(e, t)
                    }
                }, t.getConfigDefaultForKey = d, t.getConfigDefaultForObjectKey = p, t.getConfig = h, t.isDefaultSettingOverwritten = f, t.getHiddenConfig = m, t.dumpConfig = function(e) {
                    return e.get(u).dumpConfig()
                }, t.getLanguageConfig = g, t.getEnabledConfig = function(e, r) {
                    return g(e, t.ConfigKey.Enable, r)
                }, t.suffixPercent = async function(e, r, n) {
                    return m(e, t.ConfigKey.DebugUseSuffix, {
                        default: !1
                    }) ? 15 : e.get(i.Features).suffixPercent(r, n)
                };
                class _ {
                    constructor() {
                        this.packageJson = s
                    }
                    isProduction() {
                        return "dev" != this.getBuildType()
                    }
                    getBuildType() {
                        return this.packageJson.buildType
                    }
                    getVersion() {
                        return this.packageJson.version
                    }
                    getBuild() {
                        return this.packageJson.build
                    }
                    getName() {
                        return this.packageJson.name
                    }
                }
                t.BuildInfo = _, t.isProduction = function(e) {
                    return e.get(_).isProduction()
                }, t.getBuildType = function(e) {
                    return e.get(_).getBuildType()
                }, t.getBuild = function(e) {
                    return e.get(_).getBuild()
                }, t.getVersion = function(e) {
                    return e.get(_).getVersion()
                };
                class y {
                    constructor(e, t, r) {
                        this.sessionId = e, this.machineId = t, this.vsCodeVersion = r
                    }
                }
                t.VscInfo = y, t.getTestVscInfo = function() {
                    return new y("test-session-id", "test-machine-id", "test-vscode-version")
                }, t.formatNameAndVersion = function({
                    name: e,
                    version: t
                }) {
                    return `${e}/${t}`
                }, t.EditorAndPluginInfo = class {}
            },
            4197: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CopilotScheme = t.CopilotConfigPrefix = void 0, t.CopilotConfigPrefix = "github.copilot", t.CopilotScheme = "copilot"
            },
            7870: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Context = void 0, t.Context = class {
                    constructor(e) {
                        var t;
                        this.baseContext = e, this.constructionStack = [], this.instances = new Map;
                        const r = null === (t = (new Error).stack) || void 0 === t ? void 0 : t.split("\n");
                        r && this.constructionStack.push(...r.slice(1))
                    }
                    get(e) {
                        const t = this.tryGet(e);
                        if (t) return t;
                        throw new Error(`No instance of ${e.name} has been registered.\n${this}`)
                    }
                    tryGet(e) {
                        return this.instances.get(e) || (this.baseContext ? this.baseContext.tryGet(e) : void 0)
                    }
                    set(e, t) {
                        if (this.tryGet(e)) throw new Error(`An instance of ${e.name} has already been registered. Use forceSet() if you're sure it's a good idea.`);
                        this.instances.set(e, t)
                    }
                    forceSet(e, t) {
                        this.instances.set(e, t)
                    }
                    toString() {
                        var e, t;
                        let r = "    Context created at:\n";
                        for (const e of this.constructionStack || []) r += `    ${e}\n`;
                        return r += null !== (t = null === (e = this.baseContext) || void 0 === e ? void 0 : e.toString()) && void 0 !== t ? t : "", r
                    }
                    get debug() {
                        const e = {};
                        for (const [t, r] of this.instances) e[t.name] = r;
                        return e
                    }
                }
            },
            256: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.decodeLocation = t.encodeLocation = t.completionContextForDocument = t.CompletionContext = t.completionTypeToString = t.CompletionType = void 0;
                const n = r(7373),
                    o = r(6403),
                    i = r(4197);
                var s;
                ! function(e) {
                    e[e.OPEN_COPILOT = 2] = "OPEN_COPILOT", e[e.TODO_QUICK_FIX = 3] = "TODO_QUICK_FIX", e[e.UNKNOWN_FUNCTION_QUICK_FIX = 4] = "UNKNOWN_FUNCTION_QUICK_FIX"
                }(s = t.CompletionType || (t.CompletionType = {})), t.completionTypeToString = function(e) {
                    switch (e) {
                        case s.OPEN_COPILOT:
                            return "open copilot";
                        case s.TODO_QUICK_FIX:
                            return "todo quick fix";
                        case s.UNKNOWN_FUNCTION_QUICK_FIX:
                            return "unknown function quick fix";
                        default:
                            return "unknown"
                    }
                };
                class a {
                    constructor(e, t, r) {
                        this.prependToCompletion = "", this.appendToCompletion = "", this.indentation = null, this.completionType = s.OPEN_COPILOT, this.insertPosition = e.get(o.LocationFactory).position(t.line, t.character), this.completionType = r
                    }
                    static fromJSONParse(e, t) {
                        const r = e.get(o.LocationFactory).position(t.insertPosition.line, t.insertPosition.character),
                            n = new a(e, r, t.completionType);
                        return n.prependToCompletion = t.prependToCompletion, n.appendToCompletion = t.appendToCompletion, n.indentation = t.indentation, n
                    }
                }
                t.CompletionContext = a, t.completionContextForDocument = function(e, t, r) {
                    let n = r;
                    const o = t.lineAt(r.line);
                    return o.isEmptyOrWhitespace || (n = o.range.end), new a(e, n, s.OPEN_COPILOT)
                };
                let c = 0;
                t.encodeLocation = function(e, t) {
                    const r = e.toString().split("#"),
                        o = r.length > 1 ? r[1] : "",
                        s = JSON.stringify([r[0], t, o]);
                    return n.URI.parse(`${i.CopilotScheme}:GitHub%20Copilot?${s}#${c++}`)
                }, t.decodeLocation = function(e, t) {
                    const [r, o, i] = JSON.parse(t.query);
                    return [n.URI.parse(i.length > 0 ? r + "#" + i : r), a.fromJSONParse(e, o)]
                }
            },
            893: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CopilotListDocument = void 0;
                const n = r(106),
                    o = r(1133),
                    i = r(6333),
                    s = r(2388);
                class a {
                    constructor(e, t, r, s, a, c) {
                        this.targetDocument = r, this.completionContext = s, this.token = c, this._solutionCount = 0, this.solutionCountTarget = 0, this._solutions = [], this._wasCancelled = !1, this._updateHandlers = new Set, this.savedTelemetryData = i.TelemetryData.createAndMarkAsIssued(), this.debouncedEventFire = (0, n.debounce)(10, (() => this._updateHandlers.forEach((e => e(this._uri))))), this.onDidResultUpdated = e => (this._updateHandlers.add(e), {
                            dispose: () => {
                                this._updateHandlers.delete(e)
                            }
                        }), this.solutionCountTarget = a, this._ctx = e, this._uri = t, this._showLogprobs = (0, o.getConfig)(e, o.ConfigKey.DebugShowScores), this.startPosition = this.completionContext.insertPosition, this.numberHeaderLines = Math.max(1, this.formatDisplayLines("").length - 1)
                    }
                    async getDocument() {
                        return this.targetDocument
                    }
                    get targetUri() {
                        return this.targetDocument.uri
                    }
                    header() {
                        if (this._wasCancelled) return "No synthesized solutions found."; {
                            const e = this._solutionCount - this._solutions.length > 0 ? " (Duplicates hidden)" : "";
                            return `Synthesizing ${this._solutionCount}/${this.solutionCountTarget} solutions${e}`
                        }
                    }
                    areSolutionsDuplicates(e, t) {
                        return (0, s.normalizeCompletionText)(e.completionText) === (0, s.normalizeCompletionText)(t.completionText)
                    }
                    insertSorted(e, t, r) {
                        if (!/^\s*$/.test(t.completionText)) {
                            for (let n = 0; n < e.length; n++) {
                                const o = e[n];
                                if (this.areSolutionsDuplicates(o, t)) {
                                    if (r(o) < r(t)) {
                                        e.splice(n, 1);
                                        break
                                    }
                                    return
                                }
                            }
                            for (let n = 0; n < e.length; n++)
                                if (r(e[n]) < r(t)) return void e.splice(n, 0, t);
                            e.push(t)
                        }
                    }
                    reportCancelled() {
                        this._wasCancelled = !0, this.debouncedEventFire()
                    }
                    getCancellationToken() {
                        return this.token
                    }
                    insertSolution(e) {
                        const t = {
                            displayLines: this.formatDisplayLines(e.displayText, e.meanProb, e.meanLogProb),
                            completionText: e.completionText,
                            meanLogProb: e.meanLogProb,
                            meanProb: e.meanProb,
                            prependToCompletion: e.prependToCompletion,
                            requestId: e.requestId,
                            choiceIndex: e.choiceIndex
                        };
                        this.insertSorted(this._solutions, t, (e => e.meanProb)), this._solutionCount++, this.debouncedEventFire()
                    }
                    formatDisplayLines(e, t, r) {
                        let n = "";
                        return this._showLogprobs && (r = r || 0, n += `\n\t# mean prob: ${t}`), `${a.separator}${n}\n\n${e}`.split("\n")
                    }
                    async runQuery() {
                        const e = await (0, s.launchSolutions)(this._ctx, this);
                        this.processNextSolution(e)
                    }
                    async processNextSolution(e) {
                        switch (e.status) {
                            case "FinishedNormally":
                            case "FinishedWithError":
                                return;
                            case "Solution":
                                this.insertSolution(e.solution), this.processNextSolution(await e.next)
                        }
                    }
                    solutionsReceived() {
                        return this._solutionCount
                    }
                    solutions() {
                        return this._solutions
                    }
                    get value() {
                        return [this.header()].concat(this._solutions.flatMap((e => e.displayLines))).concat("").join("\n")
                    }
                }
                t.CopilotListDocument = a, a.separator = "\n======="
            },
            2388: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.launchSolutions = t.normalizeCompletionText = void 0;
                const n = r(2277),
                    o = r(6932),
                    i = r(1133),
                    s = r(256),
                    a = r(9899),
                    c = r(3),
                    l = r(937),
                    u = r(6722),
                    d = r(7727),
                    p = r(4969),
                    h = r(2533),
                    f = r(766),
                    m = r(1124),
                    g = r(6333),
                    _ = r(6403),
                    y = new a.Logger(a.LogLevel.INFO, "solutions");
                async function v(e, t, r) {
                    if (t.isCancellationRequested) return e.removeProgress(), {
                        status: "FinishedWithError",
                        error: "Cancelled"
                    };
                    const n = await r.next();
                    return !0 === n.done ? (e.removeProgress(), {
                        status: "FinishedNormally"
                    }) : {
                        status: "Solution",
                        solution: n.value,
                        next: v(e, t, r)
                    }
                }
                t.normalizeCompletionText = function(e) {
                    return e.replace(/\s+/g, "")
                }, t.launchSolutions = async function(e, t) {
                    var r, a;
                    const b = t.completionContext.insertPosition,
                        w = t.completionContext.prependToCompletion,
                        x = t.completionContext.indentation,
                        E = e.get(_.LocationFactory),
                        C = await t.getDocument(),
                        S = await (0, p.extractPrompt)(e, C, b);
                    if ("contextTooShort" === S.type) return t.reportCancelled(), {
                        status: "FinishedWithError",
                        error: "Context too short"
                    };
                    const T = S.prompt,
                        k = S.trailingWs;
                    k.length > 0 && (t.startPosition = E.position(t.startPosition.line, t.startPosition.character - k.length));
                    const I = t.getCancellationToken(),
                        P = n.v4();
                    if (t.savedTelemetryData = g.TelemetryData.createAndMarkAsIssued({
                            headerRequestId: P,
                            languageId: C.languageId,
                            source: (0, s.completionTypeToString)(t.completionContext.completionType)
                        }, { ...(0, g.telemetrizePromptLength)(T),
                            solutionCount: t.solutionCountTarget,
                            promptEndPos: C.offsetAt(b)
                        }), t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX) {
                        const e = T.prefix.split("\n"),
                            t = e.pop(),
                            r = e.pop();
                        if (r) {
                            const n = /^\W+(todo:?\s+)/i.exec(r);
                            if (n) {
                                const o = n[1],
                                    i = r.replace(o, "");
                                T.prefix = e.join("\n") + "\n" + i + "\n" + t
                            }
                        }
                    }
                    t.completionContext.completionType === s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX && (T.prefix += t.completionContext.prependToCompletion), y.info(e, `prompt: ${JSON.stringify(T)}`), y.debug(e, `prependToCompletion: ${w}`), (0, g.telemetry)(e, "solution.requested", t.savedTelemetryData);
                    const A = await e.get(i.BlockModeConfig).forLanguage(e, C.languageId),
                        O = (0, h.isSupportedLanguageId)(C.languageId),
                        N = (0, d.contextIndentation)(C, b),
                        R = {
                            stream: !0,
                            extra: {
                                language: C.languageId,
                                next_indent: null !== (r = N.next) && void 0 !== r ? r : 0
                            }
                        };
                    "parsing" !== A || O || (R.stop = ["\n\n", "\r\n\r\n"]);
                    const $ = (0, f.extractRepoInfoInBackground)(e, C.fileName),
                        M = {
                            prompt: T,
                            languageId: C.languageId,
                            repoInfo: $,
                            ourRequestId: P,
                            engineUrl: await (0, c.getEngineURL)(e, (0, f.tryGetGitHubNWO)($), C.languageId, t.savedTelemetryData),
                            count: t.solutionCountTarget,
                            uiKind: l.CopilotUiKind.Panel,
                            postOptions: R
                        };
                    let D;
                    const L = t.completionContext.completionType === s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX ? [s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX, t.completionContext.prependToCompletion] : t.completionContext.completionType;
                    switch (A) {
                        case i.BlockMode.Server:
                            D = async e => {}, R.extra.force_indent = null !== (a = N.prev) && void 0 !== a ? a : -1;
                            break;
                        case i.BlockMode.Parsing:
                        default:
                            D = O ? function(e, t, r, n) {
                                return async o => {
                                    if (n instanceof Array) {
                                        const [i, s] = n;
                                        return (0, d.isBlockBodyFinishedWithPrefix)(e, t, r, o, s)
                                    }
                                    return (0, d.isBlockBodyFinished)(e, t, r, o)
                                }
                            }(e, C, t.startPosition, L) : async e => {}
                    }
                    e.get(u.StatusReporter).setProgress();
                    const F = await e.get(l.OpenAIFetcher).fetchAndStreamCompletions(e, M, g.TelemetryData.createAndMarkAsIssued(), D, I);
                    if ("failed" === F.type || "canceled" === F.type) return t.reportCancelled(), e.get(u.StatusReporter).removeProgress(), {
                        status: "FinishedWithError",
                        error: `${F.type}: ${F.reason}`
                    };
                    let j = F.choices;
                    j = async function*(e, t) {
                        for await (const r of e) {
                            const e = { ...r
                            };
                            e.completionText = t + e.completionText.trimRight(), yield e
                        }
                    }(j, w), null !== x && (j = (0, l.cleanupIndentChoices)(j, x)), j = (0, o.asyncIterableMapFilter)(j, (async t => (0, m.postProcessChoice)(e, "solution", C, b, t, !1, y)));
                    const B = (0, o.asyncIterableMapFilter)(j, (async r => {
                        let n = r.completionText;
                        if (y.info(e, `Open Copilot completion: [${r.completionText}]`), t.completionContext.completionType === s.CompletionType.OPEN_COPILOT || t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX) {
                            let t = "";
                            const o = await (0, d.getNodeStart)(e, C, b, r.completionText);
                            if (o)[t] = (0, p.trimLastLine)(C.getText(E.range(E.position(o.line, o.character), b)));
                            else {
                                const e = E.position(b.line, 0);
                                t = C.getText(E.range(e, b))
                            }
                            n = t + n
                        }
                        let o = r.completionText;
                        t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX && (C.lineAt(b.line).isEmptyOrWhitespace || (o += "\n")), k.length > 0 && o.startsWith(k) && (o = o.substring(k.length));
                        const i = r.meanLogProb;
                        return {
                            displayText: n,
                            meanProb: void 0 !== i ? Math.exp(i) : 0,
                            meanLogProb: i || 0,
                            completionText: o,
                            requestId: r.requestId,
                            choiceIndex: r.choiceIndex,
                            prependToCompletion: w
                        }
                    }));
                    return v(e.get(u.StatusReporter), I, B[Symbol.asyncIterator]())
                }
            },
            9408: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.registerDefaultHandlers = void 0;
                const n = r(2279),
                    o = r(6333);
                t.registerDefaultHandlers = function(e, t) {
                    process.addListener("uncaughtException", (t => {
                        console.error("uncaughtException", t), o.telemetryException(e, t, "uncaughtException")
                    })), process.addListener("unhandledRejection", ((r, i) => {
                        if ("vscode" === t && !r) return;
                        if ("aborted" === r.type || (0, n.isAbortError)(r)) return;
                        if ("vscode" === t && ["ENOTFOUND", "ECONNREFUSED", "ECONNRESET", "ETIMEDOUT", "ENETDOWN", "ENETUNREACH", "EADDRNOTAVAIL"].includes(r.code)) return;
                        if ("ENOENT" == r.code) return;
                        let s = "";
                        try {
                            s = `${r.message} (${r.code})`, s = JSON.stringify(r)
                        } catch (e) {
                            s = "[actual reason JSON was cyclic]"
                        }
                        "vscode" === t && "{}" === s || (console.error("unhandledRejection", s), o.telemetryError(e, "unhandledRejection", o.TelemetryData.createAndMarkAsIssued({
                            origin: "unhandledRejection",
                            reason: "Unhandled rejection logged to restricted telemetry"
                        }), !1), o.telemetryError(e, "unhandledRejection", o.TelemetryData.createAndMarkAsIssued({
                            origin: "unhandledRejection",
                            reason: s
                        }), !0))
                    }))
                }
            },
            1839: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.registerDocumentTracker = t.sortByAccessTimes = void 0;
                const n = r(3136),
                    o = new Map;
                t.sortByAccessTimes = function(e) {
                    return [...e].sort(((e, t) => {
                        var r, n;
                        const i = null !== (r = o.get(e.uri.toString())) && void 0 !== r ? r : 0;
                        return (null !== (n = o.get(t.uri.toString())) && void 0 !== n ? n : 0) - i
                    }))
                }, t.registerDocumentTracker = e => e.get(n.TextDocumentManager).onDidFocusTextDocument((e => {
                    e && o.set(e.document.uri.toString(), Date.now())
                }))
            },
            219: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ExpConfig = t.ExpTreatmentVariables = void 0;
                const n = r(6333),
                    o = r(6500);
                var i;
                (i = t.ExpTreatmentVariables || (t.ExpTreatmentVariables = {})).AA = "copilotaa", i.CustomEngine = "copilotcustomengine", i.Fetcher = "copilotfetcher", i.OverrideBlockMode = "copilotoverrideblockmode", i.OverrideNumGhostCompletions = "copilotoverridednumghostcompletions", i.SuffixPercent = "CopilotSuffixPercent", i.BeforeRequestWaitMs = "copilotlms", i.NeighboringTabsOption = "copilotneighboringtabs", i.GranularityTimePeriodSizeInH = "copilottimeperiodsizeinh", i.GranularityByCallBuckets = "copilotbycallbuckets", i.SuffixStartMode = "copilotsuffixstartmode";
                class s {
                    constructor(e, t, r) {
                        this.variables = e, this.assignmentContext = t, this.features = r
                    }
                    static createFallbackConfig(e, t) {
                        return (0, n.telemetryExpProblem)(e, {
                            reason: t
                        }), this.createEmptyConfig()
                    }
                    static createEmptyConfig() {
                        return new s({}, "", "")
                    }
                    addToTelemetry(e) {
                        e.properties[o.ExpServiceTelemetryNames.featuresTelemetryPropertyName] = this.features, e.properties[o.ExpServiceTelemetryNames.assignmentContextTelemetryPropertyName] = this.assignmentContext
                    }
                }
                t.ExpConfig = s
            },
            9189: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Features = t.Task = void 0;
                const n = r(3055),
                    o = r(299),
                    i = r(3076),
                    s = r(219),
                    a = r(9748),
                    c = r(8142),
                    l = r(9030);
                class u {
                    constructor(e) {
                        this.ctx = e, this.cache = new i.LRUCache(200)
                    }
                    async fetchExpConfig(e) {
                        let t = this.cache.get(e.stringify());
                        return t || (t = new d((() => this.ctx.get(a.ExpConfigMaker).fetchExperiments(this.ctx, e.toHeaders())), 36e5), this.cache.put(e.stringify(), t)), t.run()
                    }
                    getCachedExpConfig(e) {
                        const t = this.cache.get(e.stringify());
                        return null == t ? void 0 : t.value()
                    }
                }
                class d {
                    constructor(e, t = 1 / 0) {
                        this.producer = e, this.expirationMs = t
                    }
                    async run() {
                        return void 0 === this.promise && (this.promise = this.producer(), this.storeResult(this.promise).then((() => {
                            this.expirationMs < 1 / 0 && void 0 !== this.promise && setTimeout((() => this.promise = void 0), this.expirationMs)
                        }))), this.promise
                    }
                    async storeResult(e) {
                        try {
                            this.result = await e
                        } finally {
                            void 0 === this.result && (this.promise = void 0)
                        }
                    }
                    value() {
                        return this.result
                    }
                }
                t.Task = d;
                class p {
                    constructor(e) {
                        this.ctx = e, this.staticFilters = {}, this.dynamicFilters = {}, this.upcomingDynamicFilters = {}, this.assignments = new u(this.ctx), this.granularityDirectory = new l.GranularityDirectory("unspecified", e.get(o.Clock))
                    }
                    setPrefix(e) {
                        this.granularityDirectory = new l.GranularityDirectory(e, this.ctx.get(o.Clock))
                    }
                    registerStaticFilters(e) {
                        Object.assign(this.staticFilters, e)
                    }
                    registerDynamicFilter(e, t) {
                        this.dynamicFilters[e] = t
                    }
                    getDynamicFilterValues() {
                        const e = {};
                        for (const [t, r] of Object.entries(this.dynamicFilters)) e[t] = r();
                        return e
                    }
                    registerUpcomingDynamicFilter(e, t) {
                        this.upcomingDynamicFilters[e] = t
                    }
                    async getAssignment(e, t = {}, r) {
                        var n, o;
                        const i = this.makeFilterSettings(t),
                            a = this.granularityDirectory.extendFilters(i),
                            c = await this.getExpConfig(a.newFilterSettings);
                        this.granularityDirectory.update(i, +(null !== (n = c.variables[s.ExpTreatmentVariables.GranularityByCallBuckets]) && void 0 !== n ? n : NaN), +(null !== (o = c.variables[s.ExpTreatmentVariables.GranularityTimePeriodSizeInH]) && void 0 !== o ? o : NaN));
                        const l = this.granularityDirectory.extendFilters(i),
                            u = l.newFilterSettings,
                            d = await this.getExpConfig(u);
                        let h = new Promise((e => setTimeout(e, p.upcomingDynamicFilterCheckDelayMs)));
                        for (const e of l.otherFilterSettingsToPrefetch) h = h.then((async () => {
                            await new Promise((e => setTimeout(e, p.upcomingDynamicFilterCheckDelayMs))), this.getExpConfig(e)
                        }));
                        return this.prepareForUpcomingFilters(u), r && (r.filtersAndExp = {
                            exp: d,
                            filters: u
                        }), d.variables[e]
                    }
                    makeFilterSettings(e) {
                        return new c.FilterSettings({ ...this.staticFilters,
                            ...this.getDynamicFilterValues(),
                            ...e
                        })
                    }
                    async getExpConfig(e) {
                        try {
                            return this.assignments.fetchExpConfig(e)
                        } catch (e) {
                            return s.ExpConfig.createFallbackConfig(this.ctx, `Error fetching ExP config: ${e}`)
                        }
                    }
                    async prepareForUpcomingFilters(e) {
                        if (!((new Date).getMinutes() < 60 - p.upcomingTimeBucketMinutes))
                            for (const [t, r] of Object.entries(this.upcomingDynamicFilters)) await new Promise((e => setTimeout(e, p.upcomingDynamicFilterCheckDelayMs))), this.getExpConfig(e.withChange(t, r()))
                    }
                    stringify() {
                        var e;
                        const t = this.assignments.getCachedExpConfig(new c.FilterSettings({}));
                        return JSON.stringify(null !== (e = null == t ? void 0 : t.variables) && void 0 !== e ? e : {})
                    }
                    async customEngine(e, t, r) {
                        var n;
                        const o = {
                            [c.Filter.CopilotRepository]: e,
                            [c.Filter.CopilotFileType]: t
                        };
                        return null !== (n = await this.getAssignment(s.ExpTreatmentVariables.CustomEngine, o, r)) && void 0 !== n ? n : ""
                    }
                    async beforeRequestWaitMs(e, t, r) {
                        var n;
                        const o = {
                            [c.Filter.CopilotRepository]: e,
                            [c.Filter.CopilotFileType]: t
                        };
                        return null !== (n = await this.getAssignment(s.ExpTreatmentVariables.BeforeRequestWaitMs, o, r)) && void 0 !== n ? n : 0
                    }
                    async overrideBlockMode() {
                        return await this.getAssignment(s.ExpTreatmentVariables.OverrideBlockMode)
                    }
                    async overrideNumGhostCompletions() {
                        return await this.getAssignment(s.ExpTreatmentVariables.OverrideNumGhostCompletions)
                    }
                    async suffixPercent(e, t) {
                        var r;
                        const n = {
                            [c.Filter.CopilotRepository]: e,
                            [c.Filter.CopilotFileType]: t
                        };
                        return null !== (r = await this.getAssignment(s.ExpTreatmentVariables.SuffixPercent, n)) && void 0 !== r ? r : 0
                    }
                    async suffixStartMode(e, t) {
                        const r = {
                            [c.Filter.CopilotRepository]: e,
                            [c.Filter.CopilotFileType]: t
                        };
                        switch (await this.getAssignment(s.ExpTreatmentVariables.SuffixStartMode, r)) {
                            default: return n.SuffixStartMode.Cursor;
                            case "cursortrimstart":
                                    return n.SuffixStartMode.CursorTrimStart;
                            case "cursortrimstartwithstop":
                                    return n.SuffixStartMode.CursorTrimStartWithStop;
                            case "siblingblock":
                                    return n.SuffixStartMode.SiblingBlock;
                            case "siblingblockwithstop":
                                    return n.SuffixStartMode.SiblingBlockWithStop;
                            case "siblingblocktrimstart":
                                    return n.SuffixStartMode.SiblingBlockTrimStart;
                            case "siblingblocktrimstartwithstop":
                                    return n.SuffixStartMode.SiblingBlockTrimStartWithStop
                        }
                    }
                    async neighboringTabsOption(e, t) {
                        const r = {
                            [c.Filter.CopilotRepository]: e,
                            [c.Filter.CopilotFileType]: t
                        };
                        switch (await this.getAssignment(s.ExpTreatmentVariables.NeighboringTabsOption, r)) {
                            case "none":
                                return n.NeighboringTabsOption.None;
                            case "conservative":
                                return n.NeighboringTabsOption.Conservative;
                            case "medium":
                                return n.NeighboringTabsOption.Medium;
                            default:
                                return n.NeighboringTabsOption.Eager;
                            case "eagerbutlittle":
                                return n.NeighboringTabsOption.EagerButLittle
                        }
                    }
                    async addExpAndFilterToTelemetry(e) {
                        const t = this.makeFilterSettings({});
                        e.filtersAndExp = {
                            filters: t,
                            exp: await this.getExpConfig(t)
                        }
                    }
                }
                t.Features = p, p.upcomingDynamicFilterCheckDelayMs = 20, p.upcomingTimeBucketMinutes = 5 + Math.floor(11 * Math.random())
            },
            9748: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ExpConfigNone = t.ExpConfigFromTAS = t.ExpConfigMaker = void 0;
                const n = r(2279),
                    o = r(219);
                class i {}
                t.ExpConfigMaker = i, t.ExpConfigFromTAS = class extends i {
                    async fetchExperiments(e, t) {
                        var r;
                        const i = e.get(n.Fetcher);
                        let s;
                        try {
                            s = await i.fetch("https://default.exp-tas.com/vscode/ab", {
                                method: "GET",
                                headers: t
                            })
                        } catch (t) {
                            return o.ExpConfig.createFallbackConfig(e, `Error fetching ExP config: ${t}`)
                        }
                        if (!s.ok) return o.ExpConfig.createFallbackConfig(e, `ExP responded with ${s.status}`);
                        const a = await s.json(),
                            c = null !== (r = a.Configs.find((e => "vscode" === e.Id))) && void 0 !== r ? r : {
                                Id: "vscode",
                                Parameters: {}
                            },
                            l = Object.entries(c.Parameters).map((([e, t]) => e + (t ? "" : "cf")));
                        return new o.ExpConfig(c.Parameters, a.AssignmentContext, l.join(";"))
                    }
                }, t.ExpConfigNone = class extends i {
                    async fetchExperiments(e, t) {
                        return o.ExpConfig.createEmptyConfig()
                    }
                }
            },
            8142: (e, t) => {
                "use strict";
                var r, n;
                Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.FilterSettings = t.telmetryNames = t.TargetPopulation = t.Filter = void 0,
                    function(e) {
                        e.Market = "X-MSEdge-Market", e.CorpNet = "X-FD-Corpnet", e.ApplicationVersion = "X-VSCode-AppVersion", e.Build = "X-VSCode-Build", e.ClientId = "X-MSEdge-ClientId", e.ExtensionName = "X-VSCode-ExtensionName", e.ExtensionVersion = "X-VSCode-ExtensionVersion", e.Language = "X-VSCode-Language", e.TargetPopulation = "X-VSCode-TargetPopulation", e.CopilotClientTimeBucket = "X-Copilot-ClientTimeBucket", e.CopilotOverrideEngine = "X-Copilot-OverrideEngine", e.CopilotRepository = "X-Copilot-Repository", e.CopilotFileType = "X-Copilot-FileType", e.CopilotUserKind = "X-Copilot-UserKind"
                    }(r = t.Filter || (t.Filter = {})), (n = t.TargetPopulation || (t.TargetPopulation = {})).Team = "team", n.Internal = "internal", n.Insiders = "insider", n.Public = "public", t.telmetryNames = {
                        [r.CopilotClientTimeBucket]: "timeBucket",
                        [r.CopilotOverrideEngine]: "engine",
                        [r.CopilotRepository]: "repo",
                        [r.CopilotFileType]: "fileType",
                        [r.CopilotUserKind]: "userKind"
                    };
                class o {
                    constructor(e) {
                        this.filters = e;
                        for (const [e, t] of Object.entries(this.filters)) "" === t && delete this.filters[e]
                    }
                    extends(e) {
                        for (const [t, r] of Object.entries(e.filters))
                            if (this.filters[t] !== r) return !1;
                        return !0
                    }
                    addToTelemetry(e) {
                        for (const [r, n] of Object.entries(this.filters)) {
                            const o = t.telmetryNames[r];
                            void 0 !== o && (e.properties[o] = n)
                        }
                    }
                    stringify() {
                        const e = Object.keys(this.filters);
                        return e.sort(), e.map((e => `${e}:${this.filters[e]}`)).join(";")
                    }
                    toHeaders() {
                        return { ...this.filters
                        }
                    }
                    withChange(e, t) {
                        return new o({ ...this.filters,
                            [e]: t
                        })
                    }
                }
                t.FilterSettings = o
            },
            9030: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.GranularityDirectory = void 0;
                const n = r(8142),
                    o = r(862),
                    i = n.Filter.CopilotClientTimeBucket;
                t.GranularityDirectory = class {
                    constructor(e, t) {
                        this.specs = new Map, this.prefix = e, this.clock = t, this.defaultGranularity = (0, o.DEFAULT_GRANULARITY)(e)
                    }
                    selectGranularity(e) {
                        for (const [t, r] of this.specs.entries())
                            if (e.extends(t)) return r;
                        return this.defaultGranularity
                    }
                    update(e, t, r) {
                        if (t = t > 1 ? t : NaN, r = r > 0 ? r : NaN, isNaN(t) && isNaN(r)) this.specs.delete(e);
                        else {
                            const n = new o.TimeBucketGranularity(this.prefix);
                            isNaN(t) || n.setByCallBuckets(t), isNaN(r) || n.setTimePeriod(3600 * r * 1e3), this.specs.set(e, n)
                        }
                    }
                    extendFilters(e) {
                        const t = this.selectGranularity(e),
                            [r, n] = t.getCurrentAndUpComingValues(this.clock.now());
                        return {
                            newFilterSettings: e.withChange(i, r),
                            otherFilterSettingsToPrefetch: n.map((t => e.withChange(i, t)))
                        }
                    }
                }
            },
            862: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TimeBucketGranularity = t.DEFAULT_GRANULARITY = t.GranularityImplementation = void 0;
                class r {
                    constructor(e) {
                        this.prefix = e
                    }
                    getCurrentAndUpComingValues(e) {
                        return [this.getValue(e), this.getUpcomingValues(e)]
                    }
                }
                t.GranularityImplementation = r;
                class n extends r {
                    getValue(e) {
                        return this.prefix
                    }
                    getUpcomingValues(e) {
                        return []
                    }
                }
                t.DEFAULT_GRANULARITY = e => new n(e), t.TimeBucketGranularity = class extends r {
                    constructor(e, t = .5, r = (new Date).setUTCHours(0, 0, 0, 0)) {
                        super(e), this.prefix = e, this.fetchBeforeFactor = t, this.anchor = r
                    }
                    setTimePeriod(e) {
                        isNaN(e) ? this.timePeriodLengthMs = void 0 : this.timePeriodLengthMs = e
                    }
                    setByCallBuckets(e) {
                        isNaN(e) ? this.numByCallBuckets = void 0 : this.numByCallBuckets = e
                    }
                    getValue(e) {
                        return this.prefix + this.getTimePeriodBucketString(e) + (this.numByCallBuckets ? this.timeHash(e) : "")
                    }
                    getTimePeriodBucketString(e) {
                        return this.timePeriodLengthMs ? this.dateToTimePartString(e) : ""
                    }
                    getUpcomingValues(e) {
                        const t = [],
                            r = this.getUpcomingTimePeriodBucketStrings(e),
                            n = this.getUpcomingByCallBucketStrings();
                        for (const e of r)
                            for (const r of n) t.push(this.prefix + e + r);
                        return t
                    }
                    getUpcomingTimePeriodBucketStrings(e) {
                        if (void 0 === this.timePeriodLengthMs) return [""];
                        if ((e.getTime() - this.anchor) % this.timePeriodLengthMs < this.fetchBeforeFactor * this.timePeriodLengthMs) return [this.getTimePeriodBucketString(e)]; {
                            const t = new Date(e.getTime() + this.timePeriodLengthMs);
                            return [this.getTimePeriodBucketString(e), this.getTimePeriodBucketString(t)]
                        }
                    }
                    getUpcomingByCallBucketStrings() {
                        return void 0 === this.numByCallBuckets ? [""] : Array.from(Array(this.numByCallBuckets).keys()).map((e => e.toString()))
                    }
                    timeHash(e) {
                        return null == this.numByCallBuckets ? 0 : e.getTime() % this.numByCallBuckets * 7883 % this.numByCallBuckets
                    }
                    dateToTimePartString(e) {
                        return null == this.timePeriodLengthMs ? "" : Math.floor((e.getTime() - this.anchor) / this.timePeriodLengthMs).toString()
                    }
                }
            },
            6500: (e, t) => {
                "use strict";
                var r;
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ExpServiceTelemetryNames = void 0, (r = t.ExpServiceTelemetryNames || (t.ExpServiceTelemetryNames = {})).featuresTelemetryPropertyName = "VSCode.ABExp.Features", r.assignmentContextTelemetryPropertyName = "abexp.assignmentcontext"
            },
            2218: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.completionsFromGhostTextResults = void 0;
                const n = r(2277),
                    o = r(6403),
                    i = r(9334),
                    s = r(3286);
                t.completionsFromGhostTextResults = function(e, t, r, a, c, l, u) {
                    const d = e.get(o.LocationFactory),
                        p = a.lineAt(c);
                    let h = t.map((e => {
                        let t, o = "";
                        if (l && (e.completion = (0, s.normalizeIndentCharacter)(l, e.completion, p.isEmptyOrWhitespace)), e.completion.displayNeedsWsOffset && p.isEmptyOrWhitespace) t = d.range(d.position(c.line, 0), c), o = e.completion.completionText;
                        else if (p.isEmptyOrWhitespace && e.completion.completionText.startsWith(p.text)) t = d.range(d.position(c.line, 0), c), o = e.completion.completionText;
                        else {
                            const r = a.getWordRangeAtPosition(c);
                            if (e.isMiddleOfTheLine) {
                                const r = a.lineAt(c),
                                    n = d.range(d.position(c.line, 0), c),
                                    i = a.getText(n);
                                t = e.coversSuffix ? r.range : n, o = i + e.completion.displayText
                            } else if (r) {
                                const n = a.getText(r);
                                t = d.range(r.start, c), o = n + e.completion.completionText
                            } else {
                                const r = d.range(d.position(c.line, 0), c);
                                t = r, o = a.getText(r) + e.completion.displayText
                            }
                        }
                        return {
                            uuid: (0, n.v4)(),
                            text: o,
                            range: t,
                            file: a.uri,
                            index: e.completion.completionIndex,
                            telemetry: e.telemetry,
                            displayText: e.completion.displayText,
                            position: c,
                            offset: a.offsetAt(c),
                            resultType: r
                        }
                    }));
                    if (r === i.ResultType.TypingAsSuggested && void 0 !== u) {
                        const e = h.find((e => e.index === u));
                        if (e) {
                            const t = h.filter((e => e.index !== u));
                            h = [e, ...t]
                        }
                    }
                    return h
                }
            },
            5413: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getDebounceLimit = t.GhostTextDebounceManager = void 0;
                class r {
                    constructor(e) {
                        this.forceDelayMs = e, this.extraDebounceMs = 0
                    }
                }
                t.GhostTextDebounceManager = r, t.getDebounceLimit = function(e) {
                    return 75 + e.get(r).extraDebounceMs
                }
            },
            9334: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getGhostText = t.completionCache = t.ResultType = t.ghostTextLogger = void 0;
                const n = r(3055),
                    o = r(2277),
                    i = r(3076),
                    s = r(106),
                    a = r(6932),
                    c = r(1133),
                    l = r(9189),
                    u = r(9899),
                    d = r(2279),
                    p = r(3),
                    h = r(4419),
                    f = r(937),
                    m = r(6722),
                    g = r(7727),
                    _ = r(4969),
                    y = r(766),
                    v = r(1006),
                    b = r(1124),
                    w = r(6333),
                    x = r(70),
                    E = r(6403),
                    C = r(5413),
                    S = r(750);
                var T;
                let k, I;
                async function P(e, r, n, o, i, s, a) {
                    var u, p;
                    t.ghostTextLogger.debug(e, `Getting ${s} from network`), n = n.extendedBy();
                    const m = await async function(e, t) {
                            const r = await e.get(l.Features).overrideNumGhostCompletions();
                            return r ? t.isCycling ? Math.max(0, 3 - r) : r : t.blockMode == c.BlockMode.Server && t.isCycling ? 2 : t.blockMode == c.BlockMode.Server ? 1 : t.blockMode == c.BlockMode.Parsing && t.isCycling && !t.multiline ? 2 : t.multiline ? (0, c.getConfig)(e, c.ConfigKey.InlineSuggestCount) : 1
                        }(e, r),
                        g = (0, f.getTemperatureForSamples)(e, m),
                        _ = {
                            stream: !0,
                            n: m,
                            temperature: g,
                            extra: {
                                language: r.languageId,
                                next_indent: null !== (u = r.indentation.next) && void 0 !== u ? u : 0
                            }
                        };
                    r.multiline || (_.stop = ["\n"]);
                    const y = Date.now(),
                        v = {
                            endpoint: "completions",
                            uiKind: h.CopilotUiKind.GhostText,
                            isCycling: JSON.stringify(r.isCycling),
                            temperature: JSON.stringify(g),
                            n: JSON.stringify(m),
                            stop: null !== (p = JSON.stringify(_.stop)) && void 0 !== p ? p : "unset"
                        },
                        b = (0, w.telemetrizePromptLength)(r.prompt);
                    Object.assign(n.properties, v), Object.assign(n.measurements, b);
                    try {
                        const s = {
                            prompt: r.prompt,
                            languageId: r.languageId,
                            repoInfo: r.repoInfo,
                            ourRequestId: r.ourRequestId,
                            engineUrl: r.engineURL,
                            count: m,
                            uiKind: h.CopilotUiKind.GhostText,
                            postOptions: _
                        };
                        r.delayMs > 0 && await new Promise((e => setTimeout(e, r.delayMs)));
                        const c = await e.get(h.OpenAIFetcher).fetchAndStreamCompletions(e, s, n, i, o);
                        return "failed" === c.type ? {
                            type: "failed",
                            reason: c.reason,
                            telemetryData: (0, S.mkBasicResultTelemetry)(n)
                        } : "canceled" === c.type ? (t.ghostTextLogger.debug(e, "Cancelled after awaiting fetchCompletions"), {
                            type: "canceled",
                            reason: c.reason,
                            telemetryData: (0, S.mkCanceledResultTelemetry)(n)
                        }) : a(m, y, c.getProcessingTime(), c.choices)
                    } catch (r) {
                        if ((0, d.isAbortError)(r)) return {
                            type: "canceled",
                            reason: "network request aborted",
                            telemetryData: (0, S.mkCanceledResultTelemetry)(n, {
                                cancelledNetworkRequest: !0
                            })
                        };
                        if (t.ghostTextLogger.error(e, `Error on ghost text request ${r}`), (0, x.shouldFailForDebugPurposes)(e)) throw r;
                        return {
                            type: "failed",
                            reason: "non-abort error on ghost text request",
                            telemetryData: (0, S.mkBasicResultTelemetry)(n)
                        }
                    }
                }

                function A(e, t) {
                    const r = { ...e
                    };
                    return r.completionText = e.completionText.trimEnd(), t.forceSingleLine && (r.completionText = r.completionText.split("\n")[0]), r
                }
                t.ghostTextLogger = new u.Logger(u.LogLevel.INFO, "ghostText"),
                    function(e) {
                        e[e.Network = 0] = "Network", e[e.Cache = 1] = "Cache", e[e.TypingAsSuggested = 2] = "TypingAsSuggested", e[e.Cycling = 3] = "Cycling"
                    }(T = t.ResultType || (t.ResultType = {})), t.completionCache = new i.LRUCache(100);
                const O = new s.Debouncer;

                function N(e, t) {
                    k = e, I = t
                }

                function R(e, r, n) {
                    const o = (0, i.keyForPrompt)(r.prompt),
                        s = t.completionCache.get(o);
                    s && s.multiline === n.multiline ? t.completionCache.put(o, {
                        multiline: s.multiline,
                        choices: s.choices.concat(n.choices)
                    }) : t.completionCache.put(o, n), t.ghostTextLogger.debug(e, `Appended cached ghost text for key: ${o}, multiline: ${n.multiline}, number of suggestions: ${n.choices.length}`)
                }

                function $(e, r) {
                    const n = t.completionCache.get(e);
                    if (n && (!r || n.multiline)) return n.choices
                }

                function M(e, t, r) {
                    if (r.length > 0) {
                        if (t.startsWith(r)) return {
                            completionIndex: e,
                            completionText: t,
                            displayText: t.substr(r.length),
                            displayNeedsWsOffset: !1
                        }; {
                            const n = t.substr(0, t.length - t.trimLeft().length);
                            return r.startsWith(n) ? {
                                completionIndex: e,
                                completionText: t,
                                displayText: t.trimLeft(),
                                displayNeedsWsOffset: !0
                            } : {
                                completionIndex: e,
                                completionText: t,
                                displayText: t,
                                displayNeedsWsOffset: !1
                            }
                        }
                    }
                    return {
                        completionIndex: e,
                        completionText: t,
                        displayText: t,
                        displayNeedsWsOffset: !1
                    }
                }

                function D(e, r) {
                    const n = r.requestId,
                        o = {
                            choiceIndex: r.choiceIndex.toString()
                        },
                        i = {
                            numTokens: r.numTokens,
                            compCharLen: r.completionText.length,
                            numLines: r.completionText.split("\n").length
                        };
                    r.meanLogProb && (i.meanLogProb = r.meanLogProb), r.meanAlternativeLogProb && (i.meanAlternativeLogProb = r.meanAlternativeLogProb);
                    const s = r.telemetryData.extendedBy(o, i);
                    return s.extendWithRequestId(n), s.measurements.confidence = (0, v.ghostTextScoreConfidence)(e, s), s.measurements.quantile = (0, v.ghostTextScoreQuantile)(e, s), t.ghostTextLogger.debug(e, `Extended telemetry for ${r.telemetryData.properties.headerRequestId} with retention confidence ${s.measurements.confidence} (expected as good or better than about ${s.measurements.quantile} of all suggestions)`), s
                }

                function L(e, t, r, n, o) {
                    const i = Date.now() - n,
                        s = i - o,
                        a = r.telemetryData.extendedBy({}, {
                            completionCharLen: r.completionText.length,
                            requestTimeMs: i,
                            processingTimeMs: o,
                            deltaMs: s,
                            meanLogProb: r.meanLogProb || NaN,
                            meanAlternativeLogProb: r.meanAlternativeLogProb || NaN,
                            numTokens: r.numTokens
                        });
                    a.extendWithRequestId(r.requestId), (0, w.telemetry)(e, `ghostText.${t}`, a)
                }
                t.getGhostText = async function(e, r, s, u, d) {
                    var f, v;
                    const F = await (0, _.extractPrompt)(e, r, s);
                    if ("contextTooShort" === F.type) return t.ghostTextLogger.debug(e, "Breaking, not enough context"), {
                        type: "abortedBeforeIssued",
                        reason: "Not enough context"
                    };
                    if (null == d ? void 0 : d.isCancellationRequested) return t.ghostTextLogger.info(e, "Cancelled after extractPrompt"), {
                        type: "abortedBeforeIssued",
                        reason: "Cancelled after extractPrompt"
                    };
                    const j = function(e, t) {
                        const r = (o = t, 0 != e.lineAt(o).text.substr(o.character).trim().length),
                            n = function(e, t) {
                                const r = t.lineAt(e).text.substr(e.character).trim();
                                return /^\s*[)}\]"'`]*\s*[:{;,]?\s*$/.test(r)
                            }(t, e);
                        var o;
                        if (!r || n) return r && n
                    }(r, s);
                    if (void 0 === j) return t.ghostTextLogger.debug(e, "Breaking, invalid middle of the line"), {
                        type: "abortedBeforeIssued",
                        reason: "Invalid middle of the line"
                    };
                    const B = e.get(m.StatusReporter),
                        q = e.get(E.LocationFactory),
                        U = await async function(e, t, r, o, i, s) {
                            switch (await e.get(c.BlockModeConfig).forLanguage(e, t.languageId)) {
                                case c.BlockMode.Server:
                                    return {
                                        blockMode: c.BlockMode.Server,
                                        requestMultiline: !0,
                                        isCyclingRequest: i,
                                        finishedCb: async e => {}
                                    };
                                case c.BlockMode.Parsing:
                                default:
                                    {
                                        const a = await async function(e, t, r, o) {
                                            if (t.lineCount >= 8e3)(0, w.telemetry)(e, "ghostText.longFileMultilineSkip", w.TelemetryData.createAndMarkAsIssued({
                                                languageId: t.languageId,
                                                lineCount: String(t.lineCount),
                                                currentLine: String(r.line)
                                            }));
                                            else {
                                                if (!o && (0, n.isSupportedLanguageId)(t.languageId)) return await (0, g.isEmptyBlockStart)(t, r);
                                                if (o && (0, n.isSupportedLanguageId)(t.languageId)) return await (0, g.isEmptyBlockStart)(t, r) || await (0, g.isEmptyBlockStart)(t, t.lineAt(r).range.end)
                                            }
                                            return !1
                                        }(e, t, r, s);
                                        return a ? {
                                            blockMode: c.BlockMode.Parsing,
                                            requestMultiline: !0,
                                            isCyclingRequest: !1,
                                            finishedCb: async n => {
                                                let i;
                                                return i = o.trailingWs.length > 0 && !o.prompt.prefix.endsWith(o.trailingWs) ? e.get(E.LocationFactory).position(r.line, Math.max(r.character - o.trailingWs.length, 0)) : r, (0, g.isBlockBodyFinished)(e, t, i, n)
                                            }
                                        } : {
                                            blockMode: c.BlockMode.Parsing,
                                            requestMultiline: !1,
                                            isCyclingRequest: i,
                                            finishedCb: async e => {}
                                        }
                                    }
                            }
                        }(e, r, s, F, u, j);
                    if (null == d ? void 0 : d.isCancellationRequested) return t.ghostTextLogger.info(e, "Cancelled after requestMultiline"), {
                        type: "abortedBeforeIssued",
                        reason: "Cancelled after requestMultiline"
                    };
                    const [H] = (0, _.trimLastLine)(r.getText(q.range(q.position(0, 0), s)));
                    let G = function(e, r, n, o) {
                        const s = function(e, r, n) {
                            if (!k || !I || !r.startsWith(k)) return;
                            const o = $(I, n);
                            if (!o) return;
                            const i = r.substring(k.length);
                            t.ghostTextLogger.debug(e, `Getting completions for user-typing flow - remaining prefix: ${i}`);
                            const s = [];
                            return o.forEach((e => {
                                const t = A(e, {
                                    forceSingleLine: !1
                                });
                                t.completionText.startsWith(i) && (t.completionText = t.completionText.substring(i.length), s.push(t))
                            })), s
                        }(e, r, o);
                        if (s && s.length > 0) return [s, T.TypingAsSuggested];
                        const a = function(e, r, n, o) {
                            const s = (0, i.keyForPrompt)(n);
                            t.ghostTextLogger.debug(e, `Trying to get completions from cache for key: ${s}`);
                            const a = $(s, o);
                            if (a) {
                                t.ghostTextLogger.debug(e, `Got completions from cache for key: ${s}`);
                                const n = [];
                                a.forEach((e => {
                                    const t = A(e, {
                                        forceSingleLine: !o
                                    });
                                    n.push(t)
                                }));
                                const i = n.filter((e => e.completionText));
                                return i.length > 0 && N(r, s), i
                            }
                        }(e, r, n, o);
                        return a && a.length > 0 ? [a, T.Cache] : void 0
                    }(e, H, F.prompt, U.requestMultiline);
                    const z = o.v4(),
                        V = w.TelemetryData.createAndMarkAsIssued(),
                        W = (0, y.extractRepoInfoInBackground)(e, r.fileName),
                        K = await (0, p.getEngineURL)(e, (0, y.tryGetGitHubNWO)(W), r.languageId, V),
                        J = await e.get(l.Features).beforeRequestWaitMs((0, y.tryGetGitHubNWO)(W) || "", r.languageId),
                        X = {
                            blockMode: U.blockMode,
                            languageId: r.languageId,
                            repoInfo: W,
                            engineURL: K,
                            ourRequestId: z,
                            prefix: H,
                            prompt: F.prompt,
                            multiline: U.requestMultiline,
                            indentation: (0, g.contextIndentation)(r, s),
                            isCycling: u,
                            delayMs: J
                        },
                        Q = function(e, t, r, n, o, i) {
                            const s = e.get(E.LocationFactory),
                                a = t.lineAt(n.line),
                                c = t.getText(s.range(a.range.start, n)),
                                l = t.getText(s.range(n, a.range.end)),
                                u = {
                                    languageId: t.languageId,
                                    beforeCursorWhitespace: JSON.stringify("" === c.trim()),
                                    afterCursorWhitespace: JSON.stringify("" === l.trim())
                                },
                                d = { ...(0, w.telemetrizePromptLength)(o.prompt),
                                    promptEndPos: t.offsetAt(n),
                                    documentLength: t.getText().length,
                                    delayMs: r.delayMs
                                },
                                p = i.extendedBy(u, d);
                            p.properties.promptChoices = JSON.stringify(o.promptChoices, ((e, t) => t instanceof Map ? Array.from(t.entries()).reduce(((e, [t, r]) => ({ ...e,
                                [t]: r
                            })), {}) : t)), p.properties.promptBackground = JSON.stringify(o.promptBackground, ((e, t) => t instanceof Map ? Array.from(t.values()) : t)), p.measurements.promptComputeTimeMs = o.computeTimeMs;
                            const f = r.repoInfo;
                            return p.properties.gitRepoInformation = void 0 === f ? "unavailable" : f === y.ComputationStatus.PENDING ? "pending" : "available", void 0 !== f && f !== y.ComputationStatus.PENDING && (p.properties.gitRepoUrl = f.url, p.properties.gitRepoHost = f.hostname, p.properties.gitRepoOwner = f.owner, p.properties.gitRepoName = f.repo), p.properties.engineName = (0, h.extractEngineName)(e, r.engineURL), p.properties.isMultiline = JSON.stringify(r.multiline), p.properties.blockMode = r.blockMode, p.properties.isCycling = JSON.stringify(r.isCycling), p.properties.headerRequestId = r.ourRequestId, (0, w.telemetry)(e, "ghostText.issued", p), p
                        }(e, r, X, s, F, V);
                    if (U.isCyclingRequest && (null !== (f = null == G ? void 0 : G[0].length) && void 0 !== f ? f : 0) > 1 || !U.isCyclingRequest && void 0 !== G) t.ghostTextLogger.info(e, "Found inline suggestions locally");
                    else {
                        if (null == B || B.setProgress(), U.isCyclingRequest) {
                            const r = await async function(e, r, n, o, i) {
                                return P(e, r, n, o, i, "all completions", (async (i, s, a, c) => {
                                    const l = [];
                                    for await (const r of c) {
                                        if (null == o ? void 0 : o.isCancellationRequested) return t.ghostTextLogger.debug(e, "Cancelled after awaiting choices iterator"), {
                                            type: "canceled",
                                            reason: "after awaiting choices iterator",
                                            telemetryData: (0, S.mkCanceledResultTelemetry)(n)
                                        };
                                        if (r.completionText.trimEnd()) {
                                            if (-1 !== l.findIndex((e => e.completionText.trim() === r.completionText.trim()))) continue;
                                            l.push(r)
                                        }
                                    }
                                    return l.length > 0 && (R(e, r, {
                                        multiline: r.multiline,
                                        choices: l
                                    }), L(e, "cyclingPerformance", l[0], s, a)), {
                                        type: "success",
                                        value: l,
                                        telemetryData: (0, S.mkBasicResultTelemetry)(n),
                                        telemetryBlob: n
                                    }
                                }))
                            }(e, X, Q, d, U.finishedCb);
                            if ("success" === r.type) {
                                const e = null !== (v = null == G ? void 0 : G[0]) && void 0 !== v ? v : [];
                                r.value.forEach((t => {
                                    -1 === e.findIndex((e => e.completionText.trim() === t.completionText.trim())) && e.push(t)
                                })), G = [e, T.Cycling]
                            } else if (void 0 === G) return null == B || B.removeProgress(), r
                        } else {
                            const r = (0, C.getDebounceLimit)(e);
                            try {
                                await O.debounce(r)
                            } catch {
                                return {
                                    type: "canceled",
                                    reason: "by debouncer",
                                    telemetryData: (0, S.mkCanceledResultTelemetry)(Q)
                                }
                            }
                            const n = await async function(e, r, n, o, s) {
                                return P(e, r, n, o, s, "completions", (async (s, a, c, l) => {
                                    const u = l[Symbol.asyncIterator](),
                                        d = await u.next();
                                    if (d.done) return t.ghostTextLogger.debug(e, "All choices redacted"), {
                                        type: "empty",
                                        reason: "all choices redacted",
                                        telemetryData: (0, S.mkBasicResultTelemetry)(n)
                                    };
                                    if (null == o ? void 0 : o.isCancellationRequested) return t.ghostTextLogger.debug(e, "Cancelled after awaiting redactedChoices iterator"), {
                                        type: "canceled",
                                        reason: "after awaiting redactedChoices iterator",
                                        telemetryData: (0, S.mkCanceledResultTelemetry)(n)
                                    };
                                    const p = d.value;
                                    if (void 0 === p) return t.ghostTextLogger.debug(e, "Got undefined choice from redactedChoices iterator"), {
                                        type: "empty",
                                        reason: "got undefined choice from redactedChoices iterator",
                                        telemetryData: (0, S.mkBasicResultTelemetry)(n)
                                    };
                                    L(e, "performance", p, a, c);
                                    const h = s - 1;
                                    t.ghostTextLogger.debug(e, `Awaited first result, id:  ${p.choiceIndex}`),
                                        function(e, r, n) {
                                            const o = (0, i.keyForPrompt)(r.prompt);
                                            N(r.prefix, o), t.completionCache.put(o, n), t.ghostTextLogger.debug(e, `Cached ghost text for key: ${o}, multiline: ${n.multiline}, number of suggestions: ${n.choices.length}`)
                                        }(e, r, {
                                            multiline: r.multiline,
                                            choices: [p]
                                        });
                                    const f = [];
                                    for (let e = 0; e < h; e++) f.push(u.next());
                                    const m = Promise.all(f).then((n => {
                                        t.ghostTextLogger.debug(e, `Awaited remaining results, number of results: ${n.length}`);
                                        const o = [];
                                        for (const r of n) {
                                            const n = r.value;
                                            if (void 0 !== n && (t.ghostTextLogger.info(e, `GhostText later completion: [${n.completionText}]`), n.completionText.trimEnd())) {
                                                if (-1 !== o.findIndex((e => e.completionText.trim() === n.completionText.trim()))) continue;
                                                if (n.completionText.trim() === p.completionText.trim()) continue;
                                                o.push(n)
                                            }
                                        }
                                        o.length > 0 && R(e, r, {
                                            multiline: r.multiline,
                                            choices: o
                                        })
                                    }));
                                    return (0, x.isRunningInTest)(e) && await m, {
                                        type: "success",
                                        value: A(d.value, {
                                            forceSingleLine: !1
                                        }),
                                        telemetryData: (0, S.mkBasicResultTelemetry)(n),
                                        telemetryBlob: n
                                    }
                                }))
                            }(e, X, Q, d, U.finishedCb);
                            if ("success" !== n.type) return null == B || B.removeProgress(), n;
                            G = [
                                [n.value], T.Network
                            ]
                        }
                        null == B || B.removeProgress()
                    }
                    if (void 0 === G) return {
                        type: "failed",
                        reason: "internal error: choices should be defined after network call",
                        telemetryData: (0, S.mkBasicResultTelemetry)(Q)
                    };
                    const [Y, Z] = G, ee = (0, a.asyncIterableMapFilter)((0, a.asyncIterableFromArray)(Y), (async n => (0, b.postProcessChoice)(e, "ghostText", r, s, n, j, t.ghostTextLogger))), te = [];
                    for await (const n of ee) {
                        const o = j && (0, b.checkSuffix)(r, s, n);
                        if (null == d ? void 0 : d.isCancellationRequested) return t.ghostTextLogger.info(e, "Cancelled after post processing completions"), {
                            type: "canceled",
                            reason: "after post processing completions",
                            telemetryData: (0, S.mkCanceledResultTelemetry)(Q)
                        };
                        const i = D(e, n),
                            a = {
                                completion: M(n.choiceIndex, n.completionText, F.trailingWs),
                                telemetry: i,
                                isMiddleOfTheLine: j,
                                coversSuffix: o
                            };
                        te.push(a)
                    }
                    return {
                        type: "success",
                        value: [te, Z],
                        telemetryData: (0, S.mkBasicResultTelemetry)(Q),
                        telemetryBlob: Q
                    }
                }
            },
            3286: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.normalizeIndentCharacter = void 0, t.normalizeIndentCharacter = function(e, t, r) {
                    function n(e, t, r) {
                        const n = new RegExp(`^(${t})+`, "g");
                        return e.split("\n").map((e => {
                            const t = e.replace(n, ""),
                                o = e.length - t.length;
                            return r(o) + t
                        })).join("\n")
                    }
                    let o;
                    if (o = void 0 === e.tabSize || "string" == typeof e.tabSize ? 4 : e.tabSize, !1 === e.insertSpaces) {
                        const e = e => n(e, " ", (e => "\t".repeat(Math.floor(e / o)) + " ".repeat(e % o)));
                        t.displayText = e(t.displayText), t.completionText = e(t.completionText)
                    } else if (!0 === e.insertSpaces) {
                        const e = e => n(e, "\t", (e => " ".repeat(e * o)));
                        if (t.displayText = e(t.displayText), t.completionText = e(t.completionText), r) {
                            const e = e => {
                                const t = e.length - e.trimLeft().length,
                                    r = t % o;
                                return 0 !== r && t > 0 ? n(e, " ".repeat(r), (e => " ".repeat((Math.floor(e / o) + 1) * o))) : e
                            };
                            t.displayText = e(t.displayText), t.completionText = e(t.completionText)
                        }
                    }
                    return t
                }
            },
            750: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.handleGhostTextResultTelemetry = t.mkBasicResultTelemetry = t.mkCanceledResultTelemetry = t.telemetryRejected = t.telemetryAccepted = t.telemetryShown = void 0;
                const n = r(6333);
                t.telemetryShown = function(e, t, r, o) {
                    r.markAsDisplayed();
                    const i = o ? `${t}.shownFromCache` : `${t}.shown`;
                    (0, n.telemetry)(e, i, r)
                }, t.telemetryAccepted = function(e, t, r) {
                    const o = t + ".accepted";
                    (0, n.telemetry)(e, o, r)
                }, t.telemetryRejected = function(e, t, r) {
                    const o = t + ".rejected";
                    (0, n.telemetry)(e, o, r)
                }, t.mkCanceledResultTelemetry = function(e, t = {}) {
                    return { ...t,
                        telemetryBlob: e
                    }
                }, t.mkBasicResultTelemetry = function(e) {
                    return {
                        headerRequestId: e.properties.headerRequestId,
                        copilot_trackingId: e.properties.copilot_trackingId
                    }
                }, t.handleGhostTextResultTelemetry = async function(e, t) {
                    if ("success" === t.type) return (0, n.telemetryRaw)(e, "ghostText.produced", t.telemetryData, {}), t.value;
                    "abortedBeforeIssued" !== t.type && ("canceled" !== t.type ? (0, n.telemetryRaw)(e, `ghostText.${t.type}`, { ...t.telemetryData,
                        reason: t.reason
                    }, {}) : (0, n.telemetry)(e, "ghostText.canceled", t.telemetryData.telemetryBlob.extendedBy({
                        reason: t.reason,
                        cancelledNetworkRequest: t.telemetryData.cancelledNetworkRequest ? "true" : "false"
                    })))
                }
            },
            9899: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.logger = t.toPlainText = t.Logger = t.MultiLog = t.OutputChannelLog = t.ConsoleLog = t.LogTarget = t.verboseLogging = t.LogVerbose = t.LogLevel = void 0;
                const n = r(299),
                    o = r(1133),
                    i = r(6333);
                var s;
                ! function(e) {
                    e[e.DEBUG = 0] = "DEBUG", e[e.INFO = 1] = "INFO", e[e.WARN = 2] = "WARN", e[e.ERROR = 3] = "ERROR"
                }(s = t.LogLevel || (t.LogLevel = {}));
                class a {
                    constructor(e) {
                        this.logVerbose = e
                    }
                }

                function c(e) {
                    return e.get(a).logVerbose
                }
                t.LogVerbose = a, t.verboseLogging = c;
                class l {
                    shouldLog(e, t) {}
                }
                t.LogTarget = l, t.ConsoleLog = class extends l {
                    constructor(e) {
                        super(), this.console = e
                    }
                    logIt(e, t, r, ...n) {
                        c(e) || t == s.ERROR ? this.console.error(r, ...n) : t == s.WARN && this.console.warn(r, ...n)
                    }
                }, t.OutputChannelLog = class extends l {
                    constructor(e) {
                        super(), this.output = e
                    }
                    logIt(e, t, r, ...n) {
                        this.output.appendLine(`${r} ${n.map(d)}`)
                    }
                }, t.MultiLog = class extends l {
                    constructor(e) {
                        super(), this.targets = e
                    }
                    logIt(e, t, r, ...n) {
                        this.targets.forEach((o => o.logIt(e, t, r, ...n)))
                    }
                };
                class u {
                    constructor(e, t) {
                        this.minLoggedLevel = e, this.context = t
                    }
                    setLevel(e) {
                        this.minLoggedLevel = e
                    }
                    stringToLevel(e) {
                        return s[e]
                    }
                    log(e, t, r, ...o) {
                        const a = s[t];
                        t == s.ERROR && (0, i.telemetryError)(e, "log", i.TelemetryData.createAndMarkAsIssued({
                            context: this.context,
                            level: a,
                            message: o.length > 0 ? JSON.stringify(o) : "no msg"
                        }), r);
                        const c = e.get(l),
                            u = c.shouldLog(e, t);
                        if (!1 === u) return;
                        if (void 0 === u && !this.shouldLog(e, t, this.context)) return;
                        const d = e.get(n.Clock).now().toISOString(),
                            p = `[${a}] [${this.context}] [${d}]`;
                        c.logIt(e, t, p, ...o)
                    }
                    shouldLog(e, t, r) {
                        var n, i;
                        if (c(e)) return !0;
                        const s = (0, o.getConfig)(e, o.ConfigKey.DebugFilterLogCategories);
                        if (s.length > 0 && !s.includes(r)) return !1;
                        if ((0, o.isProduction)(e)) return t >= this.minLoggedLevel;
                        const a = (0, o.getConfig)(e, o.ConfigKey.DebugOverrideLogLevels);
                        return t >= (null !== (i = null !== (n = this.stringToLevel(a["*"])) && void 0 !== n ? n : this.stringToLevel(a[this.context])) && void 0 !== i ? i : this.minLoggedLevel)
                    }
                    debug(e, ...t) {
                        this.log(e, s.DEBUG, !1, ...t)
                    }
                    info(e, ...t) {
                        this.log(e, s.INFO, !1, ...t)
                    }
                    warn(e, ...t) {
                        this.log(e, s.WARN, !1, ...t)
                    }
                    error(e, ...t) {
                        this.log(e, s.ERROR, !1, ...t)
                    }
                    secureError(e, t, ...r) {
                        this.log(e, s.ERROR, !1, t), this.log(e, s.ERROR, !0, t, ...r)
                    }
                }

                function d(e) {
                    return "object" == typeof e ? JSON.stringify(e) : String(e)
                }
                t.Logger = u, t.toPlainText = d, t.logger = new u(s.INFO, "default")
            },
            2279: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.postRequest = t.Response = t.HelixFetcher = t.isAbortError = t.Fetcher = t.init = void 0;
                const n = r(9825),
                    o = r(3837),
                    i = r(1133),
                    s = r(5413),
                    a = r(6333);
                let c, l = !1;
                t.init = function(e) {
                    if (l) {
                        if (e !== c) throw new Error(`Networking re-initialized with mismatched version (old: ${c}, new: ${e})`)
                    } else c = e, l = !0
                };
                class u {}
                t.Fetcher = u, t.isAbortError = function(e) {
                    return e instanceof n.AbortError
                }, t.HelixFetcher = class extends u {
                    constructor(e) {
                        super();
                        const t = e.get(i.BuildInfo),
                            r = t.getBuildType() === i.BuildType.DEV,
                            o = t.getBuildType() === i.BuildType.NIGHTLY,
                            s = (0, i.getHiddenConfig)(e, i.ConfigKey.DebugAcceptSelfSignedCertificate, {
                                default: !1
                            }) && (r || o);
                        this.fetchApi = n.context({
                            userAgent: `GithubCopilot/${t.getVersion()}`,
                            rejectUnauthorized: !s
                        })
                    }
                    async fetch(e, t) {
                        const r = { ...t,
                                body: t.body ? t.body : t.json,
                                signal: t.signal
                            },
                            n = await this.fetchApi.fetch(e, r);
                        return new d(n.status, n.statusText, n.headers, (() => n.text()), (() => n.json()), (async () => n.body))
                    }
                    disconnectAll() {
                        return this.fetchApi.reset()
                    }
                    async makeAbortController() {
                        return new n.AbortController
                    }
                };
                class d {
                    constructor(e, t, r, n, o, i) {
                        this.status = e, this.statusText = t, this.headers = r, this.getText = n, this.getJson = o, this.getBody = i, this.ok = this.status >= 200 && this.status < 300
                    }
                    async text() {
                        return this.getText()
                    }
                    async json() {
                        return this.getJson()
                    }
                    async body() {
                        return this.getBody()
                    }
                }
                t.Response = d, t.postRequest = async function(e, t, r, n, c, d, p) {
                    if (!l) throw new Error("Networking must be initialized before being used");
                    const h = {
                        Authorization: o.format("Bearer %s", r),
                        "X-Request-Id": c,
                        "Openai-Organization": "github-copilot",
                        "VScode-SessionId": e.get(i.VscInfo).sessionId,
                        "VScode-MachineId": e.get(i.VscInfo).machineId,
                        "Editor-Version": (0, i.formatNameAndVersion)(e.get(i.EditorAndPluginInfo).getEditorInfo(e)),
                        "Editor-Plugin-Version": (0, i.formatNameAndVersion)(e.get(i.EditorAndPluginInfo).getEditorPluginInfo(e))
                    };
                    n && (h["OpenAI-Intent"] = n);
                    const f = e.get(s.GhostTextDebounceManager).forceDelayMs;
                    f && (h["X-Copilot-Force-Delay"] = f.toString());
                    const m = {
                            method: "POST",
                            headers: h,
                            json: d,
                            timeout: 3e4
                        },
                        g = e.get(u);
                    if (p) {
                        const t = await g.makeAbortController();
                        p.onCancellationRequested((() => {
                            (0, a.telemetry)(e, "networking.cancelRequest", a.TelemetryData.createAndMarkAsIssued({
                                headerRequestId: c
                            })), t.abort()
                        })), m.signal = t.signal
                    }
                    return g.fetch(t, m).catch((r => {
                        if ("ECONNRESET" == r.code || "ETIMEDOUT" == r.code || "ERR_HTTP2_INVALID_SESSION" == r.code || "ERR_HTTP2_GOAWAY_SESSION" == r.message) return (0, a.telemetry)(e, "networking.disconnectAll"), g.disconnectAll().then((() => g.fetch(t, m)));
                        throw r
                    }))
                }
            },
            1547: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.NotificationSender = void 0, t.NotificationSender = class {}
            },
            3: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getEngineURL = t.TEST_ENGINE_PATHS = t.OPENAI_PROXY_HOST = void 0;
                const n = r(1133),
                    o = r(9189),
                    i = r(70);
                t.OPENAI_PROXY_HOST = "https://copilot-proxy.githubusercontent.com";
                const s = "/v1/engines/copilot-codex";
                t.TEST_ENGINE_PATHS = [s], t.getEngineURL = async function(e, r = "", a, c) {
                    return function(e, r) {
                        let o = function(e) {
                            return (0, i.isRunningInTest)(e) ? (0, n.getConfig)(e, n.ConfigKey.DebugTestOverrideProxyUrl) : (0, n.getConfig)(e, n.ConfigKey.DebugOverrideProxyUrl)
                        }(e);
                        return 0 == o.length && (o = t.OPENAI_PROXY_HOST), `${o}${r}`
                    }(e, await async function(e, t, r, i) {
                        const a = (0, n.getConfig)(e, n.ConfigKey.DebugOverrideEngine);
                        if (a) return `/v1/engines/${a}`;
                        const c = await e.get(o.Features).customEngine(t, r, i);
                        return "" !== c ? `/v1/engines/${c}` : await e.get(o.Features).suffixPercent(t, r) > 0 ? "/v1/engines/copilot-experiment-e-centralus" : s
                    }(e, r, a, c))
                }
            },
            4419: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.LiveOpenAIFetcher = t.postProcessChoices = t.OpenAIFetcher = t.extractEngineName = t.getProcessingTime = t.getRequestId = t.CopilotUiKind = void 0;
                const n = r(3055),
                    o = r(3837),
                    i = r(362),
                    s = r(6932),
                    a = r(1133),
                    c = r(9189),
                    l = r(5413),
                    u = r(9899),
                    d = r(2279),
                    p = r(6722),
                    h = r(766),
                    f = r(6333),
                    m = r(937),
                    g = r(2901),
                    _ = new u.Logger(u.LogLevel.INFO, "fetch");
                var y;

                function v(e, t) {
                    return {
                        headerRequestId: e.headers.get("x-request-id") || "",
                        completionId: t && t.id ? t.id : "",
                        created: t && t.created ? t.created : 0,
                        serverExperiments: e.headers.get("X-Copilot-Experiment") || "",
                        deploymentId: e.headers.get("azureml-model-deployment") || ""
                    }
                }

                function b(e) {
                    const t = e.headers.get("openai-processing-ms");
                    return t ? parseInt(t, 10) : 0
                }

                function w(e, t) {
                    return t.split("/").pop() || (_.error(e, "Malformed engine URL: " + t), t)
                }! function(e) {
                    e.GhostText = "ghostText", e.Panel = "synthesize"
                }(y = t.CopilotUiKind || (t.CopilotUiKind = {})), t.getRequestId = v, t.getProcessingTime = b, t.extractEngineName = w;
                class x {}

                function E(e, t) {
                    return null != t && t ? e : (0, s.asyncIterableFilter)(e, (async e => e.completionText.trim().length > 0))
                }
                t.OpenAIFetcher = x, t.postProcessChoices = E, t.LiveOpenAIFetcher = class extends x {
                    async fetchAndStreamCompletions(e, t, r, n, o) {
                        const i = e.get(p.StatusReporter),
                            a = "completions",
                            c = await this.fetchWithParameters(e, a, t, o);
                        if (null == o ? void 0 : o.isCancellationRequested) {
                            const t = await c.body();
                            try {
                                t.destroy()
                            } catch (t) {
                                u.logger.error(e, `Error destroying stream: ${t}`)
                            }
                            return {
                                type: "canceled",
                                reason: "after fetch request"
                            }
                        }
                        if (void 0 === c) {
                            const r = this.createTelemetryData(a, e, t);
                            return i.setWarning(), r.properties.error = "Response was undefined", (0, f.telemetry)(e, "request.shownWarning", r), {
                                type: "failed",
                                reason: "fetch response was undefined"
                            }
                        }
                        if (200 !== c.status) {
                            const r = this.createTelemetryData(a, e, t);
                            return this.handleError(e, i, r, c)
                        }
                        return {
                            type: "success",
                            choices: E((0, s.asyncIterableMap)((0, g.processSSE)(e, c, n, o), (async t => (0, g.prepareSolutionForReturn)(e, t, r))), t.allowEmptyChoices),
                            getProcessingTime: () => b(c)
                        }
                    }
                    createTelemetryData(e, t, r) {
                        return f.TelemetryData.createAndMarkAsIssued({
                            endpoint: e,
                            engineName: w(t, r.engineUrl),
                            uiKind: r.uiKind,
                            headerRequestId: r.ourRequestId
                        })
                    }
                    async fetchWithParameters(e, t, r, s) {
                        const g = {
                                prompt: r.prompt.prefix,
                                suffix: r.prompt.suffix,
                                max_tokens: (0, a.getConfig)(e, a.ConfigKey.SolutionLength),
                                temperature: (0, m.getTemperatureForSamples)(e, r.count),
                                top_p: (0, a.getConfig)(e, a.ConfigKey.TopP),
                                n: r.count
                            },
                            _ = (0, h.tryGetGitHubNWO)(r.repoInfo);
                        void 0 !== _ && (g.nwo = _), 0 == await (0, a.suffixPercent)(e, null != _ ? _ : "", r.languageId) && (g.logprobs = 2, g.stop = (0, a.getLanguageConfig)(e, a.ConfigKey.Stops));
                        const b = await e.get(c.Features).suffixStartMode(null != _ ? _ : "", r.languageId);
                        return b !== n.SuffixStartMode.SiblingBlockWithStop && b !== n.SuffixStartMode.SiblingBlockTrimStartWithStop && b != n.SuffixStartMode.CursorTrimStartWithStop || (g.stop = (0, a.getLanguageConfig)(e, a.ConfigKey.Stops)), await e.get(a.BlockModeConfig).forLanguage(e, r.languageId) === a.BlockMode.Server && (g.feature_flags = ["trim_to_block"]), r.postOptions && Object.assign(g, r.postOptions), u.logger.info(e, `[fetchCompletions] engine ${r.engineUrl}`), await
                        function(e, t, r, n, i, s, a, c, h) {
                            var m;
                            const g = e.get(p.StatusReporter),
                                _ = o.format("%s/%s", r, n);
                            if (!a) return void u.logger.error(e, `Failed to send request to ${_} due to missing key`);
                            const b = f.TelemetryData.createAndMarkAsIssued({
                                endpoint: n,
                                engineName: w(e, r),
                                uiKind: c
                            }, (0, f.telemetrizePromptLength)(t));
                            for (const [e, t] of Object.entries(s)) "prompt" != e && "suffix" != e && (b.properties[`request.option.${e}`] = null !== (m = JSON.stringify(t)) && void 0 !== m ? m : "undefined");
                            b.properties.headerRequestId = i, (0, f.telemetry)(e, "request.sent", b);
                            const x = (0, f.now)(),
                                E = function(e) {
                                    switch (e) {
                                        case y.GhostText:
                                            return "copilot-ghost";
                                        case y.Panel:
                                            return "copilot-panel"
                                    }
                                }(c);
                            return (0, d.postRequest)(e, _, a, E, i, s, h).then((r => {
                                const n = v(r, void 0);
                                b.extendWithRequestId(n);
                                const o = (0, f.now)() - x;
                                b.measurements.totalTimeMs = o, u.logger.info(e, `request.response: [${_}] took ${o} ms`), u.logger.debug(e, "request.response properties", b.properties), u.logger.debug(e, "request.response measurements", b.measurements), u.logger.debug(e, `prompt: ${JSON.stringify(t)}`), (0, f.telemetry)(e, "request.response", b), (0, f.logEnginePrompt)(e, t, b);
                                const i = r.headers.get("x-copilot-delay"),
                                    s = i ? parseInt(i, 10) : 0;
                                return e.get(l.GhostTextDebounceManager).extraDebounceMs = s, r
                            })).catch((t => {
                                var r, n, o, i;
                                if ((0, d.isAbortError)(t)) throw t;
                                g.setWarning();
                                const s = b.extendedBy({
                                    error: "Network exception"
                                });
                                (0, f.telemetry)(e, "request.shownWarning", s), b.properties.code = String(null !== (r = t.code) && void 0 !== r ? r : ""), b.properties.errno = String(null !== (n = t.errno) && void 0 !== n ? n : ""), b.properties.message = String(null !== (o = t.message) && void 0 !== o ? o : ""), b.properties.type = String(null !== (i = t.type) && void 0 !== i ? i : "");
                                const a = (0, f.now)() - x;
                                throw b.measurements.totalTimeMs = a, u.logger.debug(e, `request.response: [${_}] took ${a} ms`), u.logger.debug(e, "request.error properties", b.properties), u.logger.debug(e, "request.error measurements", b.measurements), u.logger.error(e, `Request Error: ${t.message}`), (0, f.telemetry)(e, "request.error", b), t
                            }))
                        }(e, r.prompt, r.engineUrl, t, r.ourRequestId, g, await e.get(i.CopilotTokenManager).getCopilotToken(e), r.uiKind, s)
                    }
                    async handleError(e, t, r, n) {
                        if (t.setWarning(), r.properties.error = `Response status was ${n.status}`, r.properties.status = String(n.status), (0, f.telemetry)(e, "request.shownWarning", r), 401 === n.status || 403 === n.status) return e.get(i.CopilotTokenManager).resetCopilotToken(e, n.status), {
                            type: "failed",
                            reason: `token expired or invalid: ${n.status}`
                        };
                        if (499 === n.status) return _.info(e, "Cancelled by server"), {
                            type: "failed",
                            reason: "canceled by server"
                        };
                        const o = await n.text();
                        return 466 === n.status ? (t.setError(o), _.info(e, o), {
                            type: "failed",
                            reason: `client not supported: ${o}`
                        }) : (_.error(e, "Unhandled status from server:", n.status, o), {
                            type: "failed",
                            reason: `unhandled status from server: ${n.status} ${o}`
                        })
                    }
                }
            },
            937: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getTemperatureForSamples = t.calculateMeanAlternativeLogProb = t.calculateMeanLogProb = t.cleanupIndentChoices = t.convertToAPIChoice = t.DEFAULT_CHARACTER_MULTIPLIER = t.MAX_PROMPT_LENGTH = t.OpenAIFetcher = t.LiveOpenAIFetcher = t.getRequestId = t.CopilotUiKind = void 0;
                const n = r(1133),
                    o = r(9899),
                    i = r(6333),
                    s = r(70);
                var a = r(4419);

                function c(e, t) {
                    if (t.logprobs.token_logprobs) try {
                        let e = 0,
                            r = 0,
                            n = 50;
                        for (let o = 0; o < t.logprobs.token_logprobs.length - 1 && n > 0; o++, n--) e += t.logprobs.token_logprobs[o], r += 1;
                        return r > 0 ? e / r : void 0
                    } catch (t) {
                        o.logger.error(e, `Error calculating mean prob: ${t}`)
                    }
                }

                function l(e, t) {
                    if (t.logprobs.top_logprobs) try {
                        let e = 0,
                            r = 0,
                            n = 50;
                        for (let o = 0; o < t.logprobs.token_logprobs.length - 1 && n > 0; o++, n--) {
                            const n = { ...t.logprobs.top_logprobs[o]
                            };
                            delete n[t.logprobs.tokens[o]], e += Math.max(...Object.values(n)), r += 1
                        }
                        return r > 0 ? e / r : void 0
                    } catch (t) {
                        o.logger.error(e, `Error calculating mean prob: ${t}`)
                    }
                }
                Object.defineProperty(t, "CopilotUiKind", {
                    enumerable: !0,
                    get: function() {
                        return a.CopilotUiKind
                    }
                }), Object.defineProperty(t, "getRequestId", {
                    enumerable: !0,
                    get: function() {
                        return a.getRequestId
                    }
                }), Object.defineProperty(t, "LiveOpenAIFetcher", {
                    enumerable: !0,
                    get: function() {
                        return a.LiveOpenAIFetcher
                    }
                }), Object.defineProperty(t, "OpenAIFetcher", {
                    enumerable: !0,
                    get: function() {
                        return a.OpenAIFetcher
                    }
                }), t.MAX_PROMPT_LENGTH = 1500, t.DEFAULT_CHARACTER_MULTIPLIER = 3, t.convertToAPIChoice = function(e, t, r, n, o, s, a, u) {
                    return (0, i.logEngineCompletion)(e, t, r, o, n), {
                        completionText: t,
                        meanLogProb: c(e, r),
                        meanAlternativeLogProb: l(e, r),
                        choiceIndex: n,
                        requestId: o,
                        modelInfo: u,
                        blockFinished: s,
                        tokens: r.logprobs.tokens,
                        numTokens: r.logprobs.tokens.length,
                        telemetryData: a
                    }
                }, t.cleanupIndentChoices = async function*(e, t) {
                    for await (const r of e) {
                        const e = { ...r
                            },
                            n = e.completionText.split("\n");
                        for (let e = 0; e < n.length; ++e) {
                            const r = n[e].trimLeft();
                            n[e] = "" === r ? r : t + r
                        }
                        e.completionText = n.join("\n"), yield e
                    }
                }, t.calculateMeanLogProb = c, t.calculateMeanAlternativeLogProb = l, t.getTemperatureForSamples = function(e, t) {
                    if ((0, s.isRunningInTest)(e)) return 0;
                    const r = parseFloat((0, n.getConfig)(e, n.ConfigKey.Temperature));
                    return r >= 0 && r <= 1 ? r : t <= 1 ? 0 : t < 10 ? .2 : t < 20 ? .4 : .8
                }
            },
            2901: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.prepareSolutionForReturn = t.processSSE = t.splitChunk = void 0;
                const n = r(9899),
                    o = r(937),
                    i = new n.Logger(n.LogLevel.INFO, "streamChoices");

                function s(e) {
                    const t = e.split("\n"),
                        r = t.pop();
                    return [t.filter((e => "" != e)), r]
                }
                t.splitChunk = s, t.processSSE = async function*(e, t, r, n) {
                    var a, c, l, u, d, p, h, f;
                    const m = await t.body();
                    m.setEncoding("utf8");
                    let g = (0, o.getRequestId)(t);
                    i.debug(e, `requestId: ${g.headerRequestId}`);
                    const _ = {};
                    let y = "";
                    for await (const v of m) {
                        if (null == n ? void 0 : n.isCancellationRequested) return i.info(e, "Cancelled after awaiting body chunk"), void m.destroy();
                        i.debug(e, "chunk", v.toString());
                        const [b, w] = s(y + v.toString());
                        y = w;
                        for (const s of b) {
                            const y = s.slice("data:".length).trim();
                            if ("[DONE]" == y) {
                                for (const [t, r] of Object.entries(_)) {
                                    const o = Number(t);
                                    if (null != r && (yield {
                                            solution: r,
                                            finishOffset: void 0,
                                            reason: "DONE",
                                            requestId: g,
                                            index: o
                                        }, null == n ? void 0 : n.isCancellationRequested)) return i.debug(e, "Cancelled after yielding on DONE"), void m.destroy()
                                }
                                return
                            }
                            let v;
                            try {
                                v = JSON.parse(y)
                            } catch (t) {
                                i.error(e, "Error parsing JSON stream data", s);
                                continue
                            }
                            if (void 0 !== v.choices || void 0 === v.error) {
                                0 == g.created && (g = (0, o.getRequestId)(t, v), 0 == g.created && i.error(e, `Request id invalid, should have "completionId" and "created": ${g}`, g));
                                for (let t = 0; t < v.choices.length; t++) {
                                    const o = v.choices[t];
                                    i.debug(e, "choice", o), o.index in _ || (_[o.index] = {
                                        logprobs: [],
                                        top_logprobs: [],
                                        text: [],
                                        text_offset: [],
                                        tokens: []
                                    });
                                    const s = _[o.index];
                                    if (null == s) continue;
                                    let y;
                                    if (s.text.push(o.text), s.tokens.push(null !== (c = null === (a = o.logprobs) || void 0 === a ? void 0 : a.tokens) && void 0 !== c ? c : []), s.text_offset.push(null !== (u = null === (l = o.logprobs) || void 0 === l ? void 0 : l.text_offset) && void 0 !== u ? u : []), s.logprobs.push(null !== (p = null === (d = o.logprobs) || void 0 === d ? void 0 : d.token_logprobs) && void 0 !== p ? p : []), s.top_logprobs.push(null !== (f = null === (h = o.logprobs) || void 0 === h ? void 0 : h.top_logprobs) && void 0 !== f ? f : []), (o.finish_reason || o.text.indexOf("\n") > -1) && (y = await r(s.text.join("")), null == n ? void 0 : n.isCancellationRequested)) return i.debug(e, "Cancelled after awaiting finishedCb"), void m.destroy();
                                    if (o.finish_reason || void 0 !== y) {
                                        if (yield {
                                                solution: s,
                                                finishOffset: y,
                                                reason: JSON.stringify(o.finish_reason),
                                                requestId: g,
                                                index: o.index
                                            }, null == n ? void 0 : n.isCancellationRequested) return i.debug(e, "Cancelled after yielding finished choice"), void m.destroy();
                                        _[o.index] = null
                                    }
                                }
                            } else i.error(e, "Error in response:", v.error.message)
                        }
                    }
                    for (const [t, r] of Object.entries(_)) {
                        const o = Number(t);
                        if (null != r && (yield {
                                solution: r,
                                finishOffset: void 0,
                                reason: "Iteration Done",
                                requestId: g,
                                index: o
                            }, null == n ? void 0 : n.isCancellationRequested)) return i.debug(e, "Cancelled after yielding after iteration done"), void m.destroy()
                    }
                    if (y.length > 0) try {
                        const t = JSON.parse(y);
                        void 0 !== t.error && i.error(e, `Error in response: ${t.error.message}`, t.error)
                    } catch (t) {
                        i.error(e, `Error parsing extraData: ${y}`)
                    }
                }, t.prepareSolutionForReturn = function(e, t, r) {
                    let n = t.solution.text.join(""),
                        s = !1;
                    void 0 !== t.finishOffset && (i.debug(e, `solution ${t.index}: early finish at offset ${t.finishOffset}`), n = n.substring(0, t.finishOffset), s = !0), i.info(e, `solution ${t.index} returned. finish reason: [${t.reason}] finishOffset: [${t.finishOffset}] completionId: [{${t.requestId.completionId}}] created: [{${t.requestId.created}}]`);
                    const a = function(e, t) {
                        const r = t.text.length,
                            n = t.tokens.length,
                            o = t.text_offset.length,
                            s = t.logprobs.length;
                        r === n && r === o && n === s || i.error(e, `Invalid streamingData: numText:${r}, numTokens:${n}, numOffsets:${o}, numLogprobs:${s}`);
                        const a = t.text.join(""),
                            c = t.tokens.map((e => e.join(""))).join("");
                        c.indexOf(a) < 0 && i.secureError(e, "Invalid streamingData", `joinedText:[${a}] not a substring of joinedTokens:[${c}]`);
                        return {
                            text: a,
                            logprobs: {
                                token_logprobs: t.logprobs.reduce(((e, t) => e.concat(t)), []),
                                top_logprobs: t.top_logprobs.reduce(((e, t) => e.concat(t)), []),
                                text_offset: t.text_offset.reduce(((e, t) => e.concat(t)), []),
                                tokens: t.tokens.reduce(((e, t) => e.concat(t)), [])
                            }
                        }
                    }(e, t.solution);
                    return (0, o.convertToAPIChoice)(e, n, a, t.index, t.requestId, s, r)
                }
            },
            7017: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.postInsertionTasks = t.postRejectionTasks = t.captureCode = void 0;
                const n = r(6881),
                    o = r(750),
                    i = r(9899),
                    s = r(7727),
                    a = r(4969),
                    c = r(5120),
                    l = r(6333),
                    u = r(3136),
                    d = new i.Logger(i.LogLevel.INFO, "post-insertion"),
                    p = [{
                        seconds: 15,
                        captureCode: !1,
                        captureRejection: !1
                    }, {
                        seconds: 30,
                        captureCode: !0,
                        captureRejection: !0
                    }, {
                        seconds: 120,
                        captureCode: !1,
                        captureRejection: !1
                    }, {
                        seconds: 300,
                        captureCode: !1,
                        captureRejection: !1
                    }, {
                        seconds: 600,
                        captureCode: !1,
                        captureRejection: !1
                    }];
                async function h(e, t, r) {
                    const n = await e.get(u.TextDocumentManager).getTextDocument(t);
                    if (!n) return d.info(e, `Could not get document for ${t.fsPath}. Maybe it was closed by the editor.`), {
                        prompt: {
                            prefix: "",
                            suffix: "",
                            isFimEnabled: !1
                        },
                        capturedCode: "",
                        terminationOffset: 0
                    };
                    const o = n.getText(),
                        i = o.substring(0, r),
                        c = n.positionAt(r),
                        l = await (0, a.extractPrompt)(e, n, c),
                        p = "prompt" === l.type ? l.prompt : {
                            prefix: i,
                            suffix: "",
                            isFimEnabled: !1
                        },
                        h = o.substring(r),
                        f = (0, s.contextIndentationFromText)(i, r, n.languageId),
                        m = (0, s.indentationBlockFinished)(f, void 0),
                        g = await m(h),
                        _ = Math.min(o.length, r + (g ? 2 * g : 500));
                    return {
                        prompt: p,
                        capturedCode: o.substring(r, _),
                        terminationOffset: null != g ? g : -1
                    }
                }

                function f(e, t, r, n) {
                    const o = e.substring(Math.max(0, n - r), Math.min(e.length, n + t.length + r)),
                        i = (0, c.lexEditDistance)(o, t),
                        s = i.lexDistance / i.needleLexLength,
                        {
                            distance: a
                        } = (0, c.editDistance)(o.substring(i.startOffset, i.endOffset), t);
                    return {
                        relativeLexEditDistance: s,
                        charEditDistance: a,
                        completionLexLength: i.needleLexLength,
                        foundOffset: i.startOffset + Math.max(0, n - r),
                        lexEditDistance: i.lexDistance,
                        stillInCodeHeuristic: s <= .5 ? 1 : 0
                    }
                }
                t.captureCode = h, t.postRejectionTasks = function(e, t, r, i, s) {
                    s.forEach((({
                        completionText: r,
                        completionTelemetryData: n
                    }) => {
                        d.debug(e, `${t}.rejected choiceIndex: ${n.properties.choiceIndex}`), (0, o.telemetryRejected)(e, t, n)
                    }));
                    const a = new n.ChangeTracker(e, i, r);
                    p.filter((e => e.captureRejection)).map((n => {
                        a.push((async () => {
                            d.debug(e, `Original offset: ${r}, Tracked offset: ${a.offset}`);
                            const {
                                completionTelemetryData: o
                            } = s[0], {
                                prompt: c,
                                capturedCode: u,
                                terminationOffset: p
                            } = await h(e, i, a.offset);
                            let f;
                            f = c.isFimEnabled ? {
                                hypotheticalPromptPrefixJson: JSON.stringify(c.prefix),
                                hypotheticalPromptSuffixJson: JSON.stringify(c.suffix)
                            } : {
                                hypotheticalPromptJson: JSON.stringify(c.prefix)
                            };
                            const m = o.extendedBy({ ...f,
                                capturedCodeJson: JSON.stringify(u)
                            }, {
                                timeout: n.seconds,
                                insertionOffset: r,
                                trackedOffset: a.offset,
                                terminationOffsetInCapturedCode: p
                            });
                            d.debug(e, `${t}.capturedAfterRejected choiceIndex: ${o.properties.choiceIndex}`, m), (0, l.telemetry)(e, t + ".capturedAfterRejected", m, !0)
                        }), 1e3 * n.seconds)
                    }))
                }, t.postInsertionTasks = async function(e, t, r, i, s, a) {
                    d.debug(e, `${t}.accepted choiceIndex: ${a.properties.choiceIndex}`), (0, o.telemetryAccepted)(e, t, a);
                    const c = new n.ChangeTracker(e, s, i),
                        m = r.trim();
                    p.map((r => c.push((() => async function(e, t, r, n, o, i, s, a) {
                        const c = await e.get(u.TextDocumentManager).getTextDocument(o);
                        if (c) {
                            const u = c.getText();
                            let p = f(u, r, 50, a.offset);
                            p.stillInCodeHeuristic || (p = f(u, r, 1500, a.offset)), d.debug(e, `stillInCode: ${p.stillInCodeHeuristic?"Found":"Not found"}! Completion '${r}' in file ${o.fsPath}. lexEditDistance fraction was ${p.relativeLexEditDistance}. Char edit distance was ${p.charEditDistance}. Inserted at ${n}, tracked at ${a.offset}, found at ${p.foundOffset}. choiceIndex: ${s.properties.choiceIndex}`);
                            const m = s.extendedBy({}, {
                                timeout: i.seconds,
                                insertionOffset: n,
                                trackedOffset: a.offset
                            }).extendedBy({}, p);
                            if ((0, l.telemetry)(e, t + ".stillInCode", m), i.captureCode) {
                                const {
                                    prompt: r,
                                    capturedCode: c,
                                    terminationOffset: u
                                } = await h(e, o, a.offset), p = s.extendedBy({
                                    hypotheticalPromptJson: JSON.stringify(r),
                                    capturedCodeJson: JSON.stringify(c)
                                }, {
                                    timeout: i.seconds,
                                    insertionOffset: n,
                                    trackedOffset: a.offset,
                                    terminationOffsetInCapturedCode: u
                                });
                                d.debug(e, `${t}.capturedAfterAccepted choiceIndex: ${s.properties.choiceIndex}`, m), (0, l.telemetry)(e, t + ".capturedAfterAccepted", p, !0)
                            }
                        }
                    }(e, t, m, i, s, r, a, c)), 1e3 * r.seconds)))
                }
            },
            6722: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.NoOpStatusReporter = t.StatusReporter = void 0;
                class r {}
                t.StatusReporter = r, t.NoOpStatusReporter = class extends r {
                    setProgress() {}
                    removeProgress() {}
                    setWarning() {}
                    setError(e) {}
                }
            },
            7727: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.indentationBlockFinished = t.completionCutOrContinue = t.contextIndentationFromText = t.contextIndentation = t.getNodeStart = t.isBlockBodyFinishedWithPrefix = t.isBlockBodyFinished = t.isEmptyBlockStart = void 0;
                const n = r(6403),
                    o = r(2533);
                t.isEmptyBlockStart = function(e, t) {
                    return o.isEmptyBlockStart(e.languageId, e.getText(), e.offsetAt(t))
                }, t.isBlockBodyFinished = function(e, t, r, i) {
                    const s = e.get(n.LocationFactory),
                        a = t.getText(s.range(s.position(0, 0), r)),
                        c = t.offsetAt(r);
                    return o.isBlockBodyFinished(t.languageId, a, i, c)
                }, t.isBlockBodyFinishedWithPrefix = function(e, t, r, i, s) {
                    const a = e.get(n.LocationFactory),
                        c = t.getText(a.range(a.position(0, 0), r)),
                        l = t.offsetAt(r);
                    return o.isBlockBodyFinished(t.languageId, c + s, i, l + s.length)
                }, t.getNodeStart = async function(e, t, r, i) {
                    const s = e.get(n.LocationFactory),
                        a = t.getText(s.range(s.position(0, 0), r)) + i,
                        c = await o.getNodeStart(t.languageId, a, t.offsetAt(r));
                    if (c) return t.positionAt(c)
                };
                const i = ["\\{", "\\}", "\\[", "\\]", "\\(", "\\)"].concat(["then", "else", "elseif", "elif", "catch", "finally", "fi", "done", "end", "loop", "until", "where", "when"].map((e => e + "\\b"))),
                    s = new RegExp(`^(${i.join("|")})`);

                function a(e) {
                    return s.test(e.trimLeft().toLowerCase())
                }

                function c(e) {
                    const t = /^(\s*)([^]*)$/.exec(e);
                    return t && t[2] && t[2].length > 0 ? t[1].length : void 0
                }

                function l(e, t, r) {
                    const n = e.slice(0, t).split("\n"),
                        o = e.slice(t).split("\n");

                    function i(e, t, n) {
                        let o, i, s = t;
                        for (; void 0 === o && s >= 0 && s < e.length;) o = c(e[s]), i = s, s += n;
                        if ("python" === r && -1 === n) {
                            s++;
                            const t = e[s].trim();
                            if (t.endsWith('"""')) {
                                if (!t.startsWith('"""') || '"""' === t)
                                    for (s--; s >= 0 && !e[s].trim().startsWith('"""');) s--;
                                if (s >= 0)
                                    for (o = void 0, s--; void 0 === o && s >= 0;) o = c(e[s]), i = s, s--
                            }
                        }
                        return [o, i]
                    }
                    const [s, a] = i(n, n.length - 1, -1), l = (() => {
                        if (void 0 !== s && void 0 !== a)
                            for (let e = a - 1; e >= 0; e--) {
                                const t = c(n[e]);
                                if (void 0 !== t && t < s) return t
                            }
                    })(), [u] = i(o, 1, 1);
                    return {
                        prev: l,
                        current: null != s ? s : 0,
                        next: u
                    }
                }

                function u(e, t, r) {
                    var n;
                    const o = e.split("\n"),
                        i = void 0 !== r,
                        s = null == r ? void 0 : r.split("\n").pop();
                    let l = 0;
                    if (i && "" != (null == s ? void 0 : s.trim()) && "" !== o[0].trim() && l++, i || l++, o.length === l) return "continue";
                    const u = Math.max(t.current, null !== (n = t.next) && void 0 !== n ? n : 0);
                    for (let e = l; e < o.length; e++) {
                        let t = o[e];
                        0 == e && void 0 !== s && (t = s + t);
                        const r = c(t);
                        if (void 0 !== r && (r < u || r === u && !a(t))) return o.slice(0, e).join("\n").length
                    }
                    return "continue"
                }
                t.contextIndentation = function(e, t) {
                    return l(e.getText(), e.offsetAt(t), e.languageId)
                }, t.contextIndentationFromText = l, t.completionCutOrContinue = u, t.indentationBlockFinished = function(e, t) {
                    return async r => {
                        const n = u(r, e, t);
                        return "continue" === n ? void 0 : n
                    }
                }
            },
            4969: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.extractPrompt = t.trimLastLine = t._contextTooShort = t.MIN_PROMPT_CHARS = void 0;
                const n = r(3055),
                    o = r(1133),
                    i = r(1839),
                    s = r(9189),
                    a = r(3136),
                    c = r(2533),
                    l = r(766);

                function u(e) {
                    const t = e.split("\n"),
                        r = t[t.length - 1],
                        n = r.length - r.trimRight().length,
                        o = e.slice(0, e.length - n),
                        i = e.substr(o.length);
                    return [r.length == n ? o : e, i]
                }
                async function d(e, r, d, p, h, f) {
                    var m;
                    const g = null !== (m = (0, l.tryGetGitHubNWO)((0, l.extractRepoInfoInBackground)(e, h.toString()))) && void 0 !== m ? m : "",
                        _ = await (0, o.suffixPercent)(e, g, f);
                    console.log("e", e, "r", r, "d", d, "p", p, "h", h, "f", f, "g", g)
                    if ((_ > 0 ? r.length : d) < t.MIN_PROMPT_CHARS) return t._contextTooShort;
                    const y = Date.now(),
                        {
                            prefix: v,
                            suffix: b,
                            promptChoices: w,
                            promptBackground: x
                        } = await async function(e, t, r, u, d, p) {
                            var h;
                            let f = [];
                            f = await async function(e, t, r) {
                                const n = [],
                                    o = (0, i.sortByAccessTimes)(e.get(a.TextDocumentManager).textDocuments);
                                let s = 0;
                                console.log("len of o", o)
                                for (const i of o) {
                                    if (n.length + 1 > 20 || s + i.getText().length > 2e5) break;
                                    "file" == i.uri.scheme && i.fileName !== t && i.languageId === r && (n.push({
                                        uri: i.uri.toString(),
                                        relativePath: await e.get(a.TextDocumentManager).getRelativePath(i),
                                        languageId: i.languageId,
                                        source: i.getText()
                                    }), s += i.getText().length)
                                }
                                return n
                            }(e, d.fsPath, p);
                            console.log("some other f", f)
                            const m = {
                                    uri: d.toString(),
                                    source: t,
                                    offset: r,
                                    relativePath: u,
                                    languageId: p
                                },
                                g = null !== (h = (0, l.tryGetGitHubNWO)((0, l.extractRepoInfoInBackground)(e, d.toString()))) && void 0 !== h ? h : "";
                            let _ = {
                                maxPromptLength: 2048 - (0, o.getConfig)(e, o.ConfigKey.SolutionLength),
                                neighboringTabs: await e.get(s.Features).neighboringTabsOption(g, p),
                                suffixStartMode: await e.get(s.Features).suffixStartMode(g, p)
                            };
                            const y = await (0, o.suffixPercent)(e, g, p);
                            y > 0 && (_ = { ..._,
                                includeSiblingFunctions: n.SiblingOption.NoSiblings,
                                suffixPercent: y
                            });
                            const v = e.get(n.FileSystem);
                            console.log("Get prompt is ", c.getPrompt, "v", v, "m", m, "_", _, "f", f)
                            const prompt1234 = await (0, c.getPrompt)(v, m, _, f);
                            console.log("Get prompt result 1234", prompt1234)
                            return prompt1234;
                        }(e, r, d, p, h, f),
                        [E, C] = u(v);
                    const foobar12345 = {
                        type: "prompt",
                        prompt: {
                            prefix: E,
                            suffix: b,
                            isFimEnabled: _ > 0
                        },
                        trailingWs: C,
                        promptChoices: w,
                        computeTimeMs: Date.now() - y,
                        promptBackground: x
                    }
                    console.log("Real stuff: ", foobar12345)
                    return foobar12345;
                }
                async function p(e, t, r) {
                    const n = await e.get(a.TextDocumentManager).getRelativePath(t);
                    return d(e, t.getText(), t.offsetAt(r), n, t.uri, t.languageId)
                }
                t.MIN_PROMPT_CHARS = 10, t._contextTooShort = {
                    type: "contextTooShort"
                }, t.trimLastLine = u, t.extractPrompt = function(e, t, r) {
                    const n = e.get(a.TextDocumentManager).findNotebook(t);
                    return void 0 === n ? p(e, t, r) : async function(e, t, r, n) {
                        const o = r.getCells().find((e => e.document.uri === t.uri));
                        if (o) {
                            const i = r.getCells().filter((e => e.index < o.index && e.document.languageId === o.document.languageId)),
                                s = i.length > 0 ? i.map((e => e.document.getText())).join("\n\n") + "\n\n" : "",
                                c = s + t.getText(),
                                l = s.length + t.offsetAt(n),
                                u = await e.get(a.TextDocumentManager).getRelativePath(t);
                            return d(e, c, l, u, t.uri, o.document.languageId)
                        }
                        return p(e, t, n)
                    }(e, t, n, r)
                }
            },
            2533: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.parsesWithoutError = t.getPrompt = t.getNodeStart = t.getFunctionPositions = t.getBlockCloseToken = t.isSupportedLanguageId = t.isBlockBodyFinished = t.isEmptyBlockStart = t.terminate = t.init = void 0;
                const n = r(3055);
                let o = null;
                const i = new Map;
                let s = 0;
                t.init = function(t, u, d) {
                    if (!u) {
                        const t = r(4723);
                        for (const r of [...a, ...c]) e.exports[r] = t[r];
                        return
                    }
                    for (const r of a) e.exports[r] = l(t, d, r);
                    e.exports.getPrompt = function(e, t) {
                        return function(r, ...n) {
                            const a = s++;
                            return new Promise(((r, s) => {
                                i.set(a, {
                                    resolve: r,
                                    reject: s
                                }), t.debug(e, `Proxy getPrompt - ${a}`), null == o || o.postMessage({
                                    id: a,
                                    fn: "getPrompt",
                                    args: n
                                })
                            }))
                        }
                    }(t, d), o = n.createWorker(), i.clear(), s = 0;
                    const p = t.get(n.FileSystem);

                    function h(e) {
                        d.error(t, e);
                        for (const t of i.values()) t.reject(e);
                        i.clear()
                    }
                    o.on("message", (({
                        id: e,
                        err: r,
                        res: n
                    }) => {
                        const o = i.get(e);
                        d.debug(t, `Response ${e} - ${n}, ${r}`), o && (i.delete(e), r ? o.reject(r) : o.resolve(n))
                    })), o.on("error", h), o.on("exit", (e => {
                        0 !== e && h(new Error(`Worker thread exited with code ${e}.`))
                    })), o.on("readFileReq", (e => {
                        d.debug(t, `READ_FILE_REQ - ${e}`), p.readFile(e).then((e => {
                            null == o || o.emit("readFileRes", e)
                        })).catch(h)
                    })), o.on("mtimeRes", (e => {
                        d.debug(t, `mTime_REQ - ${e}`), p.mtime(e).then((e => {
                            null == o || o.emit("mtimeRes", e)
                        })).catch(h)
                    }))
                }, t.terminate = function() {
                    o && (o.removeAllListeners(), o.terminate(), o = null, i.clear())
                };
                const a = ["getFunctionPositions", "isEmptyBlockStart", "isBlockBodyFinished", "getNodeStart", "parsesWithoutError"],
                    c = ["isSupportedLanguageId", "getBlockCloseToken"];

                function l(e, t, r) {
                    return function(...n) {
                        const a = s++;
                        return new Promise(((s, c) => {
                            i.set(a, {
                                resolve: s,
                                reject: c
                            }), t.debug(e, `Proxy ${r}`), null == o || o.postMessage({
                                id: a,
                                fn: r,
                                args: n
                            })
                        }))
                    }
                }
                t.isEmptyBlockStart = n.isEmptyBlockStart, t.isBlockBodyFinished = n.isBlockBodyFinished, t.isSupportedLanguageId = n.isSupportedLanguageId, t.getBlockCloseToken = n.getBlockCloseToken, t.getFunctionPositions = n.getFunctionPositions, t.getNodeStart = n.getNodeStart, t.getPrompt = n.getPrompt, t.parsesWithoutError = n.parsesWithoutError
            },
            766: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ComputationStatus = t.getRepoUrlUsingChildProcess = t.getRepoUrlFromConfigText = t.parseRepoUrl = t.extractRepoInfoInBackground = t.tryGetGitHubNWO = void 0;
                const n = r(1017),
                    o = r(3076),
                    i = r(2081),
                    s = r(3055);
                t.tryGetGitHubNWO = function(e) {
                    if (void 0 !== e && e !== d.PENDING) return "github.com" === e.hostname ? e.owner + "/" + e.repo : void 0
                }, t.extractRepoInfoInBackground = function(e, t) {
                    if (!t) return;
                    const r = (0, n.dirname)(t);
                    return a(e, r)
                };
                const a = function(e, t) {
                        const r = new o.LRUCache(1e4),
                            i = new Set;
                        return (...e) => {
                            const t = JSON.stringify(e),
                                o = r.get(t);
                            if (o) return o.result;
                            if (i.has(t)) return d.PENDING;
                            const a = async function(e, t) {
                                var r;
                                const o = await async function(e, t) {
                                    let r = t + "_add_to_make_longer";
                                    const o = e.get(s.FileSystem);
                                    for (; t.length > 1 && t.length < r.length;) {
                                        const e = (0, n.join)(t, ".git", "config");
                                        if (await o.stat(e).then((() => !0), (() => !1))) return t;
                                        r = t, t = (0, n.dirname)(t)
                                    }
                                }(e, t);
                                if (!o) return;
                                const i = e.get(s.FileSystem),
                                    a = (0, n.join)(o, ".git", "config"),
                                    c = (await i.readFile(a)).toString(),
                                    d = null !== (r = u(c)) && void 0 !== r ? r : "";
                                return {
                                    baseFolder: o,
                                    url: d,
                                    ...l(d)
                                }
                            }(...e);
                            return i.add(t), a.then((e => {
                                r.put(t, new p(e)), i.delete(t)
                            })), d.PENDING
                        }
                    }(),
                    c = /([^:/@]+)[:/]([^/:]+)\/([^/]+)+/;

                function l(e) {
                    var t, r, n, o;
                    const i = null !== (t = e.match(c)) && void 0 !== t ? t : [];
                    return {
                        hostname: null !== (r = i[1]) && void 0 !== r ? r : "",
                        owner: null !== (n = i[2]) && void 0 !== n ? n : "",
                        repo: i[3] && i[3].endsWith(".git") ? i[3].slice(0, -4) : null !== (o = i[3]) && void 0 !== o ? o : ""
                    }
                }

                function u(e) {
                    var t;
                    const r = /^\s*\[\s*remote\s+"((\\\\|\\"|[^\\"])+)"/,
                        n = /^\s*\[remote.([^"\s]+)/,
                        o = /^\s*url\s*=\s*([^\s#;]+)/,
                        i = /^\s*\[/;
                    let s, a, c = !1;
                    for (const l of e.split("\n"))
                        if (c && void 0 !== s) {
                            if (s += l, l.endsWith("\\")) s = s.substring(0, s.length - 1);
                            else if (c = !1, "origin" === a) return s
                        } else {
                            const e = null !== (t = l.match(r)) && void 0 !== t ? t : l.match(n);
                            if (e) a = e[1];
                            else if (l.match(i)) a = void 0;
                            else {
                                if (s && "origin" !== a) continue; {
                                    const e = l.match(o);
                                    if (e)
                                        if (s = e[1], s.endsWith("\\")) s = s.substring(0, s.length - 1), c = !0;
                                        else if ("origin" === a) return s
                                }
                            }
                        }
                    return s
                }
                var d;
                t.parseRepoUrl = l, t.getRepoUrlFromConfigText = u, t.getRepoUrlUsingChildProcess = async function(e) {
                        const t = (0, n.dirname)(e),
                            r = (0, i.execFile)("git", ["config", "--get", "remote.origin.url"], {
                                cwd: t,
                                encoding: "utf8"
                            });
                        return await new Promise(((e, t) => {
                            var n;
                            null === (n = r.stdout) || void 0 === n || n.on("data", (t => {
                                t = null == t ? void 0 : t.replace(/\n$/, ""), e(t || void 0)
                            })), r.on("exit", (() => {
                                e(void 0)
                            }))
                        }))
                    },
                    function(e) {
                        e[e.PENDING = 0] = "PENDING"
                    }(d = t.ComputationStatus || (t.ComputationStatus = {}));
                class p {
                    constructor(e) {
                        this.result = e
                    }
                }
            },
            9657: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isRepetitive = void 0;
                const r = [{
                    max_token_sequence_length: 1,
                    last_tokens_to_consider: 10
                }, {
                    max_token_sequence_length: 10,
                    last_tokens_to_consider: 30
                }, {
                    max_token_sequence_length: 20,
                    last_tokens_to_consider: 45
                }, {
                    max_token_sequence_length: 30,
                    last_tokens_to_consider: 60
                }];

                function n(e) {
                    const t = function(e) {
                        const t = Array(e.length).fill(0);
                        t[0] = -1;
                        let r = -1;
                        for (let n = 1; n < e.length; n++) {
                            for (; r >= 0 && e[r + 1] !== e[n];) r = t[r];
                            e[r + 1] === e[n] && r++, t[n] = r
                        }
                        return t
                    }(e);
                    for (const n of r)
                        if (!(e.length < n.last_tokens_to_consider) && n.last_tokens_to_consider - 1 - t[n.last_tokens_to_consider - 1] <= n.max_token_sequence_length) return !0;
                    return !1
                }
                t.isRepetitive = function(e) {
                    return n(e.reverse()) || n(e.reverse().filter((e => e.trim().length > 0)))
                }
            },
            5120: (e, t) => {
                "use strict";

                function r(e, t, r = ((e, t) => e === t ? 0 : 1)) {
                    if (0 === t.length || 0 === e.length) return {
                        distance: t.length,
                        startOffset: 0,
                        endOffset: 0
                    };
                    let n = new Array(t.length + 1).fill(0),
                        o = new Array(t.length + 1).fill(0),
                        i = new Array(e.length + 1).fill(0),
                        s = new Array(e.length + 1).fill(0),
                        a = t[0];
                    for (let t = 0; t < e.length + 1; t++) n[t] = 0 === t ? 1 : r(e[t - 1], a, t - 1, 0), o[t] = t > 0 ? t - 1 : 0;
                    for (let c = 1; c < t.length; c++) {
                        let l = i;
                        i = n, n = l, l = s, s = o, o = l, a = t[c], n[0] = c + 1;
                        for (let t = 1; t < e.length + 1; t++) {
                            const l = 1 + i[t],
                                u = 1 + n[t - 1],
                                d = r(e[t - 1], a, t - 1, c) + i[t - 1];
                            n[t] = Math.min(u, l, d), n[t] === d ? o[t] = s[t - 1] : n[t] === l ? o[t] = s[t] : o[t] = o[t - 1]
                        }
                    }
                    let c = 0;
                    for (let t = 0; t < e.length + 1; t++) n[t] < n[c] && (c = t);
                    return {
                        distance: n[c],
                        startOffset: o[c],
                        endOffset: c
                    }
                }

                function n() {
                    return new Map
                }

                function o(e) {
                    const t = new Array(e.size);
                    for (const [r, n] of e) t[n] = r;
                    return t
                }

                function* i(e) {
                    let t, r = "";
                    ! function(e) {
                        e[e.Word = 0] = "Word", e[e.Space = 1] = "Space", e[e.Other = 2] = "Other"
                    }(t || (t = {}));
                    let n = t.Word;
                    for (const o of e) {
                        let e;
                        e = /(\p{L}|\p{Nd}|_)/u.test(o) ? t.Word : " " === o ? t.Space : t.Other, e === n && e !== t.Other ? r += o : (r.length > 0 && (yield r), r = o, n = e)
                    }
                    r.length > 0 && (yield r)
                }

                function s(e, t, r, n) {
                    const o = [];
                    let i = 0;
                    for (const s of r(e)) n(s) && (t.has(s) || t.set(s, t.size), o.push([t.get(s), i])), i += s.length;
                    return [o, t]
                }

                function a(e) {
                    return " " !== e
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.lexEditDistance = t.lexicalAnalyzer = t.lexGeneratorWords = t.reverseLexDictionary = t.emptyLexDictionary = t.editDistance = void 0, t.editDistance = r, t.emptyLexDictionary = n, t.reverseLexDictionary = o, t.lexGeneratorWords = i, t.lexicalAnalyzer = s, t.lexEditDistance = function(e, t, c = i) {
                    const [l, u] = s(e, n(), c, a), [d, p] = s(t, u, c, a);
                    if (0 === d.length || 0 === l.length) return {
                        lexDistance: d.length,
                        startOffset: 0,
                        endOffset: 0,
                        haystackLexLength: l.length,
                        needleLexLength: d.length
                    };
                    const h = o(p),
                        f = d.length,
                        m = h[d[0][0]],
                        g = h[d[f - 1][0]],
                        _ = r(l.map((e => e[0])), d.map((e => e[0])), (function(e, t, r, n) {
                            if (0 === n || n === f - 1) {
                                const e = h[l[r][0]];
                                return 0 == n && e.endsWith(m) || n == f - 1 && e.startsWith(g) ? 0 : 1
                            }
                            return e === t ? 0 : 1
                        })),
                        y = l[_.startOffset][1];
                    let v = _.endOffset < l.length ? l[_.endOffset][1] : e.length;
                    return v > 0 && " " === e[v - 1] && --v, {
                        lexDistance: _.distance,
                        startOffset: y,
                        endOffset: v,
                        haystackLexLength: l.length,
                        needleLexLength: d.length
                    }
                }
            },
            7481: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ghostTextDisplayQuantiles = t.ghostTextDisplayLanguageParameters = t.ghostTextDisplayMeanAlternativeLogProbParameter = t.ghostTextDisplayMeanLogProbParameter = t.ghostTextDisplayLog1pcompCharLenParameter = t.ghostTextDisplayInterceptParameter = void 0, t.ghostTextDisplayInterceptParameter = 2.98410452738298, t.ghostTextDisplayLog1pcompCharLenParameter = -.838732736843507, t.ghostTextDisplayMeanLogProbParameter = 1.50314646255716, t.ghostTextDisplayMeanAlternativeLogProbParameter = -.237798634012662, t.ghostTextDisplayLanguageParameters = {
                    python: .314368072478742
                }, t.ghostTextDisplayQuantiles = {
                    .01: .225800751784931,
                    .02: .290204307767402,
                    .03: .333153496466045,
                    .05: .404516749849559,
                    .1: .513216040545626,
                    .2: .626904979128674,
                    .3: .694880719658273,
                    .4: .743100684947291,
                    .5: .782524520571946,
                    .6: .816856186092243,
                    .7: .84922977716585,
                    .8: .883694877241999,
                    .9: .921859050950077,
                    .95: .944571268106974,
                    .99: .969535563141733
                }
            },
            1006: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ghostTextScoreQuantile = t.ghostTextScoreConfidence = void 0;
                const n = r(9899),
                    o = r(7481),
                    i = new n.Logger(n.LogLevel.INFO, "restraint"),
                    s = {
                        link: e => Math.exp(e) / (1 + Math.exp(e)),
                        unlink: e => Math.log(e / (1 - e))
                    };
                class a {
                    constructor(e, t, r) {
                        this.name = e, this.coefficient = t, this.transformation = r || (e => e)
                    }
                    contribution(e) {
                        return this.coefficient * this.transformation(e)
                    }
                }
                const c = new class {
                    constructor(e, t, r) {
                        if (this.link = s, this.intercept = e, this.coefficients = t, this.logitsToQuantiles = new Map, this.logitsToQuantiles.set(0, 0), this.logitsToQuantiles.set(1, 1), r)
                            for (const e in r) this.logitsToQuantiles.set(r[e], Number(e))
                    }
                    predict(e, t) {
                        let r = this.intercept;
                        for (const n of this.coefficients) {
                            const o = t[n.name];
                            if (void 0 === o) return i.error(e, `No value found for ${n.name} -- only got ${JSON.stringify(t)}`), NaN;
                            r += n.contribution(o)
                        }
                        return this.link.link(r)
                    }
                    quantile(e, t) {
                        return function(e, t) {
                            const r = Math.min(...Array.from(t.keys()).filter((t => t >= e))),
                                n = Math.max(...Array.from(t.keys()).filter((t => t < e))),
                                o = t.get(r),
                                i = t.get(n);
                            return i + (o - i) * (e - n) / (r - n)
                        }(this.predict(e, t), this.logitsToQuantiles)
                    }
                }(o.ghostTextDisplayInterceptParameter, [new a("compCharLen", o.ghostTextDisplayLog1pcompCharLenParameter, (e => Math.log(1 + e))), new a("meanLogProb", o.ghostTextDisplayMeanLogProbParameter), new a("meanAlternativeLogProb", o.ghostTextDisplayMeanAlternativeLogProbParameter)].concat(Object.entries(o.ghostTextDisplayLanguageParameters).map((e => new a(e[0], e[1])))), o.ghostTextDisplayQuantiles);
                t.ghostTextScoreConfidence = function(e, t) {
                    const r = { ...t.measurements
                    };
                    return Object.keys(o.ghostTextDisplayLanguageParameters).forEach((e => {
                        r[e] = t.properties["customDimensions.languageId"] == e ? 1 : 0
                    })), c.predict(e, r)
                }, t.ghostTextScoreQuantile = function(e, t) {
                    const r = { ...t.measurements
                    };
                    return Object.keys(o.ghostTextDisplayLanguageParameters).forEach((e => {
                        r[e] = t.properties["customDimensions.languageId"] == e ? 1 : 0
                    })), c.quantile(e, r)
                }
            },
            1124: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.checkSuffix = t.postProcessChoice = void 0;
                const n = r(2533),
                    o = r(6333),
                    i = r(70),
                    s = r(9657);
                t.postProcessChoice = async function(e, t, r, a, c, l, u) {
                    if ((0, s.isRepetitive)(c.tokens)) {
                        const t = o.TelemetryData.createAndMarkAsIssued();
                        return t.extendWithRequestId(c.requestId), (0, o.telemetry)(e, "repetition.detected", t, !0), void u.info(e, "Filtered out repetitive solution")
                    }
                    const d = { ...c
                    };
                    if (function(e, t, r) {
                            let n = "",
                                o = t.line + 1;
                            for (;
                                "" === n && o < e.lineCount;) {
                                if (n = e.lineAt(o).text.trim(), n === r.trim()) return !0;
                                o++
                            }
                            return !1
                        }(r, a, d.completionText)) {
                        const t = o.TelemetryData.createAndMarkAsIssued();
                        return t.extendWithRequestId(c.requestId), (0, o.telemetry)(e, "completion.alreadyInDocument", t), (0, o.telemetry)(e, "completion.alreadyInDocument", t.extendedBy({
                            completionTextJson: JSON.stringify(d.completionText)
                        }), !0), void u.info(e, "Filtered out solution matching next line")
                    }
                    return d.completionText = await async function(e, t, r, o, s) {
                        var a;
                        if ("" === o) return o;
                        let c = "}";
                        try {
                            c = null !== (a = (0, n.getBlockCloseToken)(t.languageId)) && void 0 !== a ? a : "}"
                        } catch (e) {}
                        let l = o.length;
                        do {
                            const n = o.lastIndexOf("\n", l - 2) + 1,
                                a = o.substring(n, l);
                            if (a.trim() === c) {
                                for (let e = r.line; e < t.lineCount; e++) {
                                    let i = t.lineAt(e).text;
                                    if (e === r.line && (i = i.substr(r.character)), i.startsWith(a.trimRight())) return o.substring(0, Math.max(0, s ? n : n - 1));
                                    if ("" !== i.trim()) break
                                }
                                break
                            }
                            if (l === n) {
                                if ((0, i.shouldFailForDebugPurposes)(e)) throw Error(`Aborting: maybeSnipCompletion would have looped on completion: ${o}`);
                                break
                            }
                            l = n
                        } while (l > 1);
                        return o
                    }(e, r, a, d.completionText, l), d.completionText ? d : void 0
                }, t.checkSuffix = function(e, t, r) {
                    const n = e.lineAt(t.line).text.substring(t.character);
                    if (n.length > 0) {
                        if (-1 !== r.completionText.indexOf(n)) return !0; {
                            let e = 0;
                            for (const t of n) {
                                const n = r.completionText.indexOf(t, e + 1);
                                if (!(n > e)) {
                                    e = -1;
                                    break
                                }
                                e = n
                            }
                            return -1 !== e
                        }
                    }
                    return !1
                }
            },
            6333: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.dropTelemetryConfig = t.setTelemetryConfig = t.logEnginePrompt = t.logEngineCompletion = t.telemetryError = t.telemetryException = t.telemetryRaw = t.telemetryExpProblem = t.telemetry = t.configureReporter = t.telemetryEndpointUrlOverride = t.noTelemetryEndpointUrlOverride = t.TelemetryEndpointUrlOverride = t.now = t.telemetrizePromptLength = t.TelemetryData = t.setupStandardReporters = t.TelemetryReporters = t.APP_INSIGHTS_KEY_SECURE = t.APP_INSIGHTS_KEY = void 0;
                const n = r(1581),
                    o = r(4398),
                    i = r(1133),
                    s = r(9189),
                    a = r(6500),
                    c = r(70),
                    l = r(2499);
                t.APP_INSIGHTS_KEY = "7d7048df-6dd0-4048-bb23-b716c1461f8f", t.APP_INSIGHTS_KEY_SECURE = "3fdd7f28-937a-48c8-9a21-ba337db23bd1";
                class u {
                    constructor(e, t) {
                        this.reporter = e, this.reporterSecure = t
                    }
                    getReporter(e) {
                        return this.reporter
                    }
                    getSecureReporter(e) {
                        if (y()) return this.reporterSecure;
                        if ((0, c.shouldFailForDebugPurposes)(e)) throw new Error("Internal error: telemetry opt-out")
                    }
                    async deactivate() {
                        let e = Promise.resolve();
                        this.reporter && (e = this.reporter.dispose(), this.reporter = void 0);
                        let t = Promise.resolve();
                        this.reporterSecure && (t = this.reporterSecure.dispose(), this.reporterSecure = void 0), await Promise.all([e, t])
                    }
                    hackOptOutListener() {
                        this.reporter.optOutListener = {
                            dispose() {}
                        }, this.reporterSecure.optOutListener = {
                            dispose() {}
                        }
                    }
                    setToken(e) {
                        this.reporter && this.configureToken(this.reporter, e), this.reporterSecure && this.configureToken(this.reporterSecure, e)
                    }
                    configureToken(e, t) {
                        const r = e;
                        r && r.appInsightsClient && (r.appInsightsClient.context.tags.github_telemetry_token = t.token)
                    }
                }
                let d;

                function p(e, t, r, n) {
                    const i = new o.default(t, r, n);
                    return _(e, i, n), i
                }
                t.TelemetryReporters = u, t.setupStandardReporters = function(e, r) {
                    const n = (0, i.getVersion)(e),
                        o = p(e, r, n, t.APP_INSIGHTS_KEY),
                        s = p(e, r, n, t.APP_INSIGHTS_KEY_SECURE);
                    return new u(o, s)
                }, o.default.TELEMETRY_CONFIG_ID = "copilot";
                class h {
                    constructor(e, t, r) {
                        this.properties = e, this.measurements = t, this.issuedTime = r
                    }
                    static createAndMarkAsIssued(e, t) {
                        return new h(e || {}, t || {}, m())
                    }
                    extendedBy(e, t) {
                        const r = { ...this.properties,
                                ...e
                            },
                            n = { ...this.measurements,
                                ...t
                            },
                            o = new h(r, n, this.issuedTime);
                        return o.displayedTime = this.displayedTime, o.filtersAndExp = this.filtersAndExp, o
                    }
                    markAsDisplayed() {
                        void 0 === this.displayedTime && (this.displayedTime = m())
                    }
                    async extendWithExpTelemetry(e) {
                        this.filtersAndExp || await e.get(s.Features).addExpAndFilterToTelemetry(this), this.filtersAndExp.exp.addToTelemetry(this), this.filtersAndExp.filters.addToTelemetry(this)
                    }
                    extendWithEditorAgnosticFields(e) {
                        this.properties.editor_version = (0, i.formatNameAndVersion)(e.get(i.EditorAndPluginInfo).getEditorInfo(e)), this.properties.editor_plugin_version = (0, i.formatNameAndVersion)(e.get(i.EditorAndPluginInfo).getEditorPluginInfo(e));
                        const t = e.get(i.VscInfo);
                        this.properties.client_machineid = t.machineId, this.properties.client_sessionid = t.sessionId, this.properties.copilot_version = `copilot/${(0,i.getVersion)(e)}`, this.properties.common_extname = e.get(i.EditorAndPluginInfo).getEditorPluginInfo(e).name, this.properties.common_extversion = e.get(i.EditorAndPluginInfo).getEditorPluginInfo(e).version
                    }
                    extendWithConfigProperties(e) {
                        const t = (0, i.dumpConfig)(e);
                        try {
                            t["copilot.build"] = (0, i.getBuild)(e), t["copilot.buildType"] = (0, i.getBuildType)(e)
                        } catch (e) {}
                        d && (t["copilot.trackingId"] = d.trackingId), this.properties = { ...this.properties,
                            ...t
                        }
                    }
                    extendWithRequestId(e) {
                        const t = {
                            completionId: e.completionId,
                            created: e.created.toString(),
                            headerRequestId: e.headerRequestId,
                            serverExperiments: e.serverExperiments,
                            deploymentId: e.deploymentId
                        };
                        this.properties = { ...this.properties,
                            ...t
                        }
                    }
                    static maybeRemoveRepoInfoFromPropertiesHack(e, t) {
                        if (e) return t;
                        const r = {};
                        for (const e in t) h.keysToRemoveFromStandardTelemetryHack.includes(e) || (r[e] = t[e]);
                        return r
                    }
                    sanitizeKeys() {
                        this.properties = h.sanitizeKeys(this.properties), this.measurements = h.sanitizeKeys(this.measurements)
                    }
                    static sanitizeKeys(e) {
                        e = e || {};
                        const t = {};
                        for (const r in e) t[h.keysExemptedFromSanitization.includes(r) ? r : r.replace(/\./g, "_")] = e[r];
                        return t
                    }
                    updateTimeSinceIssuedAndDisplayed() {
                        const e = m() - this.issuedTime;
                        if (this.measurements.timeSinceIssuedMs = e, void 0 !== this.displayedTime) {
                            const e = m() - this.displayedTime;
                            this.measurements.timeSinceDisplayedMs = e
                        }
                    }
                    validateData(e, t) {
                        var r;
                        let n;
                        if (h.validateTelemetryProperties(this.properties) || (n = {
                                problem: "properties",
                                error: JSON.stringify(h.validateTelemetryProperties.errors)
                            }), !h.validateTelemetryMeasurements(this.measurements)) {
                            const e = JSON.stringify(h.validateTelemetryMeasurements.errors);
                            void 0 === n ? n = {
                                problem: "measurements",
                                error: e
                            } : (n.problem = "both", n.error += `; ${e}`)
                        }
                        if (void 0 === n) return !0;
                        if ((0, c.shouldFailForDebugPurposes)(e)) throw new Error(`Invalid telemetry data: ${n.problem} ${n.error} properties=${JSON.stringify(this.properties)} measurements=${JSON.stringify(this.measurements)}`);
                        return b(e, "invalidTelemetryData", h.createAndMarkAsIssued({
                            properties: JSON.stringify(this.properties),
                            measurements: JSON.stringify(this.measurements),
                            problem: n.problem,
                            validationError: n.error
                        }), t), t && b(e, "invalidTelemetryData_in_secure", h.createAndMarkAsIssued({
                            problem: n.problem,
                            requestId: null !== (r = this.properties.requestId) && void 0 !== r ? r : "unknown"
                        }), !1), !1
                    }
                    async makeReadyForSending(e, t, r) {
                        this.extendWithConfigProperties(e), this.extendWithEditorAgnosticFields(e), this.sanitizeKeys(), "IncludeExp" === r && await this.extendWithExpTelemetry(e), this.updateTimeSinceIssuedAndDisplayed(), this.validateData(e, t) || (this.properties.telemetry_failed_validation = "true")
                    }
                }

                function f(e, t, r, n) {
                    const o = t ? e.get(u).getSecureReporter(e) : e.get(u).getReporter(e);
                    o && o.sendTelemetryEvent(r, h.maybeRemoveRepoInfoFromPropertiesHack(t, n.properties), n.measurements)
                }

                function m() {
                    return (new Date).getTime()
                }
                t.TelemetryData = h, h.ajv = new n.default({
                    strictNumbers: !1
                }), h.validateTelemetryProperties = h.ajv.compile({
                    type: "object",
                    additionalProperties: {
                        type: "string"
                    },
                    required: []
                }), h.validateTelemetryMeasurements = h.ajv.compile({
                    type: "object",
                    properties: {
                        meanLogProb: {
                            type: "number",
                            nullable: !0
                        },
                        meanAlternativeLogProb: {
                            type: "number",
                            nullable: !0
                        }
                    },
                    additionalProperties: {
                        type: "number"
                    },
                    required: []
                }), h.keysExemptedFromSanitization = [a.ExpServiceTelemetryNames.assignmentContextTelemetryPropertyName, a.ExpServiceTelemetryNames.featuresTelemetryPropertyName], h.keysToRemoveFromStandardTelemetryHack = ["gitRepoHost", "gitRepoName", "gitRepoOwner", "gitRepoUrl", "repo", "request_option_nwo"], t.telemetrizePromptLength = function(e) {
                    return e.isFimEnabled ? {
                        promptPrefixCharLen: e.prefix.length,
                        promptSuffixCharLen: e.suffix.length
                    } : {
                        promptCharLen: e.prefix.length
                    }
                }, t.now = m;
                class g {
                    constructor(e) {
                        this.url = e
                    }
                    getUrl() {
                        return this.url
                    }
                }

                function _(e, t, r) {
                    const n = t;
                    if (n.appInsightsClient || (n.userOptIn = !0, n.createAppInsightsClient(r)), n.appInsightsClient) {
                        const t = n.appInsightsClient.commonProperties,
                            r = h.sanitizeKeys(t);
                        n.appInsightsClient.commonProperties = r, n.appInsightsClient.context.tags[n.appInsightsClient.context.keys.cloudRoleInstance] = "REDACTED";
                        const o = e.get(g).getUrl();
                        void 0 !== o && (n.appInsightsClient.config.endpointUrl = o)
                    }
                }

                function y() {
                    var e;
                    return null !== (e = null == d ? void 0 : d.optedIn) && void 0 !== e && e
                }
                async function v(e, t, r, n) {
                    if (n && !y()) return;
                    const o = r || h.createAndMarkAsIssued({}, {});
                    await o.makeReadyForSending(e, null != n && n, "IncludeExp"), f(e, null != n && n, t, o)
                }
                async function b(e, t, r, n) {
                    if (n && !y()) return;
                    const o = r || h.createAndMarkAsIssued({}, {});
                    await o.makeReadyForSending(e, null != n && n, "IncludeExp"),
                        function(e, t, r, n) {
                            const o = t ? e.get(u).getSecureReporter(e) : e.get(u).getReporter(e);
                            o && o.sendTelemetryErrorEvent(r, h.maybeRemoveRepoInfoFromPropertiesHack(t, n.properties), n.measurements)
                        }(e, null != n && n, t, o)
                }
                t.TelemetryEndpointUrlOverride = g, t.noTelemetryEndpointUrlOverride = new g, t.telemetryEndpointUrlOverride = new g("https://copilot-telemetry.githubusercontent.com/telemetry"), t.configureReporter = _, t.telemetry = v, t.telemetryExpProblem = async function(e, t) {
                    const r = h.createAndMarkAsIssued(t, {});
                    await r.makeReadyForSending(e, !1, "SkipExp"), f(e, !1, "expProblem", r)
                }, t.telemetryRaw = async function(e, t, r, n) {
                    f(e, !1, t, {
                        properties: r,
                        measurements: n
                    })
                }, t.telemetryException = async function(e, t, r, n) {
                    const o = t instanceof Error ? t : new Error("Non-error thrown: " + t),
                        i = y(),
                        s = h.createAndMarkAsIssued({
                            origin: (0, l.redactPaths)(r),
                            reason: i ? "Exception logged to restricted telemetry" : "Exception, not logged due to opt-out",
                            ...n
                        });
                    if (await s.makeReadyForSending(e, !1, "IncludeExp"), f(e, !1, "exception", s), !i) return;
                    const a = h.createAndMarkAsIssued({
                        origin: r,
                        ...n
                    });
                    await a.makeReadyForSending(e, !0, "IncludeExp"),
                        function(e, t, r, n) {
                            const o = e.get(u).getSecureReporter(e);
                            o && o.sendTelemetryException(r, h.maybeRemoveRepoInfoFromPropertiesHack(true, n.properties), n.measurements)
                        }(e, 0, o, a)
                }, t.telemetryError = b, t.logEngineCompletion = async function(e, t, r, n, o) {
                    var i;
                    const s = h.createAndMarkAsIssued({
                        completionTextJson: JSON.stringify(t),
                        choiceIndex: o.toString()
                    });
                    for (const [e, t] of Object.entries(r.logprobs)) s.properties["logprobs_" + e] = null !== (i = JSON.stringify(t)) && void 0 !== i ? i : "unset";
                    s.extendWithRequestId(n), await v(e, "engine.completion", s, !0)
                }, t.logEnginePrompt = async function(e, t, r) {
                    let n;
                    n = t.isFimEnabled ? {
                        promptPrefixJson: JSON.stringify(t.prefix),
                        promptSuffixJson: JSON.stringify(t.suffix)
                    } : {
                        promptJson: JSON.stringify(t.prefix)
                    };
                    const o = r.extendedBy(n);
                    await v(e, "engine.prompt", o, !0)
                }, t.setTelemetryConfig = function(e) {
                    d = e
                }, t.dropTelemetryConfig = function() {
                    d = void 0
                }
            },
            956: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.readTestingGitHubToken = t.makeTestingCopilotTokenManager = void 0;
                const n = r(7147),
                    o = r(362);

                function i() {
                    const e = `${process.env.HOME}/.copilot-testing-gh-token`;
                    if (n.existsSync(e)) return n.readFileSync(e).toString();
                    throw new Error(`Tests: either GH_COPILOT_TOKEN, or GITHUB_TOKEN, must be set, or there must be a GitHub token from an app with access to Copilot in ${e}. Run "npm run get_token" to get one.`)
                }
                t.makeTestingCopilotTokenManager = function() {
                    if (process.env.GH_COPILOT_TOKEN) return new o.FixedCopilotTokenManager({
                        token: process.env.GH_COPILOT_TOKEN,
                        telemetry: "enabled"
                    });
                    if (process.env.GITHUB_TOKEN) return new o.CopilotTokenManagerFromGitHubToken(process.env.GITHUB_TOKEN);
                    const e = i();
                    return process.env.GITHUB_TOKEN = e, new o.CopilotTokenManagerFromGitHubToken(e)
                }, t.readTestingGitHubToken = i
            },
            70: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isVerboseLoggingEnabled = t.isDebugEnabled = t.shouldFailForDebugPurposes = t.isRunningInTest = t.RuntimeMode = void 0;
                class r {
                    constructor(e) {
                        this.flags = e
                    }
                    static fromEnvironment(e) {
                        return new r({
                            debug: (t = process.argv, n = process.env, t.includes("--debug") || "true" === (null === (s = n.GITHUB_COPILOT_DEBUG) || void 0 === s ? void 0 : s.toLowerCase())),
                            verboseLogging: o(process.env),
                            testMode: e,
                            recordInput: i(process.argv, process.env)
                        });
                        var t, n, s
                    }
                }

                function n(e) {
                    return e.get(r).flags.testMode
                }

                function o(e) {
                    if ("COPILOT_AGENT_VERBOSE" in e) {
                        const t = e.COPILOT_AGENT_VERBOSE;
                        return "1" === t || "true" === t
                    }
                    return !1
                }

                function i(e, t) {
                    var r;
                    return e.includes("--record") || "true" === (null === (r = t.GITHUB_COPILOT_RECORD) || void 0 === r ? void 0 : r.toLowerCase())
                }
                t.RuntimeMode = r, t.isRunningInTest = n, t.shouldFailForDebugPurposes = function(e) {
                    return n(e)
                }, t.isDebugEnabled = function(e) {
                    return e.get(r).flags.debug
                }, t.isVerboseLoggingEnabled = function(e) {
                    return e.get(r).flags.verboseLogging
                }
            },
            8771: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TestNotificationSender = t.TestUrlOpener = t.rangeToString = t.positionToString = void 0;
                const n = r(1547);

                function o(e) {
                    return `${e.line}:${e.character}`
                }
                t.positionToString = o, t.rangeToString = function(e) {
                    return `[${o(e.start)}--${o(e.end)}]`
                }, t.TestUrlOpener = class {
                    constructor() {
                        this.openedUrls = []
                    }
                    open(e) {
                        this.openedUrls.push(e)
                    }
                };
                class i extends n.NotificationSender {
                    constructor() {
                        super(), this.sentMessages = []
                    }
                    showWarningMessage(e, ...t) {
                        return this.sentMessages.push(e), t ? Promise.resolve(t[0]) : Promise.resolve(void 0)
                    }
                }
                t.TestNotificationSender = i
            },
            6403: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.LocationFactory = void 0, t.LocationFactory = class {}
            },
            3136: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TextDocumentManager = t.getRelativePath = void 0;
                const n = r(1017);
                t.getRelativePath = function(e, t) {
                    for (const r of e) {
                        const e = r.fsPath;
                        if (t.startsWith(e + n.sep)) return n.relative(e, t)
                    }
                }, t.TextDocumentManager = class {}
            },
            7057: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.RealUrlOpener = t.UrlOpener = void 0;
                const n = r(8318);
                t.UrlOpener = class {}, t.RealUrlOpener = class {
                    async open(e) {
                        await n(e)
                    }
                }
            },
            2499: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.redactPaths = void 0, t.redactPaths = function(e) {
                    return e.replace(/([\s|(]|file:\/\/)(\/[^\s]+)/g, "$1[redacted]").replace(/([\s|(]|file:\/\/)([a-zA-Z]:[(\\|/){1,2}][^\s]+)/gi, "$1[redacted]").replace(/([\s|(]|file:\/\/)(\\[^\s]+)/gi, "$1[redacted]")
                }
            },
            5012: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.defaultFileSystem = t.FileSystem = void 0;
                const n = r(7147);
                t.FileSystem = class {}, t.defaultFileSystem = {
                    readFile: e => n.promises.readFile(e),
                    mtime: async e => (await n.promises.stat(e)).mtimeMs,
                    stat: async function(e) {
                        const t = await n.promises.stat(e);
                        return {
                            ctime: t.ctimeMs,
                            mtime: t.mtimeMs,
                            size: t.size
                        }
                    }
                }
            },
            1788: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getPathMarker = t.getLanguageMarker = t.comment = t.hasLanguageMarker = t.languageCommentMarkers = void 0, t.languageCommentMarkers = {
                    abap: {
                        start: '"',
                        end: ""
                    },
                    bat: {
                        start: "REM",
                        end: ""
                    },
                    bibtex: {
                        start: "%",
                        end: ""
                    },
                    blade: {
                        start: "#",
                        end: ""
                    },
                    c: {
                        start: "//",
                        end: ""
                    },
                    clojure: {
                        start: ";",
                        end: ""
                    },
                    coffeescript: {
                        start: "//",
                        end: ""
                    },
                    cpp: {
                        start: "//",
                        end: ""
                    },
                    csharp: {
                        start: "//",
                        end: ""
                    },
                    css: {
                        start: "/*",
                        end: "*/"
                    },
                    dart: {
                        start: "//",
                        end: ""
                    },
                    dockerfile: {
                        start: "#",
                        end: ""
                    },
                    elixir: {
                        start: "#",
                        end: ""
                    },
                    erb: {
                        start: "<%#",
                        end: "%>"
                    },
                    fsharp: {
                        start: "//",
                        end: ""
                    },
                    go: {
                        start: "//",
                        end: ""
                    },
                    groovy: {
                        start: "//",
                        end: ""
                    },
                    haml: {
                        start: "-#",
                        end: ""
                    },
                    handlebars: {
                        start: "{{!",
                        end: "}}"
                    },
                    html: {
                        start: "\x3c!--",
                        end: "--\x3e"
                    },
                    ini: {
                        start: ";",
                        end: ""
                    },
                    java: {
                        start: "//",
                        end: ""
                    },
                    javascript: {
                        start: "//",
                        end: ""
                    },
                    javascriptreact: {
                        start: "//",
                        end: ""
                    },
                    jsonc: {
                        start: "//",
                        end: ""
                    },
                    jsx: {
                        start: "//",
                        end: ""
                    },
                    julia: {
                        start: "#",
                        end: ""
                    },
                    latex: {
                        start: "%",
                        end: ""
                    },
                    less: {
                        start: "//",
                        end: ""
                    },
                    lua: {
                        start: "--",
                        end: ""
                    },
                    makefile: {
                        start: "#",
                        end: ""
                    },
                    markdown: {
                        start: "[]: #",
                        end: ""
                    },
                    "objective-c": {
                        start: "//",
                        end: ""
                    },
                    "objective-cpp": {
                        start: "//",
                        end: ""
                    },
                    perl: {
                        start: "#",
                        end: ""
                    },
                    php: {
                        start: "//",
                        end: ""
                    },
                    pug: {
                        start: "//",
                        end: ""
                    },
                    python: {
                        start: "#",
                        end: ""
                    },
                    r: {
                        start: "#",
                        end: ""
                    },
                    razor: {
                        start: "\x3c!--",
                        end: "--\x3e"
                    },
                    ruby: {
                        start: "#",
                        end: ""
                    },
                    rust: {
                        start: "//",
                        end: ""
                    },
                    sass: {
                        start: "//",
                        end: ""
                    },
                    scss: {
                        start: "//",
                        end: ""
                    },
                    shellscript: {
                        start: "#",
                        end: ""
                    },
                    slim: {
                        start: "/",
                        end: ""
                    },
                    solidity: {
                        start: "//",
                        end: ""
                    },
                    sql: {
                        start: "--",
                        end: ""
                    },
                    stylus: {
                        start: "//",
                        end: ""
                    },
                    svelte: {
                        start: "\x3c!--",
                        end: "--\x3e"
                    },
                    swift: {
                        start: "//",
                        end: ""
                    },
                    terraform: {
                        start: "#",
                        end: ""
                    },
                    tex: {
                        start: "%",
                        end: ""
                    },
                    typescript: {
                        start: "//",
                        end: ""
                    },
                    typescriptreact: {
                        start: "//",
                        end: ""
                    },
                    vb: {
                        start: "'",
                        end: ""
                    },
                    "vue-html": {
                        start: "\x3c!--",
                        end: "--\x3e"
                    },
                    vue: {
                        start: "//",
                        end: ""
                    },
                    xml: {
                        start: "\x3c!--",
                        end: "--\x3e"
                    },
                    xsl: {
                        start: "\x3c!--",
                        end: "--\x3e"
                    },
                    yaml: {
                        start: "#",
                        end: ""
                    }
                };
                const r = ["php", "plaintext"],
                    n = {
                        shellscript: "#!/bin/sh",
                        python: "#!/usr/bin/env python3",
                        ruby: "#!/usr/bin/env ruby",
                        html: "<!DOCTYPE html>",
                        yaml: "# YAML data"
                    };

                function o({
                    source: e
                }) {
                    return e.startsWith("#!") || e.startsWith("<!DOCTYPE")
                }

                function i(e, r) {
                    const n = t.languageCommentMarkers[r];
                    if (n) {
                        const t = "" == n.end ? "" : " " + n.end;
                        return `${n.start} ${e}${t}`
                    }
                    return ""
                }
                t.hasLanguageMarker = o, t.comment = i, t.getLanguageMarker = function(e) {
                    const {
                        languageId: t
                    } = e;
                    return -1 !== r.indexOf(t) || o(e) ? "" : t in n ? n[t] : i(`Language: ${t}`, t)
                }, t.getPathMarker = function(e) {
                    return e.relativePath ? i(`Path: ${e.relativePath}`, e.languageId) : ""
                }
            },
            4723: function(e, t, r) {
                "use strict";
                var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                        void 0 === n && (n = r), Object.defineProperty(e, n, {
                            enumerable: !0,
                            get: function() {
                                return t[r]
                            }
                        })
                    } : function(e, t, r, n) {
                        void 0 === n && (n = r), e[n] = t[r]
                    }),
                    o = this && this.__exportStar || function(e, t) {
                        for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
                    };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.createWorker = t.FileSystem = t.comment = t.languageCommentMarkers = void 0;
                const i = r(1017),
                    s = r(1267);
                o(r(464), t), o(r(9940), t), o(r(1747), t), o(r(9852), t);
                var a = r(1788);
                Object.defineProperty(t, "languageCommentMarkers", {
                    enumerable: !0,
                    get: function() {
                        return a.languageCommentMarkers
                    }
                }), Object.defineProperty(t, "comment", {
                    enumerable: !0,
                    get: function() {
                        return a.comment
                    }
                });
                var c = r(5012);
                Object.defineProperty(t, "FileSystem", {
                    enumerable: !0,
                    get: function() {
                        return c.FileSystem
                    }
                }), t.createWorker = function() {
                    return new s.Worker((0, i.resolve)(__dirname, "..", "dist", "worker.js"))
                }
            },
            3507: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.extractLocalImportContext = t.getDocComment = void 0;
                const n = r(1017),
                    o = r(464);

                function i(e, t) {
                    var r;
                    let o = null === (r = t.namedChild(1)) || void 0 === r ? void 0 : r.text.slice(1, -1);
                    if (!o || !o.startsWith(".")) return null;
                    if ("" === (0, n.extname)(o)) o += ".ts";
                    else if (".ts" !== (0, n.extname)(o)) return null;
                    return (0, n.join)((0, n.dirname)(e), o)
                }

                function s(e) {
                    var t, r, n, o, i;
                    let s = [];
                    if ("import_clause" === (null === (t = e.namedChild(0)) || void 0 === t ? void 0 : t.type)) {
                        let t = e.namedChild(0);
                        if ("named_imports" === (null === (r = null == t ? void 0 : t.namedChild(0)) || void 0 === r ? void 0 : r.type)) {
                            let e = t.namedChild(0);
                            for (let t of null !== (n = null == e ? void 0 : e.namedChildren) && void 0 !== n ? n : [])
                                if ("import_specifier" === t.type) {
                                    const e = null === (o = t.childForFieldName("name")) || void 0 === o ? void 0 : o.text;
                                    if (e) {
                                        const r = null === (i = t.childForFieldName("alias")) || void 0 === i ? void 0 : i.text;
                                        s.push({
                                            name: e,
                                            alias: r
                                        })
                                    }
                                }
                        }
                    }
                    return s
                }
                const a = new Map;

                function c(e, t) {
                    var r, n;
                    let o = null !== (n = null === (r = null == t ? void 0 : t.childForFieldName("name")) || void 0 === r ? void 0 : r.text) && void 0 !== n ? n : "";
                    switch (null == t ? void 0 : t.type) {
                        case "ambient_declaration":
                            return c(e, t.namedChild(0));
                        case "interface_declaration":
                        case "enum_declaration":
                        case "type_alias_declaration":
                            return {
                                name: o,
                                decl: t.text
                            };
                        case "function_declaration":
                        case "function_signature":
                            return {
                                name: o,
                                decl: l(e, t)
                            };
                        case "class_declaration":
                            {
                                let r = function(e, t) {
                                        let r = t.childForFieldName("body");
                                        if (r) return r.namedChildren.map((t => d(e, t))).filter((e => e))
                                    }(e, t),
                                    n = "";
                                if (r) {
                                    let o = t.childForFieldName("body");
                                    n = `declare ${e.substring(t.startIndex,o.startIndex+1)}`, n += r.map((e => "\n" + e)).join(""), n += "\n}"
                                }
                                return {
                                    name: o,
                                    decl: n
                                }
                            }
                    }
                    return {
                        name: o,
                        decl: ""
                    }
                }

                function l(e, t) {
                    var r, n, o;
                    const i = null !== (n = null === (r = t.childForFieldName("return_type")) || void 0 === r ? void 0 : r.endIndex) && void 0 !== n ? n : null === (o = t.childForFieldName("parameters")) || void 0 === o ? void 0 : o.endIndex;
                    if (void 0 !== i) {
                        let r = e.substring(t.startIndex, i) + ";";
                        return "function_declaration" === t.type || "function_signature" === t.type ? "declare " + r : r
                    }
                    return ""
                }

                function u(e, t) {
                    const r = (0, o.getFirstPrecedingComment)(t);
                    return r ? e.substring(r.startIndex, t.startIndex) : ""
                }

                function d(e, t) {
                    var r, n, i, s, a;
                    if ("accessibility_modifier" === (null === (r = null == t ? void 0 : t.firstChild) || void 0 === r ? void 0 : r.type) && "private" === t.firstChild.text) return "";
                    const c = (0, o.getFirstPrecedingComment)(t),
                        p = null !== (n = function(e, t) {
                            let r = t.startIndex - 1;
                            for (; r >= 0 && (" " === e[r] || "\t" === e[r]);) r--;
                            if (r < 0 || "\n" === e[r]) return e.substring(r + 1, t.startIndex)
                        }(e, null != c ? c : t)) && void 0 !== n ? n : "  ",
                        h = u(e, t);
                    switch (t.type) {
                        case "ambient_declaration":
                            const r = t.namedChild(0);
                            return r ? p + h + d(e, r) : "";
                        case "method_definition":
                        case "method_signature":
                            return p + h + l(e, t);
                        case "public_field_definition":
                            {
                                let r = null !== (s = null === (i = t.childForFieldName("type")) || void 0 === i ? void 0 : i.endIndex) && void 0 !== s ? s : null === (a = t.childForFieldName("name")) || void 0 === a ? void 0 : a.endIndex;
                                if (void 0 !== r) return p + h + e.substring(t.startIndex, r) + ";"
                            }
                    }
                    return ""
                }
                async function p(e, t, r) {
                    let n = new Map,
                        i = -1;
                    try {
                        i = await r.mtime(e)
                    } catch {
                        return n
                    }
                    let s = a.get(e);
                    if (s && s.mtime === i) return s.exports;
                    if ("typescript" === t) {
                        let i = null;
                        try {
                            let s = (await r.readFile(e)).toString();
                            i = await (0, o.parseTree)(t, s);
                            for (let e of (0, o.queryExports)(t, i.rootNode))
                                for (let t of e.captures) {
                                    let e = t.node;
                                    if ("export_statement" === e.type) {
                                        let t = e.childForFieldName("declaration");
                                        if (null == t ? void 0 : t.hasError()) continue;
                                        let {
                                            name: r,
                                            decl: o
                                        } = c(s, t);
                                        if (r) {
                                            o = u(s, e) + o;
                                            let t = n.get(r);
                                            t || (t = [], n.set(r, t)), t.push(o)
                                        }
                                    }
                                }
                        } catch {} finally {
                            i && i.delete()
                        }
                    }
                    if (a.size > 2e3)
                        for (let e of a.keys())
                            if (a.delete(e), n.size <= 1e3) break;
                    return a.set(e, {
                        mtime: i,
                        exports: n
                    }), n
                }
                t.getDocComment = u;
                const h = /^\s*import\s*(type|)\s*\{[^}]*\}\s*from\s*['"]\./gm;
                t.extractLocalImportContext = async function(e, t) {
                    let {
                        source: r,
                        uri: n,
                        languageId: a
                    } = e;
                    return t && "typescript" === a ? async function(e, t, r) {
                        let n = "typescript",
                            a = [];
                        const c = function(e) {
                            let t, r = -1;
                            h.lastIndex = -1;
                            do {
                                t = h.exec(e), t && (r = h.lastIndex + t.length)
                            } while (t);
                            if (-1 === r) return -1;
                            const n = e.indexOf("\n", r);
                            return -1 !== n ? n : e.length
                        }(e);
                        if (-1 === c) return a;
                        e = e.substring(0, c);
                        let l = await (0, o.parseTree)(n, e);
                        try {
                            for (let e of function(e) {
                                    let t = [];
                                    for (let r of e.namedChildren) "import_statement" === r.type && t.push(r);
                                    return t
                                }(l.rootNode)) {
                                let o = i(t, e);
                                if (!o) continue;
                                let c = s(e);
                                if (0 === c.length) continue;
                                let l = await p(o, n, r);
                                for (let e of c) l.has(e.name) && a.push(...l.get(e.name))
                            }
                        } finally {
                            l.delete()
                        }
                        return a
                    }(r, n, t) : []
                }
            },
            5531: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getNeighborSnippets = void 0;
                const n = r(1788),
                    o = r(5572),
                    i = {
                        none: {
                            windowLength: 1,
                            threshold: -1,
                            numberOfNeighbors: 0
                        },
                        conservative: {
                            windowLength: 10,
                            threshold: .3,
                            numberOfNeighbors: 1
                        },
                        medium: {
                            windowLength: 20,
                            threshold: .1,
                            numberOfNeighbors: 2
                        },
                        eager: {
                            windowLength: 60,
                            threshold: 0,
                            numberOfNeighbors: 4
                        },
                        eagerButLittle: {
                            windowLength: 10,
                            threshold: 0,
                            numberOfNeighbors: 1
                        }
                    };

                function s(e) {
                    return [e.relativePath ? "Compare this snippet from " + e.relativePath + ":" : "Compare this snippet:"].concat(e.snippet.split("\n"))
                }
                t.getNeighborSnippets = async function(e, t, r) {
                    const a = i[r],
                        c = {
                            uri: e.uri,
                            languageId: e.languageId,
                            source: e.source.slice(0, e.offset).split("\n").slice(-a.windowLength).join("\n")
                        };
                    return t.filter((e => e.source.length < 1e4 && e.source.length > 0)).slice(0, 20).map((e => ({
                        relativePath: e.relativePath,
                        ...(0, o.findBestJaccardMatch)(e, c, a.windowLength)
                    }))).filter((e => e.score && e.snippet && e.score > a.threshold)).sort(((e, t) => e.score - t.score)).slice(-a.numberOfNeighbors).map((t => ({
                        score: t.score,
                        snippet: s(t).map((t => (0, n.comment)(t, e.languageId) + "\n")).join("")
                    })))
                }
            },
            464: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getFunctionPositions = t.getFirstPrecedingComment = t.isFunctionDefinition = t.isFunction = t.getAncestorWithSiblingFunctions = t.queryPythonIsDocstring = t.queryGlobalVars = t.queryExports = t.queryImports = t.queryFunctions = t.getBlockCloseToken = t.parsesWithoutError = t.parseTree = t.getLanguage = t.languageIdToWasmLanguage = t.isSupportedLanguageId = t.WASMLanguage = void 0;
                const n = r(1017),
                    o = r(4087),
                    i = r(4087);
                var s;
                ! function(e) {
                    e.Python = "python", e.JavaScript = "javascript", e.TypeScript = "typescript", e.Go = "go", e.Ruby = "ruby"
                }(s = t.WASMLanguage || (t.WASMLanguage = {}));
                const a = {
                    python: s.Python,
                    javascript: s.JavaScript,
                    javascriptreact: s.JavaScript,
                    jsx: s.JavaScript,
                    typescript: s.TypeScript,
                    typescriptreact: s.TypeScript,
                    go: s.Go,
                    ruby: s.Ruby
                };

                function c(e) {
                    if (!(e in a)) throw new Error(`Unrecognized language: ${e}`);
                    return a[e]
                }
                t.isSupportedLanguageId = function(e) {
                    return e in a
                }, t.languageIdToWasmLanguage = c;
                const l = {
                        python: [
                            ["(function_definition body: (block\n             (expression_statement (string))? @docstring) @body) @function"],
                            ['(ERROR ("def" (identifier) (parameters))) @function']
                        ],
                        javascript: [
                            ["[\n            (function body: (statement_block) @body)\n            (function_declaration body: (statement_block) @body)\n            (generator_function body: (statement_block) @body)\n            (generator_function_declaration body: (statement_block) @body)\n            (method_definition body: (statement_block) @body)\n          ] @function"]
                        ],
                        typescript: [
                            ["[\n            (function body: (statement_block) @body)\n            (function_declaration body: (statement_block) @body)\n            (generator_function body: (statement_block) @body)\n            (generator_function_declaration body: (statement_block) @body)\n            (method_definition body: (statement_block) @body)\n          ] @function"]
                        ],
                        go: [
                            ["[\n            (function_declaration body: (block) @body)\n            (method_declaration body: (block) @body)\n          ] @function"]
                        ],
                        ruby: [
                            ['[\n            (method name: (_) parameters: (method_parameters)? @params [(_)+ "end"] @body)\n            (singleton_method name: (_) parameters: (method_parameters)? @params [(_)+ "end"] @body)\n          ] @function']
                        ]
                    },
                    u = '(variable_declarator value: (call_expression function: ((identifier) @req (#eq? @req "require"))))',
                    d = `\n    (lexical_declaration ${u}+)\n    (variable_declaration ${u}+)\n`,
                    p = {
                        python: [
                            ["(module (future_import_statement) @import)"],
                            ["(module (import_statement) @import)"],
                            ["(module (import_from_statement) @import)"]
                        ],
                        javascript: [
                            [`(program [ ${d} ] @import)`],
                            ["(program [ (import_statement) ] @import)"]
                        ],
                        typescript: [
                            [`(program [ ${d} ] @import)`],
                            ["(program [ (import_statement) (import_alias) ] @import)"]
                        ],
                        go: [],
                        ruby: []
                    },
                    h = {
                        python: [],
                        javascript: [
                            ["(program (export_statement) @export)"]
                        ],
                        typescript: [
                            ["(program (export_statement) @export)"]
                        ],
                        go: [],
                        ruby: []
                    },
                    f = {
                        python: [
                            ["(module (global_statement) @globalVar)"],
                            ["(module (expression_statement) @globalVar)"]
                        ],
                        javascript: [],
                        typescript: [],
                        go: [],
                        ruby: []
                    },
                    m = {
                        python: new Set(["function_definition"]),
                        javascript: new Set(["function", "function_declaration", "generator_function", "generator_function_declaration", "method_definition", "arrow_function"]),
                        typescript: new Set(["function", "function_declaration", "generator_function", "generator_function_declaration", "method_definition", "arrow_function"]),
                        go: new Set(["function_declaration", "method_declaration"]),
                        ruby: new Set(["method", "singleton_method"])
                    },
                    g = {
                        python: e => {
                            var t;
                            return "module" === e.type || "block" === e.type && "class_definition" === (null === (t = e.parent) || void 0 === t ? void 0 : t.type)
                        },
                        javascript: e => "program" === e.type || "class_body" === e.type,
                        typescript: e => "program" === e.type || "class_body" === e.type,
                        go: e => "source_file" === e.type,
                        ruby: e => "program" === e.type || "class" === e.type
                    },
                    _ = new Map;
                async function y(e) {
                    const t = c(e);
                    if (!_.has(t)) {
                        const e = await async function(e) {
                            await o.init();
                            const t = (0, n.resolve)(__dirname, "..", "dist", `tree-sitter-${e}.wasm`);
                            return i.Language.load(t)
                        }(t);
                        _.set(t, e)
                    }
                    return _.get(t)
                }
                async function v(e, t) {
                    let r = await y(e);
                    const n = new o;
                    n.setLanguage(r);
                    const i = n.parse(t);
                    return n.delete(), i
                }

                function b(e, t) {
                    const r = [];
                    for (const n of e) {
                        if (!n[1]) {
                            const e = t.tree.getLanguage();
                            n[1] = e.query(n[0])
                        }
                        r.push(...n[1].matches(t))
                    }
                    return r
                }

                function w(e, t) {
                    return b(l[c(e)], t)
                }
                t.getLanguage = y, t.parseTree = v, t.parsesWithoutError = async function(e, t) {
                    const r = await v(e, t),
                        n = !r.rootNode.hasError();
                    return r.delete(), n
                }, t.getBlockCloseToken = function(e) {
                    switch (c(e)) {
                        case s.Python:
                            return null;
                        case s.JavaScript:
                        case s.TypeScript:
                        case s.Go:
                            return "}";
                        case s.Ruby:
                            return "end"
                    }
                }, t.queryFunctions = w, t.queryImports = function(e, t) {
                    return b(p[c(e)], t)
                }, t.queryExports = function(e, t) {
                    return b(h[c(e)], t)
                }, t.queryGlobalVars = function(e, t) {
                    return b(f[c(e)], t)
                };
                const x = ["[\n    (class_definition (block (expression_statement (string))))\n    (function_definition (block (expression_statement (string))))\n]"];

                function E(e, t) {
                    return m[c(e)].has(t.type)
                }
                t.queryPythonIsDocstring = function(e) {
                    return 1 == b([x], e).length
                }, t.getAncestorWithSiblingFunctions = function(e, t) {
                    const r = g[c(e)];
                    for (; t.parent;) {
                        if (r(t.parent)) return t;
                        t = t.parent
                    }
                    return t.parent ? t : null
                }, t.isFunction = E, t.isFunctionDefinition = function(e, t) {
                    switch (c(e)) {
                        case s.Python:
                        case s.Go:
                        case s.Ruby:
                            return E(e, t);
                        case s.JavaScript:
                        case s.TypeScript:
                            if ("function_declaration" === t.type || "generator_function_declaration" === t.type || "method_definition" === t.type) return !0;
                            if ("lexical_declaration" === t.type || "variable_declaration" === t.type) {
                                if (t.namedChildCount > 1) return !1;
                                let r = t.namedChild(0);
                                if (null == r) return !1;
                                let n = r.namedChild(1);
                                return null !== n && E(e, n)
                            }
                            if ("expression_statement" === t.type) {
                                let r = t.namedChild(0);
                                if ("assignment_expression" === (null == r ? void 0 : r.type)) {
                                    let t = r.namedChild(1);
                                    return null !== t && E(e, t)
                                }
                            }
                            return !1
                    }
                }, t.getFirstPrecedingComment = function(e) {
                    var t;
                    let r = e;
                    for (;
                        "comment" === (null === (t = r.previousSibling) || void 0 === t ? void 0 : t.type);) {
                        let e = r.previousSibling;
                        if (e.endPosition.row < r.startPosition.row - 1) break;
                        r = e
                    }
                    return "comment" === (null == r ? void 0 : r.type) ? r : null
                }, t.getFunctionPositions = async function(e, t) {
                    return w(e, (await v(e, t)).rootNode).map((e => {
                        const t = e.captures.find((e => "function" === e.name)).node;
                        return {
                            startIndex: t.startIndex,
                            endIndex: t.endIndex
                        }
                    }))
                }
            },
            9940: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getNodeStart = t.isBlockBodyFinished = t.isEmptyBlockStart = t.getBlockParser = void 0;
                const n = r(464);
                class o {
                    constructor(e, t, r) {
                        this.languageId = e, this.nodeMatch = t, this.nodeTypesWithBlockOrStmtChild = r
                    }
                    async getNodeMatchAtPosition(e, t, r) {
                        const o = await (0, n.parseTree)(this.languageId, e);
                        try {
                            let e = o.rootNode.descendantForIndex(t);
                            for (; e;) {
                                const t = this.nodeMatch[e.type];
                                if (t) {
                                    if (!this.nodeTypesWithBlockOrStmtChild.has(e.type)) break;
                                    const r = this.nodeTypesWithBlockOrStmtChild.get(e.type),
                                        n = "" == r ? e.namedChildren[0] : e.childForFieldName(r);
                                    if ((null == n ? void 0 : n.type) == t) break
                                }
                                e = e.parent
                            }
                            if (!e) return;
                            return r(e)
                        } finally {
                            o.delete()
                        }
                    }
                    getNextBlockAtPosition(e, t, r) {
                        return this.getNodeMatchAtPosition(e, t, (e => {
                            let t = e.children.reverse().find((t => t.type == this.nodeMatch[e.type]));
                            if (t) {
                                if ("python" == this.languageId && t.parent) {
                                    const e = ":" == t.parent.type ? t.parent.parent : t.parent;
                                    let r = null == e ? void 0 : e.nextSibling;
                                    for (; r && "comment" == r.type;) {
                                        const n = r.startPosition.row == t.endPosition.row && r.startPosition.column >= t.endPosition.column,
                                            o = r.startPosition.row > e.endPosition.row && r.startPosition.column > e.startPosition.column;
                                        if (!n && !o) break;
                                        t = r, r = r.nextSibling
                                    }
                                }
                                if (!(t.endIndex >= t.tree.rootNode.endIndex - 1 && (t.hasError() || t.parent.hasError()))) return r(t)
                            }
                        }))
                    }
                    async isBlockBodyFinished(e, t, r) {
                        const n = (e + t).trimEnd(),
                            o = await this.getNextBlockAtPosition(n, r, (e => e.endIndex));
                        if (void 0 !== o && o < n.length) {
                            const t = o - e.length;
                            return t > 0 ? t : void 0
                        }
                    }
                    getNodeStart(e, t) {
                        const r = e.trimEnd();
                        return this.getNodeMatchAtPosition(r, t, (e => e.startIndex))
                    }
                }
                class i extends o {
                    constructor(e, t, r, n, o) {
                        super(e, n, o), this.blockEmptyMatch = t, this.lineMatch = r
                    }
                    isBlockStart(e) {
                        return this.lineMatch.test(e.trimStart())
                    }
                    async isBlockBodyEmpty(e, t) {
                        const r = await this.getNextBlockAtPosition(e, t, (r => {
                            r.startIndex < t && (t = r.startIndex);
                            let n = e.substring(t, r.endIndex).trim();
                            return "" == n || n.replace(/\s/g, "") == this.blockEmptyMatch
                        }));
                        return void 0 === r || r
                    }
                    async isEmptyBlockStart(e, t) {
                        return t = s(e, t), this.isBlockStart(function(e, t) {
                            const r = e.lastIndexOf("\n", t - 1);
                            let n = e.indexOf("\n", t);
                            return n < 0 && (n = e.length), e.slice(r + 1, n)
                        }(e, t)) && this.isBlockBodyEmpty(e, t)
                    }
                }

                function s(e, t) {
                    let r = t;
                    for (; r > 0 && /\s/.test(e.charAt(r - 1));) r--;
                    return r
                }

                function a(e, t) {
                    const r = e.startIndex,
                        n = e.startIndex - e.startPosition.column,
                        o = t.substring(n, r);
                    if (/^\s*$/.test(o)) return o
                }

                function c(e, t, r) {
                    if (t.startPosition.row <= e.startPosition.row) return !1;
                    const n = a(e, r),
                        o = a(t, r);
                    return void 0 !== n && void 0 !== o && n.startsWith(o)
                }
                class l extends o {
                    constructor(e, t, r, n, o, i, s) {
                        super(e, t, r), this.startKeywords = n, this.blockNodeType = o, this.emptyStatementType = i, this.curlyBraceLanguage = s
                    }
                    isBlockEmpty(e, t) {
                        var r, o;
                        let i = e.text.trim();
                        return this.curlyBraceLanguage && (i.startsWith("{") && (i = i.slice(1)), i.endsWith("}") && (i = i.slice(0, -1)), i = i.trim()), 0 == i.length || !("python" != this.languageId || "class_definition" != (null === (r = e.parent) || void 0 === r ? void 0 : r.type) && "function_definition" != (null === (o = e.parent) || void 0 === o ? void 0 : o.type) || 1 != e.children.length || !(0, n.queryPythonIsDocstring)(e.parent))
                    }
                    async isEmptyBlockStart(e, t) {
                        var r, o, i;
                        if (t > e.length) throw new RangeError("Invalid offset");
                        for (let r = t; r < e.length && "\n" != e.charAt(r); r++)
                            if (/\S/.test(e.charAt(r))) return !1;
                        t = s(e, t);
                        const a = await (0, n.parseTree)(this.languageId, e);
                        try {
                            const n = a.rootNode.descendantForIndex(t - 1);
                            if (null == n) return !1;
                            if (this.curlyBraceLanguage && "}" == n.type) return !1;
                            if (("javascript" == this.languageId || "typescript" == this.languageId) && n.parent && "object" == n.parent.type && "{" == n.parent.text.trim()) return !0;
                            if ("typescript" == this.languageId) {
                                let r = n;
                                for (; r.parent;) {
                                    if ("function_signature" == r.type || "method_signature" == r.type) {
                                        const o = n.nextSibling;
                                        return !!(o && r.hasError() && c(r, o, e)) || !r.children.find((e => ";" == e.type)) && r.endIndex <= t
                                    }
                                    r = r.parent
                                }
                            }
                            let s = null,
                                l = null,
                                u = null,
                                d = n;
                            for (; null != d;) {
                                if (d.type == this.blockNodeType) {
                                    l = d;
                                    break
                                }
                                if (this.nodeMatch[d.type]) {
                                    u = d;
                                    break
                                }
                                if ("ERROR" == d.type) {
                                    s = d;
                                    break
                                }
                                d = d.parent
                            }
                            if (null != l) {
                                if (!l.parent || !this.nodeMatch[l.parent.type]) return !1;
                                if ("python" == this.languageId) {
                                    const e = l.previousSibling;
                                    if (null != e && e.hasError() && (e.text.startsWith('"""') || e.text.startsWith("'''"))) return !0
                                }
                                return this.isBlockEmpty(l, t)
                            }
                            if (null != s) {
                                if ("module" == (null === (r = s.previousSibling) || void 0 === r ? void 0 : r.type) || "internal_module" == (null === (o = s.previousSibling) || void 0 === o ? void 0 : o.type)) return !0;
                                const e = [...s.children].reverse(),
                                    a = e.find((e => this.startKeywords.includes(e.type)));
                                let c = e.find((e => e.type == this.blockNodeType));
                                if (a) {
                                    switch (this.languageId) {
                                        case "python":
                                            {
                                                "try" == a.type && "identifier" == n.type && n.text.length > 4 && (c = null === (i = e.find((e => e.hasError()))) || void 0 === i ? void 0 : i.children.find((e => "block" == e.type)));
                                                const t = e.find((e => ":" == e.type));
                                                if (t && a.endIndex <= t.startIndex && t.nextSibling) {
                                                    if ("def" == a.type) {
                                                        const e = t.nextSibling;
                                                        if ('"' == e.type || "'" == e.type) return !0;
                                                        if ("ERROR" == e.type && ('"""' == e.text || "'''" == e.text)) return !0
                                                    }
                                                    return !1
                                                }
                                                break
                                            }
                                        case "javascript":
                                            {
                                                const t = e.find((e => "formal_parameters" == e.type));
                                                if ("class" == a.type && t) return !0;
                                                const r = e.find((e => "{" == e.type));
                                                if (r && r.startIndex > a.endIndex && null != r.nextSibling) return !1;
                                                if (e.find((e => "do" == e.type)) && "while" == a.type) return !1;
                                                if ("=>" == a.type && a.nextSibling && "{" != a.nextSibling.type) return !1;
                                                break
                                            }
                                        case "typescript":
                                            {
                                                const t = e.find((e => "{" == e.type));
                                                if (t && t.startIndex > a.endIndex && null != t.nextSibling) return !1;
                                                if (e.find((e => "do" == e.type)) && "while" == a.type) return !1;
                                                if ("=>" == a.type && a.nextSibling && "{" != a.nextSibling.type) return !1;
                                                break
                                            }
                                    }
                                    return !(c && c.startIndex > a.endIndex) || this.isBlockEmpty(c, t)
                                }
                            }
                            if (null != u) {
                                const e = this.nodeMatch[u.type],
                                    r = u.children.slice().reverse().find((t => t.type == e));
                                if (r) return this.isBlockEmpty(r, t);
                                if (this.nodeTypesWithBlockOrStmtChild.has(u.type)) {
                                    const e = this.nodeTypesWithBlockOrStmtChild.get(u.type),
                                        t = "" == e ? u.children[0] : u.childForFieldName(e);
                                    if (t && t.type != this.blockNodeType && t.type != this.emptyStatementType) return !1
                                }
                                return !0
                            }
                            return !1
                        } finally {
                            a.delete()
                        }
                    }
                }
                const u = {
                    python: new l("python", {
                        class_definition: "block",
                        elif_clause: "block",
                        else_clause: "block",
                        except_clause: "block",
                        finally_clause: "block",
                        for_statement: "block",
                        function_definition: "block",
                        if_statement: "block",
                        try_statement: "block",
                        while_statement: "block",
                        with_statement: "block"
                    }, new Map, ["def", "class", "if", "elif", "else", "for", "while", "try", "except", "finally", "with"], "block", null, !1),
                    javascript: new l("javascript", {
                        arrow_function: "statement_block",
                        catch_clause: "statement_block",
                        do_statement: "statement_block",
                        else_clause: "statement_block",
                        finally_clause: "statement_block",
                        for_in_statement: "statement_block",
                        for_statement: "statement_block",
                        function: "statement_block",
                        function_declaration: "statement_block",
                        generator_function: "statement_block",
                        generator_function_declaration: "statement_block",
                        if_statement: "statement_block",
                        method_definition: "statement_block",
                        try_statement: "statement_block",
                        while_statement: "statement_block",
                        with_statement: "statement_block",
                        class: "class_body",
                        class_declaration: "class_body"
                    }, new Map([
                        ["arrow_function", "body"],
                        ["do_statement", "body"],
                        ["else_clause", ""],
                        ["for_in_statement", "body"],
                        ["for_statement", "body"],
                        ["if_statement", "consequence"],
                        ["while_statement", "body"],
                        ["with_statement", "body"]
                    ]), ["=>", "try", "catch", "finally", "do", "for", "if", "else", "while", "with", "function", "function*", "class"], "statement_block", "empty_statement", !0),
                    typescript: new l("typescript", {
                        ambient_declaration: "statement_block",
                        arrow_function: "statement_block",
                        catch_clause: "statement_block",
                        do_statement: "statement_block",
                        else_clause: "statement_block",
                        finally_clause: "statement_block",
                        for_in_statement: "statement_block",
                        for_statement: "statement_block",
                        function: "statement_block",
                        function_declaration: "statement_block",
                        generator_function: "statement_block",
                        generator_function_declaration: "statement_block",
                        if_statement: "statement_block",
                        internal_module: "statement_block",
                        method_definition: "statement_block",
                        module: "statement_block",
                        try_statement: "statement_block",
                        while_statement: "statement_block",
                        abstract_class_declaration: "class_body",
                        class: "class_body",
                        class_declaration: "class_body"
                    }, new Map([
                        ["arrow_function", "body"],
                        ["do_statement", "body"],
                        ["else_clause", ""],
                        ["for_in_statement", "body"],
                        ["for_statement", "body"],
                        ["if_statement", "consequence"],
                        ["while_statement", "body"],
                        ["with_statement", "body"]
                    ]), ["declare", "=>", "try", "catch", "finally", "do", "for", "if", "else", "while", "with", "function", "function*", "class"], "statement_block", "empty_statement", !0),
                    go: new i("go", "{}", /\b(func|if|else|for)\b/, {
                        communication_case: "block",
                        default_case: "block",
                        expression_case: "block",
                        for_statement: "block",
                        func_literal: "block",
                        function_declaration: "block",
                        if_statement: "block",
                        labeled_statement: "block",
                        method_declaration: "block",
                        type_case: "block"
                    }, new Map),
                    ruby: new i("ruby", "end", /\b(BEGIN|END|case|class|def|do|else|elsif|for|if|module|unless|until|while)\b|->/, {
                        begin_block: "}",
                        block: "}",
                        end_block: "}",
                        lambda: "block",
                        for: "do",
                        until: "do",
                        while: "do",
                        case: "end",
                        do: "end",
                        if: "end",
                        method: "end",
                        module: "end",
                        unless: "end",
                        do_block: "end"
                    }, new Map)
                };

                function d(e) {
                    return u[(0, n.languageIdToWasmLanguage)(e)]
                }
                t.getBlockParser = d, t.isEmptyBlockStart = async function(e, t, r) {
                    return !!(0, n.isSupportedLanguageId)(e) && d(e).isEmptyBlockStart(t, r)
                }, t.isBlockBodyFinished = async function(e, t, r, o) {
                    if ((0, n.isSupportedLanguageId)(e)) return d(e).isBlockBodyFinished(t, r, o)
                }, t.getNodeStart = async function(e, t, r) {
                    if ((0, n.isSupportedLanguageId)(e)) return d(e).getNodeStart(t, r)
                }
            },
            1747: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getPrompt = t.newLineEnded = t.normalizeLanguageId = t.PromptOptions = t.SuffixStartMode = t.SuffixOption = t.LineEndingOptions = t.LocalImportContextOption = t.NeighboringTabsOption = t.SiblingOption = t.PathMarkerOption = t.LanguageMarkerOption = t.TOKENS_RESERVED_FOR_SUFFIX_ENCODING = t.MAX_PROMPT_LENGTH = void 0;
                const n = r(9852),
                    o = r(1788),
                    i = r(3507),
                    s = r(5531),
                    a = r(820),
                    c = r(9852),
                    l = r(7408);
                var u, d, p, h, f, m, g, _;
                t.MAX_PROMPT_LENGTH = 1500, t.TOKENS_RESERVED_FOR_SUFFIX_ENCODING = 5,
                    function(e) {
                        e.NoMarker = "nomarker", e.Top = "top", e.Always = "always"
                    }(u = t.LanguageMarkerOption || (t.LanguageMarkerOption = {})),
                    function(e) {
                        e.NoMarker = "nomarker", e.Top = "top", e.Always = "always"
                    }(d = t.PathMarkerOption || (t.PathMarkerOption = {})),
                    function(e) {
                        e.NoSiblings = "nosiblings", e.SiblingsOverContext = "siblingabove", e.ContextOverSiblings = "contextabove"
                    }(p = t.SiblingOption || (t.SiblingOption = {})),
                    function(e) {
                        e.None = "none", e.Conservative = "conservative", e.Medium = "medium", e.Eager = "eager", e.EagerButLittle = "eagerButLittle"
                    }(h = t.NeighboringTabsOption || (t.NeighboringTabsOption = {})),
                    function(e) {
                        e.NoContext = "nocontext", e.Declarations = "declarations"
                    }(f = t.LocalImportContextOption || (t.LocalImportContextOption = {})),
                    function(e) {
                        e.ConvertToUnix = "unix", e.KeepOriginal = "keep"
                    }(m = t.LineEndingOptions || (t.LineEndingOptions = {})), (_ = t.SuffixOption || (t.SuffixOption = {})).None = "none", _.FifteenPercent = "fifteenPercent",
                    function(e) {
                        e.Cursor = "cursor", e.CursorTrimStart = "cursortrimstart", e.CursorTrimStartWithStop = "cursortrimstartwithstop", e.SiblingBlock = "siblingblock", e.SiblingBlockTrimStart = "siblingblocktrimstart", e.SiblingBlockWithStop = "siblingblockwithstop", e.SiblingBlockTrimStartWithStop = "siblingblocktrimstartwithstop"
                    }(g = t.SuffixStartMode || (t.SuffixStartMode = {}));
                class y {
                    constructor(e, r) {
                        if (this.fs = e, this.maxPromptLength = t.MAX_PROMPT_LENGTH, this.languageMarker = u.Top, this.pathMarker = d.Top, this.includeSiblingFunctions = p.ContextOverSiblings, this.localImportContext = f.Declarations, this.neighboringTabs = h.Eager, this.lineEnding = m.ConvertToUnix, this.suffixPercent = 0, this.suffixStartMode = g.Cursor, r)
                            for (const e in r) this[e] = r[e];
                        if (this.suffixPercent < 0 || this.suffixPercent > 100) throw new Error(`suffixPercent must be between 0 and 100, but was ${this.suffixPercent}`);
                        if (this.suffixPercent > 0 && this.includeSiblingFunctions != p.NoSiblings) throw new Error(`Invalid option combination. Cannot set suffixPercent > 0 (${this.suffixPercent}) and includeSiblingFunctions ${this.includeSiblingFunctions}`)
                    }
                }
                t.PromptOptions = y;
                const v = {
                    javascriptreact: "javascript",
                    jsx: "javascript",
                    typescriptreact: "typescript",
                    jade: "pug",
                    cshtml: "razor"
                };

                function b(e) {
                    var t;
                    return e = e.toLowerCase(), null !== (t = v[e]) && void 0 !== t ? t : e
                }

                function w(e) {
                    return "" == e || e.endsWith("\n") ? e : e + "\n"
                }
                t.normalizeLanguageId = b, t.newLineEnded = w, t.getPrompt = async function(e, r, m = {}, _ = []) {
                    const v = new y(e, m),
                        {
                            source: x,
                            offset: E
                        } = r;
                    if (E < 0 || E > x.length) throw new Error(`Offset ${E} is out of range.`);
                    r.languageId = b(r.languageId);
                    const C = new l.Priorities,
                        S = C.justBelow(l.Priorities.TOP),
                        T = v.pathMarker == d.Always ? C.justBelow(l.Priorities.TOP) : C.justBelow(S),
                        k = v.languageMarker == u.Always ? C.justBelow(l.Priorities.TOP) : C.justBelow(S),
                        I = v.includeSiblingFunctions == p.ContextOverSiblings ? C.justBelow(S) : C.justAbove(S),
                        P = C.justBelow(S, I),
                        A = C.justBelow(P),
                        O = new l.PromptWishlist(v.lineEnding);
                    let N, R;
                    if (v.languageMarker != u.NoMarker) {
                        const e = w((0, o.getLanguageMarker)(r));
                        N = O.append(e, l.PromptElementKind.LanguageMarker, k)
                    }
                    if (v.pathMarker != d.NoMarker) {
                        const e = w((0, o.getPathMarker)(r));
                        R = O.append(e, l.PromptElementKind.PathMarker, T)
                    }
                    if (v.localImportContext != f.NoContext)
                        for (const e of await (0, i.extractLocalImportContext)(r, v.fs)) O.append(w(e), l.PromptElementKind.ImportedFile, P);
                    v.neighboringTabs != h.None && _.length > 0 && (await (0, s.getNeighborSnippets)(r, _, v.neighboringTabs)).forEach((e => O.append(e.snippet, l.PromptElementKind.SimilarFile, A, (0, c.tokenLength)(e.snippet), e.score)));
                    let $ = [];
                    if (v.includeSiblingFunctions == p.NoSiblings) $ = O.appendLineForLine(x.substring(0, E), l.PromptElementKind.BeforeCursor, S);
                    else {
                        const {
                            siblings: e,
                            beforeInsertion: t,
                            afterInsertion: n
                        } = await (0, a.getSiblingFunctions)(r);
                        O.appendLineForLine(t, l.PromptElementKind.BeforeCursor, S);
                        let o = I;
                        e.forEach((e => {
                            O.append(e, l.PromptElementKind.AfterCursor, o), o = C.justBelow(o)
                        })), $ = O.appendLineForLine(n, l.PromptElementKind.BeforeCursor, S)
                    }
                    if (u.Top == v.languageMarker && $.length > 0 && void 0 !== N && O.require(N, $[0]), d.Top == v.pathMarker && $.length > 0 && void 0 !== R && (N ? O.require(R, N) : O.require(R, $[0])), 0 == v.suffixPercent) return O.fulfill(v.maxPromptLength); {
                        let e = r.offset;
                        v.suffixStartMode !== g.Cursor && v.suffixStartMode !== g.CursorTrimStart && v.suffixStartMode !== g.CursorTrimStartWithStop && (e = await (0, a.getSiblingFunctionStart)(r));
                        const o = v.maxPromptLength - t.TOKENS_RESERVED_FOR_SUFFIX_ENCODING;
                        let i = Math.floor(o * (100 - v.suffixPercent) / 100),
                            s = O.fulfill(i);
                        const l = o - s.prefixLength;
                        let u = x.slice(e);
                        v.suffixStartMode != g.SiblingBlockTrimStart && v.suffixStartMode != g.SiblingBlockTrimStartWithStop && v.suffixStartMode != g.CursorTrimStart && v.suffixStartMode != g.CursorTrimStartWithStop || (u = u.trimStart());
                        const d = (0, n.takeFirstTokens)(u, l),
                            p = (0, c.tokenLength)(d);
                        return p <= l - 3 && (i = o - p, s = O.fulfill(i)), s.suffix = d, s.suffixLength = p, s
                    }
                }
            },
            5572: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.splitIntoWords = t.findBestJaccardMatch = void 0;
                const r = new class {
                    constructor(e) {
                        this.keys = [], this.cache = {}, this.size = e
                    }
                    put(e, t) {
                        var r;
                        if (this.cache[e] = t, this.keys.length > this.size) {
                            this.keys.push(e);
                            const t = null !== (r = this.keys.shift()) && void 0 !== r ? r : "";
                            delete this.cache[t]
                        }
                    }
                    get(e) {
                        return this.cache[e]
                    }
                }(20);

                function n(e, t) {
                    const r = new Set;
                    return e.forEach((e => {
                        t.has(e) && r.add(e)
                    })), r.size / (e.size + t.size - r.size)
                }

                function o(e) {
                    return e.split(/[^a-zA-Z0-9]/).filter((e => e.length > 0))
                }
                t.findBestJaccardMatch = function(e, t, i) {
                    var c, l;
                    if (0 === e.source.length || 0 === t.source.length) return;
                    const u = null !== (c = a.get(t.languageId)) && void 0 !== c ? c : s,
                        d = new Set(o(t.source).filter((e => !u.has(e)))),
                        p = e.source.split("\n"),
                        h = i.toString() + ":" + e.source,
                        f = null !== (l = r.get(h)) && void 0 !== l ? l : [],
                        m = 0 == f.length,
                        g = m ? p.map((e => new Set(o(e).filter((e => !u.has(e)))))) : [];
                    let _ = -1,
                        y = 0;
                    for (let e = 0; 0 == e || e < p.length - i; e++) {
                        const t = Math.min(e + i, p.length);
                        if (m) {
                            const r = new Set;
                            g.slice(e, t).forEach((e => e.forEach(r.add, r))), f.push(r)
                        }
                        const r = n(f[e], d);
                        r > y && (y = r, _ = e)
                    }
                    if (m && r.put(h, f), -1 !== _) {
                        const e = _,
                            t = Math.min(e + i, p.length);
                        return {
                            snippet: p.slice(e, t).join("\n"),
                            score: y
                        }
                    }
                }, t.splitIntoWords = o;
                const i = new Set(["we", "our", "you", "it", "its", "they", "them", "their", "this", "that", "these", "those", "is", "are", "was", "were", "be", "been", "being", "have", "has", "had", "having", "do", "does", "did", "doing", "can", "don", "t", "s", "will", "would", "should", "what", "which", "who", "when", "where", "why", "how", "a", "an", "the", "and", "or", "not", "no", "but", "because", "as", "until", "again", "further", "then", "once", "here", "there", "all", "any", "both", "each", "few", "more", "most", "other", "some", "such", "above", "below", "to", "during", "before", "after", "of", "at", "by", "about", "between", "into", "through", "from", "up", "down", "in", "out", "on", "off", "over", "under", "only", "own", "same", "so", "than", "too", "very", "just", "now"]),
                    s = new Set(["if", "then", "else", "for", "while", "with", "def", "function", "return", "TODO", "import", "try", "catch", "raise", "finally", "repeat", "switch", "case", "match", "assert", "continue", "break", "const", "class", "enum", "struct", "static", "new", "super", "this", "var", ...i]),
                    a = new Map([])
            },
            820: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getSiblingFunctionStart = t.getSiblingFunctions = void 0;
                const n = r(1747),
                    o = r(464);
                t.getSiblingFunctions = async function({
                    source: e,
                    offset: t,
                    languageId: r
                }) {
                    var i, s;
                    const a = [];
                    let c = "",
                        l = e.substring(0, t);
                    if ((0, o.isSupportedLanguageId)(r)) {
                        const u = await (0, o.parseTree)(r, e);
                        try {
                            let d = t;
                            for (; d >= 0 && /\s/.test(e[d]);) d--;
                            const p = u.rootNode.descendantForIndex(d),
                                h = (0, o.getAncestorWithSiblingFunctions)(r, p);
                            if (h) {
                                const u = (0, o.getFirstPrecedingComment)(h),
                                    d = null !== (i = null == u ? void 0 : u.startIndex) && void 0 !== i ? i : h.startIndex;
                                let p, f = 0;
                                for (;
                                    " " == (p = e[d - f - 1]) || "\t" == p;) f++;
                                const m = e.substring(d - f, d);
                                for (let i = h.nextSibling; i; i = i.nextSibling)
                                    if ((0, o.isFunctionDefinition)(r, i)) {
                                        const r = (0, o.getFirstPrecedingComment)(i),
                                            c = null !== (s = null == r ? void 0 : r.startIndex) && void 0 !== s ? s : i.startIndex;
                                        if (c < t) continue;
                                        const l = e.substring(c, i.endIndex),
                                            u = (0, n.newLineEnded)(l) + "\n" + m;
                                        a.push(u)
                                    }
                                c = e.substring(0, d), l = e.substring(d, t)
                            }
                        } finally {
                            u.delete()
                        }
                    }
                    return {
                        siblings: a,
                        beforeInsertion: c,
                        afterInsertion: l
                    }
                }, t.getSiblingFunctionStart = async function({
                    source: e,
                    offset: t,
                    languageId: r
                }) {
                    var n;
                    if ((0, o.isSupportedLanguageId)(r)) {
                        const i = await (0, o.parseTree)(r, e);
                        try {
                            let s = t;
                            for (; s >= 0 && /\s/.test(e[s]);) s--;
                            const a = i.rootNode.descendantForIndex(s),
                                c = (0, o.getAncestorWithSiblingFunctions)(r, a);
                            if (c) {
                                for (let e = c.nextSibling; e; e = e.nextSibling)
                                    if ((0, o.isFunctionDefinition)(r, e)) {
                                        const r = (0, o.getFirstPrecedingComment)(e),
                                            i = null !== (n = null == r ? void 0 : r.startIndex) && void 0 !== n ? n : e.startIndex;
                                        if (i < t) continue;
                                        return i
                                    }
                                if (c.endIndex >= t) return c.endIndex
                            }
                        } finally {
                            i.delete()
                        }
                    }
                    return t
                }
            },
            7408: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Priorities = t.PromptWishlist = t.PromptChoices = t.PromptBackground = t.PromptElementKind = void 0;
                const n = r(1747),
                    o = r(9852);
                var i;
                ! function(e) {
                    e.BeforeCursor = "BeforeCursor", e.AfterCursor = "AfterCursor", e.SimilarFile = "SimilarFile", e.ImportedFile = "ImportedFile", e.LanguageMarker = "LanguageMarker", e.PathMarker = "PathMarker"
                }(i = t.PromptElementKind || (t.PromptElementKind = {}));
                class s {
                    constructor() {
                        this.used = new Map, this.unused = new Map
                    }
                    markUsed(e) {
                        this.IsNeighboringTab(e) && this.used.set(e.id, this.convert(e))
                    }
                    undoMarkUsed(e) {
                        this.IsNeighboringTab(e) && this.used.delete(e.id)
                    }
                    markUnused(e) {
                        this.IsNeighboringTab(e) && this.unused.set(e.id, this.convert(e))
                    }
                    convert(e) {
                        return {
                            score: e.score.toFixed(4),
                            length: e.text.length
                        }
                    }
                    IsNeighboringTab(e) {
                        return e.kind == i.SimilarFile
                    }
                }
                t.PromptBackground = s;
                class a {
                    constructor() {
                        this.used = new Map, this.unused = new Map
                    }
                    markUsed(e) {
                        this.used.set(e.kind, (this.used.get(e.kind) || 0) + e.tokens)
                    }
                    undoMarkUsed(e) {
                        this.used.set(e.kind, (this.used.get(e.kind) || 0) - e.tokens)
                    }
                    markUnused(e) {
                        this.unused.set(e.kind, (this.used.get(e.kind) || 0) + e.tokens)
                    }
                }
                t.PromptChoices = a, t.PromptWishlist = class {
                    constructor(e) {
                        this.content = [], this.lineEndingOption = e
                    }
                    getContent() {
                        return [...this.content]
                    }
                    convertLineEndings(e) {
                        return this.lineEndingOption === n.LineEndingOptions.ConvertToUnix && (e = e.replace(/\r\n/g, "\n").replace(/\r/g, "\n")), e
                    }
                    append(e, t, r, n = (0, o.tokenLength)(e), i = NaN) {
                        e = this.convertLineEndings(e);
                        const s = this.content.length;
                        return this.content.push({
                            id: s,
                            text: e,
                            kind: t,
                            priority: r,
                            tokens: n,
                            requires: [],
                            excludes: [],
                            score: i
                        }), s
                    }
                    appendLineForLine(e, t, r) {
                        const n = (e = this.convertLineEndings(e)).split("\n");
                        for (let e = 0; e < n.length - 1; e++) n[e] += "\n";
                        const o = [];
                        n.forEach(((e, t) => {
                            "\n" === e && o.length > 0 && !o[o.length - 1].endsWith("\n\n") ? o[o.length - 1] += "\n" : o.push(e)
                        }));
                        const i = [];
                        return o.forEach(((e, n) => {
                            "" !== e && (i.push(this.append(e, t, r)), n > 0 && (this.content[this.content.length - 2].requires = [this.content[this.content.length - 1]]))
                        })), i
                    }
                    require(e, t) {
                        const r = this.content.find((t => t.id === e)),
                            n = this.content.find((e => e.id === t));
                        r && n && r.requires.push(n)
                    }
                    exclude(e, t) {
                        const r = this.content.find((t => t.id === e)),
                            n = this.content.find((e => e.id === t));
                        r && n && r.excludes.push(n)
                    }
                    fulfill(e) {
                        const t = new a,
                            r = new s,
                            n = this.content.map(((e, t) => ({
                                element: e,
                                index: t
                            })));
                        n.sort(((e, t) => e.element.priority === t.element.priority ? t.index - e.index : t.element.priority - e.element.priority));
                        const i = new Set,
                            c = new Set;
                        let l;
                        const u = [];
                        let d = e;
                        n.forEach((e => {
                            var n;
                            const o = e.element,
                                s = e.index;
                            if (d >= 0 && (d > 0 || void 0 === l) && o.requires.every((e => i.has(e.id))) && !c.has(o.id)) {
                                let a = o.tokens;
                                const p = null === (n = function(e, t) {
                                    let r, n = 1 / 0;
                                    for (const o of e) o.index > t && o.index < n && (r = o, n = o.index);
                                    return r
                                }(u, s)) || void 0 === n ? void 0 : n.element;
                                o.text.endsWith("\n\n") && p && !p.text.match(/^\s/) && a++, d >= a ? (d -= a, i.add(o.id), o.excludes.forEach((e => c.add(e.id))), t.markUsed(o), r.markUsed(o), u.push(e)) : l = null != l ? l : e
                            } else t.markUnused(o), r.markUnused(o)
                        })), u.sort(((e, t) => e.index - t.index));
                        let p = u.reduce(((e, t) => e + t.element.text), ""),
                            h = (0, o.tokenLength)(p);
                        for (; h > e;) {
                            u.sort(((e, t) => t.element.priority === e.element.priority ? t.index - e.index : t.element.priority - e.element.priority));
                            const e = u.pop();
                            e && (t.undoMarkUsed(e.element), t.markUnused(e.element), r.undoMarkUsed(e.element), r.markUnused(e.element), l = void 0), u.sort(((e, t) => e.index - t.index)), p = u.reduce(((e, t) => e + t.element.text), ""), h = (0, o.tokenLength)(p)
                        }
                        const f = [...u];
                        if (void 0 !== l) {
                            f.push(l), f.sort(((e, t) => e.index - t.index));
                            const n = f.reduce(((e, t) => e + t.element.text), ""),
                                i = (0, o.tokenLength)(n);
                            if (i <= e) return t.markUsed(l.element), r.markUsed(l.element), {
                                prefix: n,
                                suffix: "",
                                prefixLength: i,
                                suffixLength: 0,
                                promptChoices: t,
                                promptBackground: r
                            };
                            t.markUnused(l.element), r.markUnused(l.element)
                        }
                        return {
                            prefix: p,
                            suffix: "",
                            prefixLength: h,
                            suffixLength: 0,
                            promptChoices: t,
                            promptBackground: r
                        }
                    }
                };
                class c {
                    constructor() {
                        this.registeredPriorities = [0, 1]
                    }
                    register(e) {
                        if (e > c.TOP || e < c.BOTTOM) throw new Error("Priority must be between 0 and 1");
                        return this.registeredPriorities.push(e), e
                    }
                    justAbove(...e) {
                        const t = Math.max(...e),
                            r = Math.min(...this.registeredPriorities.filter((e => e > t)));
                        return this.register((r + t) / 2)
                    }
                    justBelow(...e) {
                        const t = Math.min(...e),
                            r = Math.max(...this.registeredPriorities.filter((e => e < t)));
                        return this.register((r + t) / 2)
                    }
                    between(e, t) {
                        if (this.registeredPriorities.some((r => r > e && r < t)) || !this.registeredPriorities.includes(e) || !this.registeredPriorities.includes(t)) throw new Error("Priorities must be adjacent in the list of priorities");
                        return this.register((e + t) / 2)
                    }
                }
                t.Priorities = c, c.TOP = 1, c.BOTTOM = 0
            },
            540: function(e, t) {
                ! function(e) {
                    "use strict";

                    function t() {
                        for (var e = arguments.length, t = Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                        if (t.length > 1) {
                            t[0] = t[0].slice(0, -1);
                            for (var n = t.length - 1, o = 1; o < n; ++o) t[o] = t[o].slice(1, -1);
                            return t[n] = t[n].slice(1), t.join("")
                        }
                        return t[0]
                    }

                    function r(e) {
                        return "(?:" + e + ")"
                    }

                    function n(e) {
                        return void 0 === e ? "undefined" : null === e ? "null" : Object.prototype.toString.call(e).split(" ").pop().split("]").shift().toLowerCase()
                    }

                    function o(e) {
                        return e.toUpperCase()
                    }

                    function i(e) {
                        var n = "[A-Za-z]",
                            o = "[0-9]",
                            i = t(o, "[A-Fa-f]"),
                            s = r(r("%[EFef]" + i + "%" + i + i + "%" + i + i) + "|" + r("%[89A-Fa-f]" + i + "%" + i + i) + "|" + r("%" + i + i)),
                            a = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
                            c = t("[\\:\\/\\?\\#\\[\\]\\@]", a),
                            l = e ? "[\\uE000-\\uF8FF]" : "[]",
                            u = t(n, o, "[\\-\\.\\_\\~]", e ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]"),
                            d = r(n + t(n, o, "[\\+\\-\\.]") + "*"),
                            p = r(r(s + "|" + t(u, a, "[\\:]")) + "*"),
                            h = (r(r("25[0-5]") + "|" + r("2[0-4][0-9]") + "|" + r("1[0-9][0-9]") + "|" + r("[1-9][0-9]") + "|" + o), r(r("25[0-5]") + "|" + r("2[0-4][0-9]") + "|" + r("1[0-9][0-9]") + "|" + r("0?[1-9][0-9]") + "|0?0?" + o)),
                            f = r(h + "\\." + h + "\\." + h + "\\." + h),
                            m = r(i + "{1,4}"),
                            g = r(r(m + "\\:" + m) + "|" + f),
                            _ = r(r(m + "\\:") + "{6}" + g),
                            y = r("\\:\\:" + r(m + "\\:") + "{5}" + g),
                            v = r(r(m) + "?\\:\\:" + r(m + "\\:") + "{4}" + g),
                            b = r(r(r(m + "\\:") + "{0,1}" + m) + "?\\:\\:" + r(m + "\\:") + "{3}" + g),
                            w = r(r(r(m + "\\:") + "{0,2}" + m) + "?\\:\\:" + r(m + "\\:") + "{2}" + g),
                            x = r(r(r(m + "\\:") + "{0,3}" + m) + "?\\:\\:" + m + "\\:" + g),
                            E = r(r(r(m + "\\:") + "{0,4}" + m) + "?\\:\\:" + g),
                            C = r(r(r(m + "\\:") + "{0,5}" + m) + "?\\:\\:" + m),
                            S = r(r(r(m + "\\:") + "{0,6}" + m) + "?\\:\\:"),
                            T = r([_, y, v, b, w, x, E, C, S].join("|")),
                            k = r(r(u + "|" + s) + "+"),
                            I = (r(T + "\\%25" + k), r(T + r("\\%25|\\%(?!" + i + "{2})") + k)),
                            P = r("[vV]" + i + "+\\." + t(u, a, "[\\:]") + "+"),
                            A = r("\\[" + r(I + "|" + T + "|" + P) + "\\]"),
                            O = r(r(s + "|" + t(u, a)) + "*"),
                            N = r(A + "|" + f + "(?!" + O + ")|" + O),
                            R = r("[0-9]*"),
                            $ = r(r(p + "@") + "?" + N + r("\\:" + R) + "?"),
                            M = r(s + "|" + t(u, a, "[\\:\\@]")),
                            D = r(M + "*"),
                            L = r(M + "+"),
                            F = r(r(s + "|" + t(u, a, "[\\@]")) + "+"),
                            j = r(r("\\/" + D) + "*"),
                            B = r("\\/" + r(L + j) + "?"),
                            q = r(F + j),
                            U = r(L + j),
                            H = "(?!" + M + ")",
                            G = (r(j + "|" + B + "|" + q + "|" + U + "|" + H), r(r(M + "|" + t("[\\/\\?]", l)) + "*")),
                            z = r(r(M + "|[\\/\\?]") + "*"),
                            V = r(r("\\/\\/" + $ + j) + "|" + B + "|" + U + "|" + H),
                            W = r(d + "\\:" + V + r("\\?" + G) + "?" + r("\\#" + z) + "?"),
                            K = r(r("\\/\\/" + $ + j) + "|" + B + "|" + q + "|" + H),
                            J = r(K + r("\\?" + G) + "?" + r("\\#" + z) + "?");
                        return r(W + "|" + J), r(d + "\\:" + V + r("\\?" + G) + "?"), r(r("\\/\\/(" + r("(" + p + ")@") + "?(" + N + ")" + r("\\:(" + R + ")") + "?)") + "?(" + j + "|" + B + "|" + U + "|" + H + ")"), r("\\?(" + G + ")"), r("\\#(" + z + ")"), r(r("\\/\\/(" + r("(" + p + ")@") + "?(" + N + ")" + r("\\:(" + R + ")") + "?)") + "?(" + j + "|" + B + "|" + q + "|" + H + ")"), r("\\?(" + G + ")"), r("\\#(" + z + ")"), r(r("\\/\\/(" + r("(" + p + ")@") + "?(" + N + ")" + r("\\:(" + R + ")") + "?)") + "?(" + j + "|" + B + "|" + U + "|" + H + ")"), r("\\?(" + G + ")"), r("\\#(" + z + ")"), r("(" + p + ")@"), r("\\:(" + R + ")"), {
                            NOT_SCHEME: new RegExp(t("[^]", n, o, "[\\+\\-\\.]"), "g"),
                            NOT_USERINFO: new RegExp(t("[^\\%\\:]", u, a), "g"),
                            NOT_HOST: new RegExp(t("[^\\%\\[\\]\\:]", u, a), "g"),
                            NOT_PATH: new RegExp(t("[^\\%\\/\\:\\@]", u, a), "g"),
                            NOT_PATH_NOSCHEME: new RegExp(t("[^\\%\\/\\@]", u, a), "g"),
                            NOT_QUERY: new RegExp(t("[^\\%]", u, a, "[\\:\\@\\/\\?]", l), "g"),
                            NOT_FRAGMENT: new RegExp(t("[^\\%]", u, a, "[\\:\\@\\/\\?]"), "g"),
                            ESCAPE: new RegExp(t("[^]", u, a), "g"),
                            UNRESERVED: new RegExp(u, "g"),
                            OTHER_CHARS: new RegExp(t("[^\\%]", u, c), "g"),
                            PCT_ENCODED: new RegExp(s, "g"),
                            IPV4ADDRESS: new RegExp("^(" + f + ")$"),
                            IPV6ADDRESS: new RegExp("^\\[?(" + T + ")" + r(r("\\%25|\\%(?!" + i + "{2})") + "(" + k + ")") + "?\\]?$")
                        }
                    }
                    var s = i(!1),
                        a = i(!0),
                        c = function(e, t) {
                            if (Array.isArray(e)) return e;
                            if (Symbol.iterator in Object(e)) return function(e, t) {
                                var r = [],
                                    n = !0,
                                    o = !1,
                                    i = void 0;
                                try {
                                    for (var s, a = e[Symbol.iterator](); !(n = (s = a.next()).done) && (r.push(s.value), !t || r.length !== t); n = !0);
                                } catch (e) {
                                    o = !0, i = e
                                } finally {
                                    try {
                                        !n && a.return && a.return()
                                    } finally {
                                        if (o) throw i
                                    }
                                }
                                return r
                            }(e, t);
                            throw new TypeError("Invalid attempt to destructure non-iterable instance")
                        },
                        l = 2147483647,
                        u = 36,
                        d = /^xn--/,
                        p = /[^\0-\x7E]/,
                        h = /[\x2E\u3002\uFF0E\uFF61]/g,
                        f = {
                            overflow: "Overflow: input needs wider integers to process",
                            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                            "invalid-input": "Invalid input"
                        },
                        m = Math.floor,
                        g = String.fromCharCode;

                    function _(e) {
                        throw new RangeError(f[e])
                    }

                    function y(e, t) {
                        var r = e.split("@"),
                            n = "";
                        return r.length > 1 && (n = r[0] + "@", e = r[1]), n + function(e, t) {
                            for (var r = [], n = e.length; n--;) r[n] = t(e[n]);
                            return r
                        }((e = e.replace(h, ".")).split("."), t).join(".")
                    }

                    function v(e) {
                        for (var t = [], r = 0, n = e.length; r < n;) {
                            var o = e.charCodeAt(r++);
                            if (o >= 55296 && o <= 56319 && r < n) {
                                var i = e.charCodeAt(r++);
                                56320 == (64512 & i) ? t.push(((1023 & o) << 10) + (1023 & i) + 65536) : (t.push(o), r--)
                            } else t.push(o)
                        }
                        return t
                    }
                    var b = function(e, t) {
                            return e + 22 + 75 * (e < 26) - ((0 != t) << 5)
                        },
                        w = function(e, t, r) {
                            var n = 0;
                            for (e = r ? m(e / 700) : e >> 1, e += m(e / t); e > 455; n += u) e = m(e / 35);
                            return m(n + 36 * e / (e + 38))
                        },
                        x = function(e) {
                            var t, r = [],
                                n = e.length,
                                o = 0,
                                i = 128,
                                s = 72,
                                a = e.lastIndexOf("-");
                            a < 0 && (a = 0);
                            for (var c = 0; c < a; ++c) e.charCodeAt(c) >= 128 && _("not-basic"), r.push(e.charCodeAt(c));
                            for (var d = a > 0 ? a + 1 : 0; d < n;) {
                                for (var p = o, h = 1, f = u;; f += u) {
                                    d >= n && _("invalid-input");
                                    var g = (t = e.charCodeAt(d++)) - 48 < 10 ? t - 22 : t - 65 < 26 ? t - 65 : t - 97 < 26 ? t - 97 : u;
                                    (g >= u || g > m((l - o) / h)) && _("overflow"), o += g * h;
                                    var y = f <= s ? 1 : f >= s + 26 ? 26 : f - s;
                                    if (g < y) break;
                                    var v = u - y;
                                    h > m(l / v) && _("overflow"), h *= v
                                }
                                var b = r.length + 1;
                                s = w(o - p, b, 0 == p), m(o / b) > l - i && _("overflow"), i += m(o / b), o %= b, r.splice(o++, 0, i)
                            }
                            return String.fromCodePoint.apply(String, r)
                        },
                        E = function(e) {
                            var t = [],
                                r = (e = v(e)).length,
                                n = 128,
                                o = 0,
                                i = 72,
                                s = !0,
                                a = !1,
                                c = void 0;
                            try {
                                for (var d, p = e[Symbol.iterator](); !(s = (d = p.next()).done); s = !0) {
                                    var h = d.value;
                                    h < 128 && t.push(g(h))
                                }
                            } catch (e) {
                                a = !0, c = e
                            } finally {
                                try {
                                    !s && p.return && p.return()
                                } finally {
                                    if (a) throw c
                                }
                            }
                            var f = t.length,
                                y = f;
                            for (f && t.push("-"); y < r;) {
                                var x = l,
                                    E = !0,
                                    C = !1,
                                    S = void 0;
                                try {
                                    for (var T, k = e[Symbol.iterator](); !(E = (T = k.next()).done); E = !0) {
                                        var I = T.value;
                                        I >= n && I < x && (x = I)
                                    }
                                } catch (e) {
                                    C = !0, S = e
                                } finally {
                                    try {
                                        !E && k.return && k.return()
                                    } finally {
                                        if (C) throw S
                                    }
                                }
                                var P = y + 1;
                                x - n > m((l - o) / P) && _("overflow"), o += (x - n) * P, n = x;
                                var A = !0,
                                    O = !1,
                                    N = void 0;
                                try {
                                    for (var R, $ = e[Symbol.iterator](); !(A = (R = $.next()).done); A = !0) {
                                        var M = R.value;
                                        if (M < n && ++o > l && _("overflow"), M == n) {
                                            for (var D = o, L = u;; L += u) {
                                                var F = L <= i ? 1 : L >= i + 26 ? 26 : L - i;
                                                if (D < F) break;
                                                var j = D - F,
                                                    B = u - F;
                                                t.push(g(b(F + j % B, 0))), D = m(j / B)
                                            }
                                            t.push(g(b(D, 0))), i = w(o, P, y == f), o = 0, ++y
                                        }
                                    }
                                } catch (e) {
                                    O = !0, N = e
                                } finally {
                                    try {
                                        !A && $.return && $.return()
                                    } finally {
                                        if (O) throw N
                                    }
                                }++o, ++n
                            }
                            return t.join("")
                        },
                        C = function(e) {
                            return y(e, (function(e) {
                                return p.test(e) ? "xn--" + E(e) : e
                            }))
                        },
                        S = function(e) {
                            return y(e, (function(e) {
                                return d.test(e) ? x(e.slice(4).toLowerCase()) : e
                            }))
                        },
                        T = {};

                    function k(e) {
                        var t = e.charCodeAt(0);
                        return t < 16 ? "%0" + t.toString(16).toUpperCase() : t < 128 ? "%" + t.toString(16).toUpperCase() : t < 2048 ? "%" + (t >> 6 | 192).toString(16).toUpperCase() + "%" + (63 & t | 128).toString(16).toUpperCase() : "%" + (t >> 12 | 224).toString(16).toUpperCase() + "%" + (t >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (63 & t | 128).toString(16).toUpperCase()
                    }

                    function I(e) {
                        for (var t = "", r = 0, n = e.length; r < n;) {
                            var o = parseInt(e.substr(r + 1, 2), 16);
                            if (o < 128) t += String.fromCharCode(o), r += 3;
                            else if (o >= 194 && o < 224) {
                                if (n - r >= 6) {
                                    var i = parseInt(e.substr(r + 4, 2), 16);
                                    t += String.fromCharCode((31 & o) << 6 | 63 & i)
                                } else t += e.substr(r, 6);
                                r += 6
                            } else if (o >= 224) {
                                if (n - r >= 9) {
                                    var s = parseInt(e.substr(r + 4, 2), 16),
                                        a = parseInt(e.substr(r + 7, 2), 16);
                                    t += String.fromCharCode((15 & o) << 12 | (63 & s) << 6 | 63 & a)
                                } else t += e.substr(r, 9);
                                r += 9
                            } else t += e.substr(r, 3), r += 3
                        }
                        return t
                    }

                    function P(e, t) {
                        function r(e) {
                            var r = I(e);
                            return r.match(t.UNRESERVED) ? r : e
                        }
                        return e.scheme && (e.scheme = String(e.scheme).replace(t.PCT_ENCODED, r).toLowerCase().replace(t.NOT_SCHEME, "")), void 0 !== e.userinfo && (e.userinfo = String(e.userinfo).replace(t.PCT_ENCODED, r).replace(t.NOT_USERINFO, k).replace(t.PCT_ENCODED, o)), void 0 !== e.host && (e.host = String(e.host).replace(t.PCT_ENCODED, r).toLowerCase().replace(t.NOT_HOST, k).replace(t.PCT_ENCODED, o)), void 0 !== e.path && (e.path = String(e.path).replace(t.PCT_ENCODED, r).replace(e.scheme ? t.NOT_PATH : t.NOT_PATH_NOSCHEME, k).replace(t.PCT_ENCODED, o)), void 0 !== e.query && (e.query = String(e.query).replace(t.PCT_ENCODED, r).replace(t.NOT_QUERY, k).replace(t.PCT_ENCODED, o)), void 0 !== e.fragment && (e.fragment = String(e.fragment).replace(t.PCT_ENCODED, r).replace(t.NOT_FRAGMENT, k).replace(t.PCT_ENCODED, o)), e
                    }

                    function A(e) {
                        return e.replace(/^0*(.*)/, "$1") || "0"
                    }

                    function O(e, t) {
                        var r = e.match(t.IPV4ADDRESS) || [],
                            n = c(r, 2)[1];
                        return n ? n.split(".").map(A).join(".") : e
                    }

                    function N(e, t) {
                        var r = e.match(t.IPV6ADDRESS) || [],
                            n = c(r, 3),
                            o = n[1],
                            i = n[2];
                        if (o) {
                            for (var s = o.toLowerCase().split("::").reverse(), a = c(s, 2), l = a[0], u = a[1], d = u ? u.split(":").map(A) : [], p = l.split(":").map(A), h = t.IPV4ADDRESS.test(p[p.length - 1]), f = h ? 7 : 8, m = p.length - f, g = Array(f), _ = 0; _ < f; ++_) g[_] = d[_] || p[m + _] || "";
                            h && (g[f - 1] = O(g[f - 1], t));
                            var y = g.reduce((function(e, t, r) {
                                    if (!t || "0" === t) {
                                        var n = e[e.length - 1];
                                        n && n.index + n.length === r ? n.length++ : e.push({
                                            index: r,
                                            length: 1
                                        })
                                    }
                                    return e
                                }), []).sort((function(e, t) {
                                    return t.length - e.length
                                }))[0],
                                v = void 0;
                            if (y && y.length > 1) {
                                var b = g.slice(0, y.index),
                                    w = g.slice(y.index + y.length);
                                v = b.join(":") + "::" + w.join(":")
                            } else v = g.join(":");
                            return i && (v += "%" + i), v
                        }
                        return e
                    }
                    var R = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i,
                        $ = void 0 === "".match(/(){0}/)[1];

                    function M(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                            r = {},
                            n = !1 !== t.iri ? a : s;
                        "suffix" === t.reference && (e = (t.scheme ? t.scheme + ":" : "") + "//" + e);
                        var o = e.match(R);
                        if (o) {
                            $ ? (r.scheme = o[1], r.userinfo = o[3], r.host = o[4], r.port = parseInt(o[5], 10), r.path = o[6] || "", r.query = o[7], r.fragment = o[8], isNaN(r.port) && (r.port = o[5])) : (r.scheme = o[1] || void 0, r.userinfo = -1 !== e.indexOf("@") ? o[3] : void 0, r.host = -1 !== e.indexOf("//") ? o[4] : void 0, r.port = parseInt(o[5], 10), r.path = o[6] || "", r.query = -1 !== e.indexOf("?") ? o[7] : void 0, r.fragment = -1 !== e.indexOf("#") ? o[8] : void 0, isNaN(r.port) && (r.port = e.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? o[4] : void 0)), r.host && (r.host = N(O(r.host, n), n)), void 0 !== r.scheme || void 0 !== r.userinfo || void 0 !== r.host || void 0 !== r.port || r.path || void 0 !== r.query ? void 0 === r.scheme ? r.reference = "relative" : void 0 === r.fragment ? r.reference = "absolute" : r.reference = "uri" : r.reference = "same-document", t.reference && "suffix" !== t.reference && t.reference !== r.reference && (r.error = r.error || "URI is not a " + t.reference + " reference.");
                            var i = T[(t.scheme || r.scheme || "").toLowerCase()];
                            if (t.unicodeSupport || i && i.unicodeSupport) P(r, n);
                            else {
                                if (r.host && (t.domainHost || i && i.domainHost)) try {
                                    r.host = C(r.host.replace(n.PCT_ENCODED, I).toLowerCase())
                                } catch (e) {
                                    r.error = r.error || "Host's domain name can not be converted to ASCII via punycode: " + e
                                }
                                P(r, s)
                            }
                            i && i.parse && i.parse(r, t)
                        } else r.error = r.error || "URI can not be parsed.";
                        return r
                    }

                    function D(e, t) {
                        var r = !1 !== t.iri ? a : s,
                            n = [];
                        return void 0 !== e.userinfo && (n.push(e.userinfo), n.push("@")), void 0 !== e.host && n.push(N(O(String(e.host), r), r).replace(r.IPV6ADDRESS, (function(e, t, r) {
                            return "[" + t + (r ? "%25" + r : "") + "]"
                        }))), "number" != typeof e.port && "string" != typeof e.port || (n.push(":"), n.push(String(e.port))), n.length ? n.join("") : void 0
                    }
                    var L = /^\.\.?\//,
                        F = /^\/\.(\/|$)/,
                        j = /^\/\.\.(\/|$)/,
                        B = /^\/?(?:.|\n)*?(?=\/|$)/;

                    function q(e) {
                        for (var t = []; e.length;)
                            if (e.match(L)) e = e.replace(L, "");
                            else if (e.match(F)) e = e.replace(F, "/");
                        else if (e.match(j)) e = e.replace(j, "/"), t.pop();
                        else if ("." === e || ".." === e) e = "";
                        else {
                            var r = e.match(B);
                            if (!r) throw new Error("Unexpected dot segment condition");
                            var n = r[0];
                            e = e.slice(n.length), t.push(n)
                        }
                        return t.join("")
                    }

                    function U(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                            r = t.iri ? a : s,
                            n = [],
                            o = T[(t.scheme || e.scheme || "").toLowerCase()];
                        if (o && o.serialize && o.serialize(e, t), e.host)
                            if (r.IPV6ADDRESS.test(e.host));
                            else if (t.domainHost || o && o.domainHost) try {
                            e.host = t.iri ? S(e.host) : C(e.host.replace(r.PCT_ENCODED, I).toLowerCase())
                        } catch (r) {
                            e.error = e.error || "Host's domain name can not be converted to " + (t.iri ? "Unicode" : "ASCII") + " via punycode: " + r
                        }
                        P(e, r), "suffix" !== t.reference && e.scheme && (n.push(e.scheme), n.push(":"));
                        var i = D(e, t);
                        if (void 0 !== i && ("suffix" !== t.reference && n.push("//"), n.push(i), e.path && "/" !== e.path.charAt(0) && n.push("/")), void 0 !== e.path) {
                            var c = e.path;
                            t.absolutePath || o && o.absolutePath || (c = q(c)), void 0 === i && (c = c.replace(/^\/\//, "/%2F")), n.push(c)
                        }
                        return void 0 !== e.query && (n.push("?"), n.push(e.query)), void 0 !== e.fragment && (n.push("#"), n.push(e.fragment)), n.join("")
                    }

                    function H(e, t) {
                        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                            n = {};
                        return arguments[3] || (e = M(U(e, r), r), t = M(U(t, r), r)), !(r = r || {}).tolerant && t.scheme ? (n.scheme = t.scheme, n.userinfo = t.userinfo, n.host = t.host, n.port = t.port, n.path = q(t.path || ""), n.query = t.query) : (void 0 !== t.userinfo || void 0 !== t.host || void 0 !== t.port ? (n.userinfo = t.userinfo, n.host = t.host, n.port = t.port, n.path = q(t.path || ""), n.query = t.query) : (t.path ? ("/" === t.path.charAt(0) ? n.path = q(t.path) : (void 0 === e.userinfo && void 0 === e.host && void 0 === e.port || e.path ? e.path ? n.path = e.path.slice(0, e.path.lastIndexOf("/") + 1) + t.path : n.path = t.path : n.path = "/" + t.path, n.path = q(n.path)), n.query = t.query) : (n.path = e.path, void 0 !== t.query ? n.query = t.query : n.query = e.query), n.userinfo = e.userinfo, n.host = e.host, n.port = e.port), n.scheme = e.scheme), n.fragment = t.fragment, n
                    }

                    function G(e, t) {
                        return e && e.toString().replace(t && t.iri ? a.PCT_ENCODED : s.PCT_ENCODED, I)
                    }
                    var z = {
                            scheme: "http",
                            domainHost: !0,
                            parse: function(e, t) {
                                return e.host || (e.error = e.error || "HTTP URIs must have a host."), e
                            },
                            serialize: function(e, t) {
                                var r = "https" === String(e.scheme).toLowerCase();
                                return e.port !== (r ? 443 : 80) && "" !== e.port || (e.port = void 0), e.path || (e.path = "/"), e
                            }
                        },
                        V = {
                            scheme: "https",
                            domainHost: z.domainHost,
                            parse: z.parse,
                            serialize: z.serialize
                        };

                    function W(e) {
                        return "boolean" == typeof e.secure ? e.secure : "wss" === String(e.scheme).toLowerCase()
                    }
                    var K = {
                            scheme: "ws",
                            domainHost: !0,
                            parse: function(e, t) {
                                var r = e;
                                return r.secure = W(r), r.resourceName = (r.path || "/") + (r.query ? "?" + r.query : ""), r.path = void 0, r.query = void 0, r
                            },
                            serialize: function(e, t) {
                                if (e.port !== (W(e) ? 443 : 80) && "" !== e.port || (e.port = void 0), "boolean" == typeof e.secure && (e.scheme = e.secure ? "wss" : "ws", e.secure = void 0), e.resourceName) {
                                    var r = e.resourceName.split("?"),
                                        n = c(r, 2),
                                        o = n[0],
                                        i = n[1];
                                    e.path = o && "/" !== o ? o : void 0, e.query = i, e.resourceName = void 0
                                }
                                return e.fragment = void 0, e
                            }
                        },
                        J = {
                            scheme: "wss",
                            domainHost: K.domainHost,
                            parse: K.parse,
                            serialize: K.serialize
                        },
                        X = {},
                        Q = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]",
                        Y = "[0-9A-Fa-f]",
                        Z = r(r("%[EFef][0-9A-Fa-f]%" + Y + Y + "%" + Y + Y) + "|" + r("%[89A-Fa-f][0-9A-Fa-f]%" + Y + Y) + "|" + r("%" + Y + Y)),
                        ee = t("[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", '[\\"\\\\]'),
                        te = new RegExp(Q, "g"),
                        re = new RegExp(Z, "g"),
                        ne = new RegExp(t("[^]", "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", "[\\.]", '[\\"]', ee), "g"),
                        oe = new RegExp(t("[^]", Q, "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"), "g"),
                        ie = oe;

                    function se(e) {
                        var t = I(e);
                        return t.match(te) ? t : e
                    }
                    var ae = {
                            scheme: "mailto",
                            parse: function(e, t) {
                                var r = e,
                                    n = r.to = r.path ? r.path.split(",") : [];
                                if (r.path = void 0, r.query) {
                                    for (var o = !1, i = {}, s = r.query.split("&"), a = 0, c = s.length; a < c; ++a) {
                                        var l = s[a].split("=");
                                        switch (l[0]) {
                                            case "to":
                                                for (var u = l[1].split(","), d = 0, p = u.length; d < p; ++d) n.push(u[d]);
                                                break;
                                            case "subject":
                                                r.subject = G(l[1], t);
                                                break;
                                            case "body":
                                                r.body = G(l[1], t);
                                                break;
                                            default:
                                                o = !0, i[G(l[0], t)] = G(l[1], t)
                                        }
                                    }
                                    o && (r.headers = i)
                                }
                                r.query = void 0;
                                for (var h = 0, f = n.length; h < f; ++h) {
                                    var m = n[h].split("@");
                                    if (m[0] = G(m[0]), t.unicodeSupport) m[1] = G(m[1], t).toLowerCase();
                                    else try {
                                        m[1] = C(G(m[1], t).toLowerCase())
                                    } catch (e) {
                                        r.error = r.error || "Email address's domain name can not be converted to ASCII via punycode: " + e
                                    }
                                    n[h] = m.join("@")
                                }
                                return r
                            },
                            serialize: function(e, t) {
                                var r, n = e,
                                    i = null != (r = e.to) ? r instanceof Array ? r : "number" != typeof r.length || r.split || r.setInterval || r.call ? [r] : Array.prototype.slice.call(r) : [];
                                if (i) {
                                    for (var s = 0, a = i.length; s < a; ++s) {
                                        var c = String(i[s]),
                                            l = c.lastIndexOf("@"),
                                            u = c.slice(0, l).replace(re, se).replace(re, o).replace(ne, k),
                                            d = c.slice(l + 1);
                                        try {
                                            d = t.iri ? S(d) : C(G(d, t).toLowerCase())
                                        } catch (e) {
                                            n.error = n.error || "Email address's domain name can not be converted to " + (t.iri ? "Unicode" : "ASCII") + " via punycode: " + e
                                        }
                                        i[s] = u + "@" + d
                                    }
                                    n.path = i.join(",")
                                }
                                var p = e.headers = e.headers || {};
                                e.subject && (p.subject = e.subject), e.body && (p.body = e.body);
                                var h = [];
                                for (var f in p) p[f] !== X[f] && h.push(f.replace(re, se).replace(re, o).replace(oe, k) + "=" + p[f].replace(re, se).replace(re, o).replace(ie, k));
                                return h.length && (n.query = h.join("&")), n
                            }
                        },
                        ce = /^([^\:]+)\:(.*)/,
                        le = {
                            scheme: "urn",
                            parse: function(e, t) {
                                var r = e.path && e.path.match(ce),
                                    n = e;
                                if (r) {
                                    var o = t.scheme || n.scheme || "urn",
                                        i = r[1].toLowerCase(),
                                        s = r[2],
                                        a = o + ":" + (t.nid || i),
                                        c = T[a];
                                    n.nid = i, n.nss = s, n.path = void 0, c && (n = c.parse(n, t))
                                } else n.error = n.error || "URN can not be parsed.";
                                return n
                            },
                            serialize: function(e, t) {
                                var r = t.scheme || e.scheme || "urn",
                                    n = e.nid,
                                    o = r + ":" + (t.nid || n),
                                    i = T[o];
                                i && (e = i.serialize(e, t));
                                var s = e,
                                    a = e.nss;
                                return s.path = (n || t.nid) + ":" + a, s
                            }
                        },
                        ue = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/,
                        de = {
                            scheme: "urn:uuid",
                            parse: function(e, t) {
                                var r = e;
                                return r.uuid = r.nss, r.nss = void 0, t.tolerant || r.uuid && r.uuid.match(ue) || (r.error = r.error || "UUID is not valid."), r
                            },
                            serialize: function(e, t) {
                                var r = e;
                                return r.nss = (e.uuid || "").toLowerCase(), r
                            }
                        };
                    T[z.scheme] = z, T[V.scheme] = V, T[K.scheme] = K, T[J.scheme] = J, T[ae.scheme] = ae, T[le.scheme] = le, T[de.scheme] = de, e.SCHEMES = T, e.pctEncChar = k, e.pctDecChars = I, e.parse = M, e.removeDotSegments = q, e.serialize = U, e.resolveComponents = H, e.resolve = function(e, t, r) {
                        var n = function(e, t) {
                            var r = e;
                            if (t)
                                for (var n in t) r[n] = t[n];
                            return r
                        }({
                            scheme: "null"
                        }, r);
                        return U(H(M(e, n), M(t, n), n, !0), n)
                    }, e.normalize = function(e, t) {
                        return "string" == typeof e ? e = U(M(e, t), t) : "object" === n(e) && (e = M(U(e, t), t)), e
                    }, e.equal = function(e, t, r) {
                        return "string" == typeof e ? e = U(M(e, r), r) : "object" === n(e) && (e = U(e, r)), "string" == typeof t ? t = U(M(t, r), r) : "object" === n(t) && (t = U(t, r)), e === t
                    }, e.escapeComponent = function(e, t) {
                        return e && e.toString().replace(t && t.iri ? a.ESCAPE : s.ESCAPE, k)
                    }, e.unescapeComponent = G, Object.defineProperty(e, "__esModule", {
                        value: !0
                    })
                }(t)
            },
            2277: (e, t, r) => {
                "use strict";
                r.r(t), r.d(t, {
                    NIL: () => x,
                    parse: () => _,
                    stringify: () => d,
                    v1: () => g,
                    v3: () => v,
                    v4: () => b,
                    v5: () => w,
                    validate: () => l,
                    version: () => E
                });
                var n = r(6113),
                    o = r.n(n);
                const i = new Uint8Array(256);
                let s = i.length;

                function a() {
                    return s > i.length - 16 && (o().randomFillSync(i), s = 0), i.slice(s, s += 16)
                }
                const c = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i,
                    l = function(e) {
                        return "string" == typeof e && c.test(e)
                    },
                    u = [];
                for (let e = 0; e < 256; ++e) u.push((e + 256).toString(16).substr(1));
                const d = function(e, t = 0) {
                    const r = (u[e[t + 0]] + u[e[t + 1]] + u[e[t + 2]] + u[e[t + 3]] + "-" + u[e[t + 4]] + u[e[t + 5]] + "-" + u[e[t + 6]] + u[e[t + 7]] + "-" + u[e[t + 8]] + u[e[t + 9]] + "-" + u[e[t + 10]] + u[e[t + 11]] + u[e[t + 12]] + u[e[t + 13]] + u[e[t + 14]] + u[e[t + 15]]).toLowerCase();
                    if (!l(r)) throw TypeError("Stringified UUID is invalid");
                    return r
                };
                let p, h, f = 0,
                    m = 0;
                const g = function(e, t, r) {
                        let n = t && r || 0;
                        const o = t || new Array(16);
                        let i = (e = e || {}).node || p,
                            s = void 0 !== e.clockseq ? e.clockseq : h;
                        if (null == i || null == s) {
                            const t = e.random || (e.rng || a)();
                            null == i && (i = p = [1 | t[0], t[1], t[2], t[3], t[4], t[5]]), null == s && (s = h = 16383 & (t[6] << 8 | t[7]))
                        }
                        let c = void 0 !== e.msecs ? e.msecs : Date.now(),
                            l = void 0 !== e.nsecs ? e.nsecs : m + 1;
                        const u = c - f + (l - m) / 1e4;
                        if (u < 0 && void 0 === e.clockseq && (s = s + 1 & 16383), (u < 0 || c > f) && void 0 === e.nsecs && (l = 0), l >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
                        f = c, m = l, h = s, c += 122192928e5;
                        const g = (1e4 * (268435455 & c) + l) % 4294967296;
                        o[n++] = g >>> 24 & 255, o[n++] = g >>> 16 & 255, o[n++] = g >>> 8 & 255, o[n++] = 255 & g;
                        const _ = c / 4294967296 * 1e4 & 268435455;
                        o[n++] = _ >>> 8 & 255, o[n++] = 255 & _, o[n++] = _ >>> 24 & 15 | 16, o[n++] = _ >>> 16 & 255, o[n++] = s >>> 8 | 128, o[n++] = 255 & s;
                        for (let e = 0; e < 6; ++e) o[n + e] = i[e];
                        return t || d(o)
                    },
                    _ = function(e) {
                        if (!l(e)) throw TypeError("Invalid UUID");
                        let t;
                        const r = new Uint8Array(16);
                        return r[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24, r[1] = t >>> 16 & 255, r[2] = t >>> 8 & 255, r[3] = 255 & t, r[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8, r[5] = 255 & t, r[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8, r[7] = 255 & t, r[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8, r[9] = 255 & t, r[10] = (t = parseInt(e.slice(24, 36), 16)) / 1099511627776 & 255, r[11] = t / 4294967296 & 255, r[12] = t >>> 24 & 255, r[13] = t >>> 16 & 255, r[14] = t >>> 8 & 255, r[15] = 255 & t, r
                    };

                function y(e, t, r) {
                    function n(e, n, o, i) {
                        if ("string" == typeof e && (e = function(e) {
                                e = unescape(encodeURIComponent(e));
                                const t = [];
                                for (let r = 0; r < e.length; ++r) t.push(e.charCodeAt(r));
                                return t
                            }(e)), "string" == typeof n && (n = _(n)), 16 !== n.length) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
                        let s = new Uint8Array(16 + e.length);
                        if (s.set(n), s.set(e, n.length), s = r(s), s[6] = 15 & s[6] | t, s[8] = 63 & s[8] | 128, o) {
                            i = i || 0;
                            for (let e = 0; e < 16; ++e) o[i + e] = s[e];
                            return o
                        }
                        return d(s)
                    }
                    try {
                        n.name = e
                    } catch (e) {}
                    return n.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", n.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8", n
                }
                const v = y("v3", 48, (function(e) {
                        return Array.isArray(e) ? e = Buffer.from(e) : "string" == typeof e && (e = Buffer.from(e, "utf8")), o().createHash("md5").update(e).digest()
                    })),
                    b = function(e, t, r) {
                        const n = (e = e || {}).random || (e.rng || a)();
                        if (n[6] = 15 & n[6] | 64, n[8] = 63 & n[8] | 128, t) {
                            r = r || 0;
                            for (let e = 0; e < 16; ++e) t[r + e] = n[e];
                            return t
                        }
                        return d(n)
                    },
                    w = y("v5", 80, (function(e) {
                        return Array.isArray(e) ? e = Buffer.from(e) : "string" == typeof e && (e = Buffer.from(e, "utf8")), o().createHash("sha1").update(e).digest()
                    })),
                    x = "00000000-0000-0000-0000-000000000000",
                    E = function(e) {
                        if (!l(e)) throw TypeError("Invalid UUID");
                        return parseInt(e.substr(14, 1), 16)
                    }
            },
            4398: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), process.env.APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL = !0;
                var n = r(7147),
                    o = r(2037),
                    i = r(1017),
                    s = r(9496),
                    a = r(9574),
                    c = function() {
                        function e(e, t, r, o) {
                            var a = this;
                            this.extensionId = e, this.extensionVersion = t, this.firstParty = !1, this.userOptIn = !1, this.firstParty = !!o;
                            var c = process.env.VSCODE_LOGS || "";
                            c && e && "trace" === process.env.VSCODE_LOG_LEVEL && (c = i.join(c, e + ".txt"), this.logStream = n.createWriteStream(c, {
                                flags: "a",
                                encoding: "utf8",
                                autoClose: !0
                            })), this.updateUserOptIn(r), void 0 !== s.env.onDidChangeTelemetryEnabled ? this.optOutListener = s.env.onDidChangeTelemetryEnabled((function() {
                                return a.updateUserOptIn(r)
                            })) : this.optOutListener = s.workspace.onDidChangeConfiguration((function() {
                                return a.updateUserOptIn(r)
                            }))
                        }
                        return e.prototype.updateUserOptIn = function(t) {
                            var r = s.workspace.getConfiguration(e.TELEMETRY_CONFIG_ID),
                                n = void 0 === s.env.isTelemetryEnabled ? r.get(e.TELEMETRY_CONFIG_ENABLED_ID, !0) : s.env.isTelemetryEnabled;
                            this.userOptIn !== n && (this.userOptIn = n, this.userOptIn ? this.createAppInsightsClient(t) : this.dispose())
                        }, e.prototype.createAppInsightsClient = function(e) {
                            a.defaultClient ? (this.appInsightsClient = new a.TelemetryClient(e), this.appInsightsClient.channel.setUseDiskRetryCaching(!0)) : (a.setup(e).setAutoCollectRequests(!1).setAutoCollectPerformance(!1).setAutoCollectExceptions(!1).setAutoCollectDependencies(!1).setAutoDependencyCorrelation(!1).setAutoCollectConsole(!1).setUseDiskRetryCaching(!0).start(), this.appInsightsClient = a.defaultClient), this.appInsightsClient.commonProperties = this.getCommonProperties(), s && s.env && (this.appInsightsClient.context.tags[this.appInsightsClient.context.keys.userId] = s.env.machineId, this.appInsightsClient.context.tags[this.appInsightsClient.context.keys.sessionId] = s.env.sessionId), e && 0 === e.indexOf("AIF-") && (this.appInsightsClient.config.endpointUrl = "https://vortex.data.microsoft.com/collect/v1", this.firstParty = !0)
                        }, e.prototype.getCommonProperties = function() {
                            var e = Object.create(null);
                            if (e["common.os"] = o.platform(), e["common.platformversion"] = (o.release() || "").replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, "$1$2$3"), e["common.extname"] = this.extensionId, e["common.extversion"] = this.extensionVersion, s && s.env) {
                                switch (e["common.vscodemachineid"] = s.env.machineId, e["common.vscodesessionid"] = s.env.sessionId, e["common.vscodeversion"] = s.version, e["common.isnewappinstall"] = s.env.isNewAppInstall, s.env.uiKind) {
                                    case s.UIKind.Web:
                                        e["common.uikind"] = "web";
                                        break;
                                    case s.UIKind.Desktop:
                                        e["common.uikind"] = "desktop";
                                        break;
                                    default:
                                        e["common.uikind"] = "unknown"
                                }
                                e["common.remotename"] = this.cleanRemoteName(s.env.remoteName)
                            }
                            return e
                        }, e.prototype.cleanRemoteName = function(e) {
                            if (!e) return "none";
                            var t = "other";
                            return ["ssh-remote", "dev-container", "attached-container", "wsl"].forEach((function(r) {
                                0 === e.indexOf(r + "+") && (t = r)
                            })), t
                        }, e.prototype.shouldSendErrorTelemetry = function() {
                            return !this.firstParty || "other" !== this.cleanRemoteName(s.env.remoteName) || void 0 !== this.extension && this.extension.extensionKind !== s.ExtensionKind.Workspace && s.env.uiKind !== s.UIKind.Web
                        }, Object.defineProperty(e.prototype, "extension", {
                            get: function() {
                                return void 0 === this._extension && (this._extension = s.extensions.getExtension(this.extensionId)), this._extension
                            },
                            enumerable: !1,
                            configurable: !0
                        }), e.prototype.cloneAndChange = function(e, t) {
                            if (null === e || "object" != typeof e) return e;
                            if ("function" != typeof t) return e;
                            var r = {};
                            for (var n in e) r[n] = t(n, e[n]);
                            return r
                        }, e.prototype.anonymizeFilePaths = function(e, t) {
                            if (null == e) return "";
                            var r = [new RegExp(s.env.appRoot.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gi")];
                            this.extension && r.push(new RegExp(this.extension.extensionPath.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gi"));
                            var n = e;
                            if (t) {
                                for (var o = [], i = 0, a = r; i < a.length; i++)
                                    for (var c = a[i];;) {
                                        var l = c.exec(e);
                                        if (!l) break;
                                        o.push([l.index, c.lastIndex])
                                    }
                                var u = /^[\\\/]?(node_modules|node_modules\.asar)[\\\/]/,
                                    d = /(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-\._]+(\\\\|\\|\/))+[\w-\._]*/g,
                                    p = 0;
                                n = "";
                                for (var h = function() {
                                        var t = d.exec(e);
                                        if (!t) return "break";
                                        !u.test(t[0]) && o.every((function(e) {
                                            var r = e[0],
                                                n = e[1];
                                            return t.index < r || t.index >= n
                                        })) && (n += e.substring(p, t.index) + "<REDACTED: user-file-path>", p = d.lastIndex)
                                    };
                                    "break" !== h(););
                                p < e.length && (n += e.substr(p))
                            }
                            for (var f = 0, m = r; f < m.length; f++) c = m[f], n = n.replace(c, "");
                            return n
                        }, e.prototype.sendTelemetryEvent = function(e, t, r) {
                            var n = this;
                            if (this.userOptIn && e && this.appInsightsClient) {
                                var o = this.cloneAndChange(t, (function(e, t) {
                                    return n.anonymizeFilePaths(t, n.firstParty)
                                }));
                                this.appInsightsClient.trackEvent({
                                    name: this.extensionId + "/" + e,
                                    properties: o,
                                    measurements: r
                                }), this.logStream && this.logStream.write("telemetry/" + e + " " + JSON.stringify({
                                    properties: t,
                                    measurements: r
                                }) + "\n")
                            }
                        }, e.prototype.sendTelemetryErrorEvent = function(e, t, r, n) {
                            var o = this;
                            if (this.userOptIn && e && this.appInsightsClient) {
                                var i = this.cloneAndChange(t, (function(e, t) {
                                    return o.shouldSendErrorTelemetry() ? o.anonymizeFilePaths(t, o.firstParty) : void 0 === n || -1 !== n.indexOf(e) ? "REDACTED" : o.anonymizeFilePaths(t, o.firstParty)
                                }));
                                this.appInsightsClient.trackEvent({
                                    name: this.extensionId + "/" + e,
                                    properties: i,
                                    measurements: r
                                }), this.logStream && this.logStream.write("telemetry/" + e + " " + JSON.stringify({
                                    properties: t,
                                    measurements: r
                                }) + "\n")
                            }
                        }, e.prototype.sendTelemetryException = function(e, t, r) {
                            var n = this;
                            if (this.shouldSendErrorTelemetry() && this.userOptIn && e && this.appInsightsClient) {
                                var o = this.cloneAndChange(t, (function(e, t) {
                                    return n.anonymizeFilePaths(t, n.firstParty)
                                }));
                                this.appInsightsClient.trackException({
                                    exception: e,
                                    properties: o,
                                    measurements: r
                                }), this.logStream && this.logStream.write("telemetry/" + e.name + " " + e.message + " " + JSON.stringify({
                                    properties: t,
                                    measurements: r
                                }) + "\n")
                            }
                        }, e.prototype.dispose = function() {
                            var e = this;
                            this.optOutListener.dispose();
                            var t = new Promise((function(t) {
                                    if (!e.logStream) return t(void 0);
                                    e.logStream.on("finish", t), e.logStream.end()
                                })),
                                r = new Promise((function(t) {
                                    e.appInsightsClient ? e.appInsightsClient.flush({
                                        callback: function() {
                                            e.appInsightsClient = void 0, t(void 0)
                                        }
                                    }) : t(void 0)
                                }));
                            return Promise.all([r, t])
                        }, e.TELEMETRY_CONFIG_ID = "telemetry", e.TELEMETRY_CONFIG_ENABLED_ID = "enableTelemetry", e
                    }();
                t.default = c
            },
            7373: (e, t, r) => {
                "use strict";
                var n;
                r.r(t), r.d(t, {
                    URI: () => o,
                    Utils: () => i
                }), n = (() => {
                    var e = {
                            470: e => {
                                function t(e) {
                                    if ("string" != typeof e) throw new TypeError("Path must be a string. Received " + JSON.stringify(e))
                                }

                                function r(e, t) {
                                    for (var r, n = "", o = 0, i = -1, s = 0, a = 0; a <= e.length; ++a) {
                                        if (a < e.length) r = e.charCodeAt(a);
                                        else {
                                            if (47 === r) break;
                                            r = 47
                                        }
                                        if (47 === r) {
                                            if (i === a - 1 || 1 === s);
                                            else if (i !== a - 1 && 2 === s) {
                                                if (n.length < 2 || 2 !== o || 46 !== n.charCodeAt(n.length - 1) || 46 !== n.charCodeAt(n.length - 2))
                                                    if (n.length > 2) {
                                                        var c = n.lastIndexOf("/");
                                                        if (c !== n.length - 1) {
                                                            -1 === c ? (n = "", o = 0) : o = (n = n.slice(0, c)).length - 1 - n.lastIndexOf("/"), i = a, s = 0;
                                                            continue
                                                        }
                                                    } else if (2 === n.length || 1 === n.length) {
                                                    n = "", o = 0, i = a, s = 0;
                                                    continue
                                                }
                                                t && (n.length > 0 ? n += "/.." : n = "..", o = 2)
                                            } else n.length > 0 ? n += "/" + e.slice(i + 1, a) : n = e.slice(i + 1, a), o = a - i - 1;
                                            i = a, s = 0
                                        } else 46 === r && -1 !== s ? ++s : s = -1
                                    }
                                    return n
                                }
                                var n = {
                                    resolve: function() {
                                        for (var e, n = "", o = !1, i = arguments.length - 1; i >= -1 && !o; i--) {
                                            var s;
                                            i >= 0 ? s = arguments[i] : (void 0 === e && (e = process.cwd()), s = e), t(s), 0 !== s.length && (n = s + "/" + n, o = 47 === s.charCodeAt(0))
                                        }
                                        return n = r(n, !o), o ? n.length > 0 ? "/" + n : "/" : n.length > 0 ? n : "."
                                    },
                                    normalize: function(e) {
                                        if (t(e), 0 === e.length) return ".";
                                        var n = 47 === e.charCodeAt(0),
                                            o = 47 === e.charCodeAt(e.length - 1);
                                        return 0 !== (e = r(e, !n)).length || n || (e = "."), e.length > 0 && o && (e += "/"), n ? "/" + e : e
                                    },
                                    isAbsolute: function(e) {
                                        return t(e), e.length > 0 && 47 === e.charCodeAt(0)
                                    },
                                    join: function() {
                                        if (0 === arguments.length) return ".";
                                        for (var e, r = 0; r < arguments.length; ++r) {
                                            var o = arguments[r];
                                            t(o), o.length > 0 && (void 0 === e ? e = o : e += "/" + o)
                                        }
                                        return void 0 === e ? "." : n.normalize(e)
                                    },
                                    relative: function(e, r) {
                                        if (t(e), t(r), e === r) return "";
                                        if ((e = n.resolve(e)) === (r = n.resolve(r))) return "";
                                        for (var o = 1; o < e.length && 47 === e.charCodeAt(o); ++o);
                                        for (var i = e.length, s = i - o, a = 1; a < r.length && 47 === r.charCodeAt(a); ++a);
                                        for (var c = r.length - a, l = s < c ? s : c, u = -1, d = 0; d <= l; ++d) {
                                            if (d === l) {
                                                if (c > l) {
                                                    if (47 === r.charCodeAt(a + d)) return r.slice(a + d + 1);
                                                    if (0 === d) return r.slice(a + d)
                                                } else s > l && (47 === e.charCodeAt(o + d) ? u = d : 0 === d && (u = 0));
                                                break
                                            }
                                            var p = e.charCodeAt(o + d);
                                            if (p !== r.charCodeAt(a + d)) break;
                                            47 === p && (u = d)
                                        }
                                        var h = "";
                                        for (d = o + u + 1; d <= i; ++d) d !== i && 47 !== e.charCodeAt(d) || (0 === h.length ? h += ".." : h += "/..");
                                        return h.length > 0 ? h + r.slice(a + u) : (a += u, 47 === r.charCodeAt(a) && ++a, r.slice(a))
                                    },
                                    _makeLong: function(e) {
                                        return e
                                    },
                                    dirname: function(e) {
                                        if (t(e), 0 === e.length) return ".";
                                        for (var r = e.charCodeAt(0), n = 47 === r, o = -1, i = !0, s = e.length - 1; s >= 1; --s)
                                            if (47 === (r = e.charCodeAt(s))) {
                                                if (!i) {
                                                    o = s;
                                                    break
                                                }
                                            } else i = !1;
                                        return -1 === o ? n ? "/" : "." : n && 1 === o ? "//" : e.slice(0, o)
                                    },
                                    basename: function(e, r) {
                                        if (void 0 !== r && "string" != typeof r) throw new TypeError('"ext" argument must be a string');
                                        t(e);
                                        var n, o = 0,
                                            i = -1,
                                            s = !0;
                                        if (void 0 !== r && r.length > 0 && r.length <= e.length) {
                                            if (r.length === e.length && r === e) return "";
                                            var a = r.length - 1,
                                                c = -1;
                                            for (n = e.length - 1; n >= 0; --n) {
                                                var l = e.charCodeAt(n);
                                                if (47 === l) {
                                                    if (!s) {
                                                        o = n + 1;
                                                        break
                                                    }
                                                } else -1 === c && (s = !1, c = n + 1), a >= 0 && (l === r.charCodeAt(a) ? -1 == --a && (i = n) : (a = -1, i = c))
                                            }
                                            return o === i ? i = c : -1 === i && (i = e.length), e.slice(o, i)
                                        }
                                        for (n = e.length - 1; n >= 0; --n)
                                            if (47 === e.charCodeAt(n)) {
                                                if (!s) {
                                                    o = n + 1;
                                                    break
                                                }
                                            } else -1 === i && (s = !1, i = n + 1);
                                        return -1 === i ? "" : e.slice(o, i)
                                    },
                                    extname: function(e) {
                                        t(e);
                                        for (var r = -1, n = 0, o = -1, i = !0, s = 0, a = e.length - 1; a >= 0; --a) {
                                            var c = e.charCodeAt(a);
                                            if (47 !== c) - 1 === o && (i = !1, o = a + 1), 46 === c ? -1 === r ? r = a : 1 !== s && (s = 1) : -1 !== r && (s = -1);
                                            else if (!i) {
                                                n = a + 1;
                                                break
                                            }
                                        }
                                        return -1 === r || -1 === o || 0 === s || 1 === s && r === o - 1 && r === n + 1 ? "" : e.slice(r, o)
                                    },
                                    format: function(e) {
                                        if (null === e || "object" != typeof e) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
                                        return function(e, t) {
                                            var r = t.dir || t.root,
                                                n = t.base || (t.name || "") + (t.ext || "");
                                            return r ? r === t.root ? r + n : r + "/" + n : n
                                        }(0, e)
                                    },
                                    parse: function(e) {
                                        t(e);
                                        var r = {
                                            root: "",
                                            dir: "",
                                            base: "",
                                            ext: "",
                                            name: ""
                                        };
                                        if (0 === e.length) return r;
                                        var n, o = e.charCodeAt(0),
                                            i = 47 === o;
                                        i ? (r.root = "/", n = 1) : n = 0;
                                        for (var s = -1, a = 0, c = -1, l = !0, u = e.length - 1, d = 0; u >= n; --u)
                                            if (47 !== (o = e.charCodeAt(u))) - 1 === c && (l = !1, c = u + 1), 46 === o ? -1 === s ? s = u : 1 !== d && (d = 1) : -1 !== s && (d = -1);
                                            else if (!l) {
                                            a = u + 1;
                                            break
                                        }
                                        return -1 === s || -1 === c || 0 === d || 1 === d && s === c - 1 && s === a + 1 ? -1 !== c && (r.base = r.name = 0 === a && i ? e.slice(1, c) : e.slice(a, c)) : (0 === a && i ? (r.name = e.slice(1, s), r.base = e.slice(1, c)) : (r.name = e.slice(a, s), r.base = e.slice(a, c)), r.ext = e.slice(s, c)), a > 0 ? r.dir = e.slice(0, a - 1) : i && (r.dir = "/"), r
                                    },
                                    sep: "/",
                                    delimiter: ":",
                                    win32: null,
                                    posix: null
                                };
                                n.posix = n, e.exports = n
                            },
                            447: (e, t, r) => {
                                var n;
                                if (r.r(t), r.d(t, {
                                        URI: () => f,
                                        Utils: () => S
                                    }), "object" == typeof process) n = "win32" === process.platform;
                                else if ("object" == typeof navigator) {
                                    var o = navigator.userAgent;
                                    n = o.indexOf("Windows") >= 0
                                }
                                var i, s, a = (i = function(e, t) {
                                        return (i = Object.setPrototypeOf || {
                                                __proto__: []
                                            }
                                            instanceof Array && function(e, t) {
                                                e.__proto__ = t
                                            } || function(e, t) {
                                                for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r])
                                            })(e, t)
                                    }, function(e, t) {
                                        function r() {
                                            this.constructor = e
                                        }
                                        i(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                                    }),
                                    c = /^\w[\w\d+.-]*$/,
                                    l = /^\//,
                                    u = /^\/\//,
                                    d = "",
                                    p = "/",
                                    h = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,
                                    f = function() {
                                        function e(e, t, r, n, o, i) {
                                            void 0 === i && (i = !1), "object" == typeof e ? (this.scheme = e.scheme || d, this.authority = e.authority || d, this.path = e.path || d, this.query = e.query || d, this.fragment = e.fragment || d) : (this.scheme = function(e, t) {
                                                return e || t ? e : "file"
                                            }(e, i), this.authority = t || d, this.path = function(e, t) {
                                                switch (e) {
                                                    case "https":
                                                    case "http":
                                                    case "file":
                                                        t ? t[0] !== p && (t = p + t) : t = p
                                                }
                                                return t
                                            }(this.scheme, r || d), this.query = n || d, this.fragment = o || d, function(e, t) {
                                                if (!e.scheme && t) throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "' + e.authority + '", path: "' + e.path + '", query: "' + e.query + '", fragment: "' + e.fragment + '"}');
                                                if (e.scheme && !c.test(e.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
                                                if (e.path)
                                                    if (e.authority) {
                                                        if (!l.test(e.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character')
                                                    } else if (u.test(e.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")')
                                            }(this, i))
                                        }
                                        return e.isUri = function(t) {
                                            return t instanceof e || !!t && "string" == typeof t.authority && "string" == typeof t.fragment && "string" == typeof t.path && "string" == typeof t.query && "string" == typeof t.scheme && "function" == typeof t.fsPath && "function" == typeof t.with && "function" == typeof t.toString
                                        }, Object.defineProperty(e.prototype, "fsPath", {
                                            get: function() {
                                                return b(this, !1)
                                            },
                                            enumerable: !1,
                                            configurable: !0
                                        }), e.prototype.with = function(e) {
                                            if (!e) return this;
                                            var t = e.scheme,
                                                r = e.authority,
                                                n = e.path,
                                                o = e.query,
                                                i = e.fragment;
                                            return void 0 === t ? t = this.scheme : null === t && (t = d), void 0 === r ? r = this.authority : null === r && (r = d), void 0 === n ? n = this.path : null === n && (n = d), void 0 === o ? o = this.query : null === o && (o = d), void 0 === i ? i = this.fragment : null === i && (i = d), t === this.scheme && r === this.authority && n === this.path && o === this.query && i === this.fragment ? this : new g(t, r, n, o, i)
                                        }, e.parse = function(e, t) {
                                            void 0 === t && (t = !1);
                                            var r = h.exec(e);
                                            return r ? new g(r[2] || d, C(r[4] || d), C(r[5] || d), C(r[7] || d), C(r[9] || d), t) : new g(d, d, d, d, d)
                                        }, e.file = function(e) {
                                            var t = d;
                                            if (n && (e = e.replace(/\\/g, p)), e[0] === p && e[1] === p) {
                                                var r = e.indexOf(p, 2); - 1 === r ? (t = e.substring(2), e = p) : (t = e.substring(2, r), e = e.substring(r) || p)
                                            }
                                            return new g("file", t, e, d, d)
                                        }, e.from = function(e) {
                                            return new g(e.scheme, e.authority, e.path, e.query, e.fragment)
                                        }, e.prototype.toString = function(e) {
                                            return void 0 === e && (e = !1), w(this, e)
                                        }, e.prototype.toJSON = function() {
                                            return this
                                        }, e.revive = function(t) {
                                            if (t) {
                                                if (t instanceof e) return t;
                                                var r = new g(t);
                                                return r._formatted = t.external, r._fsPath = t._sep === m ? t.fsPath : null, r
                                            }
                                            return t
                                        }, e
                                    }(),
                                    m = n ? 1 : void 0,
                                    g = function(e) {
                                        function t() {
                                            var t = null !== e && e.apply(this, arguments) || this;
                                            return t._formatted = null, t._fsPath = null, t
                                        }
                                        return a(t, e), Object.defineProperty(t.prototype, "fsPath", {
                                            get: function() {
                                                return this._fsPath || (this._fsPath = b(this, !1)), this._fsPath
                                            },
                                            enumerable: !1,
                                            configurable: !0
                                        }), t.prototype.toString = function(e) {
                                            return void 0 === e && (e = !1), e ? w(this, !0) : (this._formatted || (this._formatted = w(this, !1)), this._formatted)
                                        }, t.prototype.toJSON = function() {
                                            var e = {
                                                $mid: 1
                                            };
                                            return this._fsPath && (e.fsPath = this._fsPath, e._sep = m), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e
                                        }, t
                                    }(f),
                                    _ = ((s = {})[58] = "%3A", s[47] = "%2F", s[63] = "%3F", s[35] = "%23", s[91] = "%5B", s[93] = "%5D", s[64] = "%40", s[33] = "%21", s[36] = "%24", s[38] = "%26", s[39] = "%27", s[40] = "%28", s[41] = "%29", s[42] = "%2A", s[43] = "%2B", s[44] = "%2C", s[59] = "%3B", s[61] = "%3D", s[32] = "%20", s);

                                function y(e, t) {
                                    for (var r = void 0, n = -1, o = 0; o < e.length; o++) {
                                        var i = e.charCodeAt(o);
                                        if (i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || 45 === i || 46 === i || 95 === i || 126 === i || t && 47 === i) - 1 !== n && (r += encodeURIComponent(e.substring(n, o)), n = -1), void 0 !== r && (r += e.charAt(o));
                                        else {
                                            void 0 === r && (r = e.substr(0, o));
                                            var s = _[i];
                                            void 0 !== s ? (-1 !== n && (r += encodeURIComponent(e.substring(n, o)), n = -1), r += s) : -1 === n && (n = o)
                                        }
                                    }
                                    return -1 !== n && (r += encodeURIComponent(e.substring(n))), void 0 !== r ? r : e
                                }

                                function v(e) {
                                    for (var t = void 0, r = 0; r < e.length; r++) {
                                        var n = e.charCodeAt(r);
                                        35 === n || 63 === n ? (void 0 === t && (t = e.substr(0, r)), t += _[n]) : void 0 !== t && (t += e[r])
                                    }
                                    return void 0 !== t ? t : e
                                }

                                function b(e, t) {
                                    var r;
                                    return r = e.authority && e.path.length > 1 && "file" === e.scheme ? "//" + e.authority + e.path : 47 === e.path.charCodeAt(0) && (e.path.charCodeAt(1) >= 65 && e.path.charCodeAt(1) <= 90 || e.path.charCodeAt(1) >= 97 && e.path.charCodeAt(1) <= 122) && 58 === e.path.charCodeAt(2) ? t ? e.path.substr(1) : e.path[1].toLowerCase() + e.path.substr(2) : e.path, n && (r = r.replace(/\//g, "\\")), r
                                }

                                function w(e, t) {
                                    var r = t ? v : y,
                                        n = "",
                                        o = e.scheme,
                                        i = e.authority,
                                        s = e.path,
                                        a = e.query,
                                        c = e.fragment;
                                    if (o && (n += o, n += ":"), (i || "file" === o) && (n += p, n += p), i) {
                                        var l = i.indexOf("@");
                                        if (-1 !== l) {
                                            var u = i.substr(0, l);
                                            i = i.substr(l + 1), -1 === (l = u.indexOf(":")) ? n += r(u, !1) : (n += r(u.substr(0, l), !1), n += ":", n += r(u.substr(l + 1), !1)), n += "@"
                                        } - 1 === (l = (i = i.toLowerCase()).indexOf(":")) ? n += r(i, !1) : (n += r(i.substr(0, l), !1), n += i.substr(l))
                                    }
                                    if (s) {
                                        if (s.length >= 3 && 47 === s.charCodeAt(0) && 58 === s.charCodeAt(2))(d = s.charCodeAt(1)) >= 65 && d <= 90 && (s = "/" + String.fromCharCode(d + 32) + ":" + s.substr(3));
                                        else if (s.length >= 2 && 58 === s.charCodeAt(1)) {
                                            var d;
                                            (d = s.charCodeAt(0)) >= 65 && d <= 90 && (s = String.fromCharCode(d + 32) + ":" + s.substr(2))
                                        }
                                        n += r(s, !0)
                                    }
                                    return a && (n += "?", n += r(a, !1)), c && (n += "#", n += t ? c : y(c, !1)), n
                                }

                                function x(e) {
                                    try {
                                        return decodeURIComponent(e)
                                    } catch (t) {
                                        return e.length > 3 ? e.substr(0, 3) + x(e.substr(3)) : e
                                    }
                                }
                                var E = /(%[0-9A-Za-z][0-9A-Za-z])+/g;

                                function C(e) {
                                    return e.match(E) ? e.replace(E, (function(e) {
                                        return x(e)
                                    })) : e
                                }
                                var S, T = r(470),
                                    k = function() {
                                        for (var e = 0, t = 0, r = arguments.length; t < r; t++) e += arguments[t].length;
                                        var n = Array(e),
                                            o = 0;
                                        for (t = 0; t < r; t++)
                                            for (var i = arguments[t], s = 0, a = i.length; s < a; s++, o++) n[o] = i[s];
                                        return n
                                    },
                                    I = T.posix || T;
                                ! function(e) {
                                    e.joinPath = function(e) {
                                        for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
                                        return e.with({
                                            path: I.join.apply(I, k([e.path], t))
                                        })
                                    }, e.resolvePath = function(e) {
                                        for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
                                        var n = e.path || "/";
                                        return e.with({
                                            path: I.resolve.apply(I, k([n], t))
                                        })
                                    }, e.dirname = function(e) {
                                        var t = I.dirname(e.path);
                                        return 1 === t.length && 46 === t.charCodeAt(0) ? e : e.with({
                                            path: t
                                        })
                                    }, e.basename = function(e) {
                                        return I.basename(e.path)
                                    }, e.extname = function(e) {
                                        return I.extname(e.path)
                                    }
                                }(S || (S = {}))
                            }
                        },
                        t = {};

                    function r(n) {
                        if (t[n]) return t[n].exports;
                        var o = t[n] = {
                            exports: {}
                        };
                        return e[n](o, o.exports, r), o.exports
                    }
                    return r.d = (e, t) => {
                        for (var n in t) r.o(t, n) && !r.o(e, n) && Object.defineProperty(e, n, {
                            enumerable: !0,
                            get: t[n]
                        })
                    }, r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), r.r = e => {
                        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                            value: "Module"
                        }), Object.defineProperty(e, "__esModule", {
                            value: !0
                        })
                    }, r(447)
                })();
                const {
                    URI: o,
                    Utils: i
                } = n
            },
            4087: (e, t, r) => {
                var n, o = void 0 !== o ? o : {};
                void 0 === (n = function() {
                    var t, n = {};
                    for (t in o) o.hasOwnProperty(t) && (n[t] = o[t]);
                    var i, s, a = [],
                        c = "./this.program",
                        l = function(e, t) {
                            throw t
                        },
                        u = !1,
                        d = !1;
                    u = "object" == typeof window, d = "function" == typeof importScripts, i = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, s = !u && !i && !d;
                    var p, h, f, m, g, _ = "";
                    i ? (_ = d ? r(1017).dirname(_) + "/" : __dirname + "/", p = function(e, t) {
                        return m || (m = r(7147)), g || (g = r(1017)), e = g.normalize(e), m.readFileSync(e, t ? null : "utf8")
                    }, f = function(e) {
                        var t = p(e, !0);
                        return t.buffer || (t = new Uint8Array(t)), O(t.buffer), t
                    }, process.argv.length > 1 && (c = process.argv[1].replace(/\\/g, "/")), a = process.argv.slice(2), e.exports = o, l = function(e) {
                        process.exit(e)
                    }, o.inspect = function() {
                        return "[Emscripten Module object]"
                    }) : s ? ("undefined" != typeof read && (p = function(e) {
                        return read(e)
                    }), f = function(e) {
                        var t;
                        return "function" == typeof readbuffer ? new Uint8Array(readbuffer(e)) : (O("object" == typeof(t = read(e, "binary"))), t)
                    }, "undefined" != typeof scriptArgs ? a = scriptArgs : void 0 !== arguments && (a = arguments), "function" == typeof quit && (l = function(e) {
                        quit(e)
                    }), "undefined" != typeof print && ("undefined" == typeof console && (console = {}), console.log = print, console.warn = console.error = "undefined" != typeof printErr ? printErr : print)) : (u || d) && (d ? _ = self.location.href : "undefined" != typeof document && document.currentScript && (_ = document.currentScript.src), _ = 0 !== _.indexOf("blob:") ? _.substr(0, _.lastIndexOf("/") + 1) : "", p = function(e) {
                        var t = new XMLHttpRequest;
                        return t.open("GET", e, !1), t.send(null), t.responseText
                    }, d && (f = function(e) {
                        var t = new XMLHttpRequest;
                        return t.open("GET", e, !1), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response)
                    }), h = function(e, t, r) {
                        var n = new XMLHttpRequest;
                        n.open("GET", e, !0), n.responseType = "arraybuffer", n.onload = function() {
                            200 == n.status || 0 == n.status && n.response ? t(n.response) : r()
                        }, n.onerror = r, n.send(null)
                    }), o.print || console.log.bind(console);
                    var y = o.printErr || console.warn.bind(console);
                    for (t in n) n.hasOwnProperty(t) && (o[t] = n[t]);
                    n = null, o.arguments && (a = o.arguments), o.thisProgram && (c = o.thisProgram), o.quit && (l = o.quit);
                    var v, b = 16,
                        w = [];

                    function x(e, t) {
                        if (!v) {
                            v = new WeakMap;
                            for (var r = 0; r < J.length; r++) {
                                var n = J.get(r);
                                n && v.set(n, r)
                            }
                        }
                        if (v.has(e)) return v.get(e);
                        var o = function() {
                            if (w.length) return w.pop();
                            try {
                                J.grow(1)
                            } catch (e) {
                                if (!(e instanceof RangeError)) throw e;
                                throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH."
                            }
                            return J.length - 1
                        }();
                        try {
                            J.set(o, e)
                        } catch (r) {
                            if (!(r instanceof TypeError)) throw r;
                            var i = function(e, t) {
                                if ("function" == typeof WebAssembly.Function) {
                                    for (var r = {
                                            i: "i32",
                                            j: "i64",
                                            f: "f32",
                                            d: "f64"
                                        }, n = {
                                            parameters: [],
                                            results: "v" == t[0] ? [] : [r[t[0]]]
                                        }, o = 1; o < t.length; ++o) n.parameters.push(r[t[o]]);
                                    return new WebAssembly.Function(n, e)
                                }
                                var i = [1, 0, 1, 96],
                                    s = t.slice(0, 1),
                                    a = t.slice(1),
                                    c = {
                                        i: 127,
                                        j: 126,
                                        f: 125,
                                        d: 124
                                    };
                                for (i.push(a.length), o = 0; o < a.length; ++o) i.push(c[a[o]]);
                                "v" == s ? i.push(0) : i = i.concat([1, c[s]]), i[1] = i.length - 2;
                                var l = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0].concat(i, [2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0])),
                                    u = new WebAssembly.Module(l);
                                return new WebAssembly.Instance(u, {
                                    e: {
                                        f: e
                                    }
                                }).exports.f
                            }(e, t);
                            J.set(o, i)
                        }
                        return v.set(e, o), o
                    }
                    var E, C = function(e) {},
                        S = o.dynamicLibraries || [];
                    o.wasmBinary && (E = o.wasmBinary);
                    var T, k = o.noExitRuntime || !0;

                    function I(e, t, r, n) {
                        switch ("*" === (r = r || "i8").charAt(r.length - 1) && (r = "i32"), r) {
                            case "i1":
                            case "i8":
                                R[e >> 0] = t;
                                break;
                            case "i16":
                                M[e >> 1] = t;
                                break;
                            case "i32":
                                D[e >> 2] = t;
                                break;
                            case "i64":
                                pe = [t >>> 0, (de = t, +Math.abs(de) >= 1 ? de > 0 ? (0 | Math.min(+Math.floor(de / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((de - +(~~de >>> 0)) / 4294967296) >>> 0 : 0)], D[e >> 2] = pe[0], D[e + 4 >> 2] = pe[1];
                                break;
                            case "float":
                                L[e >> 2] = t;
                                break;
                            case "double":
                                F[e >> 3] = t;
                                break;
                            default:
                                se("invalid type for setValue: " + r)
                        }
                    }

                    function P(e, t, r) {
                        switch ("*" === (t = t || "i8").charAt(t.length - 1) && (t = "i32"), t) {
                            case "i1":
                            case "i8":
                                return R[e >> 0];
                            case "i16":
                                return M[e >> 1];
                            case "i32":
                            case "i64":
                                return D[e >> 2];
                            case "float":
                                return L[e >> 2];
                            case "double":
                                return F[e >> 3];
                            default:
                                se("invalid type for getValue: " + t)
                        }
                        return null
                    }
                    "object" != typeof WebAssembly && se("no native wasm support detected");
                    var A = !1;

                    function O(e, t) {
                        e || se("Assertion failed: " + t)
                    }
                    var N, R, $, M, D, L, F, j = 1,
                        B = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;

                    function q(e, t, r) {
                        for (var n = t + r, o = t; e[o] && !(o >= n);) ++o;
                        if (o - t > 16 && e.subarray && B) return B.decode(e.subarray(t, o));
                        for (var i = ""; t < o;) {
                            var s = e[t++];
                            if (128 & s) {
                                var a = 63 & e[t++];
                                if (192 != (224 & s)) {
                                    var c = 63 & e[t++];
                                    if ((s = 224 == (240 & s) ? (15 & s) << 12 | a << 6 | c : (7 & s) << 18 | a << 12 | c << 6 | 63 & e[t++]) < 65536) i += String.fromCharCode(s);
                                    else {
                                        var l = s - 65536;
                                        i += String.fromCharCode(55296 | l >> 10, 56320 | 1023 & l)
                                    }
                                } else i += String.fromCharCode((31 & s) << 6 | a)
                            } else i += String.fromCharCode(s)
                        }
                        return i
                    }

                    function U(e, t) {
                        return e ? q($, e, t) : ""
                    }

                    function H(e, t, r, n) {
                        if (!(n > 0)) return 0;
                        for (var o = r, i = r + n - 1, s = 0; s < e.length; ++s) {
                            var a = e.charCodeAt(s);
                            if (a >= 55296 && a <= 57343 && (a = 65536 + ((1023 & a) << 10) | 1023 & e.charCodeAt(++s)), a <= 127) {
                                if (r >= i) break;
                                t[r++] = a
                            } else if (a <= 2047) {
                                if (r + 1 >= i) break;
                                t[r++] = 192 | a >> 6, t[r++] = 128 | 63 & a
                            } else if (a <= 65535) {
                                if (r + 2 >= i) break;
                                t[r++] = 224 | a >> 12, t[r++] = 128 | a >> 6 & 63, t[r++] = 128 | 63 & a
                            } else {
                                if (r + 3 >= i) break;
                                t[r++] = 240 | a >> 18, t[r++] = 128 | a >> 12 & 63, t[r++] = 128 | a >> 6 & 63, t[r++] = 128 | 63 & a
                            }
                        }
                        return t[r] = 0, r - o
                    }

                    function G(e, t, r) {
                        return H(e, $, t, r)
                    }

                    function z(e) {
                        for (var t = 0, r = 0; r < e.length; ++r) {
                            var n = e.charCodeAt(r);
                            n >= 55296 && n <= 57343 && (n = 65536 + ((1023 & n) << 10) | 1023 & e.charCodeAt(++r)), n <= 127 ? ++t : t += n <= 2047 ? 2 : n <= 65535 ? 3 : 4
                        }
                        return t
                    }

                    function V(e) {
                        var t = z(e) + 1,
                            r = Ve(t);
                        return H(e, R, r, t), r
                    }

                    function W(e) {
                        N = e, o.HEAP8 = R = new Int8Array(e), o.HEAP16 = M = new Int16Array(e), o.HEAP32 = D = new Int32Array(e), o.HEAPU8 = $ = new Uint8Array(e), o.HEAPU16 = new Uint16Array(e), o.HEAPU32 = new Uint32Array(e), o.HEAPF32 = L = new Float32Array(e), o.HEAPF64 = F = new Float64Array(e)
                    }
                    var K = o.INITIAL_MEMORY || 33554432;
                    (T = o.wasmMemory ? o.wasmMemory : new WebAssembly.Memory({
                        initial: K / 65536,
                        maximum: 32768
                    })) && (N = T.buffer), K = N.byteLength, W(N);
                    var J = new WebAssembly.Table({
                            initial: 13,
                            element: "anyfunc"
                        }),
                        X = [],
                        Q = [],
                        Y = [],
                        Z = [],
                        ee = !1,
                        te = 0,
                        re = null,
                        ne = null;

                    function oe(e) {
                        te++, o.monitorRunDependencies && o.monitorRunDependencies(te)
                    }

                    function ie(e) {
                        if (te--, o.monitorRunDependencies && o.monitorRunDependencies(te), 0 == te && (null !== re && (clearInterval(re), re = null), ne)) {
                            var t = ne;
                            ne = null, t()
                        }
                    }

                    function se(e) {
                        throw o.onAbort && o.onAbort(e), y(e += ""), A = !0, e = "abort(" + e + "). Build with -s ASSERTIONS=1 for more info.", new WebAssembly.RuntimeError(e)
                    }
                    o.preloadedImages = {}, o.preloadedAudios = {}, o.preloadedWasm = {};
                    var ae = "data:application/octet-stream;base64,";

                    function ce(e) {
                        return e.startsWith(ae)
                    }

                    function le(e) {
                        return e.startsWith("file://")
                    }
                    var ue, de, pe, he = "tree-sitter.wasm";

                    function fe(e) {
                        try {
                            if (e == he && E) return new Uint8Array(E);
                            if (f) return f(e);
                            throw "both async and sync fetching of the wasm failed"
                        } catch (e) {
                            se(e)
                        }
                    }
                    ce(he) || (ue = he, he = o.locateFile ? o.locateFile(ue, _) : _ + ue);
                    var me = {},
                        ge = {
                            get: function(e, t) {
                                return me[t] || (me[t] = new WebAssembly.Global({
                                    value: "i32",
                                    mutable: !0
                                })), me[t]
                            }
                        };

                    function _e(e) {
                        for (; e.length > 0;) {
                            var t = e.shift();
                            if ("function" != typeof t) {
                                var r = t.func;
                                "number" == typeof r ? void 0 === t.arg ? J.get(r)() : J.get(r)(t.arg) : r(void 0 === t.arg ? null : t.arg)
                            } else t(o)
                        }
                    }

                    function ye(e) {
                        var t = 0;

                        function r() {
                            for (var r = 0, n = 1;;) {
                                var o = e[t++];
                                if (r += (127 & o) * n, n *= 128, !(128 & o)) break
                            }
                            return r
                        }
                        if (e instanceof WebAssembly.Module) {
                            var n = WebAssembly.Module.customSections(e, "dylink");
                            O(0 != n.length, "need dylink section"), e = new Int8Array(n[0])
                        } else O(1836278016 == new Uint32Array(new Uint8Array(e.subarray(0, 24)).buffer)[0], "need to see wasm magic number"), O(0 === e[8], "need the dylink section to be first"), t = 9, r(), O(6 === e[t]), O(e[++t] === "d".charCodeAt(0)), O(e[++t] === "y".charCodeAt(0)), O(e[++t] === "l".charCodeAt(0)), O(e[++t] === "i".charCodeAt(0)), O(e[++t] === "n".charCodeAt(0)), O(e[++t] === "k".charCodeAt(0)), t++;
                        var o = {};
                        o.memorySize = r(), o.memoryAlign = r(), o.tableSize = r(), o.tableAlign = r();
                        var i = r();
                        o.neededDynlibs = [];
                        for (var s = 0; s < i; ++s) {
                            var a = r(),
                                c = e.subarray(t, t + a);
                            t += a;
                            var l = q(c, 0);
                            o.neededDynlibs.push(l)
                        }
                        return o
                    }
                    var ve = 0;

                    function be() {
                        return k || ve > 0
                    }

                    function we(e) {
                        return 0 == e.indexOf("dynCall_") || ["stackAlloc", "stackSave", "stackRestore"].includes(e) ? e : "_" + e
                    }

                    function xe(e, t) {
                        for (var r in e)
                            if (e.hasOwnProperty(r)) {
                                qe.hasOwnProperty(r) || (qe[r] = e[r]);
                                var n = we(r);
                                o.hasOwnProperty(n) || (o[n] = e[r])
                            }
                    }
                    var Ee = {
                        nextHandle: 1,
                        loadedLibs: {},
                        loadedLibNames: {}
                    };

                    function Ce(e, t, r) {
                        return e.includes("j") ? function(e, t, r) {
                            var n = o["dynCall_" + e];
                            return r && r.length ? n.apply(null, [t].concat(r)) : n.call(null, t)
                        }(e, t, r) : J.get(t).apply(null, r)
                    }
                    var Se = 5250816;

                    function Te(e) {
                        return ["__cpp_exception", "__wasm_apply_data_relocs", "__dso_handle", "__set_stack_limits"].includes(e)
                    }

                    function ke(e, t) {
                        var r = {};
                        for (var n in e) {
                            var o = e[n];
                            "object" == typeof o && (o = o.value), "number" == typeof o && (o += t), r[n] = o
                        }
                        return function(e) {
                            for (var t in e)
                                if (!Te(t)) {
                                    var r = !1,
                                        n = e[t];
                                    t.startsWith("orig$") && (t = t.split("$")[1], r = !0), me[t] || (me[t] = new WebAssembly.Global({
                                        value: "i32",
                                        mutable: !0
                                    })), (r || 0 == me[t].value) && ("function" == typeof n ? me[t].value = x(n) : "number" == typeof n ? me[t].value = n : y("unhandled export type for `" + t + "`: " + typeof n))
                                }
                        }(r), r
                    }

                    function Ie(e, t) {
                        var r, n;
                        return t && (r = qe["orig$" + e]), r || (r = qe[e]), r || (r = o[we(e)]), !r && e.startsWith("invoke_") && (n = e.split("_")[1], r = function() {
                            var e = Ge();
                            try {
                                return Ce(n, arguments[0], Array.prototype.slice.call(arguments, 1))
                            } catch (t) {
                                if (ze(e), t !== t + 0 && "longjmp" !== t) throw t;
                                We(1, 0)
                            }
                        }), r
                    }

                    function Pe(e, t) {
                        var r = ye(e);

                        function n() {
                            var n = Math.pow(2, r.memoryAlign);
                            n = Math.max(n, b);
                            var o, i, s, a = (o = function(e) {
                                    if (ee) return Ue(e);
                                    var t = Se,
                                        r = t + e + 15 & -16;
                                    return Se = r, me.__heap_base.value = r, t
                                }(r.memorySize + n), (i = n) || (i = b), Math.ceil(o / i) * i),
                                c = J.length;
                            J.grow(r.tableSize);
                            for (var l = a; l < a + r.memorySize; l++) R[l] = 0;
                            for (l = c; l < c + r.tableSize; l++) J.set(l, null);
                            var u = new Proxy({}, {
                                    get: function(e, t) {
                                        switch (t) {
                                            case "__memory_base":
                                                return a;
                                            case "__table_base":
                                                return c
                                        }
                                        return t in qe ? qe[t] : (t in e || (e[t] = function() {
                                            return r || (r = function(e) {
                                                var t = Ie(e, !1);
                                                return t || (t = s[e]), t
                                            }(t)), r.apply(null, arguments)
                                        }), e[t]);
                                        var r
                                    }
                                }),
                                d = {
                                    "GOT.mem": new Proxy({}, ge),
                                    "GOT.func": new Proxy({}, ge),
                                    env: u,
                                    wasi_snapshot_preview1: u
                                };

                            function p(e) {
                                for (var n = 0; n < r.tableSize; n++) {
                                    var o = J.get(c + n);
                                    o && v.set(o, c + n)
                                }
                                s = ke(e.exports, a), t.allowUndefined || Oe();
                                var i = s.__wasm_call_ctors;
                                return i || (i = s.__post_instantiate), i && (ee ? i() : Q.push(i)), s
                            }
                            if (t.loadAsync) {
                                if (e instanceof WebAssembly.Module) {
                                    var h = new WebAssembly.Instance(e, d);
                                    return Promise.resolve(p(h))
                                }
                                return WebAssembly.instantiate(e, d).then((function(e) {
                                    return p(e.instance)
                                }))
                            }
                            var f = e instanceof WebAssembly.Module ? e : new WebAssembly.Module(e);
                            return p(h = new WebAssembly.Instance(f, d))
                        }
                        return t.loadAsync ? r.neededDynlibs.reduce((function(e, r) {
                            return e.then((function() {
                                return Ae(r, t)
                            }))
                        }), Promise.resolve()).then((function() {
                            return n()
                        })) : (r.neededDynlibs.forEach((function(e) {
                            Ae(e, t)
                        })), n())
                    }

                    function Ae(e, t) {
                        "__main__" != e || Ee.loadedLibNames[e] || (Ee.loadedLibs[-1] = {
                            refcount: 1 / 0,
                            name: "__main__",
                            module: o.asm,
                            global: !0
                        }, Ee.loadedLibNames.__main__ = -1), t = t || {
                            global: !0,
                            nodelete: !0
                        };
                        var r, n = Ee.loadedLibNames[e];
                        if (n) return r = Ee.loadedLibs[n], t.global && !r.global && (r.global = !0, "loading" !== r.module && xe(r.module)), t.nodelete && r.refcount !== 1 / 0 && (r.refcount = 1 / 0), r.refcount++, t.loadAsync ? Promise.resolve(n) : n;

                        function i(e) {
                            if (t.fs) {
                                var r = t.fs.readFile(e, {
                                    encoding: "binary"
                                });
                                return r instanceof Uint8Array || (r = new Uint8Array(r)), t.loadAsync ? Promise.resolve(r) : r
                            }
                            return t.loadAsync ? (n = e, fetch(n, {
                                credentials: "same-origin"
                            }).then((function(e) {
                                if (!e.ok) throw "failed to load binary file at '" + n + "'";
                                return e.arrayBuffer()
                            })).then((function(e) {
                                return new Uint8Array(e)
                            }))) : f(e);
                            var n
                        }

                        function s() {
                            if (void 0 !== o.preloadedWasm && void 0 !== o.preloadedWasm[e]) {
                                var r = o.preloadedWasm[e];
                                return t.loadAsync ? Promise.resolve(r) : r
                            }
                            return t.loadAsync ? i(e).then((function(e) {
                                return Pe(e, t)
                            })) : Pe(i(e), t)
                        }

                        function a(e) {
                            r.global && xe(e), r.module = e
                        }
                        return n = Ee.nextHandle++, r = {
                            refcount: t.nodelete ? 1 / 0 : 1,
                            name: e,
                            module: "loading",
                            global: t.global
                        }, Ee.loadedLibNames[e] = n, Ee.loadedLibs[n] = r, t.loadAsync ? s().then((function(e) {
                            return a(e), n
                        })) : (a(s()), n)
                    }

                    function Oe() {
                        for (var e in me)
                            if (0 == me[e].value) {
                                var t = Ie(e, !0);
                                "function" == typeof t ? me[e].value = x(t, t.sig) : "number" == typeof t ? me[e].value = t : O(!1, "bad export type for `" + e + "`: " + typeof t)
                            }
                    }
                    o.___heap_base = Se;
                    var Ne, Re = new WebAssembly.Global({
                        value: "i32",
                        mutable: !0
                    }, 5250816);

                    function $e() {
                        se()
                    }
                    o._abort = $e, $e.sig = "v", Ne = i ? function() {
                        var e = process.hrtime();
                        return 1e3 * e[0] + e[1] / 1e6
                    } : "undefined" != typeof dateNow ? dateNow : function() {
                        return performance.now()
                    };
                    var Me = !0;

                    function De(e, t) {
                        var r;
                        if (0 === e) r = Date.now();
                        else {
                            if (1 !== e && 4 !== e || !Me) return 28, D[He() >> 2] = 28, -1;
                            r = Ne()
                        }
                        return D[t >> 2] = r / 1e3 | 0, D[t + 4 >> 2] = r % 1e3 * 1e3 * 1e3 | 0, 0
                    }

                    function Le(e) {
                        try {
                            return T.grow(e - N.byteLength + 65535 >>> 16), W(T.buffer), 1
                        } catch (e) {}
                    }

                    function Fe(e) {
                        Qe(e)
                    }

                    function je(e) {
                        C(e)
                    }
                    De.sig = "iii", Fe.sig = "vi", je.sig = "vi";
                    var Be, qe = {
                            __heap_base: Se,
                            __indirect_function_table: J,
                            __memory_base: 1024,
                            __stack_pointer: Re,
                            __table_base: 1,
                            abort: $e,
                            clock_gettime: De,
                            emscripten_memcpy_big: function(e, t, r) {
                                $.copyWithin(e, t, t + r)
                            },
                            emscripten_resize_heap: function(e) {
                                var t, r = $.length;
                                if ((e >>>= 0) > 2147483648) return !1;
                                for (var n = 1; n <= 4; n *= 2) {
                                    var o = r * (1 + .2 / n);
                                    if (o = Math.min(o, e + 100663296), Le(Math.min(2147483648, ((t = Math.max(e, o)) % 65536 > 0 && (t += 65536 - t % 65536), t)))) return !0
                                }
                                return !1
                            },
                            exit: Fe,
                            memory: T,
                            setTempRet0: je,
                            tree_sitter_log_callback: function(e, t) {
                                if (ft) {
                                    const r = U(t);
                                    ft(r, 0 !== e)
                                }
                            },
                            tree_sitter_parse_callback: function(e, t, r, n, o) {
                                var i = ht(t, {
                                    row: r,
                                    column: n
                                });
                                "string" == typeof i ? (I(o, i.length, "i32"), function(e, t, r) {
                                    if (void 0 === r && (r = 2147483647), r < 2) return 0;
                                    for (var n = (r -= 2) < 2 * e.length ? r / 2 : e.length, o = 0; o < n; ++o) {
                                        var i = e.charCodeAt(o);
                                        M[t >> 1] = i, t += 2
                                    }
                                    M[t >> 1] = 0
                                }(i, e, 10240)) : I(o, 0, "i32")
                            }
                        },
                        Ue = (function() {
                            var e = {
                                env: qe,
                                wasi_snapshot_preview1: qe,
                                "GOT.mem": new Proxy(qe, ge),
                                "GOT.func": new Proxy(qe, ge)
                            };

                            function t(e, t) {
                                var r = e.exports;
                                r = ke(r, 1024), o.asm = r;
                                var n, i = ye(t);
                                i.neededDynlibs && (S = i.neededDynlibs.concat(S)), xe(r), n = o.asm.__wasm_call_ctors, Q.unshift(n), ie()
                            }

                            function r(e) {
                                t(e.instance, e.module)
                            }

                            function n(t) {
                                return function() {
                                    if (!E && (u || d)) {
                                        if ("function" == typeof fetch && !le(he)) return fetch(he, {
                                            credentials: "same-origin"
                                        }).then((function(e) {
                                            if (!e.ok) throw "failed to load wasm binary file at '" + he + "'";
                                            return e.arrayBuffer()
                                        })).catch((function() {
                                            return fe(he)
                                        }));
                                        if (h) return new Promise((function(e, t) {
                                            h(he, (function(t) {
                                                e(new Uint8Array(t))
                                            }), t)
                                        }))
                                    }
                                    return Promise.resolve().then((function() {
                                        return fe(he)
                                    }))
                                }().then((function(t) {
                                    return WebAssembly.instantiate(t, e)
                                })).then(t, (function(e) {
                                    y("failed to asynchronously prepare wasm: " + e), se(e)
                                }))
                            }
                            if (oe(), o.instantiateWasm) try {
                                return o.instantiateWasm(e, t)
                            } catch (e) {
                                return y("Module.instantiateWasm callback failed with error: " + e), !1
                            }
                            E || "function" != typeof WebAssembly.instantiateStreaming || ce(he) || le(he) || "function" != typeof fetch ? n(r) : fetch(he, {
                                credentials: "same-origin"
                            }).then((function(t) {
                                return WebAssembly.instantiateStreaming(t, e).then(r, (function(e) {
                                    return y("wasm streaming compile failed: " + e), y("falling back to ArrayBuffer instantiation"), n(r)
                                }))
                            }))
                        }(), o.___wasm_call_ctors = function() {
                            return (o.___wasm_call_ctors = o.asm.__wasm_call_ctors).apply(null, arguments)
                        }, o._malloc = function() {
                            return (Ue = o._malloc = o.asm.malloc).apply(null, arguments)
                        }),
                        He = (o._ts_language_symbol_count = function() {
                            return (o._ts_language_symbol_count = o.asm.ts_language_symbol_count).apply(null, arguments)
                        }, o._ts_language_version = function() {
                            return (o._ts_language_version = o.asm.ts_language_version).apply(null, arguments)
                        }, o._ts_language_field_count = function() {
                            return (o._ts_language_field_count = o.asm.ts_language_field_count).apply(null, arguments)
                        }, o._ts_language_symbol_name = function() {
                            return (o._ts_language_symbol_name = o.asm.ts_language_symbol_name).apply(null, arguments)
                        }, o._ts_language_symbol_for_name = function() {
                            return (o._ts_language_symbol_for_name = o.asm.ts_language_symbol_for_name).apply(null, arguments)
                        }, o._ts_language_symbol_type = function() {
                            return (o._ts_language_symbol_type = o.asm.ts_language_symbol_type).apply(null, arguments)
                        }, o._ts_language_field_name_for_id = function() {
                            return (o._ts_language_field_name_for_id = o.asm.ts_language_field_name_for_id).apply(null, arguments)
                        }, o._memcpy = function() {
                            return (o._memcpy = o.asm.memcpy).apply(null, arguments)
                        }, o._free = function() {
                            return (o._free = o.asm.free).apply(null, arguments)
                        }, o._calloc = function() {
                            return (o._calloc = o.asm.calloc).apply(null, arguments)
                        }, o._ts_parser_delete = function() {
                            return (o._ts_parser_delete = o.asm.ts_parser_delete).apply(null, arguments)
                        }, o._ts_parser_reset = function() {
                            return (o._ts_parser_reset = o.asm.ts_parser_reset).apply(null, arguments)
                        }, o._ts_parser_set_language = function() {
                            return (o._ts_parser_set_language = o.asm.ts_parser_set_language).apply(null, arguments)
                        }, o._ts_parser_timeout_micros = function() {
                            return (o._ts_parser_timeout_micros = o.asm.ts_parser_timeout_micros).apply(null, arguments)
                        }, o._ts_parser_set_timeout_micros = function() {
                            return (o._ts_parser_set_timeout_micros = o.asm.ts_parser_set_timeout_micros).apply(null, arguments)
                        }, o._memcmp = function() {
                            return (o._memcmp = o.asm.memcmp).apply(null, arguments)
                        }, o._ts_query_new = function() {
                            return (o._ts_query_new = o.asm.ts_query_new).apply(null, arguments)
                        }, o._ts_query_delete = function() {
                            return (o._ts_query_delete = o.asm.ts_query_delete).apply(null, arguments)
                        }, o._iswspace = function() {
                            return (o._iswspace = o.asm.iswspace).apply(null, arguments)
                        }, o._iswalnum = function() {
                            return (o._iswalnum = o.asm.iswalnum).apply(null, arguments)
                        }, o._ts_query_pattern_count = function() {
                            return (o._ts_query_pattern_count = o.asm.ts_query_pattern_count).apply(null, arguments)
                        }, o._ts_query_capture_count = function() {
                            return (o._ts_query_capture_count = o.asm.ts_query_capture_count).apply(null, arguments)
                        }, o._ts_query_string_count = function() {
                            return (o._ts_query_string_count = o.asm.ts_query_string_count).apply(null, arguments)
                        }, o._ts_query_capture_name_for_id = function() {
                            return (o._ts_query_capture_name_for_id = o.asm.ts_query_capture_name_for_id).apply(null, arguments)
                        }, o._ts_query_string_value_for_id = function() {
                            return (o._ts_query_string_value_for_id = o.asm.ts_query_string_value_for_id).apply(null, arguments)
                        }, o._ts_query_predicates_for_pattern = function() {
                            return (o._ts_query_predicates_for_pattern = o.asm.ts_query_predicates_for_pattern).apply(null, arguments)
                        }, o._ts_tree_copy = function() {
                            return (o._ts_tree_copy = o.asm.ts_tree_copy).apply(null, arguments)
                        }, o._ts_tree_delete = function() {
                            return (o._ts_tree_delete = o.asm.ts_tree_delete).apply(null, arguments)
                        }, o._ts_init = function() {
                            return (o._ts_init = o.asm.ts_init).apply(null, arguments)
                        }, o._ts_parser_new_wasm = function() {
                            return (o._ts_parser_new_wasm = o.asm.ts_parser_new_wasm).apply(null, arguments)
                        }, o._ts_parser_enable_logger_wasm = function() {
                            return (o._ts_parser_enable_logger_wasm = o.asm.ts_parser_enable_logger_wasm).apply(null, arguments)
                        }, o._ts_parser_parse_wasm = function() {
                            return (o._ts_parser_parse_wasm = o.asm.ts_parser_parse_wasm).apply(null, arguments)
                        }, o._ts_language_type_is_named_wasm = function() {
                            return (o._ts_language_type_is_named_wasm = o.asm.ts_language_type_is_named_wasm).apply(null, arguments)
                        }, o._ts_language_type_is_visible_wasm = function() {
                            return (o._ts_language_type_is_visible_wasm = o.asm.ts_language_type_is_visible_wasm).apply(null, arguments)
                        }, o._ts_tree_root_node_wasm = function() {
                            return (o._ts_tree_root_node_wasm = o.asm.ts_tree_root_node_wasm).apply(null, arguments)
                        }, o._ts_tree_edit_wasm = function() {
                            return (o._ts_tree_edit_wasm = o.asm.ts_tree_edit_wasm).apply(null, arguments)
                        }, o._ts_tree_get_changed_ranges_wasm = function() {
                            return (o._ts_tree_get_changed_ranges_wasm = o.asm.ts_tree_get_changed_ranges_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_new_wasm = function() {
                            return (o._ts_tree_cursor_new_wasm = o.asm.ts_tree_cursor_new_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_delete_wasm = function() {
                            return (o._ts_tree_cursor_delete_wasm = o.asm.ts_tree_cursor_delete_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_reset_wasm = function() {
                            return (o._ts_tree_cursor_reset_wasm = o.asm.ts_tree_cursor_reset_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_goto_first_child_wasm = function() {
                            return (o._ts_tree_cursor_goto_first_child_wasm = o.asm.ts_tree_cursor_goto_first_child_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_goto_next_sibling_wasm = function() {
                            return (o._ts_tree_cursor_goto_next_sibling_wasm = o.asm.ts_tree_cursor_goto_next_sibling_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_goto_parent_wasm = function() {
                            return (o._ts_tree_cursor_goto_parent_wasm = o.asm.ts_tree_cursor_goto_parent_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_current_node_type_id_wasm = function() {
                            return (o._ts_tree_cursor_current_node_type_id_wasm = o.asm.ts_tree_cursor_current_node_type_id_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_current_node_is_named_wasm = function() {
                            return (o._ts_tree_cursor_current_node_is_named_wasm = o.asm.ts_tree_cursor_current_node_is_named_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_current_node_is_missing_wasm = function() {
                            return (o._ts_tree_cursor_current_node_is_missing_wasm = o.asm.ts_tree_cursor_current_node_is_missing_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_current_node_id_wasm = function() {
                            return (o._ts_tree_cursor_current_node_id_wasm = o.asm.ts_tree_cursor_current_node_id_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_start_position_wasm = function() {
                            return (o._ts_tree_cursor_start_position_wasm = o.asm.ts_tree_cursor_start_position_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_end_position_wasm = function() {
                            return (o._ts_tree_cursor_end_position_wasm = o.asm.ts_tree_cursor_end_position_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_start_index_wasm = function() {
                            return (o._ts_tree_cursor_start_index_wasm = o.asm.ts_tree_cursor_start_index_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_end_index_wasm = function() {
                            return (o._ts_tree_cursor_end_index_wasm = o.asm.ts_tree_cursor_end_index_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_current_field_id_wasm = function() {
                            return (o._ts_tree_cursor_current_field_id_wasm = o.asm.ts_tree_cursor_current_field_id_wasm).apply(null, arguments)
                        }, o._ts_tree_cursor_current_node_wasm = function() {
                            return (o._ts_tree_cursor_current_node_wasm = o.asm.ts_tree_cursor_current_node_wasm).apply(null, arguments)
                        }, o._ts_node_symbol_wasm = function() {
                            return (o._ts_node_symbol_wasm = o.asm.ts_node_symbol_wasm).apply(null, arguments)
                        }, o._ts_node_child_count_wasm = function() {
                            return (o._ts_node_child_count_wasm = o.asm.ts_node_child_count_wasm).apply(null, arguments)
                        }, o._ts_node_named_child_count_wasm = function() {
                            return (o._ts_node_named_child_count_wasm = o.asm.ts_node_named_child_count_wasm).apply(null, arguments)
                        }, o._ts_node_child_wasm = function() {
                            return (o._ts_node_child_wasm = o.asm.ts_node_child_wasm).apply(null, arguments)
                        }, o._ts_node_named_child_wasm = function() {
                            return (o._ts_node_named_child_wasm = o.asm.ts_node_named_child_wasm).apply(null, arguments)
                        }, o._ts_node_child_by_field_id_wasm = function() {
                            return (o._ts_node_child_by_field_id_wasm = o.asm.ts_node_child_by_field_id_wasm).apply(null, arguments)
                        }, o._ts_node_next_sibling_wasm = function() {
                            return (o._ts_node_next_sibling_wasm = o.asm.ts_node_next_sibling_wasm).apply(null, arguments)
                        }, o._ts_node_prev_sibling_wasm = function() {
                            return (o._ts_node_prev_sibling_wasm = o.asm.ts_node_prev_sibling_wasm).apply(null, arguments)
                        }, o._ts_node_next_named_sibling_wasm = function() {
                            return (o._ts_node_next_named_sibling_wasm = o.asm.ts_node_next_named_sibling_wasm).apply(null, arguments)
                        }, o._ts_node_prev_named_sibling_wasm = function() {
                            return (o._ts_node_prev_named_sibling_wasm = o.asm.ts_node_prev_named_sibling_wasm).apply(null, arguments)
                        }, o._ts_node_parent_wasm = function() {
                            return (o._ts_node_parent_wasm = o.asm.ts_node_parent_wasm).apply(null, arguments)
                        }, o._ts_node_descendant_for_index_wasm = function() {
                            return (o._ts_node_descendant_for_index_wasm = o.asm.ts_node_descendant_for_index_wasm).apply(null, arguments)
                        }, o._ts_node_named_descendant_for_index_wasm = function() {
                            return (o._ts_node_named_descendant_for_index_wasm = o.asm.ts_node_named_descendant_for_index_wasm).apply(null, arguments)
                        }, o._ts_node_descendant_for_position_wasm = function() {
                            return (o._ts_node_descendant_for_position_wasm = o.asm.ts_node_descendant_for_position_wasm).apply(null, arguments)
                        }, o._ts_node_named_descendant_for_position_wasm = function() {
                            return (o._ts_node_named_descendant_for_position_wasm = o.asm.ts_node_named_descendant_for_position_wasm).apply(null, arguments)
                        }, o._ts_node_start_point_wasm = function() {
                            return (o._ts_node_start_point_wasm = o.asm.ts_node_start_point_wasm).apply(null, arguments)
                        }, o._ts_node_end_point_wasm = function() {
                            return (o._ts_node_end_point_wasm = o.asm.ts_node_end_point_wasm).apply(null, arguments)
                        }, o._ts_node_start_index_wasm = function() {
                            return (o._ts_node_start_index_wasm = o.asm.ts_node_start_index_wasm).apply(null, arguments)
                        }, o._ts_node_end_index_wasm = function() {
                            return (o._ts_node_end_index_wasm = o.asm.ts_node_end_index_wasm).apply(null, arguments)
                        }, o._ts_node_to_string_wasm = function() {
                            return (o._ts_node_to_string_wasm = o.asm.ts_node_to_string_wasm).apply(null, arguments)
                        }, o._ts_node_children_wasm = function() {
                            return (o._ts_node_children_wasm = o.asm.ts_node_children_wasm).apply(null, arguments)
                        }, o._ts_node_named_children_wasm = function() {
                            return (o._ts_node_named_children_wasm = o.asm.ts_node_named_children_wasm).apply(null, arguments)
                        }, o._ts_node_descendants_of_type_wasm = function() {
                            return (o._ts_node_descendants_of_type_wasm = o.asm.ts_node_descendants_of_type_wasm).apply(null, arguments)
                        }, o._ts_node_is_named_wasm = function() {
                            return (o._ts_node_is_named_wasm = o.asm.ts_node_is_named_wasm).apply(null, arguments)
                        }, o._ts_node_has_changes_wasm = function() {
                            return (o._ts_node_has_changes_wasm = o.asm.ts_node_has_changes_wasm).apply(null, arguments)
                        }, o._ts_node_has_error_wasm = function() {
                            return (o._ts_node_has_error_wasm = o.asm.ts_node_has_error_wasm).apply(null, arguments)
                        }, o._ts_node_is_missing_wasm = function() {
                            return (o._ts_node_is_missing_wasm = o.asm.ts_node_is_missing_wasm).apply(null, arguments)
                        }, o._ts_query_matches_wasm = function() {
                            return (o._ts_query_matches_wasm = o.asm.ts_query_matches_wasm).apply(null, arguments)
                        }, o._ts_query_captures_wasm = function() {
                            return (o._ts_query_captures_wasm = o.asm.ts_query_captures_wasm).apply(null, arguments)
                        }, o._iswdigit = function() {
                            return (o._iswdigit = o.asm.iswdigit).apply(null, arguments)
                        }, o._iswalpha = function() {
                            return (o._iswalpha = o.asm.iswalpha).apply(null, arguments)
                        }, o._iswlower = function() {
                            return (o._iswlower = o.asm.iswlower).apply(null, arguments)
                        }, o._towupper = function() {
                            return (o._towupper = o.asm.towupper).apply(null, arguments)
                        }, o.___errno_location = function() {
                            return (He = o.___errno_location = o.asm.__errno_location).apply(null, arguments)
                        }),
                        Ge = (o._memchr = function() {
                            return (o._memchr = o.asm.memchr).apply(null, arguments)
                        }, o._strlen = function() {
                            return (o._strlen = o.asm.strlen).apply(null, arguments)
                        }, o.stackSave = function() {
                            return (Ge = o.stackSave = o.asm.stackSave).apply(null, arguments)
                        }),
                        ze = o.stackRestore = function() {
                            return (ze = o.stackRestore = o.asm.stackRestore).apply(null, arguments)
                        },
                        Ve = o.stackAlloc = function() {
                            return (Ve = o.stackAlloc = o.asm.stackAlloc).apply(null, arguments)
                        },
                        We = o._setThrew = function() {
                            return (We = o._setThrew = o.asm.setThrew).apply(null, arguments)
                        };

                    function Ke(e) {
                        this.name = "ExitStatus", this.message = "Program terminated with exit(" + e + ")", this.status = e
                    }
                    o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = function() {
                        return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm).apply(null, arguments)
                    }, o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = function() {
                        return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev).apply(null, arguments)
                    }, o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = function() {
                        return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm).apply(null, arguments)
                    }, o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = function() {
                        return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm).apply(null, arguments)
                    }, o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = function() {
                        return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc).apply(null, arguments)
                    }, o.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = function() {
                        return (o.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = o.asm._ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm).apply(null, arguments)
                    }, o.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = function() {
                        return (o.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = o.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev).apply(null, arguments)
                    }, o.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = function() {
                        return (o.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = o.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw).apply(null, arguments)
                    }, o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_ = function() {
                        return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_ = o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_).apply(null, arguments)
                    }, o.__Znwm = function() {
                        return (o.__Znwm = o.asm._Znwm).apply(null, arguments)
                    }, o.__ZdlPv = function() {
                        return (o.__ZdlPv = o.asm._ZdlPv).apply(null, arguments)
                    }, o.__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv = function() {
                        return (o.__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv = o.asm._ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv).apply(null, arguments)
                    }, o._orig$ts_parser_timeout_micros = function() {
                        return (o._orig$ts_parser_timeout_micros = o.asm.orig$ts_parser_timeout_micros).apply(null, arguments)
                    }, o._orig$ts_parser_set_timeout_micros = function() {
                        return (o._orig$ts_parser_set_timeout_micros = o.asm.orig$ts_parser_set_timeout_micros).apply(null, arguments)
                    }, o.allocate = function(e, t) {
                        var r;
                        return r = t == j ? Ve(e.length) : Ue(e.length), e.subarray || e.slice ? $.set(e, r) : $.set(new Uint8Array(e), r), r
                    }, ne = function e() {
                        Be || Xe(), Be || (ne = e)
                    };
                    var Je = !1;

                    function Xe(e) {
                        function t() {
                            Be || (Be = !0, o.calledRun = !0, A || (ee = !0, _e(Q), _e(Y), o.onRuntimeInitialized && o.onRuntimeInitialized(), Ye && function(e) {
                                var t = o._main;
                                if (t) {
                                    var r = (e = e || []).length + 1,
                                        n = Ve(4 * (r + 1));
                                    D[n >> 2] = V(c);
                                    for (var i = 1; i < r; i++) D[(n >> 2) + i] = V(e[i - 1]);
                                    D[(n >> 2) + r] = 0;
                                    try {
                                        Qe(t(r, n), !0)
                                    } catch (e) {
                                        if (e instanceof Ke) return;
                                        if ("unwind" == e) return;
                                        var s = e;
                                        e && "object" == typeof e && e.stack && (s = [e, e.stack]), y("exception thrown: " + s), l(1, e)
                                    }
                                }
                            }(e), function() {
                                if (o.postRun)
                                    for ("function" == typeof o.postRun && (o.postRun = [o.postRun]); o.postRun.length;) e = o.postRun.shift(), Z.unshift(e);
                                var e;
                                _e(Z)
                            }()))
                        }
                        e = e || a, te > 0 || !Je && (function() {
                            if (S.length) {
                                if (!f) return oe(), void S.reduce((function(e, t) {
                                    return e.then((function() {
                                        return Ae(t, {
                                            loadAsync: !0,
                                            global: !0,
                                            nodelete: !0,
                                            allowUndefined: !0
                                        })
                                    }))
                                }), Promise.resolve()).then((function() {
                                    ie(), Oe()
                                }));
                                S.forEach((function(e) {
                                    Ae(e, {
                                        global: !0,
                                        nodelete: !0,
                                        allowUndefined: !0
                                    })
                                })), Oe()
                            } else Oe()
                        }(), Je = !0, te > 0) || (function() {
                            if (o.preRun)
                                for ("function" == typeof o.preRun && (o.preRun = [o.preRun]); o.preRun.length;) e = o.preRun.shift(), X.unshift(e);
                            var e;
                            _e(X)
                        }(), te > 0 || (o.setStatus ? (o.setStatus("Running..."), setTimeout((function() {
                            setTimeout((function() {
                                o.setStatus("")
                            }), 1), t()
                        }), 1)) : t()))
                    }

                    function Qe(e, t) {
                        t && be() && 0 === e || (be() || (o.onExit && o.onExit(e), A = !0), l(e, new Ke(e)))
                    }
                    if (o.run = Xe, o.preInit)
                        for ("function" == typeof o.preInit && (o.preInit = [o.preInit]); o.preInit.length > 0;) o.preInit.pop()();
                    var Ye = !0;
                    o.noInitialRun && (Ye = !1), Xe();
                    const Ze = o,
                        et = {},
                        tt = 4,
                        rt = 5 * tt,
                        nt = 2 * tt,
                        ot = 2 * tt + 2 * nt,
                        it = {
                            row: 0,
                            column: 0
                        },
                        st = /[\w-.]*/g,
                        at = 1,
                        ct = 2,
                        lt = /^_?tree_sitter_\w+/;
                    var ut, dt, pt, ht, ft, mt = new Promise((e => {
                        o.onRuntimeInitialized = e
                    })).then((() => {
                        pt = Ze._ts_init(), ut = P(pt, "i32"), dt = P(pt + tt, "i32")
                    }));
                    class gt {
                        static init() {
                            return mt
                        }
                        constructor() {
                            if (null == pt) throw new Error("You must first call Parser.init() and wait for it to resolve.");
                            Ze._ts_parser_new_wasm(), this[0] = P(pt, "i32"), this[1] = P(pt + tt, "i32")
                        }
                        delete() {
                            Ze._ts_parser_delete(this[0]), Ze._free(this[1]), this[0] = 0, this[1] = 0
                        }
                        setLanguage(e) {
                            let t;
                            if (e) {
                                if (e.constructor !== bt) throw new Error("Argument must be a Language"); {
                                    t = e[0];
                                    const r = Ze._ts_language_version(t);
                                    if (r < dt || ut < r) throw new Error(`Incompatible language version ${r}. Compatibility range ${dt} through ${ut}.`)
                                }
                            } else t = 0, e = null;
                            return this.language = e, Ze._ts_parser_set_language(this[0], t), this
                        }
                        getLanguage() {
                            return this.language
                        }
                        parse(e, t, r) {
                            if ("string" == typeof e) ht = (t, r, n) => e.slice(t, n);
                            else {
                                if ("function" != typeof e) throw new Error("Argument must be a string or a function");
                                ht = e
                            }
                            this.logCallback ? (ft = this.logCallback, Ze._ts_parser_enable_logger_wasm(this[0], 1)) : (ft = null, Ze._ts_parser_enable_logger_wasm(this[0], 0));
                            let n = 0,
                                o = 0;
                            if (r && r.includedRanges) {
                                n = r.includedRanges.length;
                                let e = o = Ze._calloc(n, ot);
                                for (let t = 0; t < n; t++) Nt(e, r.includedRanges[t]), e += ot
                            }
                            const i = Ze._ts_parser_parse_wasm(this[0], this[1], t ? t[0] : 0, o, n);
                            if (!i) throw ht = null, ft = null, new Error("Parsing failed");
                            const s = new _t(et, i, this.language, ht);
                            return ht = null, ft = null, s
                        }
                        reset() {
                            Ze._ts_parser_reset(this[0])
                        }
                        setTimeoutMicros(e) {
                            Ze._ts_parser_set_timeout_micros(this[0], e)
                        }
                        getTimeoutMicros() {
                            return Ze._ts_parser_timeout_micros(this[0])
                        }
                        setLogger(e) {
                            if (e) {
                                if ("function" != typeof e) throw new Error("Logger callback must be a function")
                            } else e = null;
                            return this.logCallback = e, this
                        }
                        getLogger() {
                            return this.logCallback
                        }
                    }
                    class _t {
                        constructor(e, t, r, n) {
                            Ct(e), this[0] = t, this.language = r, this.textCallback = n
                        }
                        copy() {
                            const e = Ze._ts_tree_copy(this[0]);
                            return new _t(et, e, this.language, this.textCallback)
                        }
                        delete() {
                            Ze._ts_tree_delete(this[0]), this[0] = 0
                        }
                        edit(e) {
                            ! function(e) {
                                let t = pt;
                                At(t, e.startPosition), At(t += nt, e.oldEndPosition), At(t += nt, e.newEndPosition), I(t += nt, e.startIndex, "i32"), I(t += tt, e.oldEndIndex, "i32"), I(t += tt, e.newEndIndex, "i32"), t += tt
                            }(e), Ze._ts_tree_edit_wasm(this[0])
                        }
                        get rootNode() {
                            return Ze._ts_tree_root_node_wasm(this[0]), kt(this)
                        }
                        getLanguage() {
                            return this.language
                        }
                        walk() {
                            return this.rootNode.walk()
                        }
                        getChangedRanges(e) {
                            if (e.constructor !== _t) throw new TypeError("Argument must be a Tree");
                            Ze._ts_tree_get_changed_ranges_wasm(this[0], e[0]);
                            const t = P(pt, "i32"),
                                r = P(pt + tt, "i32"),
                                n = new Array(t);
                            if (t > 0) {
                                let e = r;
                                for (let r = 0; r < t; r++) n[r] = Rt(e), e += ot;
                                Ze._free(r)
                            }
                            return n
                        }
                    }
                    class yt {
                        constructor(e, t) {
                            Ct(e), this.tree = t
                        }
                        get typeId() {
                            return Tt(this), Ze._ts_node_symbol_wasm(this.tree[0])
                        }
                        get type() {
                            return this.tree.language.types[this.typeId] || "ERROR"
                        }
                        get endPosition() {
                            return Tt(this), Ze._ts_node_end_point_wasm(this.tree[0]), Ot(pt)
                        }
                        get endIndex() {
                            return Tt(this), Ze._ts_node_end_index_wasm(this.tree[0])
                        }
                        get text() {
                            return xt(this.tree, this.startIndex, this.endIndex)
                        }
                        isNamed() {
                            return Tt(this), 1 === Ze._ts_node_is_named_wasm(this.tree[0])
                        }
                        hasError() {
                            return Tt(this), 1 === Ze._ts_node_has_error_wasm(this.tree[0])
                        }
                        hasChanges() {
                            return Tt(this), 1 === Ze._ts_node_has_changes_wasm(this.tree[0])
                        }
                        isMissing() {
                            return Tt(this), 1 === Ze._ts_node_is_missing_wasm(this.tree[0])
                        }
                        equals(e) {
                            return this.id === e.id
                        }
                        child(e) {
                            return Tt(this), Ze._ts_node_child_wasm(this.tree[0], e), kt(this.tree)
                        }
                        namedChild(e) {
                            return Tt(this), Ze._ts_node_named_child_wasm(this.tree[0], e), kt(this.tree)
                        }
                        childForFieldId(e) {
                            return Tt(this), Ze._ts_node_child_by_field_id_wasm(this.tree[0], e), kt(this.tree)
                        }
                        childForFieldName(e) {
                            const t = this.tree.language.fields.indexOf(e);
                            if (-1 !== t) return this.childForFieldId(t)
                        }
                        get childCount() {
                            return Tt(this), Ze._ts_node_child_count_wasm(this.tree[0])
                        }
                        get namedChildCount() {
                            return Tt(this), Ze._ts_node_named_child_count_wasm(this.tree[0])
                        }
                        get firstChild() {
                            return this.child(0)
                        }
                        get firstNamedChild() {
                            return this.namedChild(0)
                        }
                        get lastChild() {
                            return this.child(this.childCount - 1)
                        }
                        get lastNamedChild() {
                            return this.namedChild(this.namedChildCount - 1)
                        }
                        get children() {
                            if (!this._children) {
                                Tt(this), Ze._ts_node_children_wasm(this.tree[0]);
                                const e = P(pt, "i32"),
                                    t = P(pt + tt, "i32");
                                if (this._children = new Array(e), e > 0) {
                                    let r = t;
                                    for (let t = 0; t < e; t++) this._children[t] = kt(this.tree, r), r += rt;
                                    Ze._free(t)
                                }
                            }
                            return this._children
                        }
                        get namedChildren() {
                            if (!this._namedChildren) {
                                Tt(this), Ze._ts_node_named_children_wasm(this.tree[0]);
                                const e = P(pt, "i32"),
                                    t = P(pt + tt, "i32");
                                if (this._namedChildren = new Array(e), e > 0) {
                                    let r = t;
                                    for (let t = 0; t < e; t++) this._namedChildren[t] = kt(this.tree, r), r += rt;
                                    Ze._free(t)
                                }
                            }
                            return this._namedChildren
                        }
                        descendantsOfType(e, t, r) {
                            Array.isArray(e) || (e = [e]), t || (t = it), r || (r = it);
                            const n = [],
                                o = this.tree.language.types;
                            for (let t = 0, r = o.length; t < r; t++) e.includes(o[t]) && n.push(t);
                            const i = Ze._malloc(tt * n.length);
                            for (let e = 0, t = n.length; e < t; e++) I(i + e * tt, n[e], "i32");
                            Tt(this), Ze._ts_node_descendants_of_type_wasm(this.tree[0], i, n.length, t.row, t.column, r.row, r.column);
                            const s = P(pt, "i32"),
                                a = P(pt + tt, "i32"),
                                c = new Array(s);
                            if (s > 0) {
                                let e = a;
                                for (let t = 0; t < s; t++) c[t] = kt(this.tree, e), e += rt
                            }
                            return Ze._free(a), Ze._free(i), c
                        }
                        get nextSibling() {
                            return Tt(this), Ze._ts_node_next_sibling_wasm(this.tree[0]), kt(this.tree)
                        }
                        get previousSibling() {
                            return Tt(this), Ze._ts_node_prev_sibling_wasm(this.tree[0]), kt(this.tree)
                        }
                        get nextNamedSibling() {
                            return Tt(this), Ze._ts_node_next_named_sibling_wasm(this.tree[0]), kt(this.tree)
                        }
                        get previousNamedSibling() {
                            return Tt(this), Ze._ts_node_prev_named_sibling_wasm(this.tree[0]), kt(this.tree)
                        }
                        get parent() {
                            return Tt(this), Ze._ts_node_parent_wasm(this.tree[0]), kt(this.tree)
                        }
                        descendantForIndex(e, t = e) {
                            if ("number" != typeof e || "number" != typeof t) throw new Error("Arguments must be numbers");
                            Tt(this);
                            let r = pt + rt;
                            return I(r, e, "i32"), I(r + tt, t, "i32"), Ze._ts_node_descendant_for_index_wasm(this.tree[0]), kt(this.tree)
                        }
                        namedDescendantForIndex(e, t = e) {
                            if ("number" != typeof e || "number" != typeof t) throw new Error("Arguments must be numbers");
                            Tt(this);
                            let r = pt + rt;
                            return I(r, e, "i32"), I(r + tt, t, "i32"), Ze._ts_node_named_descendant_for_index_wasm(this.tree[0]), kt(this.tree)
                        }
                        descendantForPosition(e, t = e) {
                            if (!St(e) || !St(t)) throw new Error("Arguments must be {row, column} objects");
                            Tt(this);
                            let r = pt + rt;
                            return At(r, e), At(r + nt, t), Ze._ts_node_descendant_for_position_wasm(this.tree[0]), kt(this.tree)
                        }
                        namedDescendantForPosition(e, t = e) {
                            if (!St(e) || !St(t)) throw new Error("Arguments must be {row, column} objects");
                            Tt(this);
                            let r = pt + rt;
                            return At(r, e), At(r + nt, t), Ze._ts_node_named_descendant_for_position_wasm(this.tree[0]), kt(this.tree)
                        }
                        walk() {
                            return Tt(this), Ze._ts_tree_cursor_new_wasm(this.tree[0]), new vt(et, this.tree)
                        }
                        toString() {
                            Tt(this);
                            const e = Ze._ts_node_to_string_wasm(this.tree[0]),
                                t = function(e) {
                                    for (var t = "";;) {
                                        var r = $[e++ >> 0];
                                        if (!r) return t;
                                        t += String.fromCharCode(r)
                                    }
                                }(e);
                            return Ze._free(e), t
                        }
                    }
                    class vt {
                        constructor(e, t) {
                            Ct(e), this.tree = t, Pt(this)
                        }
                        delete() {
                            It(this), Ze._ts_tree_cursor_delete_wasm(this.tree[0]), this[0] = this[1] = this[2] = 0
                        }
                        reset(e) {
                            Tt(e), It(this, pt + rt), Ze._ts_tree_cursor_reset_wasm(this.tree[0]), Pt(this)
                        }
                        get nodeType() {
                            return this.tree.language.types[this.nodeTypeId] || "ERROR"
                        }
                        get nodeTypeId() {
                            return It(this), Ze._ts_tree_cursor_current_node_type_id_wasm(this.tree[0])
                        }
                        get nodeId() {
                            return It(this), Ze._ts_tree_cursor_current_node_id_wasm(this.tree[0])
                        }
                        get nodeIsNamed() {
                            return It(this), 1 === Ze._ts_tree_cursor_current_node_is_named_wasm(this.tree[0])
                        }
                        get nodeIsMissing() {
                            return It(this), 1 === Ze._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0])
                        }
                        get nodeText() {
                            It(this);
                            const e = Ze._ts_tree_cursor_start_index_wasm(this.tree[0]),
                                t = Ze._ts_tree_cursor_end_index_wasm(this.tree[0]);
                            return xt(this.tree, e, t)
                        }
                        get startPosition() {
                            return It(this), Ze._ts_tree_cursor_start_position_wasm(this.tree[0]), Ot(pt)
                        }
                        get endPosition() {
                            return It(this), Ze._ts_tree_cursor_end_position_wasm(this.tree[0]), Ot(pt)
                        }
                        get startIndex() {
                            return It(this), Ze._ts_tree_cursor_start_index_wasm(this.tree[0])
                        }
                        get endIndex() {
                            return It(this), Ze._ts_tree_cursor_end_index_wasm(this.tree[0])
                        }
                        currentNode() {
                            return It(this), Ze._ts_tree_cursor_current_node_wasm(this.tree[0]), kt(this.tree)
                        }
                        currentFieldId() {
                            return It(this), Ze._ts_tree_cursor_current_field_id_wasm(this.tree[0])
                        }
                        currentFieldName() {
                            return this.tree.language.fields[this.currentFieldId()]
                        }
                        gotoFirstChild() {
                            It(this);
                            const e = Ze._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);
                            return Pt(this), 1 === e
                        }
                        gotoNextSibling() {
                            It(this);
                            const e = Ze._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);
                            return Pt(this), 1 === e
                        }
                        gotoParent() {
                            It(this);
                            const e = Ze._ts_tree_cursor_goto_parent_wasm(this.tree[0]);
                            return Pt(this), 1 === e
                        }
                    }
                    class bt {
                        constructor(e, t) {
                            Ct(e), this[0] = t, this.types = new Array(Ze._ts_language_symbol_count(this[0]));
                            for (let e = 0, t = this.types.length; e < t; e++) Ze._ts_language_symbol_type(this[0], e) < 2 && (this.types[e] = U(Ze._ts_language_symbol_name(this[0], e)));
                            this.fields = new Array(Ze._ts_language_field_count(this[0]) + 1);
                            for (let e = 0, t = this.fields.length; e < t; e++) {
                                const t = Ze._ts_language_field_name_for_id(this[0], e);
                                this.fields[e] = 0 !== t ? U(t) : null
                            }
                        }
                        get version() {
                            return Ze._ts_language_version(this[0])
                        }
                        get fieldCount() {
                            return this.fields.length - 1
                        }
                        fieldIdForName(e) {
                            const t = this.fields.indexOf(e);
                            return -1 !== t ? t : null
                        }
                        fieldNameForId(e) {
                            return this.fields[e] || null
                        }
                        idForNodeType(e, t) {
                            const r = z(e),
                                n = Ze._malloc(r + 1);
                            G(e, n, r + 1);
                            const o = Ze._ts_language_symbol_for_name(this[0], n, r, t);
                            return Ze._free(n), o || null
                        }
                        get nodeTypeCount() {
                            return Ze._ts_language_symbol_count(this[0])
                        }
                        nodeTypeForId(e) {
                            const t = Ze._ts_language_symbol_name(this[0], e);
                            return t ? U(t) : null
                        }
                        nodeTypeIsNamed(e) {
                            return !!Ze._ts_language_type_is_named_wasm(this[0], e)
                        }
                        nodeTypeIsVisible(e) {
                            return !!Ze._ts_language_type_is_visible_wasm(this[0], e)
                        }
                        query(e) {
                            const t = z(e),
                                r = Ze._malloc(t + 1);
                            G(e, r, t + 1);
                            const n = Ze._ts_query_new(this[0], r, t, pt, pt + tt);
                            if (!n) {
                                const t = P(pt + tt, "i32"),
                                    n = U(r, P(pt, "i32")).length,
                                    o = e.substr(n, 100).split("\n")[0];
                                let i, s = o.match(st)[0];
                                switch (t) {
                                    case 2:
                                        i = new RangeError(`Bad node name '${s}'`);
                                        break;
                                    case 3:
                                        i = new RangeError(`Bad field name '${s}'`);
                                        break;
                                    case 4:
                                        i = new RangeError(`Bad capture name @${s}`);
                                        break;
                                    case 5:
                                        i = new TypeError(`Bad pattern structure at offset ${n}: '${o}'...`), s = "";
                                        break;
                                    default:
                                        i = new SyntaxError(`Bad syntax at offset ${n}: '${o}'...`), s = ""
                                }
                                throw i.index = n, i.length = s.length, Ze._free(r), i
                            }
                            const o = Ze._ts_query_string_count(n),
                                i = Ze._ts_query_capture_count(n),
                                s = Ze._ts_query_pattern_count(n),
                                a = new Array(i),
                                c = new Array(o);
                            for (let e = 0; e < i; e++) {
                                const t = Ze._ts_query_capture_name_for_id(n, e, pt),
                                    r = P(pt, "i32");
                                a[e] = U(t, r)
                            }
                            for (let e = 0; e < o; e++) {
                                const t = Ze._ts_query_string_value_for_id(n, e, pt),
                                    r = P(pt, "i32");
                                c[e] = U(t, r)
                            }
                            const l = new Array(s),
                                u = new Array(s),
                                d = new Array(s),
                                p = new Array(s),
                                h = new Array(s);
                            for (let e = 0; e < s; e++) {
                                const t = Ze._ts_query_predicates_for_pattern(n, e, pt),
                                    r = P(pt, "i32");
                                p[e] = [], h[e] = [];
                                const o = [];
                                let i = t;
                                for (let t = 0; t < r; t++) {
                                    const t = P(i, "i32"),
                                        r = P(i += tt, "i32");
                                    if (i += tt, t === at) o.push({
                                        type: "capture",
                                        name: a[r]
                                    });
                                    else if (t === ct) o.push({
                                        type: "string",
                                        value: c[r]
                                    });
                                    else if (o.length > 0) {
                                        if ("string" !== o[0].type) throw new Error("Predicates must begin with a literal value");
                                        const t = o[0].value;
                                        let r = !0;
                                        switch (t) {
                                            case "not-eq?":
                                                r = !1;
                                            case "eq?":
                                                if (3 !== o.length) throw new Error("Wrong number of arguments to `#eq?` predicate. Expected 2, got " + (o.length - 1));
                                                if ("capture" !== o[1].type) throw new Error(`First argument of \`#eq?\` predicate must be a capture. Got "${o[1].value}"`);
                                                if ("capture" === o[2].type) {
                                                    const t = o[1].name,
                                                        n = o[2].name;
                                                    h[e].push((function(e) {
                                                        let o, i;
                                                        for (const r of e) r.name === t && (o = r.node), r.name === n && (i = r.node);
                                                        return o.text === i.text === r
                                                    }))
                                                } else {
                                                    const t = o[1].name,
                                                        n = o[2].value;
                                                    h[e].push((function(e) {
                                                        for (const o of e)
                                                            if (o.name === t) return o.node.text === n === r;
                                                        return !1
                                                    }))
                                                }
                                                break;
                                            case "not-match?":
                                                r = !1;
                                            case "match?":
                                                if (3 !== o.length) throw new Error(`Wrong number of arguments to \`#match?\` predicate. Expected 2, got ${o.length-1}.`);
                                                if ("capture" !== o[1].type) throw new Error(`First argument of \`#match?\` predicate must be a capture. Got "${o[1].value}".`);
                                                if ("string" !== o[2].type) throw new Error(`Second argument of \`#match?\` predicate must be a string. Got @${o[2].value}.`);
                                                const n = o[1].name,
                                                    i = new RegExp(o[2].value);
                                                h[e].push((function(e) {
                                                    for (const t of e)
                                                        if (t.name === n) return i.test(t.node.text) === r;
                                                    return !1
                                                }));
                                                break;
                                            case "set!":
                                                if (o.length < 2 || o.length > 3) throw new Error(`Wrong number of arguments to \`#set!\` predicate. Expected 1 or 2. Got ${o.length-1}.`);
                                                if (o.some((e => "string" !== e.type))) throw new Error('Arguments to `#set!` predicate must be a strings.".');
                                                l[e] || (l[e] = {}), l[e][o[1].value] = o[2] ? o[2].value : null;
                                                break;
                                            case "is?":
                                            case "is-not?":
                                                if (o.length < 2 || o.length > 3) throw new Error(`Wrong number of arguments to \`#${t}\` predicate. Expected 1 or 2. Got ${o.length-1}.`);
                                                if (o.some((e => "string" !== e.type))) throw new Error(`Arguments to \`#${t}\` predicate must be a strings.".`);
                                                const s = "is?" === t ? u : d;
                                                s[e] || (s[e] = {}), s[e][o[1].value] = o[2] ? o[2].value : null;
                                                break;
                                            default:
                                                p[e].push({
                                                    operator: t,
                                                    operands: o.slice(1)
                                                })
                                        }
                                        o.length = 0
                                    }
                                }
                                Object.freeze(l[e]), Object.freeze(u[e]), Object.freeze(d[e])
                            }
                            return Ze._free(r), new wt(et, n, a, h, p, Object.freeze(l), Object.freeze(u), Object.freeze(d))
                        }
                        static load(e) {
                            let t;
                            if (e instanceof Uint8Array) t = Promise.resolve(e);
                            else {
                                const n = e;
                                if ("undefined" != typeof process && process.versions && process.versions.node) {
                                    const e = r(7147);
                                    t = Promise.resolve(e.readFileSync(n))
                                } else t = fetch(n).then((e => e.arrayBuffer().then((t => {
                                    if (e.ok) return new Uint8Array(t); {
                                        const r = new TextDecoder("utf-8").decode(t);
                                        throw new Error(`Language.load failed with status ${e.status}.\n\n${r}`)
                                    }
                                }))))
                            }
                            const n = "function" == typeof loadSideModule ? loadSideModule : Pe;
                            return t.then((e => n(e, {
                                loadAsync: !0
                            }))).then((e => {
                                const t = Object.keys(e),
                                    r = t.find((e => lt.test(e) && !e.includes("external_scanner_")));
                                r || console.log(`Couldn't find language function in WASM file. Symbols:\n${JSON.stringify(t,null,2)}`);
                                const n = e[r]();
                                return new bt(et, n)
                            }))
                        }
                    }
                    class wt {
                        constructor(e, t, r, n, o, i, s, a) {
                            Ct(e), this[0] = t, this.captureNames = r, this.textPredicates = n, this.predicates = o, this.setProperties = i, this.assertedProperties = s, this.refutedProperties = a, this.exceededMatchLimit = !1
                        }
                        delete() {
                            Ze._ts_query_delete(this[0]), this[0] = 0
                        }
                        matches(e, t, r) {
                            t || (t = it), r || (r = it), Tt(e), Ze._ts_query_matches_wasm(this[0], e.tree[0], t.row, t.column, r.row, r.column);
                            const n = P(pt, "i32"),
                                o = P(pt + tt, "i32"),
                                i = P(pt + 2 * tt, "i32"),
                                s = new Array(n);
                            this.exceededMatchLimit = !!i;
                            let a = 0,
                                c = o;
                            for (let t = 0; t < n; t++) {
                                const r = P(c, "i32"),
                                    n = P(c += tt, "i32");
                                c += tt;
                                const o = new Array(n);
                                if (c = Et(this, e.tree, c, o), this.textPredicates[r].every((e => e(o)))) {
                                    s[a++] = {
                                        pattern: r,
                                        captures: o
                                    };
                                    const e = this.setProperties[r];
                                    e && (s[t].setProperties = e);
                                    const n = this.assertedProperties[r];
                                    n && (s[t].assertedProperties = n);
                                    const i = this.refutedProperties[r];
                                    i && (s[t].refutedProperties = i)
                                }
                            }
                            return s.length = a, Ze._free(o), s
                        }
                        captures(e, t, r) {
                            t || (t = it), r || (r = it), Tt(e), Ze._ts_query_captures_wasm(this[0], e.tree[0], t.row, t.column, r.row, r.column);
                            const n = P(pt, "i32"),
                                o = P(pt + tt, "i32"),
                                i = P(pt + 2 * tt, "i32"),
                                s = [];
                            this.exceededMatchLimit = !!i;
                            const a = [];
                            let c = o;
                            for (let t = 0; t < n; t++) {
                                const t = P(c, "i32"),
                                    r = P(c += tt, "i32"),
                                    n = P(c += tt, "i32");
                                if (c += tt, a.length = r, c = Et(this, e.tree, c, a), this.textPredicates[t].every((e => e(a)))) {
                                    const e = a[n],
                                        r = this.setProperties[t];
                                    r && (e.setProperties = r);
                                    const o = this.assertedProperties[t];
                                    o && (e.assertedProperties = o);
                                    const i = this.refutedProperties[t];
                                    i && (e.refutedProperties = i), s.push(e)
                                }
                            }
                            return Ze._free(o), s
                        }
                        predicatesForPattern(e) {
                            return this.predicates[e]
                        }
                        didExceedMatchLimit() {
                            return this.exceededMatchLimit
                        }
                    }

                    function xt(e, t, r) {
                        const n = r - t;
                        let o = e.textCallback(t, null, r);
                        for (t += o.length; t < r;) {
                            const n = e.textCallback(t, null, r);
                            if (!(n && n.length > 0)) break;
                            t += n.length, o += n
                        }
                        return t > r && (o = o.slice(0, n)), o
                    }

                    function Et(e, t, r, n) {
                        for (let o = 0, i = n.length; o < i; o++) {
                            const i = P(r, "i32"),
                                s = kt(t, r += tt);
                            r += rt, n[o] = {
                                name: e.captureNames[i],
                                node: s
                            }
                        }
                        return r
                    }

                    function Ct(e) {
                        if (e !== et) throw new Error("Illegal constructor")
                    }

                    function St(e) {
                        return e && "number" == typeof e.row && "number" == typeof e.column
                    }

                    function Tt(e) {
                        let t = pt;
                        I(t, e.id, "i32"), I(t += tt, e.startIndex, "i32"), I(t += tt, e.startPosition.row, "i32"), I(t += tt, e.startPosition.column, "i32"), I(t += tt, e[0], "i32")
                    }

                    function kt(e, t = pt) {
                        const r = P(t, "i32");
                        if (0 === r) return null;
                        const n = P(t += tt, "i32"),
                            o = P(t += tt, "i32"),
                            i = P(t += tt, "i32"),
                            s = P(t += tt, "i32"),
                            a = new yt(et, e);
                        return a.id = r, a.startIndex = n, a.startPosition = {
                            row: o,
                            column: i
                        }, a[0] = s, a
                    }

                    function It(e, t = pt) {
                        I(t + 0 * tt, e[0], "i32"), I(t + 1 * tt, e[1], "i32"), I(t + 2 * tt, e[2], "i32")
                    }

                    function Pt(e) {
                        e[0] = P(pt + 0 * tt, "i32"), e[1] = P(pt + 1 * tt, "i32"), e[2] = P(pt + 2 * tt, "i32")
                    }

                    function At(e, t) {
                        I(e, t.row, "i32"), I(e + tt, t.column, "i32")
                    }

                    function Ot(e) {
                        return {
                            row: P(e, "i32"),
                            column: P(e + tt, "i32")
                        }
                    }

                    function Nt(e, t) {
                        At(e, t.startPosition), At(e += nt, t.endPosition), I(e += nt, t.startIndex, "i32"), I(e += tt, t.endIndex, "i32"), e += tt
                    }

                    function Rt(e) {
                        const t = {};
                        return t.startPosition = Ot(e), e += nt, t.endPosition = Ot(e), e += nt, t.startIndex = P(e, "i32"), e += tt, t.endIndex = P(e, "i32"), t
                    }
                    return gt.Language = bt, gt.Parser = gt, gt
                }.apply(t, [])) || (e.exports = n)
            },
            9602: e => {
                "use strict";
                e.exports = function(e) {
                    e.prototype[Symbol.iterator] = function*() {
                        for (let e = this.head; e; e = e.next) yield e.value
                    }
                }
            },
            4411: (e, t, r) => {
                "use strict";

                function n(e) {
                    var t = this;
                    if (t instanceof n || (t = new n), t.tail = null, t.head = null, t.length = 0, e && "function" == typeof e.forEach) e.forEach((function(e) {
                        t.push(e)
                    }));
                    else if (arguments.length > 0)
                        for (var r = 0, o = arguments.length; r < o; r++) t.push(arguments[r]);
                    return t
                }

                function o(e, t, r) {
                    var n = t === e.head ? new a(r, null, t, e) : new a(r, t, t.next, e);
                    return null === n.next && (e.tail = n), null === n.prev && (e.head = n), e.length++, n
                }

                function i(e, t) {
                    e.tail = new a(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++
                }

                function s(e, t) {
                    e.head = new a(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++
                }

                function a(e, t, r, n) {
                    if (!(this instanceof a)) return new a(e, t, r, n);
                    this.list = n, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null
                }
                e.exports = n, n.Node = a, n.create = n, n.prototype.removeNode = function(e) {
                    if (e.list !== this) throw new Error("removing node which does not belong to this list");
                    var t = e.next,
                        r = e.prev;
                    return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.next = null, e.prev = null, e.list = null, t
                }, n.prototype.unshiftNode = function(e) {
                    if (e !== this.head) {
                        e.list && e.list.removeNode(e);
                        var t = this.head;
                        e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++
                    }
                }, n.prototype.pushNode = function(e) {
                    if (e !== this.tail) {
                        e.list && e.list.removeNode(e);
                        var t = this.tail;
                        e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++
                    }
                }, n.prototype.push = function() {
                    for (var e = 0, t = arguments.length; e < t; e++) i(this, arguments[e]);
                    return this.length
                }, n.prototype.unshift = function() {
                    for (var e = 0, t = arguments.length; e < t; e++) s(this, arguments[e]);
                    return this.length
                }, n.prototype.pop = function() {
                    if (this.tail) {
                        var e = this.tail.value;
                        return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e
                    }
                }, n.prototype.shift = function() {
                    if (this.head) {
                        var e = this.head.value;
                        return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e
                    }
                }, n.prototype.forEach = function(e, t) {
                    t = t || this;
                    for (var r = this.head, n = 0; null !== r; n++) e.call(t, r.value, n, this), r = r.next
                }, n.prototype.forEachReverse = function(e, t) {
                    t = t || this;
                    for (var r = this.tail, n = this.length - 1; null !== r; n--) e.call(t, r.value, n, this), r = r.prev
                }, n.prototype.get = function(e) {
                    for (var t = 0, r = this.head; null !== r && t < e; t++) r = r.next;
                    if (t === e && null !== r) return r.value
                }, n.prototype.getReverse = function(e) {
                    for (var t = 0, r = this.tail; null !== r && t < e; t++) r = r.prev;
                    if (t === e && null !== r) return r.value
                }, n.prototype.map = function(e, t) {
                    t = t || this;
                    for (var r = new n, o = this.head; null !== o;) r.push(e.call(t, o.value, this)), o = o.next;
                    return r
                }, n.prototype.mapReverse = function(e, t) {
                    t = t || this;
                    for (var r = new n, o = this.tail; null !== o;) r.push(e.call(t, o.value, this)), o = o.prev;
                    return r
                }, n.prototype.reduce = function(e, t) {
                    var r, n = this.head;
                    if (arguments.length > 1) r = t;
                    else {
                        if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
                        n = this.head.next, r = this.head.value
                    }
                    for (var o = 0; null !== n; o++) r = e(r, n.value, o), n = n.next;
                    return r
                }, n.prototype.reduceReverse = function(e, t) {
                    var r, n = this.tail;
                    if (arguments.length > 1) r = t;
                    else {
                        if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
                        n = this.tail.prev, r = this.tail.value
                    }
                    for (var o = this.length - 1; null !== n; o--) r = e(r, n.value, o), n = n.prev;
                    return r
                }, n.prototype.toArray = function() {
                    for (var e = new Array(this.length), t = 0, r = this.head; null !== r; t++) e[t] = r.value, r = r.next;
                    return e
                }, n.prototype.toArrayReverse = function() {
                    for (var e = new Array(this.length), t = 0, r = this.tail; null !== r; t++) e[t] = r.value, r = r.prev;
                    return e
                }, n.prototype.slice = function(e, t) {
                    (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
                    var r = new n;
                    if (t < e || t < 0) return r;
                    e < 0 && (e = 0), t > this.length && (t = this.length);
                    for (var o = 0, i = this.head; null !== i && o < e; o++) i = i.next;
                    for (; null !== i && o < t; o++, i = i.next) r.push(i.value);
                    return r
                }, n.prototype.sliceReverse = function(e, t) {
                    (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
                    var r = new n;
                    if (t < e || t < 0) return r;
                    e < 0 && (e = 0), t > this.length && (t = this.length);
                    for (var o = this.length, i = this.tail; null !== i && o > t; o--) i = i.prev;
                    for (; null !== i && o > e; o--, i = i.prev) r.push(i.value);
                    return r
                }, n.prototype.splice = function(e, t, ...r) {
                    e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
                    for (var n = 0, i = this.head; null !== i && n < e; n++) i = i.next;
                    var s = [];
                    for (n = 0; i && n < t; n++) s.push(i.value), i = this.removeNode(i);
                    for (null === i && (i = this.tail), i !== this.head && i !== this.tail && (i = i.prev), n = 0; n < r.length; n++) i = o(this, i, r[n]);
                    return s
                }, n.prototype.reverse = function() {
                    for (var e = this.head, t = this.tail, r = e; null !== r; r = r.prev) {
                        var n = r.prev;
                        r.prev = r.next, r.next = n
                    }
                    return this.head = t, this.tail = e, this
                };
                try {
                    r(9602)(n)
                } catch (e) {}
            },
            3055: (e, t, r) => {
                var n, o, i;
                n = {
                    271: (e, t, r) => {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }), t.defaultFileSystem = t.FileSystem = void 0;
                        const n = r(747);
                        t.FileSystem = class {}, t.defaultFileSystem = {
                            readFile: e => n.promises.readFile(e),
                            mtime: async e => (await n.promises.stat(e)).mtimeMs,
                            stat: async function(e) {
                                const t = await n.promises.stat(e);
                                return {
                                    ctime: t.ctimeMs,
                                    mtime: t.mtimeMs,
                                    size: t.size
                                }
                            }
                        }
                    },
                    417: (e, t) => {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }), t.getPathMarker = t.getLanguageMarker = t.comment = t.hasLanguageMarker = t.languageCommentMarkers = void 0, t.languageCommentMarkers = {
                            abap: {
                                start: '"',
                                end: ""
                            },
                            bat: {
                                start: "REM",
                                end: ""
                            },
                            bibtex: {
                                start: "%",
                                end: ""
                            },
                            blade: {
                                start: "#",
                                end: ""
                            },
                            c: {
                                start: "//",
                                end: ""
                            },
                            clojure: {
                                start: ";",
                                end: ""
                            },
                            coffeescript: {
                                start: "//",
                                end: ""
                            },
                            cpp: {
                                start: "//",
                                end: ""
                            },
                            csharp: {
                                start: "//",
                                end: ""
                            },
                            css: {
                                start: "/*",
                                end: "*/"
                            },
                            dart: {
                                start: "//",
                                end: ""
                            },
                            dockerfile: {
                                start: "#",
                                end: ""
                            },
                            elixir: {
                                start: "#",
                                end: ""
                            },
                            erb: {
                                start: "<%#",
                                end: "%>"
                            },
                            fsharp: {
                                start: "//",
                                end: ""
                            },
                            go: {
                                start: "//",
                                end: ""
                            },
                            groovy: {
                                start: "//",
                                end: ""
                            },
                            haml: {
                                start: "-#",
                                end: ""
                            },
                            handlebars: {
                                start: "{{!",
                                end: "}}"
                            },
                            html: {
                                start: "\x3c!--",
                                end: "--\x3e"
                            },
                            ini: {
                                start: ";",
                                end: ""
                            },
                            java: {
                                start: "//",
                                end: ""
                            },
                            javascript: {
                                start: "//",
                                end: ""
                            },
                            javascriptreact: {
                                start: "//",
                                end: ""
                            },
                            jsonc: {
                                start: "//",
                                end: ""
                            },
                            jsx: {
                                start: "//",
                                end: ""
                            },
                            julia: {
                                start: "#",
                                end: ""
                            },
                            latex: {
                                start: "%",
                                end: ""
                            },
                            less: {
                                start: "//",
                                end: ""
                            },
                            lua: {
                                start: "--",
                                end: ""
                            },
                            makefile: {
                                start: "#",
                                end: ""
                            },
                            markdown: {
                                start: "[]: #",
                                end: ""
                            },
                            "objective-c": {
                                start: "//",
                                end: ""
                            },
                            "objective-cpp": {
                                start: "//",
                                end: ""
                            },
                            perl: {
                                start: "#",
                                end: ""
                            },
                            php: {
                                start: "//",
                                end: ""
                            },
                            pug: {
                                start: "//",
                                end: ""
                            },
                            python: {
                                start: "#",
                                end: ""
                            },
                            r: {
                                start: "#",
                                end: ""
                            },
                            razor: {
                                start: "\x3c!--",
                                end: "--\x3e"
                            },
                            ruby: {
                                start: "#",
                                end: ""
                            },
                            rust: {
                                start: "//",
                                end: ""
                            },
                            sass: {
                                start: "//",
                                end: ""
                            },
                            scss: {
                                start: "//",
                                end: ""
                            },
                            shellscript: {
                                start: "#",
                                end: ""
                            },
                            slim: {
                                start: "/",
                                end: ""
                            },
                            solidity: {
                                start: "//",
                                end: ""
                            },
                            sql: {
                                start: "--",
                                end: ""
                            },
                            stylus: {
                                start: "//",
                                end: ""
                            },
                            svelte: {
                                start: "\x3c!--",
                                end: "--\x3e"
                            },
                            swift: {
                                start: "//",
                                end: ""
                            },
                            terraform: {
                                start: "#",
                                end: ""
                            },
                            tex: {
                                start: "%",
                                end: ""
                            },
                            typescript: {
                                start: "//",
                                end: ""
                            },
                            typescriptreact: {
                                start: "//",
                                end: ""
                            },
                            vb: {
                                start: "'",
                                end: ""
                            },
                            "vue-html": {
                                start: "\x3c!--",
                                end: "--\x3e"
                            },
                            vue: {
                                start: "//",
                                end: ""
                            },
                            xml: {
                                start: "\x3c!--",
                                end: "--\x3e"
                            },
                            xsl: {
                                start: "\x3c!--",
                                end: "--\x3e"
                            },
                            yaml: {
                                start: "#",
                                end: ""
                            }
                        };
                        const r = ["php", "plaintext"],
                            n = {
                                shellscript: "#!/bin/sh",
                                python: "#!/usr/bin/env python3",
                                ruby: "#!/usr/bin/env ruby",
                                html: "<!DOCTYPE html>",
                                yaml: "# YAML data"
                            };

                        function o({
                            source: e
                        }) {
                            return e.startsWith("#!") || e.startsWith("<!DOCTYPE")
                        }

                        function i(e, r) {
                            const n = t.languageCommentMarkers[r];
                            if (n) {
                                const t = "" == n.end ? "" : " " + n.end;
                                return `${n.start} ${e}${t}`
                            }
                            return ""
                        }
                        t.hasLanguageMarker = o, t.comment = i, t.getLanguageMarker = function(e) {
                            const {
                                languageId: t
                            } = e;
                            return -1 !== r.indexOf(t) || o(e) ? "" : t in n ? n[t] : i(`Language: ${t}`, t)
                        }, t.getPathMarker = function(e) {
                            return e.relativePath ? i(`Path: ${e.relativePath}`, e.languageId) : ""
                        }
                    },
                    563: function(e, t, r) {
                        "use strict";
                        var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                                void 0 === n && (n = r), Object.defineProperty(e, n, {
                                    enumerable: !0,
                                    get: function() {
                                        return t[r]
                                    }
                                })
                            } : function(e, t, r, n) {
                                void 0 === n && (n = r), e[n] = t[r]
                            }),
                            o = this && this.__exportStar || function(e, t) {
                                for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
                            };
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }), t.createWorker = t.FileSystem = t.comment = t.languageCommentMarkers = void 0;
                        const i = r(622),
                            s = r(13);
                        o(r(306), t), o(r(610), t), o(r(312), t), o(r(94), t);
                        var a = r(417);
                        Object.defineProperty(t, "languageCommentMarkers", {
                            enumerable: !0,
                            get: function() {
                                return a.languageCommentMarkers
                            }
                        }), Object.defineProperty(t, "comment", {
                            enumerable: !0,
                            get: function() {
                                return a.comment
                            }
                        });
                        var c = r(271);
                        Object.defineProperty(t, "FileSystem", {
                            enumerable: !0,
                            get: function() {
                                return c.FileSystem
                            }
                        }), t.createWorker = function() {
                            return new s.Worker(i.resolve(__dirname, "..", "dist", "worker.js"))
                        }
                    },
                    179: (e, t, r) => {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }), t.extractLocalImportContext = t.getDocComment = void 0;
                        const n = r(622),
                            o = r(306);

                        function i(e, t) {
                            var r;
                            let o = null === (r = t.namedChild(1)) || void 0 === r ? void 0 : r.text.slice(1, -1);
                            if (!o || !o.startsWith(".")) return null;
                            if ("" === n.extname(o)) o += ".ts";
                            else if (".ts" !== n.extname(o)) return null;
                            return n.join(n.dirname(e), o)
                        }

                        function s(e) {
                            var t, r, n, o, i;
                            let s = [];
                            if ("import_clause" === (null === (t = e.namedChild(0)) || void 0 === t ? void 0 : t.type)) {
                                let t = e.namedChild(0);
                                if ("named_imports" === (null === (r = null == t ? void 0 : t.namedChild(0)) || void 0 === r ? void 0 : r.type)) {
                                    let e = t.namedChild(0);
                                    for (let t of null !== (n = null == e ? void 0 : e.namedChildren) && void 0 !== n ? n : [])
                                        if ("import_specifier" === t.type) {
                                            const e = null === (o = t.childForFieldName("name")) || void 0 === o ? void 0 : o.text;
                                            if (e) {
                                                const r = null === (i = t.childForFieldName("alias")) || void 0 === i ? void 0 : i.text;
                                                s.push({
                                                    name: e,
                                                    alias: r
                                                })
                                            }
                                        }
                                }
                            }
                            return s
                        }
                        const a = new Map;

                        function c(e, t) {
                            var r, n;
                            let o = null !== (n = null === (r = null == t ? void 0 : t.childForFieldName("name")) || void 0 === r ? void 0 : r.text) && void 0 !== n ? n : "";
                            switch (null == t ? void 0 : t.type) {
                                case "ambient_declaration":
                                    return c(e, t.namedChild(0));
                                case "interface_declaration":
                                case "enum_declaration":
                                case "type_alias_declaration":
                                    return {
                                        name: o,
                                        decl: t.text
                                    };
                                case "function_declaration":
                                case "function_signature":
                                    return {
                                        name: o,
                                        decl: l(e, t)
                                    };
                                case "class_declaration":
                                    {
                                        let r = function(e, t) {
                                                let r = t.childForFieldName("body");
                                                if (r) return r.namedChildren.map((t => d(e, t))).filter((e => e))
                                            }(e, t),
                                            n = "";
                                        if (r) {
                                            let o = t.childForFieldName("body");
                                            n = `declare ${e.substring(t.startIndex,o.startIndex+1)}`, n += r.map((e => "\n" + e)).join(""), n += "\n}"
                                        }
                                        return {
                                            name: o,
                                            decl: n
                                        }
                                    }
                            }
                            return {
                                name: o,
                                decl: ""
                            }
                        }

                        function l(e, t) {
                            var r, n, o;
                            const i = null !== (n = null === (r = t.childForFieldName("return_type")) || void 0 === r ? void 0 : r.endIndex) && void 0 !== n ? n : null === (o = t.childForFieldName("parameters")) || void 0 === o ? void 0 : o.endIndex;
                            if (void 0 !== i) {
                                let r = e.substring(t.startIndex, i) + ";";
                                return "function_declaration" === t.type || "function_signature" === t.type ? "declare " + r : r
                            }
                            return ""
                        }

                        function u(e, t) {
                            const r = o.getFirstPrecedingComment(t);
                            return r ? e.substring(r.startIndex, t.startIndex) : ""
                        }

                        function d(e, t) {
                            var r, n, i, s, a;
                            if ("accessibility_modifier" === (null === (r = null == t ? void 0 : t.firstChild) || void 0 === r ? void 0 : r.type) && "private" === t.firstChild.text) return "";
                            const c = o.getFirstPrecedingComment(t),
                                p = null !== (n = function(e, t) {
                                    let r = t.startIndex - 1;
                                    for (; r >= 0 && (" " === e[r] || "\t" === e[r]);) r--;
                                    if (r < 0 || "\n" === e[r]) return e.substring(r + 1, t.startIndex)
                                }(e, null != c ? c : t)) && void 0 !== n ? n : "  ",
                                h = u(e, t);
                            switch (t.type) {
                                case "ambient_declaration":
                                    const r = t.namedChild(0);
                                    return r ? p + h + d(e, r) : "";
                                case "method_definition":
                                case "method_signature":
                                    return p + h + l(e, t);
                                case "public_field_definition":
                                    {
                                        let r = null !== (s = null === (i = t.childForFieldName("type")) || void 0 === i ? void 0 : i.endIndex) && void 0 !== s ? s : null === (a = t.childForFieldName("name")) || void 0 === a ? void 0 : a.endIndex;
                                        if (void 0 !== r) return p + h + e.substring(t.startIndex, r) + ";"
                                    }
                            }
                            return ""
                        }
                        async function p(e, t, r) {
                            let n = new Map,
                                i = -1;
                            try {
                                i = await r.mtime(e)
                            } catch {
                                return n
                            }
                            let s = a.get(e);
                            if (s && s.mtime === i) return s.exports;
                            if ("typescript" === t) {
                                let i = null;
                                try {
                                    let s = (await r.readFile(e)).toString();
                                    i = await o.parseTree(t, s);
                                    for (let e of o.queryExports(t, i.rootNode))
                                        for (let t of e.captures) {
                                            let e = t.node;
                                            if ("export_statement" === e.type) {
                                                let t = e.childForFieldName("declaration");
                                                if (null == t ? void 0 : t.hasError()) continue;
                                                let {
                                                    name: r,
                                                    decl: o
                                                } = c(s, t);
                                                if (r) {
                                                    o = u(s, e) + o;
                                                    let t = n.get(r);
                                                    t || (t = [], n.set(r, t)), t.push(o)
                                                }
                                            }
                                        }
                                } catch {} finally {
                                    i && i.delete()
                                }
                            }
                            if (a.size > 2e3)
                                for (let e of a.keys())
                                    if (a.delete(e), n.size <= 1e3) break;
                            return a.set(e, {
                                mtime: i,
                                exports: n
                            }), n
                        }
                        t.getDocComment = u;
                        const h = /^\s*import\s*(type|)\s*\{[^}]*\}\s*from\s*['"]\./gm;
                        t.extractLocalImportContext = async function(e, t) {
                            let {
                                source: r,
                                uri: n,
                                languageId: a
                            } = e;
                            return t && "typescript" === a ? async function(e, t, r) {
                                let n = "typescript",
                                    a = [];
                                const c = function(e) {
                                    let t, r = -1;
                                    h.lastIndex = -1;
                                    do {
                                        t = h.exec(e), t && (r = h.lastIndex + t.length)
                                    } while (t);
                                    if (-1 === r) return -1;
                                    const n = e.indexOf("\n", r);
                                    return -1 !== n ? n : e.length
                                }(e);
                                if (-1 === c) return a;
                                e = e.substring(0, c);
                                let l = await o.parseTree(n, e);
                                try {
                                    for (let e of function(e) {
                                            let t = [];
                                            for (let r of e.namedChildren) "import_statement" === r.type && t.push(r);
                                            return t
                                        }(l.rootNode)) {
                                        let o = i(t, e);
                                        if (!o) continue;
                                        let c = s(e);
                                        if (0 === c.length) continue;
                                        let l = await p(o, n, r);
                                        for (let e of c) l.has(e.name) && a.push(...l.get(e.name))
                                    }
                                } finally {
                                    l.delete()
                                }
                                return a
                            }(r, n, t) : []
                        }
                    },
                    647: (e, t, r) => {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }), t.getNeighborSnippets = void 0;
                        const n = r(417),
                            o = r(302),
                            i = {
                                none: {
                                    windowLength: 1,
                                    threshold: -1,
                                    numberOfNeighbors: 0
                                },
                                conservative: {
                                    windowLength: 10,
                                    threshold: .3,
                                    numberOfNeighbors: 1
                                },
                                medium: {
                                    windowLength: 20,
                                    threshold: .1,
                                    numberOfNeighbors: 2
                                },
                                eager: {
                                    windowLength: 60,
                                    threshold: 0,
                                    numberOfNeighbors: 4
                                },
                                eagerButLittle: {
                                    windowLength: 10,
                                    threshold: 0,
                                    numberOfNeighbors: 1
                                }
                            };

                        function s(e) {
                            return [e.relativePath ? "Compare this snippet from " + e.relativePath + ":" : "Compare this snippet:"].concat(e.snippet.split("\n"))
                        }
                        t.getNeighborSnippets = async function(e, t, r) {
                            const a = i[r],
                                c = {
                                    uri: e.uri,
                                    languageId: e.languageId,
                                    source: e.source.slice(0, e.offset).split("\n").slice(-a.windowLength).join("\n")
                                };
                            return t.filter((e => e.source.length < 1e4 && e.source.length > 0)).slice(0, 20).map((e => ({
                                relativePath: e.relativePath,
                                ...o.findBestJaccardMatch(e, c, a.windowLength)
                            }))).filter((e => e.score && e.snippet && e.score > a.threshold)).sort(((e, t) => e.score - t.score)).slice(-a.numberOfNeighbors).map((t => ({
                                score: t.score,
                                snippet: s(t).map((t => n.comment(t, e.languageId) + "\n")).join("")
                            })))
                        }
                    },
                    306: (e, t, r) => {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }), t.getFunctionPositions = t.getFirstPrecedingComment = t.isFunctionDefinition = t.isFunction = t.getAncestorWithSiblingFunctions = t.queryPythonIsDocstring = t.queryGlobalVars = t.queryExports = t.queryImports = t.queryFunctions = t.getBlockCloseToken = t.parsesWithoutError = t.parseTree = t.getLanguage = t.languageIdToWasmLanguage = t.isSupportedLanguageId = t.WASMLanguage = void 0;
                        const n = r(622),
                            o = r(87),
                            i = r(87);
                        var s;
                        ! function(e) {
                            e.Python = "python", e.JavaScript = "javascript", e.TypeScript = "typescript", e.Go = "go", e.Ruby = "ruby"
                        }(s = t.WASMLanguage || (t.WASMLanguage = {}));
                        const a = {
                            python: s.Python,
                            javascript: s.JavaScript,
                            javascriptreact: s.JavaScript,
                            jsx: s.JavaScript,
                            typescript: s.TypeScript,
                            typescriptreact: s.TypeScript,
                            go: s.Go,
                            ruby: s.Ruby
                        };

                        function c(e) {
                            if (!(e in a)) throw new Error(`Unrecognized language: ${e}`);
                            return a[e]
                        }
                        t.isSupportedLanguageId = function(e) {
                            return e in a
                        }, t.languageIdToWasmLanguage = c;
                        const l = {
                                python: [
                                    ["(function_definition body: (block\n             (expression_statement (string))? @docstring) @body) @function"],
                                    ['(ERROR ("def" (identifier) (parameters))) @function']
                                ],
                                javascript: [
                                    ["[\n            (function body: (statement_block) @body)\n            (function_declaration body: (statement_block) @body)\n            (generator_function body: (statement_block) @body)\n            (generator_function_declaration body: (statement_block) @body)\n            (method_definition body: (statement_block) @body)\n          ] @function"]
                                ],
                                typescript: [
                                    ["[\n            (function body: (statement_block) @body)\n            (function_declaration body: (statement_block) @body)\n            (generator_function body: (statement_block) @body)\n            (generator_function_declaration body: (statement_block) @body)\n            (method_definition body: (statement_block) @body)\n          ] @function"]
                                ],
                                go: [
                                    ["[\n            (function_declaration body: (block) @body)\n            (method_declaration body: (block) @body)\n          ] @function"]
                                ],
                                ruby: [
                                    ['[\n            (method name: (_) parameters: (method_parameters)? @params [(_)+ "end"] @body)\n            (singleton_method name: (_) parameters: (method_parameters)? @params [(_)+ "end"] @body)\n          ] @function']
                                ]
                            },
                            u = '(variable_declarator value: (call_expression function: ((identifier) @req (#eq? @req "require"))))',
                            d = `\n    (lexical_declaration ${u}+)\n    (variable_declaration ${u}+)\n`,
                            p = {
                                python: [
                                    ["(module (future_import_statement) @import)"],
                                    ["(module (import_statement) @import)"],
                                    ["(module (import_from_statement) @import)"]
                                ],
                                javascript: [
                                    [`(program [ ${d} ] @import)`],
                                    ["(program [ (import_statement) ] @import)"]
                                ],
                                typescript: [
                                    [`(program [ ${d} ] @import)`],
                                    ["(program [ (import_statement) (import_alias) ] @import)"]
                                ],
                                go: [],
                                ruby: []
                            },
                            h = {
                                python: [],
                                javascript: [
                                    ["(program (export_statement) @export)"]
                                ],
                                typescript: [
                                    ["(program (export_statement) @export)"]
                                ],
                                go: [],
                                ruby: []
                            },
                            f = {
                                python: [
                                    ["(module (global_statement) @globalVar)"],
                                    ["(module (expression_statement) @globalVar)"]
                                ],
                                javascript: [],
                                typescript: [],
                                go: [],
                                ruby: []
                            },
                            m = {
                                python: new Set(["function_definition"]),
                                javascript: new Set(["function", "function_declaration", "generator_function", "generator_function_declaration", "method_definition", "arrow_function"]),
                                typescript: new Set(["function", "function_declaration", "generator_function", "generator_function_declaration", "method_definition", "arrow_function"]),
                                go: new Set(["function_declaration", "method_declaration"]),
                                ruby: new Set(["method", "singleton_method"])
                            },
                            g = {
                                python: e => {
                                    var t;
                                    return "module" === e.type || "block" === e.type && "class_definition" === (null === (t = e.parent) || void 0 === t ? void 0 : t.type)
                                },
                                javascript: e => "program" === e.type || "class_body" === e.type,
                                typescript: e => "program" === e.type || "class_body" === e.type,
                                go: e => "source_file" === e.type,
                                ruby: e => "program" === e.type || "class" === e.type
                            },
                            _ = new Map;
                        async function y(e) {
                            const t = c(e);
                            if (!_.has(t)) {
                                const e = await async function(e) {
                                    await o.init();
                                    const t = n.resolve(__dirname, "..", "dist", `tree-sitter-${e}.wasm`);
                                    return i.Language.load(t)
                                }(t);
                                _.set(t, e)
                            }
                            return _.get(t)
                        }
                        async function v(e, t) {
                            let r = await y(e);
                            const n = new o;
                            n.setLanguage(r);
                            const i = n.parse(t);
                            return n.delete(), i
                        }

                        function b(e, t) {
                            const r = [];
                            for (const n of e) {
                                if (!n[1]) {
                                    const e = t.tree.getLanguage();
                                    n[1] = e.query(n[0])
                                }
                                r.push(...n[1].matches(t))
                            }
                            return r
                        }

                        function w(e, t) {
                            return b(l[c(e)], t)
                        }
                        t.getLanguage = y, t.parseTree = v, t.parsesWithoutError = async function(e, t) {
                            const r = await v(e, t),
                                n = !r.rootNode.hasError();
                            return r.delete(), n
                        }, t.getBlockCloseToken = function(e) {
                            switch (c(e)) {
                                case s.Python:
                                    return null;
                                case s.JavaScript:
                                case s.TypeScript:
                                case s.Go:
                                    return "}";
                                case s.Ruby:
                                    return "end"
                            }
                        }, t.queryFunctions = w, t.queryImports = function(e, t) {
                            return b(p[c(e)], t)
                        }, t.queryExports = function(e, t) {
                            return b(h[c(e)], t)
                        }, t.queryGlobalVars = function(e, t) {
                            return b(f[c(e)], t)
                        };
                        const x = ["[\n    (class_definition (block (expression_statement (string))))\n    (function_definition (block (expression_statement (string))))\n]"];

                        function E(e, t) {
                            return m[c(e)].has(t.type)
                        }
                        t.queryPythonIsDocstring = function(e) {
                            return 1 == b([x], e).length
                        }, t.getAncestorWithSiblingFunctions = function(e, t) {
                            const r = g[c(e)];
                            for (; t.parent;) {
                                if (r(t.parent)) return t;
                                t = t.parent
                            }
                            return t.parent ? t : null
                        }, t.isFunction = E, t.isFunctionDefinition = function(e, t) {
                            switch (c(e)) {
                                case s.Python:
                                case s.Go:
                                case s.Ruby:
                                    return E(e, t);
                                case s.JavaScript:
                                case s.TypeScript:
                                    if ("function_declaration" === t.type || "generator_function_declaration" === t.type || "method_definition" === t.type) return !0;
                                    if ("lexical_declaration" === t.type || "variable_declaration" === t.type) {
                                        if (t.namedChildCount > 1) return !1;
                                        let r = t.namedChild(0);
                                        if (null == r) return !1;
                                        let n = r.namedChild(1);
                                        return null !== n && E(e, n)
                                    }
                                    if ("expression_statement" === t.type) {
                                        let r = t.namedChild(0);
                                        if ("assignment_expression" === (null == r ? void 0 : r.type)) {
                                            let t = r.namedChild(1);
                                            return null !== t && E(e, t)
                                        }
                                    }
                                    return !1
                            }
                        }, t.getFirstPrecedingComment = function(e) {
                            var t;
                            let r = e;
                            for (;
                                "comment" === (null === (t = r.previousSibling) || void 0 === t ? void 0 : t.type);) {
                                let e = r.previousSibling;
                                if (e.endPosition.row < r.startPosition.row - 1) break;
                                r = e
                            }
                            return "comment" === (null == r ? void 0 : r.type) ? r : null
                        }, t.getFunctionPositions = async function(e, t) {
                            return w(e, (await v(e, t)).rootNode).map((e => {
                                const t = e.captures.find((e => "function" === e.name)).node;
                                return {
                                    startIndex: t.startIndex,
                                    endIndex: t.endIndex
                                }
                            }))
                        }
                    },
                    610: (e, t, r) => {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }), t.getNodeStart = t.isBlockBodyFinished = t.isEmptyBlockStart = t.getBlockParser = void 0;
                        const n = r(306);
                        class o {
                            constructor(e, t, r) {
                                this.languageId = e, this.nodeMatch = t, this.nodeTypesWithBlockOrStmtChild = r
                            }
                            async getNodeMatchAtPosition(e, t, r) {
                                const o = await n.parseTree(this.languageId, e);
                                try {
                                    let e = o.rootNode.descendantForIndex(t);
                                    for (; e;) {
                                        const t = this.nodeMatch[e.type];
                                        if (t) {
                                            if (!this.nodeTypesWithBlockOrStmtChild.has(e.type)) break;
                                            const r = this.nodeTypesWithBlockOrStmtChild.get(e.type),
                                                n = "" == r ? e.namedChildren[0] : e.childForFieldName(r);
                                            if ((null == n ? void 0 : n.type) == t) break
                                        }
                                        e = e.parent
                                    }
                                    if (!e) return;
                                    return r(e)
                                } finally {
                                    o.delete()
                                }
                            }
                            getNextBlockAtPosition(e, t, r) {
                                return this.getNodeMatchAtPosition(e, t, (e => {
                                    let t = e.children.reverse().find((t => t.type == this.nodeMatch[e.type]));
                                    if (t) {
                                        if ("python" == this.languageId && t.parent) {
                                            const e = ":" == t.parent.type ? t.parent.parent : t.parent;
                                            let r = null == e ? void 0 : e.nextSibling;
                                            for (; r && "comment" == r.type;) {
                                                const n = r.startPosition.row == t.endPosition.row && r.startPosition.column >= t.endPosition.column,
                                                    o = r.startPosition.row > e.endPosition.row && r.startPosition.column > e.startPosition.column;
                                                if (!n && !o) break;
                                                t = r, r = r.nextSibling
                                            }
                                        }
                                        if (!(t.endIndex >= t.tree.rootNode.endIndex - 1 && (t.hasError() || t.parent.hasError()))) return r(t)
                                    }
                                }))
                            }
                            async isBlockBodyFinished(e, t, r) {
                                const n = (e + t).trimEnd(),
                                    o = await this.getNextBlockAtPosition(n, r, (e => e.endIndex));
                                if (void 0 !== o && o < n.length) {
                                    const t = o - e.length;
                                    return t > 0 ? t : void 0
                                }
                            }
                            getNodeStart(e, t) {
                                const r = e.trimEnd();
                                return this.getNodeMatchAtPosition(r, t, (e => e.startIndex))
                            }
                        }
                        class i extends o {
                            constructor(e, t, r, n, o) {
                                super(e, n, o), this.blockEmptyMatch = t, this.lineMatch = r
                            }
                            isBlockStart(e) {
                                return this.lineMatch.test(e.trimStart())
                            }
                            async isBlockBodyEmpty(e, t) {
                                const r = await this.getNextBlockAtPosition(e, t, (r => {
                                    r.startIndex < t && (t = r.startIndex);
                                    let n = e.substring(t, r.endIndex).trim();
                                    return "" == n || n.replace(/\s/g, "") == this.blockEmptyMatch
                                }));
                                return void 0 === r || r
                            }
                            async isEmptyBlockStart(e, t) {
                                return t = s(e, t), this.isBlockStart(function(e, t) {
                                    const r = e.lastIndexOf("\n", t - 1);
                                    let n = e.indexOf("\n", t);
                                    return n < 0 && (n = e.length), e.slice(r + 1, n)
                                }(e, t)) && this.isBlockBodyEmpty(e, t)
                            }
                        }

                        function s(e, t) {
                            let r = t;
                            for (; r > 0 && /\s/.test(e.charAt(r - 1));) r--;
                            return r
                        }

                        function a(e, t) {
                            const r = e.startIndex,
                                n = e.startIndex - e.startPosition.column,
                                o = t.substring(n, r);
                            if (/^\s*$/.test(o)) return o
                        }

                        function c(e, t, r) {
                            if (t.startPosition.row <= e.startPosition.row) return !1;
                            const n = a(e, r),
                                o = a(t, r);
                            return void 0 !== n && void 0 !== o && n.startsWith(o)
                        }
                        class l extends o {
                            constructor(e, t, r, n, o, i, s) {
                                super(e, t, r), this.startKeywords = n, this.blockNodeType = o, this.emptyStatementType = i, this.curlyBraceLanguage = s
                            }
                            isBlockEmpty(e, t) {
                                var r, o;
                                let i = e.text.trim();
                                return this.curlyBraceLanguage && (i.startsWith("{") && (i = i.slice(1)), i.endsWith("}") && (i = i.slice(0, -1)), i = i.trim()), 0 == i.length || !("python" != this.languageId || "class_definition" != (null === (r = e.parent) || void 0 === r ? void 0 : r.type) && "function_definition" != (null === (o = e.parent) || void 0 === o ? void 0 : o.type) || 1 != e.children.length || !n.queryPythonIsDocstring(e.parent))
                            }
                            async isEmptyBlockStart(e, t) {
                                var r, o, i;
                                if (t > e.length) throw new RangeError("Invalid offset");
                                for (let r = t; r < e.length && "\n" != e.charAt(r); r++)
                                    if (/\S/.test(e.charAt(r))) return !1;
                                t = s(e, t);
                                const a = await n.parseTree(this.languageId, e);
                                try {
                                    const n = a.rootNode.descendantForIndex(t - 1);
                                    if (null == n) return !1;
                                    if (this.curlyBraceLanguage && "}" == n.type) return !1;
                                    if (("javascript" == this.languageId || "typescript" == this.languageId) && n.parent && "object" == n.parent.type && "{" == n.parent.text.trim()) return !0;
                                    if ("typescript" == this.languageId) {
                                        let r = n;
                                        for (; r.parent;) {
                                            if ("function_signature" == r.type || "method_signature" == r.type) {
                                                const o = n.nextSibling;
                                                return !!(o && r.hasError() && c(r, o, e)) || !r.children.find((e => ";" == e.type)) && r.endIndex <= t
                                            }
                                            r = r.parent
                                        }
                                    }
                                    let s = null,
                                        l = null,
                                        u = null,
                                        d = n;
                                    for (; null != d;) {
                                        if (d.type == this.blockNodeType) {
                                            l = d;
                                            break
                                        }
                                        if (this.nodeMatch[d.type]) {
                                            u = d;
                                            break
                                        }
                                        if ("ERROR" == d.type) {
                                            s = d;
                                            break
                                        }
                                        d = d.parent
                                    }
                                    if (null != l) {
                                        if (!l.parent || !this.nodeMatch[l.parent.type]) return !1;
                                        if ("python" == this.languageId) {
                                            const e = l.previousSibling;
                                            if (null != e && e.hasError() && (e.text.startsWith('"""') || e.text.startsWith("'''"))) return !0
                                        }
                                        return this.isBlockEmpty(l, t)
                                    }
                                    if (null != s) {
                                        if ("module" == (null === (r = s.previousSibling) || void 0 === r ? void 0 : r.type) || "internal_module" == (null === (o = s.previousSibling) || void 0 === o ? void 0 : o.type)) return !0;
                                        const e = [...s.children].reverse(),
                                            a = e.find((e => this.startKeywords.includes(e.type)));
                                        let c = e.find((e => e.type == this.blockNodeType));
                                        if (a) {
                                            switch (this.languageId) {
                                                case "python":
                                                    {
                                                        "try" == a.type && "identifier" == n.type && n.text.length > 4 && (c = null === (i = e.find((e => e.hasError()))) || void 0 === i ? void 0 : i.children.find((e => "block" == e.type)));
                                                        const t = e.find((e => ":" == e.type));
                                                        if (t && a.endIndex <= t.startIndex && t.nextSibling) {
                                                            if ("def" == a.type) {
                                                                const e = t.nextSibling;
                                                                if ('"' == e.type || "'" == e.type) return !0;
                                                                if ("ERROR" == e.type && ('"""' == e.text || "'''" == e.text)) return !0
                                                            }
                                                            return !1
                                                        }
                                                        break
                                                    }
                                                case "javascript":
                                                    {
                                                        const t = e.find((e => "formal_parameters" == e.type));
                                                        if ("class" == a.type && t) return !0;
                                                        const r = e.find((e => "{" == e.type));
                                                        if (r && r.startIndex > a.endIndex && null != r.nextSibling) return !1;
                                                        if (e.find((e => "do" == e.type)) && "while" == a.type) return !1;
                                                        if ("=>" == a.type && a.nextSibling && "{" != a.nextSibling.type) return !1;
                                                        break
                                                    }
                                                case "typescript":
                                                    {
                                                        const t = e.find((e => "{" == e.type));
                                                        if (t && t.startIndex > a.endIndex && null != t.nextSibling) return !1;
                                                        if (e.find((e => "do" == e.type)) && "while" == a.type) return !1;
                                                        if ("=>" == a.type && a.nextSibling && "{" != a.nextSibling.type) return !1;
                                                        break
                                                    }
                                            }
                                            return !(c && c.startIndex > a.endIndex) || this.isBlockEmpty(c, t)
                                        }
                                    }
                                    if (null != u) {
                                        const e = this.nodeMatch[u.type],
                                            r = u.children.slice().reverse().find((t => t.type == e));
                                        if (r) return this.isBlockEmpty(r, t);
                                        if (this.nodeTypesWithBlockOrStmtChild.has(u.type)) {
                                            const e = this.nodeTypesWithBlockOrStmtChild.get(u.type),
                                                t = "" == e ? u.children[0] : u.childForFieldName(e);
                                            if (t && t.type != this.blockNodeType && t.type != this.emptyStatementType) return !1
                                        }
                                        return !0
                                    }
                                    return !1
                                } finally {
                                    a.delete()
                                }
                            }
                        }
                        const u = {
                            python: new l("python", {
                                class_definition: "block",
                                elif_clause: "block",
                                else_clause: "block",
                                except_clause: "block",
                                finally_clause: "block",
                                for_statement: "block",
                                function_definition: "block",
                                if_statement: "block",
                                try_statement: "block",
                                while_statement: "block",
                                with_statement: "block"
                            }, new Map, ["def", "class", "if", "elif", "else", "for", "while", "try", "except", "finally", "with"], "block", null, !1),
                            javascript: new l("javascript", {
                                arrow_function: "statement_block",
                                catch_clause: "statement_block",
                                do_statement: "statement_block",
                                else_clause: "statement_block",
                                finally_clause: "statement_block",
                                for_in_statement: "statement_block",
                                for_statement: "statement_block",
                                function: "statement_block",
                                function_declaration: "statement_block",
                                generator_function: "statement_block",
                                generator_function_declaration: "statement_block",
                                if_statement: "statement_block",
                                method_definition: "statement_block",
                                try_statement: "statement_block",
                                while_statement: "statement_block",
                                with_statement: "statement_block",
                                class: "class_body",
                                class_declaration: "class_body"
                            }, new Map([
                                ["arrow_function", "body"],
                                ["do_statement", "body"],
                                ["else_clause", ""],
                                ["for_in_statement", "body"],
                                ["for_statement", "body"],
                                ["if_statement", "consequence"],
                                ["while_statement", "body"],
                                ["with_statement", "body"]
                            ]), ["=>", "try", "catch", "finally", "do", "for", "if", "else", "while", "with", "function", "function*", "class"], "statement_block", "empty_statement", !0),
                            typescript: new l("typescript", {
                                ambient_declaration: "statement_block",
                                arrow_function: "statement_block",
                                catch_clause: "statement_block",
                                do_statement: "statement_block",
                                else_clause: "statement_block",
                                finally_clause: "statement_block",
                                for_in_statement: "statement_block",
                                for_statement: "statement_block",
                                function: "statement_block",
                                function_declaration: "statement_block",
                                generator_function: "statement_block",
                                generator_function_declaration: "statement_block",
                                if_statement: "statement_block",
                                internal_module: "statement_block",
                                method_definition: "statement_block",
                                module: "statement_block",
                                try_statement: "statement_block",
                                while_statement: "statement_block",
                                abstract_class_declaration: "class_body",
                                class: "class_body",
                                class_declaration: "class_body"
                            }, new Map([
                                ["arrow_function", "body"],
                                ["do_statement", "body"],
                                ["else_clause", ""],
                                ["for_in_statement", "body"],
                                ["for_statement", "body"],
                                ["if_statement", "consequence"],
                                ["while_statement", "body"],
                                ["with_statement", "body"]
                            ]), ["declare", "=>", "try", "catch", "finally", "do", "for", "if", "else", "while", "with", "function", "function*", "class"], "statement_block", "empty_statement", !0),
                            go: new i("go", "{}", /\b(func|if|else|for)\b/, {
                                communication_case: "block",
                                default_case: "block",
                                expression_case: "block",
                                for_statement: "block",
                                func_literal: "block",
                                function_declaration: "block",
                                if_statement: "block",
                                labeled_statement: "block",
                                method_declaration: "block",
                                type_case: "block"
                            }, new Map),
                            ruby: new i("ruby", "end", /\b(BEGIN|END|case|class|def|do|else|elsif|for|if|module|unless|until|while)\b|->/, {
                                begin_block: "}",
                                block: "}",
                                end_block: "}",
                                lambda: "block",
                                for: "do",
                                until: "do",
                                while: "do",
                                case: "end",
                                do: "end",
                                if: "end",
                                method: "end",
                                module: "end",
                                unless: "end",
                                do_block: "end"
                            }, new Map)
                        };

                        function d(e) {
                            return u[n.languageIdToWasmLanguage(e)]
                        }
                        t.getBlockParser = d, t.isEmptyBlockStart = async function(e, t, r) {
                            return !!n.isSupportedLanguageId(e) && d(e).isEmptyBlockStart(t, r)
                        }, t.isBlockBodyFinished = async function(e, t, r, o) {
                            if (n.isSupportedLanguageId(e)) return d(e).isBlockBodyFinished(t, r, o)
                        }, t.getNodeStart = async function(e, t, r) {
                            if (n.isSupportedLanguageId(e)) return d(e).getNodeStart(t, r)
                        }
                    },
                    312: (e, t, r) => {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }), t.getPrompt = t.newLineEnded = t.normalizeLanguageId = t.PromptOptions = t.SuffixStartMode = t.SuffixOption = t.LineEndingOptions = t.LocalImportContextOption = t.NeighboringTabsOption = t.SiblingOption = t.PathMarkerOption = t.LanguageMarkerOption = t.TOKENS_RESERVED_FOR_SUFFIX_ENCODING = t.MAX_PROMPT_LENGTH = void 0;
                        const n = r(94),
                            o = r(417),
                            i = r(179),
                            s = r(647),
                            a = r(670),
                            c = r(94),
                            l = r(456);
                        var u, d, p, h, f, m, g, _;
                        t.MAX_PROMPT_LENGTH = 1500, t.TOKENS_RESERVED_FOR_SUFFIX_ENCODING = 5,
                            function(e) {
                                e.NoMarker = "nomarker", e.Top = "top", e.Always = "always"
                            }(u = t.LanguageMarkerOption || (t.LanguageMarkerOption = {})),
                            function(e) {
                                e.NoMarker = "nomarker", e.Top = "top", e.Always = "always"
                            }(d = t.PathMarkerOption || (t.PathMarkerOption = {})),
                            function(e) {
                                e.NoSiblings = "nosiblings", e.SiblingsOverContext = "siblingabove", e.ContextOverSiblings = "contextabove"
                            }(p = t.SiblingOption || (t.SiblingOption = {})),
                            function(e) {
                                e.None = "none", e.Conservative = "conservative", e.Medium = "medium", e.Eager = "eager", e.EagerButLittle = "eagerButLittle"
                            }(h = t.NeighboringTabsOption || (t.NeighboringTabsOption = {})),
                            function(e) {
                                e.NoContext = "nocontext", e.Declarations = "declarations"
                            }(f = t.LocalImportContextOption || (t.LocalImportContextOption = {})),
                            function(e) {
                                e.ConvertToUnix = "unix", e.KeepOriginal = "keep"
                            }(m = t.LineEndingOptions || (t.LineEndingOptions = {})), (_ = t.SuffixOption || (t.SuffixOption = {})).None = "none", _.FifteenPercent = "fifteenPercent",
                            function(e) {
                                e.Cursor = "cursor", e.CursorTrimStart = "cursortrimstart", e.CursorTrimStartWithStop = "cursortrimstartwithstop", e.SiblingBlock = "siblingblock", e.SiblingBlockTrimStart = "siblingblocktrimstart", e.SiblingBlockWithStop = "siblingblockwithstop", e.SiblingBlockTrimStartWithStop = "siblingblocktrimstartwithstop"
                            }(g = t.SuffixStartMode || (t.SuffixStartMode = {}));
                        class y {
                            constructor(e, r) {
                                if (this.fs = e, this.maxPromptLength = t.MAX_PROMPT_LENGTH, this.languageMarker = u.Top, this.pathMarker = d.Top, this.includeSiblingFunctions = p.ContextOverSiblings, this.localImportContext = f.Declarations, this.neighboringTabs = h.Eager, this.lineEnding = m.ConvertToUnix, this.suffixPercent = 0, this.suffixStartMode = g.Cursor, r)
                                    for (const e in r) this[e] = r[e];
                                if (this.suffixPercent < 0 || this.suffixPercent > 100) throw new Error(`suffixPercent must be between 0 and 100, but was ${this.suffixPercent}`);
                                if (this.suffixPercent > 0 && this.includeSiblingFunctions != p.NoSiblings) throw new Error(`Invalid option combination. Cannot set suffixPercent > 0 (${this.suffixPercent}) and includeSiblingFunctions ${this.includeSiblingFunctions}`)
                            }
                        }
                        t.PromptOptions = y;
                        const v = {
                            javascriptreact: "javascript",
                            jsx: "javascript",
                            typescriptreact: "typescript",
                            jade: "pug",
                            cshtml: "razor"
                        };

                        function b(e) {
                            var t;
                            return e = e.toLowerCase(), null !== (t = v[e]) && void 0 !== t ? t : e
                        }

                        function w(e) {
                            return "" == e || e.endsWith("\n") ? e : e + "\n"
                        }
                        t.normalizeLanguageId = b, t.newLineEnded = w, t.getPrompt = async function(e, r, m = {}, _ = []) {
                            const v = new y(e, m),
                                {
                                    source: x,
                                    offset: E
                                } = r;
                            if (E < 0 || E > x.length) throw new Error(`Offset ${E} is out of range.`);
                            r.languageId = b(r.languageId);
                            const C = new l.Priorities,
                                S = C.justBelow(l.Priorities.TOP),
                                T = v.pathMarker == d.Always ? C.justBelow(l.Priorities.TOP) : C.justBelow(S),
                                k = v.languageMarker == u.Always ? C.justBelow(l.Priorities.TOP) : C.justBelow(S),
                                I = v.includeSiblingFunctions == p.ContextOverSiblings ? C.justBelow(S) : C.justAbove(S),
                                P = C.justBelow(S, I),
                                A = C.justBelow(P),
                                O = new l.PromptWishlist(v.lineEnding);
                            let N, R;
                            if (v.languageMarker != u.NoMarker) {
                                const e = w(o.getLanguageMarker(r));
                                N = O.append(e, l.PromptElementKind.LanguageMarker, k)
                            }
                            if (v.pathMarker != d.NoMarker) {
                                const e = w(o.getPathMarker(r));
                                R = O.append(e, l.PromptElementKind.PathMarker, T)
                            }
                            if (v.localImportContext != f.NoContext)
                                for (const e of await i.extractLocalImportContext(r, v.fs)) O.append(w(e), l.PromptElementKind.ImportedFile, P);
                            v.neighboringTabs != h.None && _.length > 0 && (await s.getNeighborSnippets(r, _, v.neighboringTabs)).forEach((e => O.append(e.snippet, l.PromptElementKind.SimilarFile, A, c.tokenLength(e.snippet), e.score)));
                            let $ = [];
                            if (v.includeSiblingFunctions == p.NoSiblings) $ = O.appendLineForLine(x.substring(0, E), l.PromptElementKind.BeforeCursor, S);
                            else {
                                const {
                                    siblings: e,
                                    beforeInsertion: t,
                                    afterInsertion: n
                                } = await a.getSiblingFunctions(r);
                                O.appendLineForLine(t, l.PromptElementKind.BeforeCursor, S);
                                let o = I;
                                e.forEach((e => {
                                    O.append(e, l.PromptElementKind.AfterCursor, o), o = C.justBelow(o)
                                })), $ = O.appendLineForLine(n, l.PromptElementKind.BeforeCursor, S)
                            }
                            if (u.Top == v.languageMarker && $.length > 0 && void 0 !== N && O.require(N, $[0]), d.Top == v.pathMarker && $.length > 0 && void 0 !== R && (N ? O.require(R, N) : O.require(R, $[0])), 0 == v.suffixPercent) return O.fulfill(v.maxPromptLength); {
                                let e = r.offset;
                                v.suffixStartMode !== g.Cursor && v.suffixStartMode !== g.CursorTrimStart && v.suffixStartMode !== g.CursorTrimStartWithStop && (e = await a.getSiblingFunctionStart(r));
                                const o = v.maxPromptLength - t.TOKENS_RESERVED_FOR_SUFFIX_ENCODING;
                                let i = Math.floor(o * (100 - v.suffixPercent) / 100),
                                    s = O.fulfill(i);
                                const l = o - s.prefixLength;
                                let u = x.slice(e);
                                v.suffixStartMode != g.SiblingBlockTrimStart && v.suffixStartMode != g.SiblingBlockTrimStartWithStop && v.suffixStartMode != g.CursorTrimStart && v.suffixStartMode != g.CursorTrimStartWithStop || (u = u.trimStart());
                                const d = n.takeFirstTokens(u, l),
                                    p = c.tokenLength(d);
                                return p <= l - 3 && (i = o - p, s = O.fulfill(i)), s.suffix = d, s.suffixLength = p, s
                            }
                        }
                    },
                    302: (e, t) => {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }), t.splitIntoWords = t.findBestJaccardMatch = void 0;
                        const r = new class {
                            constructor(e) {
                                this.keys = [], this.cache = {}, this.size = e
                            }
                            put(e, t) {
                                var r;
                                if (this.cache[e] = t, this.keys.length > this.size) {
                                    this.keys.push(e);
                                    const t = null !== (r = this.keys.shift()) && void 0 !== r ? r : "";
                                    delete this.cache[t]
                                }
                            }
                            get(e) {
                                return this.cache[e]
                            }
                        }(20);

                        function n(e, t) {
                            const r = new Set;
                            return e.forEach((e => {
                                t.has(e) && r.add(e)
                            })), r.size / (e.size + t.size - r.size)
                        }

                        function o(e) {
                            return e.split(/[^a-zA-Z0-9]/).filter((e => e.length > 0))
                        }
                        t.findBestJaccardMatch = function(e, t, i) {
                            var c, l;
                            if (0 === e.source.length || 0 === t.source.length) return;
                            const u = null !== (c = a.get(t.languageId)) && void 0 !== c ? c : s,
                                d = new Set(o(t.source).filter((e => !u.has(e)))),
                                p = e.source.split("\n"),
                                h = i.toString() + ":" + e.source,
                                f = null !== (l = r.get(h)) && void 0 !== l ? l : [],
                                m = 0 == f.length,
                                g = m ? p.map((e => new Set(o(e).filter((e => !u.has(e)))))) : [];
                            let _ = -1,
                                y = 0;
                            for (let e = 0; 0 == e || e < p.length - i; e++) {
                                const t = Math.min(e + i, p.length);
                                if (m) {
                                    const r = new Set;
                                    g.slice(e, t).forEach((e => e.forEach(r.add, r))), f.push(r)
                                }
                                const r = n(f[e], d);
                                r > y && (y = r, _ = e)
                            }
                            if (m && r.put(h, f), -1 !== _) {
                                const e = _,
                                    t = Math.min(e + i, p.length);
                                return {
                                    snippet: p.slice(e, t).join("\n"),
                                    score: y
                                }
                            }
                        }, t.splitIntoWords = o;
                        const i = new Set(["we", "our", "you", "it", "its", "they", "them", "their", "this", "that", "these", "those", "is", "are", "was", "were", "be", "been", "being", "have", "has", "had", "having", "do", "does", "did", "doing", "can", "don", "t", "s", "will", "would", "should", "what", "which", "who", "when", "where", "why", "how", "a", "an", "the", "and", "or", "not", "no", "but", "because", "as", "until", "again", "further", "then", "once", "here", "there", "all", "any", "both", "each", "few", "more", "most", "other", "some", "such", "above", "below", "to", "during", "before", "after", "of", "at", "by", "about", "between", "into", "through", "from", "up", "down", "in", "out", "on", "off", "over", "under", "only", "own", "same", "so", "than", "too", "very", "just", "now"]),
                            s = new Set(["if", "then", "else", "for", "while", "with", "def", "function", "return", "TODO", "import", "try", "catch", "raise", "finally", "repeat", "switch", "case", "match", "assert", "continue", "break", "const", "class", "enum", "struct", "static", "new", "super", "this", "var", ...i]),
                            a = new Map([])
                    },
                    670: (e, t, r) => {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }), t.getSiblingFunctionStart = t.getSiblingFunctions = void 0;
                        const n = r(312),
                            o = r(306);
                        t.getSiblingFunctions = async function({
                            source: e,
                            offset: t,
                            languageId: r
                        }) {
                            var i, s;
                            const a = [];
                            let c = "",
                                l = e.substring(0, t);
                            if (o.isSupportedLanguageId(r)) {
                                const u = await o.parseTree(r, e);
                                try {
                                    let d = t;
                                    for (; d >= 0 && /\s/.test(e[d]);) d--;
                                    const p = u.rootNode.descendantForIndex(d),
                                        h = o.getAncestorWithSiblingFunctions(r, p);
                                    if (h) {
                                        const u = o.getFirstPrecedingComment(h),
                                            d = null !== (i = null == u ? void 0 : u.startIndex) && void 0 !== i ? i : h.startIndex;
                                        let p, f = 0;
                                        for (;
                                            " " == (p = e[d - f - 1]) || "\t" == p;) f++;
                                        const m = e.substring(d - f, d);
                                        for (let i = h.nextSibling; i; i = i.nextSibling)
                                            if (o.isFunctionDefinition(r, i)) {
                                                const r = o.getFirstPrecedingComment(i),
                                                    c = null !== (s = null == r ? void 0 : r.startIndex) && void 0 !== s ? s : i.startIndex;
                                                if (c < t) continue;
                                                const l = e.substring(c, i.endIndex),
                                                    u = n.newLineEnded(l) + "\n" + m;
                                                a.push(u)
                                            }
                                        c = e.substring(0, d), l = e.substring(d, t)
                                    }
                                } finally {
                                    u.delete()
                                }
                            }
                            return {
                                siblings: a,
                                beforeInsertion: c,
                                afterInsertion: l
                            }
                        }, t.getSiblingFunctionStart = async function({
                            source: e,
                            offset: t,
                            languageId: r
                        }) {
                            var n;
                            if (o.isSupportedLanguageId(r)) {
                                const i = await o.parseTree(r, e);
                                try {
                                    let s = t;
                                    for (; s >= 0 && /\s/.test(e[s]);) s--;
                                    const a = i.rootNode.descendantForIndex(s),
                                        c = o.getAncestorWithSiblingFunctions(r, a);
                                    if (c) {
                                        for (let e = c.nextSibling; e; e = e.nextSibling)
                                            if (o.isFunctionDefinition(r, e)) {
                                                const r = o.getFirstPrecedingComment(e),
                                                    i = null !== (n = null == r ? void 0 : r.startIndex) && void 0 !== n ? n : e.startIndex;
                                                if (i < t) continue;
                                                return i
                                            }
                                        if (c.endIndex >= t) return c.endIndex
                                    }
                                } finally {
                                    i.delete()
                                }
                            }
                            return t
                        }
                    },
                    456: (e, t, r) => {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }), t.Priorities = t.PromptWishlist = t.PromptChoices = t.PromptBackground = t.PromptElementKind = void 0;
                        const n = r(312),
                            o = r(94);
                        var i;
                        ! function(e) {
                            e.BeforeCursor = "BeforeCursor", e.AfterCursor = "AfterCursor", e.SimilarFile = "SimilarFile", e.ImportedFile = "ImportedFile", e.LanguageMarker = "LanguageMarker", e.PathMarker = "PathMarker"
                        }(i = t.PromptElementKind || (t.PromptElementKind = {}));
                        class s {
                            constructor() {
                                this.used = new Map, this.unused = new Map
                            }
                            markUsed(e) {
                                this.IsNeighboringTab(e) && this.used.set(e.id, this.convert(e))
                            }
                            undoMarkUsed(e) {
                                this.IsNeighboringTab(e) && this.used.delete(e.id)
                            }
                            markUnused(e) {
                                this.IsNeighboringTab(e) && this.unused.set(e.id, this.convert(e))
                            }
                            convert(e) {
                                return {
                                    score: e.score.toFixed(4),
                                    length: e.text.length
                                }
                            }
                            IsNeighboringTab(e) {
                                return e.kind == i.SimilarFile
                            }
                        }
                        t.PromptBackground = s;
                        class a {
                            constructor() {
                                this.used = new Map, this.unused = new Map
                            }
                            markUsed(e) {
                                this.used.set(e.kind, (this.used.get(e.kind) || 0) + e.tokens)
                            }
                            undoMarkUsed(e) {
                                this.used.set(e.kind, (this.used.get(e.kind) || 0) - e.tokens)
                            }
                            markUnused(e) {
                                this.unused.set(e.kind, (this.used.get(e.kind) || 0) + e.tokens)
                            }
                        }
                        t.PromptChoices = a, t.PromptWishlist = class {
                            constructor(e) {
                                this.content = [], this.lineEndingOption = e
                            }
                            getContent() {
                                return [...this.content]
                            }
                            convertLineEndings(e) {
                                return this.lineEndingOption === n.LineEndingOptions.ConvertToUnix && (e = e.replace(/\r\n/g, "\n").replace(/\r/g, "\n")), e
                            }
                            append(e, t, r, n = o.tokenLength(e), i = NaN) {
                                e = this.convertLineEndings(e);
                                const s = this.content.length;
                                return this.content.push({
                                    id: s,
                                    text: e,
                                    kind: t,
                                    priority: r,
                                    tokens: n,
                                    requires: [],
                                    excludes: [],
                                    score: i
                                }), s
                            }
                            appendLineForLine(e, t, r) {
                                const n = (e = this.convertLineEndings(e)).split("\n");
                                for (let e = 0; e < n.length - 1; e++) n[e] += "\n";
                                const o = [];
                                n.forEach(((e, t) => {
                                    "\n" === e && o.length > 0 && !o[o.length - 1].endsWith("\n\n") ? o[o.length - 1] += "\n" : o.push(e)
                                }));
                                const i = [];
                                return o.forEach(((e, n) => {
                                    "" !== e && (i.push(this.append(e, t, r)), n > 0 && (this.content[this.content.length - 2].requires = [this.content[this.content.length - 1]]))
                                })), i
                            }
                            require(e, t) {
                                const r = this.content.find((t => t.id === e)),
                                    n = this.content.find((e => e.id === t));
                                r && n && r.requires.push(n)
                            }
                            exclude(e, t) {
                                const r = this.content.find((t => t.id === e)),
                                    n = this.content.find((e => e.id === t));
                                r && n && r.excludes.push(n)
                            }
                            fulfill(e) {
                                const t = new a,
                                    r = new s,
                                    n = this.content.map(((e, t) => ({
                                        element: e,
                                        index: t
                                    })));
                                n.sort(((e, t) => e.element.priority === t.element.priority ? t.index - e.index : t.element.priority - e.element.priority));
                                const i = new Set,
                                    c = new Set;
                                let l;
                                const u = [];
                                let d = e;
                                n.forEach((e => {
                                    var n;
                                    const o = e.element,
                                        s = e.index;
                                    if (d >= 0 && (d > 0 || void 0 === l) && o.requires.every((e => i.has(e.id))) && !c.has(o.id)) {
                                        let a = o.tokens;
                                        const p = null === (n = function(e, t) {
                                            let r, n = 1 / 0;
                                            for (const o of e) o.index > t && o.index < n && (r = o, n = o.index);
                                            return r
                                        }(u, s)) || void 0 === n ? void 0 : n.element;
                                        o.text.endsWith("\n\n") && p && !p.text.match(/^\s/) && a++, d >= a ? (d -= a, i.add(o.id), o.excludes.forEach((e => c.add(e.id))), t.markUsed(o), r.markUsed(o), u.push(e)) : l = null != l ? l : e
                                    } else t.markUnused(o), r.markUnused(o)
                                })), u.sort(((e, t) => e.index - t.index));
                                let p = u.reduce(((e, t) => e + t.element.text), ""),
                                    h = o.tokenLength(p);
                                for (; h > e;) {
                                    u.sort(((e, t) => t.element.priority === e.element.priority ? t.index - e.index : t.element.priority - e.element.priority));
                                    const e = u.pop();
                                    e && (t.undoMarkUsed(e.element), t.markUnused(e.element), r.undoMarkUsed(e.element), r.markUnused(e.element), l = void 0), u.sort(((e, t) => e.index - t.index)), p = u.reduce(((e, t) => e + t.element.text), ""), h = o.tokenLength(p)
                                }
                                const f = [...u];
                                if (void 0 !== l) {
                                    f.push(l), f.sort(((e, t) => e.index - t.index));
                                    const n = f.reduce(((e, t) => e + t.element.text), ""),
                                        i = o.tokenLength(n);
                                    if (i <= e) return t.markUsed(l.element), r.markUsed(l.element), {
                                        prefix: n,
                                        suffix: "",
                                        prefixLength: i,
                                        suffixLength: 0,
                                        promptChoices: t,
                                        promptBackground: r
                                    };
                                    t.markUnused(l.element), r.markUnused(l.element)
                                }
                                return {
                                    prefix: p,
                                    suffix: "",
                                    prefixLength: h,
                                    suffixLength: 0,
                                    promptChoices: t,
                                    promptBackground: r
                                }
                            }
                        };
                        class c {
                            constructor() {
                                this.registeredPriorities = [0, 1]
                            }
                            register(e) {
                                if (e > c.TOP || e < c.BOTTOM) throw new Error("Priority must be between 0 and 1");
                                return this.registeredPriorities.push(e), e
                            }
                            justAbove(...e) {
                                const t = Math.max(...e),
                                    r = Math.min(...this.registeredPriorities.filter((e => e > t)));
                                return this.register((r + t) / 2)
                            }
                            justBelow(...e) {
                                const t = Math.min(...e),
                                    r = Math.max(...this.registeredPriorities.filter((e => e < t)));
                                return this.register((r + t) / 2)
                            }
                            between(e, t) {
                                if (this.registeredPriorities.some((r => r > e && r < t)) || !this.registeredPriorities.includes(e) || !this.registeredPriorities.includes(t)) throw new Error("Priorities must be adjacent in the list of priorities");
                                return this.register((e + t) / 2)
                            }
                        }
                        t.Priorities = c, c.TOP = 1, c.BOTTOM = 0
                    },
                    87: (e, t, r) => {
                        var n, o, i = void 0 !== i ? i : {};
                        void 0 === (o = "function" == typeof(n = function() {
                            var t, n = {};
                            for (t in i) i.hasOwnProperty(t) && (n[t] = i[t]);
                            var o, s, a = [],
                                c = "./this.program",
                                l = function(e, t) {
                                    throw t
                                },
                                u = !1,
                                d = !1;
                            u = "object" == typeof window, d = "function" == typeof importScripts, o = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, s = !u && !o && !d;
                            var p, h, f, m, g, _ = "";
                            o ? (_ = d ? r(622).dirname(_) + "/" : __dirname + "/", p = function(e, t) {
                                return m || (m = r(747)), g || (g = r(622)), e = g.normalize(e), m.readFileSync(e, t ? null : "utf8")
                            }, f = function(e) {
                                var t = p(e, !0);
                                return t.buffer || (t = new Uint8Array(t)), O(t.buffer), t
                            }, process.argv.length > 1 && (c = process.argv[1].replace(/\\/g, "/")), a = process.argv.slice(2), e.exports = i, l = function(e) {
                                process.exit(e)
                            }, i.inspect = function() {
                                return "[Emscripten Module object]"
                            }) : s ? ("undefined" != typeof read && (p = function(e) {
                                return read(e)
                            }), f = function(e) {
                                var t;
                                return "function" == typeof readbuffer ? new Uint8Array(readbuffer(e)) : (O("object" == typeof(t = read(e, "binary"))), t)
                            }, "undefined" != typeof scriptArgs ? a = scriptArgs : void 0 !== arguments && (a = arguments), "function" == typeof quit && (l = function(e) {
                                quit(e)
                            }), "undefined" != typeof print && ("undefined" == typeof console && (console = {}), console.log = print, console.warn = console.error = "undefined" != typeof printErr ? printErr : print)) : (u || d) && (d ? _ = self.location.href : "undefined" != typeof document && document.currentScript && (_ = document.currentScript.src), _ = 0 !== _.indexOf("blob:") ? _.substr(0, _.lastIndexOf("/") + 1) : "", p = function(e) {
                                var t = new XMLHttpRequest;
                                return t.open("GET", e, !1), t.send(null), t.responseText
                            }, d && (f = function(e) {
                                var t = new XMLHttpRequest;
                                return t.open("GET", e, !1), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response)
                            }), h = function(e, t, r) {
                                var n = new XMLHttpRequest;
                                n.open("GET", e, !0), n.responseType = "arraybuffer", n.onload = function() {
                                    200 == n.status || 0 == n.status && n.response ? t(n.response) : r()
                                }, n.onerror = r, n.send(null)
                            }), i.print || console.log.bind(console);
                            var y = i.printErr || console.warn.bind(console);
                            for (t in n) n.hasOwnProperty(t) && (i[t] = n[t]);
                            n = null, i.arguments && (a = i.arguments), i.thisProgram && (c = i.thisProgram), i.quit && (l = i.quit);
                            var v, b = 16,
                                w = [];

                            function x(e, t) {
                                if (!v) {
                                    v = new WeakMap;
                                    for (var r = 0; r < J.length; r++) {
                                        var n = J.get(r);
                                        n && v.set(n, r)
                                    }
                                }
                                if (v.has(e)) return v.get(e);
                                var o = function() {
                                    if (w.length) return w.pop();
                                    try {
                                        J.grow(1)
                                    } catch (e) {
                                        if (!(e instanceof RangeError)) throw e;
                                        throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH."
                                    }
                                    return J.length - 1
                                }();
                                try {
                                    J.set(o, e)
                                } catch (r) {
                                    if (!(r instanceof TypeError)) throw r;
                                    var i = function(e, t) {
                                        if ("function" == typeof WebAssembly.Function) {
                                            for (var r = {
                                                    i: "i32",
                                                    j: "i64",
                                                    f: "f32",
                                                    d: "f64"
                                                }, n = {
                                                    parameters: [],
                                                    results: "v" == t[0] ? [] : [r[t[0]]]
                                                }, o = 1; o < t.length; ++o) n.parameters.push(r[t[o]]);
                                            return new WebAssembly.Function(n, e)
                                        }
                                        var i = [1, 0, 1, 96],
                                            s = t.slice(0, 1),
                                            a = t.slice(1),
                                            c = {
                                                i: 127,
                                                j: 126,
                                                f: 125,
                                                d: 124
                                            };
                                        for (i.push(a.length), o = 0; o < a.length; ++o) i.push(c[a[o]]);
                                        "v" == s ? i.push(0) : i = i.concat([1, c[s]]), i[1] = i.length - 2;
                                        var l = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0].concat(i, [2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0])),
                                            u = new WebAssembly.Module(l);
                                        return new WebAssembly.Instance(u, {
                                            e: {
                                                f: e
                                            }
                                        }).exports.f
                                    }(e, t);
                                    J.set(o, i)
                                }
                                return v.set(e, o), o
                            }
                            var E, C = function(e) {},
                                S = i.dynamicLibraries || [];
                            i.wasmBinary && (E = i.wasmBinary);
                            var T, k = i.noExitRuntime || !0;

                            function I(e, t, r, n) {
                                switch ("*" === (r = r || "i8").charAt(r.length - 1) && (r = "i32"), r) {
                                    case "i1":
                                    case "i8":
                                        R[e >> 0] = t;
                                        break;
                                    case "i16":
                                        M[e >> 1] = t;
                                        break;
                                    case "i32":
                                        D[e >> 2] = t;
                                        break;
                                    case "i64":
                                        pe = [t >>> 0, (de = t, +Math.abs(de) >= 1 ? de > 0 ? (0 | Math.min(+Math.floor(de / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((de - +(~~de >>> 0)) / 4294967296) >>> 0 : 0)], D[e >> 2] = pe[0], D[e + 4 >> 2] = pe[1];
                                        break;
                                    case "float":
                                        L[e >> 2] = t;
                                        break;
                                    case "double":
                                        F[e >> 3] = t;
                                        break;
                                    default:
                                        se("invalid type for setValue: " + r)
                                }
                            }

                            function P(e, t, r) {
                                switch ("*" === (t = t || "i8").charAt(t.length - 1) && (t = "i32"), t) {
                                    case "i1":
                                    case "i8":
                                        return R[e >> 0];
                                    case "i16":
                                        return M[e >> 1];
                                    case "i32":
                                    case "i64":
                                        return D[e >> 2];
                                    case "float":
                                        return L[e >> 2];
                                    case "double":
                                        return F[e >> 3];
                                    default:
                                        se("invalid type for getValue: " + t)
                                }
                                return null
                            }
                            "object" != typeof WebAssembly && se("no native wasm support detected");
                            var A = !1;

                            function O(e, t) {
                                e || se("Assertion failed: " + t)
                            }
                            var N, R, $, M, D, L, F, j = 1,
                                B = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;

                            function q(e, t, r) {
                                for (var n = t + r, o = t; e[o] && !(o >= n);) ++o;
                                if (o - t > 16 && e.subarray && B) return B.decode(e.subarray(t, o));
                                for (var i = ""; t < o;) {
                                    var s = e[t++];
                                    if (128 & s) {
                                        var a = 63 & e[t++];
                                        if (192 != (224 & s)) {
                                            var c = 63 & e[t++];
                                            if ((s = 224 == (240 & s) ? (15 & s) << 12 | a << 6 | c : (7 & s) << 18 | a << 12 | c << 6 | 63 & e[t++]) < 65536) i += String.fromCharCode(s);
                                            else {
                                                var l = s - 65536;
                                                i += String.fromCharCode(55296 | l >> 10, 56320 | 1023 & l)
                                            }
                                        } else i += String.fromCharCode((31 & s) << 6 | a)
                                    } else i += String.fromCharCode(s)
                                }
                                return i
                            }

                            function U(e, t) {
                                return e ? q($, e, t) : ""
                            }

                            function H(e, t, r, n) {
                                if (!(n > 0)) return 0;
                                for (var o = r, i = r + n - 1, s = 0; s < e.length; ++s) {
                                    var a = e.charCodeAt(s);
                                    if (a >= 55296 && a <= 57343 && (a = 65536 + ((1023 & a) << 10) | 1023 & e.charCodeAt(++s)), a <= 127) {
                                        if (r >= i) break;
                                        t[r++] = a
                                    } else if (a <= 2047) {
                                        if (r + 1 >= i) break;
                                        t[r++] = 192 | a >> 6, t[r++] = 128 | 63 & a
                                    } else if (a <= 65535) {
                                        if (r + 2 >= i) break;
                                        t[r++] = 224 | a >> 12, t[r++] = 128 | a >> 6 & 63, t[r++] = 128 | 63 & a
                                    } else {
                                        if (r + 3 >= i) break;
                                        t[r++] = 240 | a >> 18, t[r++] = 128 | a >> 12 & 63, t[r++] = 128 | a >> 6 & 63, t[r++] = 128 | 63 & a
                                    }
                                }
                                return t[r] = 0, r - o
                            }

                            function G(e, t, r) {
                                return H(e, $, t, r)
                            }

                            function z(e) {
                                for (var t = 0, r = 0; r < e.length; ++r) {
                                    var n = e.charCodeAt(r);
                                    n >= 55296 && n <= 57343 && (n = 65536 + ((1023 & n) << 10) | 1023 & e.charCodeAt(++r)), n <= 127 ? ++t : t += n <= 2047 ? 2 : n <= 65535 ? 3 : 4
                                }
                                return t
                            }

                            function V(e) {
                                var t = z(e) + 1,
                                    r = Ve(t);
                                return H(e, R, r, t), r
                            }

                            function W(e) {
                                N = e, i.HEAP8 = R = new Int8Array(e), i.HEAP16 = M = new Int16Array(e), i.HEAP32 = D = new Int32Array(e), i.HEAPU8 = $ = new Uint8Array(e), i.HEAPU16 = new Uint16Array(e), i.HEAPU32 = new Uint32Array(e), i.HEAPF32 = L = new Float32Array(e), i.HEAPF64 = F = new Float64Array(e)
                            }
                            var K = i.INITIAL_MEMORY || 33554432;
                            (T = i.wasmMemory ? i.wasmMemory : new WebAssembly.Memory({
                                initial: K / 65536,
                                maximum: 32768
                            })) && (N = T.buffer), K = N.byteLength, W(N);
                            var J = new WebAssembly.Table({
                                    initial: 13,
                                    element: "anyfunc"
                                }),
                                X = [],
                                Q = [],
                                Y = [],
                                Z = [],
                                ee = !1,
                                te = 0,
                                re = null,
                                ne = null;

                            function oe(e) {
                                te++, i.monitorRunDependencies && i.monitorRunDependencies(te)
                            }

                            function ie(e) {
                                if (te--, i.monitorRunDependencies && i.monitorRunDependencies(te), 0 == te && (null !== re && (clearInterval(re), re = null), ne)) {
                                    var t = ne;
                                    ne = null, t()
                                }
                            }

                            function se(e) {
                                throw i.onAbort && i.onAbort(e), y(e += ""), A = !0, e = "abort(" + e + "). Build with -s ASSERTIONS=1 for more info.", new WebAssembly.RuntimeError(e)
                            }
                            i.preloadedImages = {}, i.preloadedAudios = {}, i.preloadedWasm = {};
                            var ae = "data:application/octet-stream;base64,";

                            function ce(e) {
                                return e.startsWith(ae)
                            }

                            function le(e) {
                                return e.startsWith("file://")
                            }
                            var ue, de, pe, he = "tree-sitter.wasm";

                            function fe(e) {
                                try {
                                    if (e == he && E) return new Uint8Array(E);
                                    if (f) return f(e);
                                    throw "both async and sync fetching of the wasm failed"
                                } catch (e) {
                                    se(e)
                                }
                            }
                            ce(he) || (ue = he, he = i.locateFile ? i.locateFile(ue, _) : _ + ue);
                            var me = {},
                                ge = {
                                    get: function(e, t) {
                                        return me[t] || (me[t] = new WebAssembly.Global({
                                            value: "i32",
                                            mutable: !0
                                        })), me[t]
                                    }
                                };

                            function _e(e) {
                                for (; e.length > 0;) {
                                    var t = e.shift();
                                    if ("function" != typeof t) {
                                        var r = t.func;
                                        "number" == typeof r ? void 0 === t.arg ? J.get(r)() : J.get(r)(t.arg) : r(void 0 === t.arg ? null : t.arg)
                                    } else t(i)
                                }
                            }

                            function ye(e) {
                                var t = 0;

                                function r() {
                                    for (var r = 0, n = 1;;) {
                                        var o = e[t++];
                                        if (r += (127 & o) * n, n *= 128, !(128 & o)) break
                                    }
                                    return r
                                }
                                if (e instanceof WebAssembly.Module) {
                                    var n = WebAssembly.Module.customSections(e, "dylink");
                                    O(0 != n.length, "need dylink section"), e = new Int8Array(n[0])
                                } else O(1836278016 == new Uint32Array(new Uint8Array(e.subarray(0, 24)).buffer)[0], "need to see wasm magic number"), O(0 === e[8], "need the dylink section to be first"), t = 9, r(), O(6 === e[t]), O(e[++t] === "d".charCodeAt(0)), O(e[++t] === "y".charCodeAt(0)), O(e[++t] === "l".charCodeAt(0)), O(e[++t] === "i".charCodeAt(0)), O(e[++t] === "n".charCodeAt(0)), O(e[++t] === "k".charCodeAt(0)), t++;
                                var o = {};
                                o.memorySize = r(), o.memoryAlign = r(), o.tableSize = r(), o.tableAlign = r();
                                var i = r();
                                o.neededDynlibs = [];
                                for (var s = 0; s < i; ++s) {
                                    var a = r(),
                                        c = e.subarray(t, t + a);
                                    t += a;
                                    var l = q(c, 0);
                                    o.neededDynlibs.push(l)
                                }
                                return o
                            }
                            var ve = 0;

                            function be() {
                                return k || ve > 0
                            }
                            var we = {
                                nextHandle: 1,
                                loadedLibs: {},
                                loadedLibNames: {}
                            };

                            function xe(e, t, r) {
                                return e.includes("j") ? function(e, t, r) {
                                    var n = i["dynCall_" + e];
                                    return r && r.length ? n.apply(null, [t].concat(r)) : n.call(null, t)
                                }(e, t, r) : J.get(t).apply(null, r)
                            }
                            var Ee = 5250832;

                            function Ce(e) {
                                return ["__cpp_exception", "__wasm_apply_data_relocs", "__dso_handle", "__set_stack_limits"].includes(e)
                            }

                            function Se(e, t) {
                                var r = {};
                                for (var n in e) {
                                    var o = e[n];
                                    "object" == typeof o && (o = o.value), "number" == typeof o && (o += t), r[n] = o
                                }
                                return function(e) {
                                    for (var t in e)
                                        if (!Ce(t)) {
                                            var r = !1,
                                                n = e[t];
                                            t.startsWith("orig$") && (t = t.split("$")[1], r = !0), me[t] || (me[t] = new WebAssembly.Global({
                                                value: "i32",
                                                mutable: !0
                                            })), (r || 0 == me[t].value) && ("function" == typeof n ? me[t].value = x(n) : "number" == typeof n ? me[t].value = n : y("unhandled export type for `" + t + "`: " + typeof n))
                                        }
                                }(r), r
                            }

                            function Te(e) {
                                return 0 == e.indexOf("dynCall_") || ["stackAlloc", "stackSave", "stackRestore"].includes(e) ? e : "_" + e
                            }

                            function ke(e, t) {
                                var r, n;
                                return t && (r = i.asm["orig$" + e]), r || (r = i.asm[e]), !r && t && (r = i["_orig$" + e]), r || (r = i[Te(e)]), !r && e.startsWith("invoke_") && (n = e.split("_")[1], r = function() {
                                    var e = Ge();
                                    try {
                                        return xe(n, arguments[0], Array.prototype.slice.call(arguments, 1))
                                    } catch (t) {
                                        if (ze(e), t !== t + 0 && "longjmp" !== t) throw t;
                                        We(1, 0)
                                    }
                                }), r
                            }

                            function Ie(e, t) {
                                var r = ye(e);

                                function n() {
                                    var n = Math.pow(2, r.memoryAlign);
                                    n = Math.max(n, b);
                                    var o, i, s, a = (o = function(e) {
                                            if (ee) return Ue(e);
                                            var t = Ee,
                                                r = t + e + 15 & -16;
                                            return Ee = r, me.__heap_base.value = r, t
                                        }(r.memorySize + n), (i = n) || (i = b), Math.ceil(o / i) * i),
                                        c = J.length;
                                    J.grow(r.tableSize);
                                    for (var l = a; l < a + r.memorySize; l++) R[l] = 0;
                                    for (l = c; l < c + r.tableSize; l++) J.set(l, null);
                                    var u = new Proxy(qe, {
                                            get: function(e, t) {
                                                switch (t) {
                                                    case "__memory_base":
                                                        return a;
                                                    case "__table_base":
                                                        return c
                                                }
                                                return t in e ? e[t] : e[t] = function() {
                                                    return r || (r = function(e) {
                                                        var t = ke(e, !1);
                                                        return t || (t = s[e]), t
                                                    }(t)), r.apply(null, arguments)
                                                };
                                                var r
                                            }
                                        }),
                                        d = {
                                            "GOT.mem": new Proxy(qe, ge),
                                            "GOT.func": new Proxy(qe, ge),
                                            env: u,
                                            wasi_snapshot_preview1: u
                                        };

                                    function p(e) {
                                        for (var n = 0; n < r.tableSize; n++) {
                                            var o = J.get(c + n);
                                            o && v.set(o, c + n)
                                        }
                                        s = Se(e.exports, a), t.allowUndefined || Oe();
                                        var i = s.__wasm_call_ctors;
                                        return i || (i = s.__post_instantiate), i && (ee ? i() : Q.push(i)), s
                                    }
                                    if (t.loadAsync) {
                                        if (e instanceof WebAssembly.Module) {
                                            var h = new WebAssembly.Instance(e, d);
                                            return Promise.resolve(p(h))
                                        }
                                        return WebAssembly.instantiate(e, d).then((function(e) {
                                            return p(e.instance)
                                        }))
                                    }
                                    var f = e instanceof WebAssembly.Module ? e : new WebAssembly.Module(e);
                                    return p(h = new WebAssembly.Instance(f, d))
                                }
                                return t.loadAsync ? r.neededDynlibs.reduce((function(e, r) {
                                    return e.then((function() {
                                        return Ae(r, t)
                                    }))
                                }), Promise.resolve()).then((function() {
                                    return n()
                                })) : (r.neededDynlibs.forEach((function(e) {
                                    Ae(e, t)
                                })), n())
                            }

                            function Pe(e, t) {
                                for (var r in e)
                                    if (e.hasOwnProperty(r)) {
                                        qe.hasOwnProperty(r) || (qe[r] = e[r]);
                                        var n = Te(r);
                                        i.hasOwnProperty(n) || (i[n] = e[r])
                                    }
                            }

                            function Ae(e, t) {
                                "__main__" != e || we.loadedLibNames[e] || (we.loadedLibs[-1] = {
                                    refcount: 1 / 0,
                                    name: "__main__",
                                    module: i.asm,
                                    global: !0
                                }, we.loadedLibNames.__main__ = -1), t = t || {
                                    global: !0,
                                    nodelete: !0
                                };
                                var r, n = we.loadedLibNames[e];
                                if (n) return r = we.loadedLibs[n], t.global && !r.global && (r.global = !0, "loading" !== r.module && Pe(r.module)), t.nodelete && r.refcount !== 1 / 0 && (r.refcount = 1 / 0), r.refcount++, t.loadAsync ? Promise.resolve(n) : n;

                                function o(e) {
                                    if (t.fs) {
                                        var r = t.fs.readFile(e, {
                                            encoding: "binary"
                                        });
                                        return r instanceof Uint8Array || (r = new Uint8Array(r)), t.loadAsync ? Promise.resolve(r) : r
                                    }
                                    return t.loadAsync ? (n = e, fetch(n, {
                                        credentials: "same-origin"
                                    }).then((function(e) {
                                        if (!e.ok) throw "failed to load binary file at '" + n + "'";
                                        return e.arrayBuffer()
                                    })).then((function(e) {
                                        return new Uint8Array(e)
                                    }))) : f(e);
                                    var n
                                }

                                function s() {
                                    if (void 0 !== i.preloadedWasm && void 0 !== i.preloadedWasm[e]) {
                                        var r = i.preloadedWasm[e];
                                        return t.loadAsync ? Promise.resolve(r) : r
                                    }
                                    return t.loadAsync ? o(e).then((function(e) {
                                        return Ie(e, t)
                                    })) : Ie(o(e), t)
                                }

                                function a(e) {
                                    r.global && Pe(e), r.module = e
                                }
                                return n = we.nextHandle++, r = {
                                    refcount: t.nodelete ? 1 / 0 : 1,
                                    name: e,
                                    module: "loading",
                                    global: t.global
                                }, we.loadedLibNames[e] = n, we.loadedLibs[n] = r, t.loadAsync ? s().then((function(e) {
                                    return a(e), n
                                })) : (a(s()), n)
                            }

                            function Oe() {
                                for (var e in me)
                                    if (0 == me[e].value) {
                                        var t = ke(e, !0);
                                        "function" == typeof t ? me[e].value = x(t, t.sig) : "number" == typeof t ? me[e].value = t : O(!1, "bad export type for `" + e + "`: " + typeof t)
                                    }
                            }
                            i.___heap_base = Ee;
                            var Ne, Re = new WebAssembly.Global({
                                value: "i32",
                                mutable: !0
                            }, 5250832);

                            function $e() {
                                se()
                            }
                            i._abort = $e, $e.sig = "v", Ne = o ? function() {
                                var e = process.hrtime();
                                return 1e3 * e[0] + e[1] / 1e6
                            } : "undefined" != typeof dateNow ? dateNow : function() {
                                return performance.now()
                            };
                            var Me = !0;

                            function De(e, t) {
                                var r;
                                if (0 === e) r = Date.now();
                                else {
                                    if (1 !== e && 4 !== e || !Me) return D[He() >> 2] = 28, -1;
                                    r = Ne()
                                }
                                return D[t >> 2] = r / 1e3 | 0, D[t + 4 >> 2] = r % 1e3 * 1e3 * 1e3 | 0, 0
                            }

                            function Le(e) {
                                try {
                                    return T.grow(e - N.byteLength + 65535 >>> 16), W(T.buffer), 1
                                } catch (e) {}
                            }

                            function Fe(e) {
                                Qe(e)
                            }

                            function je(e) {
                                C(e)
                            }
                            De.sig = "iii", Fe.sig = "vi", je.sig = "vi";
                            var Be, qe = {
                                    __heap_base: Ee,
                                    __indirect_function_table: J,
                                    __memory_base: 1024,
                                    __stack_pointer: Re,
                                    __table_base: 1,
                                    abort: $e,
                                    clock_gettime: De,
                                    emscripten_memcpy_big: function(e, t, r) {
                                        $.copyWithin(e, t, t + r)
                                    },
                                    emscripten_resize_heap: function(e) {
                                        var t, r = $.length;
                                        if ((e >>>= 0) > 2147483648) return !1;
                                        for (var n = 1; n <= 4; n *= 2) {
                                            var o = r * (1 + .2 / n);
                                            if (o = Math.min(o, e + 100663296), Le(Math.min(2147483648, ((t = Math.max(e, o)) % 65536 > 0 && (t += 65536 - t % 65536), t)))) return !0
                                        }
                                        return !1
                                    },
                                    exit: Fe,
                                    memory: T,
                                    setTempRet0: je,
                                    tree_sitter_log_callback: function(e, t) {
                                        if (ft) {
                                            const r = U(t);
                                            ft(r, 0 !== e)
                                        }
                                    },
                                    tree_sitter_parse_callback: function(e, t, r, n, o) {
                                        var i = ht(t, {
                                            row: r,
                                            column: n
                                        });
                                        "string" == typeof i ? (I(o, i.length, "i32"), function(e, t, r) {
                                            if (void 0 === r && (r = 2147483647), r < 2) return 0;
                                            for (var n = (r -= 2) < 2 * e.length ? r / 2 : e.length, o = 0; o < n; ++o) {
                                                var i = e.charCodeAt(o);
                                                M[t >> 1] = i, t += 2
                                            }
                                            M[t >> 1] = 0
                                        }(i, e, 10240)) : I(o, 0, "i32")
                                    }
                                },
                                Ue = (function() {
                                    var e = {
                                        env: qe,
                                        wasi_snapshot_preview1: qe,
                                        "GOT.mem": new Proxy(qe, ge),
                                        "GOT.func": new Proxy(qe, ge)
                                    };

                                    function t(e, t) {
                                        var r = e.exports;
                                        r = Se(r, 1024), i.asm = r;
                                        var n, o = ye(t);
                                        o.neededDynlibs && (S = o.neededDynlibs.concat(S)), n = i.asm.__wasm_call_ctors, Q.unshift(n), ie()
                                    }

                                    function r(e) {
                                        t(e.instance, e.module)
                                    }

                                    function n(t) {
                                        return function() {
                                            if (!E && (u || d)) {
                                                if ("function" == typeof fetch && !le(he)) return fetch(he, {
                                                    credentials: "same-origin"
                                                }).then((function(e) {
                                                    if (!e.ok) throw "failed to load wasm binary file at '" + he + "'";
                                                    return e.arrayBuffer()
                                                })).catch((function() {
                                                    return fe(he)
                                                }));
                                                if (h) return new Promise((function(e, t) {
                                                    h(he, (function(t) {
                                                        e(new Uint8Array(t))
                                                    }), t)
                                                }))
                                            }
                                            return Promise.resolve().then((function() {
                                                return fe(he)
                                            }))
                                        }().then((function(t) {
                                            return WebAssembly.instantiate(t, e)
                                        })).then(t, (function(e) {
                                            y("failed to asynchronously prepare wasm: " + e), se(e)
                                        }))
                                    }
                                    if (oe(), i.instantiateWasm) try {
                                        return i.instantiateWasm(e, t)
                                    } catch (e) {
                                        return y("Module.instantiateWasm callback failed with error: " + e), !1
                                    }
                                    E || "function" != typeof WebAssembly.instantiateStreaming || ce(he) || le(he) || "function" != typeof fetch ? n(r) : fetch(he, {
                                        credentials: "same-origin"
                                    }).then((function(t) {
                                        return WebAssembly.instantiateStreaming(t, e).then(r, (function(e) {
                                            return y("wasm streaming compile failed: " + e), y("falling back to ArrayBuffer instantiation"), n(r)
                                        }))
                                    }))
                                }(), i.___wasm_call_ctors = function() {
                                    return (i.___wasm_call_ctors = i.asm.__wasm_call_ctors).apply(null, arguments)
                                }, i._malloc = function() {
                                    return (Ue = i._malloc = i.asm.malloc).apply(null, arguments)
                                }),
                                He = (i._ts_language_symbol_count = function() {
                                    return (i._ts_language_symbol_count = i.asm.ts_language_symbol_count).apply(null, arguments)
                                }, i._ts_language_version = function() {
                                    return (i._ts_language_version = i.asm.ts_language_version).apply(null, arguments)
                                }, i._ts_language_field_count = function() {
                                    return (i._ts_language_field_count = i.asm.ts_language_field_count).apply(null, arguments)
                                }, i._ts_language_symbol_name = function() {
                                    return (i._ts_language_symbol_name = i.asm.ts_language_symbol_name).apply(null, arguments)
                                }, i._ts_language_symbol_for_name = function() {
                                    return (i._ts_language_symbol_for_name = i.asm.ts_language_symbol_for_name).apply(null, arguments)
                                }, i._ts_language_symbol_type = function() {
                                    return (i._ts_language_symbol_type = i.asm.ts_language_symbol_type).apply(null, arguments)
                                }, i._ts_language_field_name_for_id = function() {
                                    return (i._ts_language_field_name_for_id = i.asm.ts_language_field_name_for_id).apply(null, arguments)
                                }, i._memcpy = function() {
                                    return (i._memcpy = i.asm.memcpy).apply(null, arguments)
                                }, i._free = function() {
                                    return (i._free = i.asm.free).apply(null, arguments)
                                }, i._calloc = function() {
                                    return (i._calloc = i.asm.calloc).apply(null, arguments)
                                }, i._ts_parser_delete = function() {
                                    return (i._ts_parser_delete = i.asm.ts_parser_delete).apply(null, arguments)
                                }, i._ts_parser_reset = function() {
                                    return (i._ts_parser_reset = i.asm.ts_parser_reset).apply(null, arguments)
                                }, i._ts_parser_set_language = function() {
                                    return (i._ts_parser_set_language = i.asm.ts_parser_set_language).apply(null, arguments)
                                }, i._ts_parser_timeout_micros = function() {
                                    return (i._ts_parser_timeout_micros = i.asm.ts_parser_timeout_micros).apply(null, arguments)
                                }, i._ts_parser_set_timeout_micros = function() {
                                    return (i._ts_parser_set_timeout_micros = i.asm.ts_parser_set_timeout_micros).apply(null, arguments)
                                }, i._memcmp = function() {
                                    return (i._memcmp = i.asm.memcmp).apply(null, arguments)
                                }, i._ts_query_new = function() {
                                    return (i._ts_query_new = i.asm.ts_query_new).apply(null, arguments)
                                }, i._ts_query_delete = function() {
                                    return (i._ts_query_delete = i.asm.ts_query_delete).apply(null, arguments)
                                }, i._iswspace = function() {
                                    return (i._iswspace = i.asm.iswspace).apply(null, arguments)
                                }, i._iswalnum = function() {
                                    return (i._iswalnum = i.asm.iswalnum).apply(null, arguments)
                                }, i._ts_query_pattern_count = function() {
                                    return (i._ts_query_pattern_count = i.asm.ts_query_pattern_count).apply(null, arguments)
                                }, i._ts_query_capture_count = function() {
                                    return (i._ts_query_capture_count = i.asm.ts_query_capture_count).apply(null, arguments)
                                }, i._ts_query_string_count = function() {
                                    return (i._ts_query_string_count = i.asm.ts_query_string_count).apply(null, arguments)
                                }, i._ts_query_capture_name_for_id = function() {
                                    return (i._ts_query_capture_name_for_id = i.asm.ts_query_capture_name_for_id).apply(null, arguments)
                                }, i._ts_query_string_value_for_id = function() {
                                    return (i._ts_query_string_value_for_id = i.asm.ts_query_string_value_for_id).apply(null, arguments)
                                }, i._ts_query_predicates_for_pattern = function() {
                                    return (i._ts_query_predicates_for_pattern = i.asm.ts_query_predicates_for_pattern).apply(null, arguments)
                                }, i._ts_tree_copy = function() {
                                    return (i._ts_tree_copy = i.asm.ts_tree_copy).apply(null, arguments)
                                }, i._ts_tree_delete = function() {
                                    return (i._ts_tree_delete = i.asm.ts_tree_delete).apply(null, arguments)
                                }, i._ts_init = function() {
                                    return (i._ts_init = i.asm.ts_init).apply(null, arguments)
                                }, i._ts_parser_new_wasm = function() {
                                    return (i._ts_parser_new_wasm = i.asm.ts_parser_new_wasm).apply(null, arguments)
                                }, i._ts_parser_enable_logger_wasm = function() {
                                    return (i._ts_parser_enable_logger_wasm = i.asm.ts_parser_enable_logger_wasm).apply(null, arguments)
                                }, i._ts_parser_parse_wasm = function() {
                                    return (i._ts_parser_parse_wasm = i.asm.ts_parser_parse_wasm).apply(null, arguments)
                                }, i._ts_language_type_is_named_wasm = function() {
                                    return (i._ts_language_type_is_named_wasm = i.asm.ts_language_type_is_named_wasm).apply(null, arguments)
                                }, i._ts_language_type_is_visible_wasm = function() {
                                    return (i._ts_language_type_is_visible_wasm = i.asm.ts_language_type_is_visible_wasm).apply(null, arguments)
                                }, i._ts_tree_root_node_wasm = function() {
                                    return (i._ts_tree_root_node_wasm = i.asm.ts_tree_root_node_wasm).apply(null, arguments)
                                }, i._ts_tree_edit_wasm = function() {
                                    return (i._ts_tree_edit_wasm = i.asm.ts_tree_edit_wasm).apply(null, arguments)
                                }, i._ts_tree_get_changed_ranges_wasm = function() {
                                    return (i._ts_tree_get_changed_ranges_wasm = i.asm.ts_tree_get_changed_ranges_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_new_wasm = function() {
                                    return (i._ts_tree_cursor_new_wasm = i.asm.ts_tree_cursor_new_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_delete_wasm = function() {
                                    return (i._ts_tree_cursor_delete_wasm = i.asm.ts_tree_cursor_delete_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_reset_wasm = function() {
                                    return (i._ts_tree_cursor_reset_wasm = i.asm.ts_tree_cursor_reset_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_goto_first_child_wasm = function() {
                                    return (i._ts_tree_cursor_goto_first_child_wasm = i.asm.ts_tree_cursor_goto_first_child_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_goto_next_sibling_wasm = function() {
                                    return (i._ts_tree_cursor_goto_next_sibling_wasm = i.asm.ts_tree_cursor_goto_next_sibling_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_goto_parent_wasm = function() {
                                    return (i._ts_tree_cursor_goto_parent_wasm = i.asm.ts_tree_cursor_goto_parent_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_current_node_type_id_wasm = function() {
                                    return (i._ts_tree_cursor_current_node_type_id_wasm = i.asm.ts_tree_cursor_current_node_type_id_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_current_node_is_named_wasm = function() {
                                    return (i._ts_tree_cursor_current_node_is_named_wasm = i.asm.ts_tree_cursor_current_node_is_named_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_current_node_is_missing_wasm = function() {
                                    return (i._ts_tree_cursor_current_node_is_missing_wasm = i.asm.ts_tree_cursor_current_node_is_missing_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_current_node_id_wasm = function() {
                                    return (i._ts_tree_cursor_current_node_id_wasm = i.asm.ts_tree_cursor_current_node_id_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_start_position_wasm = function() {
                                    return (i._ts_tree_cursor_start_position_wasm = i.asm.ts_tree_cursor_start_position_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_end_position_wasm = function() {
                                    return (i._ts_tree_cursor_end_position_wasm = i.asm.ts_tree_cursor_end_position_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_start_index_wasm = function() {
                                    return (i._ts_tree_cursor_start_index_wasm = i.asm.ts_tree_cursor_start_index_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_end_index_wasm = function() {
                                    return (i._ts_tree_cursor_end_index_wasm = i.asm.ts_tree_cursor_end_index_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_current_field_id_wasm = function() {
                                    return (i._ts_tree_cursor_current_field_id_wasm = i.asm.ts_tree_cursor_current_field_id_wasm).apply(null, arguments)
                                }, i._ts_tree_cursor_current_node_wasm = function() {
                                    return (i._ts_tree_cursor_current_node_wasm = i.asm.ts_tree_cursor_current_node_wasm).apply(null, arguments)
                                }, i._ts_node_symbol_wasm = function() {
                                    return (i._ts_node_symbol_wasm = i.asm.ts_node_symbol_wasm).apply(null, arguments)
                                }, i._ts_node_child_count_wasm = function() {
                                    return (i._ts_node_child_count_wasm = i.asm.ts_node_child_count_wasm).apply(null, arguments)
                                }, i._ts_node_named_child_count_wasm = function() {
                                    return (i._ts_node_named_child_count_wasm = i.asm.ts_node_named_child_count_wasm).apply(null, arguments)
                                }, i._ts_node_child_wasm = function() {
                                    return (i._ts_node_child_wasm = i.asm.ts_node_child_wasm).apply(null, arguments)
                                }, i._ts_node_named_child_wasm = function() {
                                    return (i._ts_node_named_child_wasm = i.asm.ts_node_named_child_wasm).apply(null, arguments)
                                }, i._ts_node_child_by_field_id_wasm = function() {
                                    return (i._ts_node_child_by_field_id_wasm = i.asm.ts_node_child_by_field_id_wasm).apply(null, arguments)
                                }, i._ts_node_next_sibling_wasm = function() {
                                    return (i._ts_node_next_sibling_wasm = i.asm.ts_node_next_sibling_wasm).apply(null, arguments)
                                }, i._ts_node_prev_sibling_wasm = function() {
                                    return (i._ts_node_prev_sibling_wasm = i.asm.ts_node_prev_sibling_wasm).apply(null, arguments)
                                }, i._ts_node_next_named_sibling_wasm = function() {
                                    return (i._ts_node_next_named_sibling_wasm = i.asm.ts_node_next_named_sibling_wasm).apply(null, arguments)
                                }, i._ts_node_prev_named_sibling_wasm = function() {
                                    return (i._ts_node_prev_named_sibling_wasm = i.asm.ts_node_prev_named_sibling_wasm).apply(null, arguments)
                                }, i._ts_node_parent_wasm = function() {
                                    return (i._ts_node_parent_wasm = i.asm.ts_node_parent_wasm).apply(null, arguments)
                                }, i._ts_node_descendant_for_index_wasm = function() {
                                    return (i._ts_node_descendant_for_index_wasm = i.asm.ts_node_descendant_for_index_wasm).apply(null, arguments)
                                }, i._ts_node_named_descendant_for_index_wasm = function() {
                                    return (i._ts_node_named_descendant_for_index_wasm = i.asm.ts_node_named_descendant_for_index_wasm).apply(null, arguments)
                                }, i._ts_node_descendant_for_position_wasm = function() {
                                    return (i._ts_node_descendant_for_position_wasm = i.asm.ts_node_descendant_for_position_wasm).apply(null, arguments)
                                }, i._ts_node_named_descendant_for_position_wasm = function() {
                                    return (i._ts_node_named_descendant_for_position_wasm = i.asm.ts_node_named_descendant_for_position_wasm).apply(null, arguments)
                                }, i._ts_node_start_point_wasm = function() {
                                    return (i._ts_node_start_point_wasm = i.asm.ts_node_start_point_wasm).apply(null, arguments)
                                }, i._ts_node_end_point_wasm = function() {
                                    return (i._ts_node_end_point_wasm = i.asm.ts_node_end_point_wasm).apply(null, arguments)
                                }, i._ts_node_start_index_wasm = function() {
                                    return (i._ts_node_start_index_wasm = i.asm.ts_node_start_index_wasm).apply(null, arguments)
                                }, i._ts_node_end_index_wasm = function() {
                                    return (i._ts_node_end_index_wasm = i.asm.ts_node_end_index_wasm).apply(null, arguments)
                                }, i._ts_node_to_string_wasm = function() {
                                    return (i._ts_node_to_string_wasm = i.asm.ts_node_to_string_wasm).apply(null, arguments)
                                }, i._ts_node_children_wasm = function() {
                                    return (i._ts_node_children_wasm = i.asm.ts_node_children_wasm).apply(null, arguments)
                                }, i._ts_node_named_children_wasm = function() {
                                    return (i._ts_node_named_children_wasm = i.asm.ts_node_named_children_wasm).apply(null, arguments)
                                }, i._ts_node_descendants_of_type_wasm = function() {
                                    return (i._ts_node_descendants_of_type_wasm = i.asm.ts_node_descendants_of_type_wasm).apply(null, arguments)
                                }, i._ts_node_is_named_wasm = function() {
                                    return (i._ts_node_is_named_wasm = i.asm.ts_node_is_named_wasm).apply(null, arguments)
                                }, i._ts_node_has_changes_wasm = function() {
                                    return (i._ts_node_has_changes_wasm = i.asm.ts_node_has_changes_wasm).apply(null, arguments)
                                }, i._ts_node_has_error_wasm = function() {
                                    return (i._ts_node_has_error_wasm = i.asm.ts_node_has_error_wasm).apply(null, arguments)
                                }, i._ts_node_is_missing_wasm = function() {
                                    return (i._ts_node_is_missing_wasm = i.asm.ts_node_is_missing_wasm).apply(null, arguments)
                                }, i._ts_query_matches_wasm = function() {
                                    return (i._ts_query_matches_wasm = i.asm.ts_query_matches_wasm).apply(null, arguments)
                                }, i._ts_query_captures_wasm = function() {
                                    return (i._ts_query_captures_wasm = i.asm.ts_query_captures_wasm).apply(null, arguments)
                                }, i._iswalpha = function() {
                                    return (i._iswalpha = i.asm.iswalpha).apply(null, arguments)
                                }, i._iswdigit = function() {
                                    return (i._iswdigit = i.asm.iswdigit).apply(null, arguments)
                                }, i._iswlower = function() {
                                    return (i._iswlower = i.asm.iswlower).apply(null, arguments)
                                }, i._towupper = function() {
                                    return (i._towupper = i.asm.towupper).apply(null, arguments)
                                }, i._memchr = function() {
                                    return (i._memchr = i.asm.memchr).apply(null, arguments)
                                }, i.___errno_location = function() {
                                    return (He = i.___errno_location = i.asm.__errno_location).apply(null, arguments)
                                }),
                                Ge = (i._strlen = function() {
                                    return (i._strlen = i.asm.strlen).apply(null, arguments)
                                }, i.stackSave = function() {
                                    return (Ge = i.stackSave = i.asm.stackSave).apply(null, arguments)
                                }),
                                ze = i.stackRestore = function() {
                                    return (ze = i.stackRestore = i.asm.stackRestore).apply(null, arguments)
                                },
                                Ve = i.stackAlloc = function() {
                                    return (Ve = i.stackAlloc = i.asm.stackAlloc).apply(null, arguments)
                                },
                                We = i._setThrew = function() {
                                    return (We = i._setThrew = i.asm.setThrew).apply(null, arguments)
                                };

                            function Ke(e) {
                                this.name = "ExitStatus", this.message = "Program terminated with exit(" + e + ")", this.status = e
                            }
                            i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = function() {
                                return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm).apply(null, arguments)
                            }, i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = function() {
                                return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev).apply(null, arguments)
                            }, i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = function() {
                                return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm).apply(null, arguments)
                            }, i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = function() {
                                return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm).apply(null, arguments)
                            }, i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = function() {
                                return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc).apply(null, arguments)
                            }, i.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = function() {
                                return (i.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = i.asm._ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm).apply(null, arguments)
                            }, i.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = function() {
                                return (i.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = i.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev).apply(null, arguments)
                            }, i.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = function() {
                                return (i.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = i.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw).apply(null, arguments)
                            }, i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_ = function() {
                                return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_ = i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_).apply(null, arguments)
                            }, i.__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv = function() {
                                return (i.__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv = i.asm._ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv).apply(null, arguments)
                            }, i.__Znwm = function() {
                                return (i.__Znwm = i.asm._Znwm).apply(null, arguments)
                            }, i.__ZdlPv = function() {
                                return (i.__ZdlPv = i.asm._ZdlPv).apply(null, arguments)
                            }, i._orig$ts_parser_timeout_micros = function() {
                                return (i._orig$ts_parser_timeout_micros = i.asm.orig$ts_parser_timeout_micros).apply(null, arguments)
                            }, i._orig$ts_parser_set_timeout_micros = function() {
                                return (i._orig$ts_parser_set_timeout_micros = i.asm.orig$ts_parser_set_timeout_micros).apply(null, arguments)
                            }, i._TRANSFER_BUFFER = 7296, i.___THREW__ = 7932, i.___threwValue = 7936, i.___cxa_new_handler = 7928, i.allocate = function(e, t) {
                                var r;
                                return r = t == j ? Ve(e.length) : Ue(e.length), e.subarray || e.slice ? $.set(e, r) : $.set(new Uint8Array(e), r), r
                            }, ne = function e() {
                                Be || Xe(), Be || (ne = e)
                            };
                            var Je = !1;

                            function Xe(e) {
                                function t() {
                                    Be || (Be = !0, i.calledRun = !0, A || (ee = !0, _e(Q), _e(Y), i.onRuntimeInitialized && i.onRuntimeInitialized(), Ye && function(e) {
                                        var t = i._main;
                                        if (t) {
                                            var r = (e = e || []).length + 1,
                                                n = Ve(4 * (r + 1));
                                            D[n >> 2] = V(c);
                                            for (var o = 1; o < r; o++) D[(n >> 2) + o] = V(e[o - 1]);
                                            D[(n >> 2) + r] = 0;
                                            try {
                                                Qe(t(r, n), !0)
                                            } catch (e) {
                                                if (e instanceof Ke) return;
                                                if ("unwind" == e) return;
                                                var s = e;
                                                e && "object" == typeof e && e.stack && (s = [e, e.stack]), y("exception thrown: " + s), l(1, e)
                                            }
                                        }
                                    }(e), function() {
                                        if (i.postRun)
                                            for ("function" == typeof i.postRun && (i.postRun = [i.postRun]); i.postRun.length;) e = i.postRun.shift(), Z.unshift(e);
                                        var e;
                                        _e(Z)
                                    }()))
                                }
                                e = e || a, te > 0 || !Je && (function() {
                                    if (S.length) {
                                        if (!f) return oe(), void S.reduce((function(e, t) {
                                            return e.then((function() {
                                                return Ae(t, {
                                                    loadAsync: !0,
                                                    global: !0,
                                                    nodelete: !0,
                                                    allowUndefined: !0
                                                })
                                            }))
                                        }), Promise.resolve()).then((function() {
                                            ie(), Oe()
                                        }));
                                        S.forEach((function(e) {
                                            Ae(e, {
                                                global: !0,
                                                nodelete: !0,
                                                allowUndefined: !0
                                            })
                                        })), Oe()
                                    } else Oe()
                                }(), Je = !0, te > 0) || (function() {
                                    if (i.preRun)
                                        for ("function" == typeof i.preRun && (i.preRun = [i.preRun]); i.preRun.length;) e = i.preRun.shift(), X.unshift(e);
                                    var e;
                                    _e(X)
                                }(), te > 0 || (i.setStatus ? (i.setStatus("Running..."), setTimeout((function() {
                                    setTimeout((function() {
                                        i.setStatus("")
                                    }), 1), t()
                                }), 1)) : t()))
                            }

                            function Qe(e, t) {
                                t && be() && 0 === e || (be() || (i.onExit && i.onExit(e), A = !0), l(e, new Ke(e)))
                            }
                            if (i.run = Xe, i.preInit)
                                for ("function" == typeof i.preInit && (i.preInit = [i.preInit]); i.preInit.length > 0;) i.preInit.pop()();
                            var Ye = !0;
                            i.noInitialRun && (Ye = !1), Xe();
                            const Ze = i,
                                et = {},
                                tt = 4,
                                rt = 5 * tt,
                                nt = 2 * tt,
                                ot = 2 * tt + 2 * nt,
                                it = {
                                    row: 0,
                                    column: 0
                                },
                                st = /[\w-.]*/g,
                                at = 1,
                                ct = 2,
                                lt = /^_?tree_sitter_\w+/;
                            var ut, dt, pt, ht, ft, mt = new Promise((e => {
                                i.onRuntimeInitialized = e
                            })).then((() => {
                                pt = Ze._ts_init(), ut = P(pt, "i32"), dt = P(pt + tt, "i32")
                            }));
                            class gt {
                                static init() {
                                    return mt
                                }
                                constructor() {
                                    if (null == pt) throw new Error("You must first call Parser.init() and wait for it to resolve.");
                                    Ze._ts_parser_new_wasm(), this[0] = P(pt, "i32"), this[1] = P(pt + tt, "i32")
                                }
                                delete() {
                                    Ze._ts_parser_delete(this[0]), Ze._free(this[1]), this[0] = 0, this[1] = 0
                                }
                                setLanguage(e) {
                                    let t;
                                    if (e) {
                                        if (e.constructor !== bt) throw new Error("Argument must be a Language"); {
                                            t = e[0];
                                            const r = Ze._ts_language_version(t);
                                            if (r < dt || ut < r) throw new Error(`Incompatible language version ${r}. Compatibility range ${dt} through ${ut}.`)
                                        }
                                    } else t = 0, e = null;
                                    return this.language = e, Ze._ts_parser_set_language(this[0], t), this
                                }
                                getLanguage() {
                                    return this.language
                                }
                                parse(e, t, r) {
                                    if ("string" == typeof e) ht = (t, r, n) => e.slice(t, n);
                                    else {
                                        if ("function" != typeof e) throw new Error("Argument must be a string or a function");
                                        ht = e
                                    }
                                    this.logCallback ? (ft = this.logCallback, Ze._ts_parser_enable_logger_wasm(this[0], 1)) : (ft = null, Ze._ts_parser_enable_logger_wasm(this[0], 0));
                                    let n = 0,
                                        o = 0;
                                    if (r && r.includedRanges) {
                                        n = r.includedRanges.length;
                                        let e = o = Ze._calloc(n, ot);
                                        for (let t = 0; t < n; t++) Nt(e, r.includedRanges[t]), e += ot
                                    }
                                    const i = Ze._ts_parser_parse_wasm(this[0], this[1], t ? t[0] : 0, o, n);
                                    if (!i) throw ht = null, ft = null, new Error("Parsing failed");
                                    const s = new _t(et, i, this.language, ht);
                                    return ht = null, ft = null, s
                                }
                                reset() {
                                    Ze._ts_parser_reset(this[0])
                                }
                                setTimeoutMicros(e) {
                                    Ze._ts_parser_set_timeout_micros(this[0], e)
                                }
                                getTimeoutMicros() {
                                    return Ze._ts_parser_timeout_micros(this[0])
                                }
                                setLogger(e) {
                                    if (e) {
                                        if ("function" != typeof e) throw new Error("Logger callback must be a function")
                                    } else e = null;
                                    return this.logCallback = e, this
                                }
                                getLogger() {
                                    return this.logCallback
                                }
                            }
                            class _t {
                                constructor(e, t, r, n) {
                                    Ct(e), this[0] = t, this.language = r, this.textCallback = n
                                }
                                copy() {
                                    const e = Ze._ts_tree_copy(this[0]);
                                    return new _t(et, e, this.language, this.textCallback)
                                }
                                delete() {
                                    Ze._ts_tree_delete(this[0]), this[0] = 0
                                }
                                edit(e) {
                                    ! function(e) {
                                        let t = pt;
                                        At(t, e.startPosition), At(t += nt, e.oldEndPosition), At(t += nt, e.newEndPosition), I(t += nt, e.startIndex, "i32"), I(t += tt, e.oldEndIndex, "i32"), I(t += tt, e.newEndIndex, "i32"), t += tt
                                    }(e), Ze._ts_tree_edit_wasm(this[0])
                                }
                                get rootNode() {
                                    return Ze._ts_tree_root_node_wasm(this[0]), kt(this)
                                }
                                getLanguage() {
                                    return this.language
                                }
                                walk() {
                                    return this.rootNode.walk()
                                }
                                getChangedRanges(e) {
                                    if (e.constructor !== _t) throw new TypeError("Argument must be a Tree");
                                    Ze._ts_tree_get_changed_ranges_wasm(this[0], e[0]);
                                    const t = P(pt, "i32"),
                                        r = P(pt + tt, "i32"),
                                        n = new Array(t);
                                    if (t > 0) {
                                        let e = r;
                                        for (let r = 0; r < t; r++) n[r] = Rt(e), e += ot;
                                        Ze._free(r)
                                    }
                                    return n
                                }
                            }
                            class yt {
                                constructor(e, t) {
                                    Ct(e), this.tree = t
                                }
                                get typeId() {
                                    return Tt(this), Ze._ts_node_symbol_wasm(this.tree[0])
                                }
                                get type() {
                                    return this.tree.language.types[this.typeId] || "ERROR"
                                }
                                get endPosition() {
                                    return Tt(this), Ze._ts_node_end_point_wasm(this.tree[0]), Ot(pt)
                                }
                                get endIndex() {
                                    return Tt(this), Ze._ts_node_end_index_wasm(this.tree[0])
                                }
                                get text() {
                                    return xt(this.tree, this.startIndex, this.endIndex)
                                }
                                isNamed() {
                                    return Tt(this), 1 === Ze._ts_node_is_named_wasm(this.tree[0])
                                }
                                hasError() {
                                    return Tt(this), 1 === Ze._ts_node_has_error_wasm(this.tree[0])
                                }
                                hasChanges() {
                                    return Tt(this), 1 === Ze._ts_node_has_changes_wasm(this.tree[0])
                                }
                                isMissing() {
                                    return Tt(this), 1 === Ze._ts_node_is_missing_wasm(this.tree[0])
                                }
                                equals(e) {
                                    return this.id === e.id
                                }
                                child(e) {
                                    return Tt(this), Ze._ts_node_child_wasm(this.tree[0], e), kt(this.tree)
                                }
                                namedChild(e) {
                                    return Tt(this), Ze._ts_node_named_child_wasm(this.tree[0], e), kt(this.tree)
                                }
                                childForFieldId(e) {
                                    return Tt(this), Ze._ts_node_child_by_field_id_wasm(this.tree[0], e), kt(this.tree)
                                }
                                childForFieldName(e) {
                                    const t = this.tree.language.fields.indexOf(e);
                                    if (-1 !== t) return this.childForFieldId(t)
                                }
                                get childCount() {
                                    return Tt(this), Ze._ts_node_child_count_wasm(this.tree[0])
                                }
                                get namedChildCount() {
                                    return Tt(this), Ze._ts_node_named_child_count_wasm(this.tree[0])
                                }
                                get firstChild() {
                                    return this.child(0)
                                }
                                get firstNamedChild() {
                                    return this.namedChild(0)
                                }
                                get lastChild() {
                                    return this.child(this.childCount - 1)
                                }
                                get lastNamedChild() {
                                    return this.namedChild(this.namedChildCount - 1)
                                }
                                get children() {
                                    if (!this._children) {
                                        Tt(this), Ze._ts_node_children_wasm(this.tree[0]);
                                        const e = P(pt, "i32"),
                                            t = P(pt + tt, "i32");
                                        if (this._children = new Array(e), e > 0) {
                                            let r = t;
                                            for (let t = 0; t < e; t++) this._children[t] = kt(this.tree, r), r += rt;
                                            Ze._free(t)
                                        }
                                    }
                                    return this._children
                                }
                                get namedChildren() {
                                    if (!this._namedChildren) {
                                        Tt(this), Ze._ts_node_named_children_wasm(this.tree[0]);
                                        const e = P(pt, "i32"),
                                            t = P(pt + tt, "i32");
                                        if (this._namedChildren = new Array(e), e > 0) {
                                            let r = t;
                                            for (let t = 0; t < e; t++) this._namedChildren[t] = kt(this.tree, r), r += rt;
                                            Ze._free(t)
                                        }
                                    }
                                    return this._namedChildren
                                }
                                descendantsOfType(e, t, r) {
                                    Array.isArray(e) || (e = [e]), t || (t = it), r || (r = it);
                                    const n = [],
                                        o = this.tree.language.types;
                                    for (let t = 0, r = o.length; t < r; t++) e.includes(o[t]) && n.push(t);
                                    const i = Ze._malloc(tt * n.length);
                                    for (let e = 0, t = n.length; e < t; e++) I(i + e * tt, n[e], "i32");
                                    Tt(this), Ze._ts_node_descendants_of_type_wasm(this.tree[0], i, n.length, t.row, t.column, r.row, r.column);
                                    const s = P(pt, "i32"),
                                        a = P(pt + tt, "i32"),
                                        c = new Array(s);
                                    if (s > 0) {
                                        let e = a;
                                        for (let t = 0; t < s; t++) c[t] = kt(this.tree, e), e += rt
                                    }
                                    return Ze._free(a), Ze._free(i), c
                                }
                                get nextSibling() {
                                    return Tt(this), Ze._ts_node_next_sibling_wasm(this.tree[0]), kt(this.tree)
                                }
                                get previousSibling() {
                                    return Tt(this), Ze._ts_node_prev_sibling_wasm(this.tree[0]), kt(this.tree)
                                }
                                get nextNamedSibling() {
                                    return Tt(this), Ze._ts_node_next_named_sibling_wasm(this.tree[0]), kt(this.tree)
                                }
                                get previousNamedSibling() {
                                    return Tt(this), Ze._ts_node_prev_named_sibling_wasm(this.tree[0]), kt(this.tree)
                                }
                                get parent() {
                                    return Tt(this), Ze._ts_node_parent_wasm(this.tree[0]), kt(this.tree)
                                }
                                descendantForIndex(e, t = e) {
                                    if ("number" != typeof e || "number" != typeof t) throw new Error("Arguments must be numbers");
                                    Tt(this);
                                    let r = pt + rt;
                                    return I(r, e, "i32"), I(r + tt, t, "i32"), Ze._ts_node_descendant_for_index_wasm(this.tree[0]), kt(this.tree)
                                }
                                namedDescendantForIndex(e, t = e) {
                                    if ("number" != typeof e || "number" != typeof t) throw new Error("Arguments must be numbers");
                                    Tt(this);
                                    let r = pt + rt;
                                    return I(r, e, "i32"), I(r + tt, t, "i32"), Ze._ts_node_named_descendant_for_index_wasm(this.tree[0]), kt(this.tree)
                                }
                                descendantForPosition(e, t = e) {
                                    if (!St(e) || !St(t)) throw new Error("Arguments must be {row, column} objects");
                                    Tt(this);
                                    let r = pt + rt;
                                    return At(r, e), At(r + nt, t), Ze._ts_node_descendant_for_position_wasm(this.tree[0]), kt(this.tree)
                                }
                                namedDescendantForPosition(e, t = e) {
                                    if (!St(e) || !St(t)) throw new Error("Arguments must be {row, column} objects");
                                    Tt(this);
                                    let r = pt + rt;
                                    return At(r, e), At(r + nt, t), Ze._ts_node_named_descendant_for_position_wasm(this.tree[0]), kt(this.tree)
                                }
                                walk() {
                                    return Tt(this), Ze._ts_tree_cursor_new_wasm(this.tree[0]), new vt(et, this.tree)
                                }
                                toString() {
                                    Tt(this);
                                    const e = Ze._ts_node_to_string_wasm(this.tree[0]),
                                        t = function(e) {
                                            for (var t = "";;) {
                                                var r = $[e++ >> 0];
                                                if (!r) return t;
                                                t += String.fromCharCode(r)
                                            }
                                        }(e);
                                    return Ze._free(e), t
                                }
                            }
                            class vt {
                                constructor(e, t) {
                                    Ct(e), this.tree = t, Pt(this)
                                }
                                delete() {
                                    It(this), Ze._ts_tree_cursor_delete_wasm(this.tree[0]), this[0] = this[1] = this[2] = 0
                                }
                                reset(e) {
                                    Tt(e), It(this, pt + rt), Ze._ts_tree_cursor_reset_wasm(this.tree[0]), Pt(this)
                                }
                                get nodeType() {
                                    return this.tree.language.types[this.nodeTypeId] || "ERROR"
                                }
                                get nodeTypeId() {
                                    return It(this), Ze._ts_tree_cursor_current_node_type_id_wasm(this.tree[0])
                                }
                                get nodeId() {
                                    return It(this), Ze._ts_tree_cursor_current_node_id_wasm(this.tree[0])
                                }
                                get nodeIsNamed() {
                                    return It(this), 1 === Ze._ts_tree_cursor_current_node_is_named_wasm(this.tree[0])
                                }
                                get nodeIsMissing() {
                                    return It(this), 1 === Ze._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0])
                                }
                                get nodeText() {
                                    It(this);
                                    const e = Ze._ts_tree_cursor_start_index_wasm(this.tree[0]),
                                        t = Ze._ts_tree_cursor_end_index_wasm(this.tree[0]);
                                    return xt(this.tree, e, t)
                                }
                                get startPosition() {
                                    return It(this), Ze._ts_tree_cursor_start_position_wasm(this.tree[0]), Ot(pt)
                                }
                                get endPosition() {
                                    return It(this), Ze._ts_tree_cursor_end_position_wasm(this.tree[0]), Ot(pt)
                                }
                                get startIndex() {
                                    return It(this), Ze._ts_tree_cursor_start_index_wasm(this.tree[0])
                                }
                                get endIndex() {
                                    return It(this), Ze._ts_tree_cursor_end_index_wasm(this.tree[0])
                                }
                                currentNode() {
                                    return It(this), Ze._ts_tree_cursor_current_node_wasm(this.tree[0]), kt(this.tree)
                                }
                                currentFieldId() {
                                    return It(this), Ze._ts_tree_cursor_current_field_id_wasm(this.tree[0])
                                }
                                currentFieldName() {
                                    return this.tree.language.fields[this.currentFieldId()]
                                }
                                gotoFirstChild() {
                                    It(this);
                                    const e = Ze._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);
                                    return Pt(this), 1 === e
                                }
                                gotoNextSibling() {
                                    It(this);
                                    const e = Ze._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);
                                    return Pt(this), 1 === e
                                }
                                gotoParent() {
                                    It(this);
                                    const e = Ze._ts_tree_cursor_goto_parent_wasm(this.tree[0]);
                                    return Pt(this), 1 === e
                                }
                            }
                            class bt {
                                constructor(e, t) {
                                    Ct(e), this[0] = t, this.types = new Array(Ze._ts_language_symbol_count(this[0]));
                                    for (let e = 0, t = this.types.length; e < t; e++) Ze._ts_language_symbol_type(this[0], e) < 2 && (this.types[e] = U(Ze._ts_language_symbol_name(this[0], e)));
                                    this.fields = new Array(Ze._ts_language_field_count(this[0]) + 1);
                                    for (let e = 0, t = this.fields.length; e < t; e++) {
                                        const t = Ze._ts_language_field_name_for_id(this[0], e);
                                        this.fields[e] = 0 !== t ? U(t) : null
                                    }
                                }
                                get version() {
                                    return Ze._ts_language_version(this[0])
                                }
                                get fieldCount() {
                                    return this.fields.length - 1
                                }
                                fieldIdForName(e) {
                                    const t = this.fields.indexOf(e);
                                    return -1 !== t ? t : null
                                }
                                fieldNameForId(e) {
                                    return this.fields[e] || null
                                }
                                idForNodeType(e, t) {
                                    const r = z(e),
                                        n = Ze._malloc(r + 1);
                                    G(e, n, r + 1);
                                    const o = Ze._ts_language_symbol_for_name(this[0], n, r, t);
                                    return Ze._free(n), o || null
                                }
                                get nodeTypeCount() {
                                    return Ze._ts_language_symbol_count(this[0])
                                }
                                nodeTypeForId(e) {
                                    const t = Ze._ts_language_symbol_name(this[0], e);
                                    return t ? U(t) : null
                                }
                                nodeTypeIsNamed(e) {
                                    return !!Ze._ts_language_type_is_named_wasm(this[0], e)
                                }
                                nodeTypeIsVisible(e) {
                                    return !!Ze._ts_language_type_is_visible_wasm(this[0], e)
                                }
                                query(e) {
                                    const t = z(e),
                                        r = Ze._malloc(t + 1);
                                    G(e, r, t + 1);
                                    const n = Ze._ts_query_new(this[0], r, t, pt, pt + tt);
                                    if (!n) {
                                        const t = P(pt + tt, "i32"),
                                            n = U(r, P(pt, "i32")).length,
                                            o = e.substr(n, 100).split("\n")[0];
                                        let i, s = o.match(st)[0];
                                        switch (t) {
                                            case 2:
                                                i = new RangeError(`Bad node name '${s}'`);
                                                break;
                                            case 3:
                                                i = new RangeError(`Bad field name '${s}'`);
                                                break;
                                            case 4:
                                                i = new RangeError(`Bad capture name @${s}`);
                                                break;
                                            case 5:
                                                i = new TypeError(`Bad pattern structure at offset ${n}: '${o}'...`), s = "";
                                                break;
                                            default:
                                                i = new SyntaxError(`Bad syntax at offset ${n}: '${o}'...`), s = ""
                                        }
                                        throw i.index = n, i.length = s.length, Ze._free(r), i
                                    }
                                    const o = Ze._ts_query_string_count(n),
                                        i = Ze._ts_query_capture_count(n),
                                        s = Ze._ts_query_pattern_count(n),
                                        a = new Array(i),
                                        c = new Array(o);
                                    for (let e = 0; e < i; e++) {
                                        const t = Ze._ts_query_capture_name_for_id(n, e, pt),
                                            r = P(pt, "i32");
                                        a[e] = U(t, r)
                                    }
                                    for (let e = 0; e < o; e++) {
                                        const t = Ze._ts_query_string_value_for_id(n, e, pt),
                                            r = P(pt, "i32");
                                        c[e] = U(t, r)
                                    }
                                    const l = new Array(s),
                                        u = new Array(s),
                                        d = new Array(s),
                                        p = new Array(s),
                                        h = new Array(s);
                                    for (let e = 0; e < s; e++) {
                                        const t = Ze._ts_query_predicates_for_pattern(n, e, pt),
                                            r = P(pt, "i32");
                                        p[e] = [], h[e] = [];
                                        const o = [];
                                        let i = t;
                                        for (let t = 0; t < r; t++) {
                                            const t = P(i, "i32"),
                                                r = P(i += tt, "i32");
                                            if (i += tt, t === at) o.push({
                                                type: "capture",
                                                name: a[r]
                                            });
                                            else if (t === ct) o.push({
                                                type: "string",
                                                value: c[r]
                                            });
                                            else if (o.length > 0) {
                                                if ("string" !== o[0].type) throw new Error("Predicates must begin with a literal value");
                                                const t = o[0].value;
                                                let r = !0;
                                                switch (t) {
                                                    case "not-eq?":
                                                        r = !1;
                                                    case "eq?":
                                                        if (3 !== o.length) throw new Error("Wrong number of arguments to `#eq?` predicate. Expected 2, got " + (o.length - 1));
                                                        if ("capture" !== o[1].type) throw new Error(`First argument of \`#eq?\` predicate must be a capture. Got "${o[1].value}"`);
                                                        if ("capture" === o[2].type) {
                                                            const t = o[1].name,
                                                                n = o[2].name;
                                                            h[e].push((function(e) {
                                                                let o, i;
                                                                for (const r of e) r.name === t && (o = r.node), r.name === n && (i = r.node);
                                                                return o.text === i.text === r
                                                            }))
                                                        } else {
                                                            const t = o[1].name,
                                                                n = o[2].value;
                                                            h[e].push((function(e) {
                                                                for (const o of e)
                                                                    if (o.name === t) return o.node.text === n === r;
                                                                return !1
                                                            }))
                                                        }
                                                        break;
                                                    case "not-match?":
                                                        r = !1;
                                                    case "match?":
                                                        if (3 !== o.length) throw new Error(`Wrong number of arguments to \`#match?\` predicate. Expected 2, got ${o.length-1}.`);
                                                        if ("capture" !== o[1].type) throw new Error(`First argument of \`#match?\` predicate must be a capture. Got "${o[1].value}".`);
                                                        if ("string" !== o[2].type) throw new Error(`Second argument of \`#match?\` predicate must be a string. Got @${o[2].value}.`);
                                                        const n = o[1].name,
                                                            i = new RegExp(o[2].value);
                                                        h[e].push((function(e) {
                                                            for (const t of e)
                                                                if (t.name === n) return i.test(t.node.text) === r;
                                                            return !1
                                                        }));
                                                        break;
                                                    case "set!":
                                                        if (o.length < 2 || o.length > 3) throw new Error(`Wrong number of arguments to \`#set!\` predicate. Expected 1 or 2. Got ${o.length-1}.`);
                                                        if (o.some((e => "string" !== e.type))) throw new Error('Arguments to `#set!` predicate must be a strings.".');
                                                        l[e] || (l[e] = {}), l[e][o[1].value] = o[2] ? o[2].value : null;
                                                        break;
                                                    case "is?":
                                                    case "is-not?":
                                                        if (o.length < 2 || o.length > 3) throw new Error(`Wrong number of arguments to \`#${t}\` predicate. Expected 1 or 2. Got ${o.length-1}.`);
                                                        if (o.some((e => "string" !== e.type))) throw new Error(`Arguments to \`#${t}\` predicate must be a strings.".`);
                                                        const s = "is?" === t ? u : d;
                                                        s[e] || (s[e] = {}), s[e][o[1].value] = o[2] ? o[2].value : null;
                                                        break;
                                                    default:
                                                        p[e].push({
                                                            operator: t,
                                                            operands: o.slice(1)
                                                        })
                                                }
                                                o.length = 0
                                            }
                                        }
                                        Object.freeze(l[e]), Object.freeze(u[e]), Object.freeze(d[e])
                                    }
                                    return Ze._free(r), new wt(et, n, a, h, p, Object.freeze(l), Object.freeze(u), Object.freeze(d))
                                }
                                static load(e) {
                                    let t;
                                    if (e instanceof Uint8Array) t = Promise.resolve(e);
                                    else {
                                        const n = e;
                                        if ("undefined" != typeof process && process.versions && process.versions.node) {
                                            const e = r(747);
                                            t = Promise.resolve(e.readFileSync(n))
                                        } else t = fetch(n).then((e => e.arrayBuffer().then((t => {
                                            if (e.ok) return new Uint8Array(t); {
                                                const r = new TextDecoder("utf-8").decode(t);
                                                throw new Error(`Language.load failed with status ${e.status}.\n\n${r}`)
                                            }
                                        }))))
                                    }
                                    const n = "function" == typeof loadSideModule ? loadSideModule : Ie;
                                    return t.then((e => n(e, {
                                        loadAsync: !0
                                    }))).then((e => {
                                        const t = Object.keys(e),
                                            r = t.find((e => lt.test(e) && !e.includes("external_scanner_")));
                                        r || console.log(`Couldn't find language function in WASM file. Symbols:\n${JSON.stringify(t,null,2)}`);
                                        const n = e[r]();
                                        return new bt(et, n)
                                    }))
                                }
                            }
                            class wt {
                                constructor(e, t, r, n, o, i, s, a) {
                                    Ct(e), this[0] = t, this.captureNames = r, this.textPredicates = n, this.predicates = o, this.setProperties = i, this.assertedProperties = s, this.refutedProperties = a, this.exceededMatchLimit = !1
                                }
                                delete() {
                                    Ze._ts_query_delete(this[0]), this[0] = 0
                                }
                                matches(e, t, r) {
                                    t || (t = it), r || (r = it), Tt(e), Ze._ts_query_matches_wasm(this[0], e.tree[0], t.row, t.column, r.row, r.column);
                                    const n = P(pt, "i32"),
                                        o = P(pt + tt, "i32"),
                                        i = P(pt + 2 * tt, "i32"),
                                        s = new Array(n);
                                    this.exceededMatchLimit = !!i;
                                    let a = 0,
                                        c = o;
                                    for (let t = 0; t < n; t++) {
                                        const r = P(c, "i32"),
                                            n = P(c += tt, "i32");
                                        c += tt;
                                        const o = new Array(n);
                                        if (c = Et(this, e.tree, c, o), this.textPredicates[r].every((e => e(o)))) {
                                            s[a++] = {
                                                pattern: r,
                                                captures: o
                                            };
                                            const e = this.setProperties[r];
                                            e && (s[t].setProperties = e);
                                            const n = this.assertedProperties[r];
                                            n && (s[t].assertedProperties = n);
                                            const i = this.refutedProperties[r];
                                            i && (s[t].refutedProperties = i)
                                        }
                                    }
                                    return s.length = a, Ze._free(o), s
                                }
                                captures(e, t, r) {
                                    t || (t = it), r || (r = it), Tt(e), Ze._ts_query_captures_wasm(this[0], e.tree[0], t.row, t.column, r.row, r.column);
                                    const n = P(pt, "i32"),
                                        o = P(pt + tt, "i32"),
                                        i = P(pt + 2 * tt, "i32"),
                                        s = [];
                                    this.exceededMatchLimit = !!i;
                                    const a = [];
                                    let c = o;
                                    for (let t = 0; t < n; t++) {
                                        const t = P(c, "i32"),
                                            r = P(c += tt, "i32"),
                                            n = P(c += tt, "i32");
                                        if (c += tt, a.length = r, c = Et(this, e.tree, c, a), this.textPredicates[t].every((e => e(a)))) {
                                            const e = a[n],
                                                r = this.setProperties[t];
                                            r && (e.setProperties = r);
                                            const o = this.assertedProperties[t];
                                            o && (e.assertedProperties = o);
                                            const i = this.refutedProperties[t];
                                            i && (e.refutedProperties = i), s.push(e)
                                        }
                                    }
                                    return Ze._free(o), s
                                }
                                predicatesForPattern(e) {
                                    return this.predicates[e]
                                }
                                didExceedMatchLimit() {
                                    return this.exceededMatchLimit
                                }
                            }

                            function xt(e, t, r) {
                                const n = r - t;
                                let o = e.textCallback(t, null, r);
                                for (t += o.length; t < r;) {
                                    const n = e.textCallback(t, null, r);
                                    if (!(n && n.length > 0)) break;
                                    t += n.length, o += n
                                }
                                return t > r && (o = o.slice(0, n)), o
                            }

                            function Et(e, t, r, n) {
                                for (let o = 0, i = n.length; o < i; o++) {
                                    const i = P(r, "i32"),
                                        s = kt(t, r += tt);
                                    r += rt, n[o] = {
                                        name: e.captureNames[i],
                                        node: s
                                    }
                                }
                                return r
                            }

                            function Ct(e) {
                                if (e !== et) throw new Error("Illegal constructor")
                            }

                            function St(e) {
                                return e && "number" == typeof e.row && "number" == typeof e.column
                            }

                            function Tt(e) {
                                let t = pt;
                                I(t, e.id, "i32"), I(t += tt, e.startIndex, "i32"), I(t += tt, e.startPosition.row, "i32"), I(t += tt, e.startPosition.column, "i32"), I(t += tt, e[0], "i32")
                            }

                            function kt(e, t = pt) {
                                const r = P(t, "i32");
                                if (0 === r) return null;
                                const n = P(t += tt, "i32"),
                                    o = P(t += tt, "i32"),
                                    i = P(t += tt, "i32"),
                                    s = P(t += tt, "i32"),
                                    a = new yt(et, e);
                                return a.id = r, a.startIndex = n, a.startPosition = {
                                    row: o,
                                    column: i
                                }, a[0] = s, a
                            }

                            function It(e, t = pt) {
                                I(t + 0 * tt, e[0], "i32"), I(t + 1 * tt, e[1], "i32"), I(t + 2 * tt, e[2], "i32")
                            }

                            function Pt(e) {
                                e[0] = P(pt + 0 * tt, "i32"), e[1] = P(pt + 1 * tt, "i32"), e[2] = P(pt + 2 * tt, "i32")
                            }

                            function At(e, t) {
                                I(e, t.row, "i32"), I(e + tt, t.column, "i32")
                            }

                            function Ot(e) {
                                return {
                                    row: P(e, "i32"),
                                    column: P(e + tt, "i32")
                                }
                            }

                            function Nt(e, t) {
                                At(e, t.startPosition), At(e += nt, t.endPosition), I(e += nt, t.startIndex, "i32"), I(e += tt, t.endIndex, "i32"), e += tt
                            }

                            function Rt(e) {
                                const t = {};
                                return t.startPosition = Ot(e), e += nt, t.endPosition = Ot(e), e += nt, t.startIndex = P(e, "i32"), e += tt, t.endIndex = P(e, "i32"), t
                            }
                            return gt.Language = bt, gt.Parser = gt, gt
                        }) ? n.apply(t, []) : n) || (e.exports = o)
                    },
                    94: (e, t, r) => {
                        const n = r(747),
                            o = r(622),
                            i = (e, t) => Array.from(Array(t).keys()).slice(e),
                            s = e => e.charCodeAt(0),
                            a = new TextDecoder("utf-8"),
                            c = e => a.decode(new Uint8Array(e));

                        function l(e) {
                            const t = new Set;
                            let r = e[0];
                            for (let n = 1; n < e.length; n++) {
                                const o = e[n];
                                t.add([r, o]), r = o
                            }
                            return t
                        }
                        const u = new TextEncoder("utf-8"),
                            d = /'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu;
                        let p = !1;
                        const h = {};
                        let f, m = {},
                            g = new Map,
                            _ = new Map;
                        const y = new Map;

                        function v() {
                            if (p) return;
                            m = JSON.parse(n.readFileSync(o.resolve(__dirname, "..", "dist", "tokenizer.json"))), Object.keys(m).map((e => {
                                h[m[e]] = e
                            }));
                            const e = n.readFileSync(o.resolve(__dirname, "..", "dist", "vocab.bpe"), "utf-8").split("\n"),
                                t = e.slice(1, e.length - 1).map((e => e.split(/(\s+)/).filter((function(e) {
                                    return e.trim().length > 0
                                }))));
                            f = ((e, t) => {
                                    const r = {};
                                    return e.map(((n, o) => {
                                        r[e[o]] = t[o]
                                    })), r
                                })(t, i(0, t.length)),
                                function(e) {
                                    const t = i(s("!"), s("~") + 1).concat(i(s(""), s("") + 1), i(s(""), s("") + 1));
                                    let r = t.slice(),
                                        n = 0;
                                    for (let e = 0; e < 256; e++) t.includes(e) || (t.push(e), r.push(256 + n), n += 1);
                                    r = r.map((e => (e => String.fromCharCode(e))(e)));
                                    for (let n = 0; n < t.length; n++) e.set(t[n], r[n])
                                }(g), g.forEach((function(e, t, r) {
                                    _.set(e, t)
                                })), p = !0
                        }

                        function b(e) {
                            if (y.has(e)) return y.get(e);
                            let t = (n = e, Array.from(u.encode(n))).map((e => g.get(e))),
                                r = l(t);
                            var n;
                            if (!r) return t.map((e => m[e]));
                            for (;;) {
                                const e = {};
                                Array.from(r).map((t => {
                                    const r = f[t];
                                    e[isNaN(r) ? 1e11 : r] = t
                                }));
                                const n = e[Math.min(...Object.keys(e).map((e => parseInt(e))))];
                                if (!(n in f)) break;
                                const o = n[0],
                                    i = n[1];
                                let s = [],
                                    a = 0;
                                for (; a < t.length;) {
                                    const e = t.indexOf(o, a);
                                    if (-1 === e) {
                                        Array.prototype.push.apply(s, t.slice(a));
                                        break
                                    }
                                    Array.prototype.push.apply(s, t.slice(a, e)), a = e, t[a] === o && a < t.length - 1 && t[a + 1] === i ? (s.push(o + i), a += 2) : (s.push(t[a]), a += 1)
                                }
                                if (t = s, 1 === t.length) break;
                                r = l(t)
                            }
                            return tokens = t.map((e => m[e])), y.set(e, tokens), tokens
                        }

                        function w(e) {
                            v();
                            let t = [];
                            const r = Array.from(e.matchAll(d)).map((e => e[0]));
                            for (let e of r) {
                                const r = b(e);
                                Array.prototype.push.apply(t, r)
                            }
                            return t
                        }

                        function x(e, t) {
                            if (t <= 0) return "";
                            let r = Math.min(e.length, 4 * t),
                                n = e.slice(-r),
                                o = w(n);
                            for (; o.length < t + 2 && r < e.length;) r = Math.min(e.length, r + 1 * t), n = e.slice(-r), o = w(n);
                            return o.length < t ? e : (o = o.slice(-t), E(o))
                        }

                        function E(e) {
                            v();
                            let t = e.map((e => h[e])).join("");
                            return t = c(t.split("").map((e => _.get(e)))), t
                        }
                        e.exports = {
                            prepareTokenizer: v,
                            tokenize: w,
                            tokenize_strings: function(e) {
                                return w(e).map((e => c(h[e].split("").map((e => _.get(e))))))
                            },
                            tokenLength: function(e) {
                                return w(e).length
                            },
                            takeLastTokens: x,
                            takeLastLinesTokens: function(e, t) {
                                const r = x(e, t);
                                if (r.length === e.length || "\n" === e[e.length - r.length - 1]) return r;
                                let n = r.indexOf("\n");
                                return r.substring(n + 1)
                            },
                            takeFirstTokens: function(e, t) {
                                if (t <= 0) return "";
                                let r = Math.min(e.length, 4 * t),
                                    n = e.slice(0, r),
                                    o = w(n);
                                for (; o.length < t + 2 && r < e.length;) r = Math.min(e.length, r + 1 * t), n = e.slice(0, r), o = w(n);
                                return o.length < t ? e : (o = o.slice(0, t), E(o))
                            },
                            detokenize: E
                        }
                    },
                    747: e => {
                        "use strict";
                        e.exports = r(7147)
                    },
                    622: e => {
                        "use strict";
                        e.exports = r(1017)
                    },
                    13: e => {
                        "use strict";
                        e.exports = r(1267)
                    }
                }, o = {}, i = function e(t) {
                    var r = o[t];
                    if (void 0 !== r) return r.exports;
                    var i = o[t] = {
                        exports: {}
                    };
                    return n[t].call(i.exports, i, i.exports, e), i.exports
                }(563), e.exports = i
            },
            9852: (e, t, r) => {
                const n = r(7147),
                    o = r(1017),
                    i = (e, t) => Array.from(Array(t).keys()).slice(e),
                    s = e => e.charCodeAt(0),
                    a = new TextDecoder("utf-8"),
                    c = e => a.decode(new Uint8Array(e));

                function l(e) {
                    const t = new Set;
                    let r = e[0];
                    for (let n = 1; n < e.length; n++) {
                        const o = e[n];
                        t.add([r, o]), r = o
                    }
                    return t
                }
                const u = new TextEncoder("utf-8");
                const d = /'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu;
                let p = !1;
                const h = {};
                let f, m = {},
                    g = new Map,
                    _ = new Map;
                const y = new Map;

                function v() {
                    if (p) return;
                    m = JSON.parse(n.readFileSync(o.resolve(__dirname, "..", "dist", "tokenizer.json"))), Object.keys(m).map((e => {
                        h[m[e]] = e
                    }));
                    const e = n.readFileSync(o.resolve(__dirname, "..", "dist", "vocab.bpe"), "utf-8").split("\n"),
                        t = e.slice(1, e.length - 1).map((e => e.split(/(\s+)/).filter((function(e) {
                            return e.trim().length > 0
                        }))));
                    f = ((e, t) => {
                            const r = {};
                            return e.map(((n, o) => {
                                r[e[o]] = t[o]
                            })), r
                        })(t, i(0, t.length)),
                        function(e) {
                            const t = i(s("!"), s("~") + 1).concat(i(s(""), s("") + 1), i(s(""), s("") + 1));
                            let r = t.slice(),
                                n = 0;
                            for (let e = 0; e < 256; e++) t.includes(e) || (t.push(e), r.push(256 + n), n += 1);
                            r = r.map((e => (e => String.fromCharCode(e))(e)));
                            for (let n = 0; n < t.length; n++) e.set(t[n], r[n])
                        }(g), g.forEach((function(e, t, r) {
                            _.set(e, t)
                        })), p = !0
                }

                function b(e) {
                    if (y.has(e)) return y.get(e);
                    let t = (n = e, Array.from(u.encode(n))).map((e => g.get(e))),
                        r = l(t);
                    var n;
                    if (!r) return t.map((e => m[e]));
                    for (;;) {
                        const e = {};
                        Array.from(r).map((t => {
                            const r = f[t];
                            e[isNaN(r) ? 1e11 : r] = t
                        }));
                        const n = e[Math.min(...Object.keys(e).map((e => parseInt(e))))];
                        if (!(n in f)) break;
                        const o = n[0],
                            i = n[1];
                        let s = [],
                            a = 0;
                        for (; a < t.length;) {
                            const e = t.indexOf(o, a);
                            if (-1 === e) {
                                Array.prototype.push.apply(s, t.slice(a));
                                break
                            }
                            Array.prototype.push.apply(s, t.slice(a, e)), a = e, t[a] === o && a < t.length - 1 && t[a + 1] === i ? (s.push(o + i), a += 2) : (s.push(t[a]), a += 1)
                        }
                        if (t = s, 1 === t.length) break;
                        r = l(t)
                    }
                    return tokens = t.map((e => m[e])), y.set(e, tokens), tokens
                }

                function w(e) {
                    v();
                    let t = [];
                    const r = Array.from(e.matchAll(d)).map((e => e[0]));
                    for (let e of r) {
                        const r = b(e);
                        Array.prototype.push.apply(t, r)
                    }
                    return t
                }

                function x(e, t) {
                    if (t <= 0) return "";
                    let r = Math.min(e.length, 4 * t),
                        n = e.slice(-r),
                        o = w(n);
                    for (; o.length < t + 2 && r < e.length;) r = Math.min(e.length, r + 1 * t), n = e.slice(-r), o = w(n);
                    return o.length < t ? e : (o = o.slice(-t), E(o))
                }

                function E(e) {
                    v();
                    let t = e.map((e => h[e])).join("");
                    return t = c(t.split("").map((e => _.get(e)))), t
                }
                e.exports = {
                    prepareTokenizer: v,
                    tokenize: w,
                    tokenize_strings: function(e) {
                        return w(e).map((e => c(h[e].split("").map((e => _.get(e))))))
                    },
                    tokenLength: function(e) {
                        return w(e).length
                    },
                    takeLastTokens: x,
                    takeLastLinesTokens: function(e, t) {
                        const r = x(e, t);
                        if (r.length === e.length || "\n" === e[e.length - r.length - 1]) return r;
                        let n = r.indexOf("\n");
                        return r.substring(n + 1)
                    },
                    takeFirstTokens: function(e, t) {
                        if (t <= 0) return "";
                        let r = Math.min(e.length, 4 * t),
                            n = e.slice(0, r),
                            o = w(n);
                        for (; o.length < t + 2 && r < e.length;) r = Math.min(e.length, r + 1 * t), n = e.slice(0, r), o = w(n);
                        return o.length < t ? e : (o = o.slice(0, t), E(o))
                    },
                    detokenize: E
                }
            },
            8028: e => {
                "use strict";
                e.exports = require("@opentelemetry/tracing")
            },
            9166: e => {
                "use strict";
                e.exports = require("applicationinsights-native-metrics")
            },
            9496: e => {
                "use strict";
                e.exports = require("vscode")
            },
            9491: e => {
                "use strict";
                e.exports = require("assert")
            },
            852: e => {
                "use strict";
                e.exports = require("async_hooks")
            },
            4300: e => {
                "use strict";
                e.exports = require("buffer")
            },
            2081: e => {
                "use strict";
                e.exports = require("child_process")
            },
            6206: e => {
                "use strict";
                e.exports = require("console")
            },
            2057: e => {
                "use strict";
                e.exports = require("constants")
            },
            6113: e => {
                "use strict";
                e.exports = require("crypto")
            },
            9523: e => {
                "use strict";
                e.exports = require("dns")
            },
            2361: e => {
                "use strict";
                e.exports = require("events")
            },
            7147: e => {
                "use strict";
                e.exports = require("fs")
            },
            3685: e => {
                "use strict";
                e.exports = require("http")
            },
            1995: e => {
                "use strict";
                e.exports = require("http2")
            },
            5687: e => {
                "use strict";
                e.exports = require("https")
            },
            8188: e => {
                "use strict";
                e.exports = require("module")
            },
            1808: e => {
                "use strict";
                e.exports = require("net")
            },
            2037: e => {
                "use strict";
                e.exports = require("os")
            },
            1017: e => {
                "use strict";
                e.exports = require("path")
            },
            2781: e => {
                "use strict";
                e.exports = require("stream")
            },
            9512: e => {
                "use strict";
                e.exports = require("timers")
            },
            4404: e => {
                "use strict";
                e.exports = require("tls")
            },
            6224: e => {
                "use strict";
                e.exports = require("tty")
            },
            7310: e => {
                "use strict";
                e.exports = require("url")
            },
            3837: e => {
                "use strict";
                e.exports = require("util")
            },
            1267: e => {
                "use strict";
                e.exports = require("worker_threads")
            },
            9796: e => {
                "use strict";
                e.exports = require("zlib")
            },
            5258: e => {
                "use strict";
                e.exports = JSON.parse('{"name":"@adobe/helix-fetch","version":"3.0.3","description":"Light-weight Fetch implementation transparently supporting both HTTP/1(.1) and HTTP/2","main":"src/index.js","scripts":{"test":" nyc --reporter=text --reporter=lcov --check-coverage --branches 100 --statements 100 --lines 100 mocha --recursive --timeout 5000","test-ci":"nyc --reporter=text --reporter=lcov --check-coverage --branches 100 --statements 100 --lines 100 mocha --recursive --timeout 5000 --reporter xunit --reporter-options output=./junit/test-results.xml && codecov","lint":"./node_modules/.bin/eslint .","semantic-release":"semantic-release"},"engines":{"node":">=12.0"},"types":"src/index.d.ts","exports":{"import":"./src/index.mjs","require":"./src/index.js"},"repository":{"type":"git","url":"https://github.com/adobe/helix-fetch"},"author":"","license":"Apache-2.0","bugs":{"url":"https://github.com/adobe/helix-fetch/issues"},"homepage":"https://github.com/adobe/helix-fetch#readme","keywords":["fetch","whatwg","Fetch API","http","https","http2","h2","promise","async","request","RFC 7234","7234","caching","cache"],"dependencies":{"debug":"4.3.3","http-cache-semantics":"4.1.0","lru-cache":"6.0.0"},"devDependencies":{"@adobe/eslint-config-helix":"1.3.2","@semantic-release/changelog":"6.0.1","@semantic-release/git":"10.0.1","chai":"4.3.6","chai-as-promised":"7.1.1","chai-iterator":"3.0.2","codecov":"3.8.3","eslint":"8.8.0","eslint-plugin-header":"3.1.1","eslint-plugin-import":"2.25.4","formdata-node":"4.3.2","lint-staged":"12.3.2","mocha":"9.2.0","nock":"13.2.2","nyc":"15.1.0","parse-cache-control":"1.0.1","pem":"1.14.6","semantic-release":"19.0.2","sinon":"13.0.0","stream-buffers":"3.0.2"},"lint-staged":{"*.js":"eslint"},"config":{"commitizen":{"path":"node_modules/cz-conventional-changelog"},"ghooks":{"pre-commit":"npx lint-staged"}}}')
            },
            4775: e => {
                "use strict";
                e.exports = JSON.parse('{"$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON AnySchema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}')
            },
            98: e => {
                "use strict";
                e.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}')
            },
            6157: e => {
                "use strict";
                e.exports = {
                    i8: "1.7.6"
                }
            },
            130: e => {
                "use strict";
                e.exports = {
                    i8: "0.2.0"
                }
            },
            2301: e => {
                "use strict";
                e.exports = {
                    i8: "1.3.7"
                }
            },
            4147: e => {
                "use strict";
                e.exports = JSON.parse('{"name":"copilot","displayName":"GitHub Copilot","description":"Your AI pair programmer","version":"1.31.6194","build":"6194","buildType":"prod","publisher":"GitHub","preview":false,"qna":"https://github.com/github-community/community/discussions/categories/copilot","icon":"assets/Copilot-App-Icon.png","engines":{"vscode":"^1.67.0","npm":">=7.0.0"},"categories":["Other"],"badges":[{"url":"https://img.shields.io/badge/GitHub%20Copilot-Subscription%20Required-orange","href":"https://github.com/github-copilot/signup","description":"Sign up for GitHub Copilot"}],"activationEvents":["onStartupFinished"],"main":"./dist/extension","enabledApiProposals":["inlineCompletionsNew","inlineCompletionsAdditions"],"contributes":{"commands":[{"command":"github.copilot.generate","title":"Open GitHub Copilot"},{"command":"github.copilot.toggleCopilot","title":"GitHub Copilot: Configure Enabled/Disabled"},{"command":"github.copilot.sendFeedback","title":"GitHub Copilot: Send Feedback"}],"keybindings":[{"command":"github.copilot.generate","key":"ctrl+enter","mac":"ctrl+enter","when":"editorTextFocus && github.copilot.activated"},{"command":"editor.action.inlineSuggest.trigger","key":"alt+\\\\","when":"editorTextFocus && !editorHasSelection && config.github.copilot.inlineSuggest.enable && !inlineSuggestionsVisible"}],"menus":{"editor/inlineCompletions/actions":[{"command":"github.copilot.generate","when":"github.copilot.activated"}],"commandPalette":[{"command":"github.copilot.generate","when":"github.copilot.activated"},{"command":"github.copilot.toggleCopilot","when":"github.copilot.activated"},{"command":"github.copilot.sendFeedback","when":"github.copilot.activated"}]},"configuration":[{"title":"Copilot","properties":{"github.copilot.advanced":{"type":"object","title":"Advanced Settings","properties":{"secret_key":{"type":"string","default":"","description":"Secret API key"},"length":{"type":"integer","default":500,"description":"Length of code to generate in tokens"},"temperature":{"type":"string","default":"","description":"Override sampling temperature (range 0.0 - 1.0)"},"top_p":{"type":"number","default":1,"description":"Top probability mass to consider"},"stops":{"type":"object","default":{"*":["\\n\\n\\n"],"python":["\\ndef ","\\nclass ","\\nif ","\\n\\n#"]},"description":"Configure per-language stop sequences"},"indentationMode":{"type":"object","default":{"python":false,"javascript":false,"javascriptreact":false,"jsx":false,"typescript":false,"typescriptreact":false,"go":false,"ruby":false,"*":true},"markdownDescription":"Enable or disable indentation block termination for specified [languages](https://code.visualstudio.com/docs/languages/identifiers)."},"inlineSuggestCount":{"type":"integer","default":3,"description":"Number of inline suggestions to fetch"},"listCount":{"type":"integer","default":10,"description":"Number of solutions to list in Open GitHub Copilot"},"debug.showScores":{"type":"boolean","default":false,"description":"Show scores in sorted solutions"},"debug.overrideEngine":{"type":"string","default":"","description":"Override engine name"},"debug.overrideProxyUrl":{"type":"string","default":"","description":"Override GitHub authentication proxy full URL"},"debug.testOverrideProxyUrl":{"type":"string","default":"","description":"Override GitHub authentication proxy URL when running tests"},"debug.filterLogCategories":{"type":"array","default":[],"description":"Show only log categories listed in this setting. If an array is empty, show all loggers"}}},"github.copilot.enable":{"type":"object","default":{"*":true,"yaml":false,"plaintext":false,"markdown":false},"markdownDescription":"Enable or disable Copilot for specified [languages](https://code.visualstudio.com/docs/languages/identifiers)"},"github.copilot.inlineSuggest.enable":{"type":"boolean","default":true,"description":"Show inline suggestions"}}}],"icons":{"copilot-logo":{"description":"GitHub Copilot icon","default":{"fontPath":"assets/copilot.woff","fontCharacter":"\\\\0041"}},"copilot-warning":{"description":"GitHub Copilot icon","default":{"fontPath":"assets/copilot.woff","fontCharacter":"\\\\0042"}},"copilot-notconnected":{"description":"GitHub Copilot icon","default":{"fontPath":"assets/copilot.woff","fontCharacter":"\\\\0043"}}},"iconFonts":[{"id":"copilot-font","src":[{"path":"assets/copilot.woff","format":"woff"}]}]},"scripts":{"postinstall":"npx vscode-dts dev && mv vscode.proposed.*.ts extension/src","vscode:prepublish":"npm-run-all build:extension","build":"npm-run-all build:*","build:agent":"cd agent && npm run build","build:agent-no-pkg":"cd agent && npm run build-no-pkg","build:extension":"webpack --mode production","build:lib":"cd lib && npm run build","compile":"npm-run-all compile:*","compile:agent":"cd agent && npm run compile","compile:extension":"webpack --mode development","compile:lib":"cd lib && npm run compile","watch":"npm-run-all -p watch:*","watch:agent":"cd agent && npm run watch","watch:extension":"webpack --mode development --watch","watch:lib":"cd lib && npm run watch","lint":"eslint lib extension agent --ext ts","check_deps":"depcruise -c .dependency-cruiser.js .","test":"npm-run-all test:*","test:agent":"cd agent && npm run test","test:extension":"cd extension && ts-node ./test/runTest.ts","test:prompt":"cd prompt && npm install && npm run test","test:lib":"cd lib && npm run test","test:lsp-client":"cd lsp-client && npm run start","build_test":"tsc extension/test/run.ts","get_token":"ts-node script/getToken.ts","lsp-sample:compile":"cd lsp-sample && npm run compile","lsp-sample:watch":"cd lsp-sample && npm run watch","lsp-sample:develop":"npm-run-all -p lsp-sample:watch watch:agent"},"devDependencies":{"@github/prettier-config":"0.0.4","@types/crypto-js":"^4.0.1","@types/mocha":"^5.2.6","@types/node":"^13.11.0","@types/uuid":"^8.3.1","@types/vscode":"^1.65.0","@typescript-eslint/eslint-plugin":"^4.27.0","@typescript-eslint/parser":"^4.27.0","axios":"^0.21.4","dependency-cruiser":"^9.26.1","eslint":"^7.29.0","eslint-plugin-no-only-tests":"^2.6.0","fantasticon":"^1.2.2","mocha":"^6.1.4","npm-run-all":"^4.1.5","prettier":"2.5.1","prettier-plugin-organize-imports":"^2.3.4","ts-dedent":"^2.2.0","ts-loader":"^8.0.11","ts-node":"^9.0.0","typescript":"^4.4.3","vsce":"1.91.0","vscode-dts":"^0.3.2","vscode-test":"^1.3.0","webpack":"^5.54.0","webpack-cli":"^4.2.0","zlib":"^1.0.5"},"dependencies":{"@adobe/helix-fetch":"^3.0.3","@github/copilot-promptlib":"file:prompt","@sinclair/typebox":"^0.23.4","ajv":"^8.6.3","ajv-errors":"^3.0.0","crypto-js":"^4.0.0","get-port":"^5.1.1","highlight.js":"^11.3.1","ip-regex":"^4.3.0","open":"^8.4.0","source-map-support":"^0.5.19","uuid":"^8.3.2","vscode-extension-telemetry":"^0.1.6","vscode-uri":"^3.0.2"}}')
            }
        },
        t = {};

    function r(n) {
        var o = t[n];
        if (void 0 !== o) return o.exports;
        var i = t[n] = {
            id: n,
            loaded: !1,
            exports: {}
        };
        return e[n].call(i.exports, i, i.exports, r), i.loaded = !0, i.exports
    }
    r.n = e => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return r.d(t, {
            a: t
        }), t
    }, r.d = (e, t) => {
        for (var n in t) r.o(t, n) && !r.o(e, n) && Object.defineProperty(e, n, {
            enumerable: !0,
            get: t[n]
        })
    }, r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), r.r = e => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }, r.nmd = e => (e.paths = [], e.children || (e.children = []), e);
    var n = {};
    (() => {
        "use strict";
        var e = n;
        Object.defineProperty(e, "__esModule", {
            value: !0
        }), e.deactivate = e.activate = e.init = void 0;
        const t = r(3055);
        r(406);
        const o = r(9496),
            i = r(362),
            s = r(299),
            a = r(1133),
            c = r(4197),
            l = r(7870),
            u = r(9408),
            d = r(1839),
            p = r(9189),
            h = r(9748),
            f = r(5413),
            m = r(9899),
            g = r(2279),
            _ = r(1547),
            y = r(4419),
            v = r(6722),
            b = r(2533),
            w = r(766),
            x = r(6333),
            E = r(956),
            C = r(70),
            S = r(8771),
            T = r(6403),
            k = r(3136),
            I = r(7057),
            P = r(3197),
            A = r(1862),
            O = r(9425),
            N = r(3060),
            R = (r(1929), r(6267)),
            $ = r(2990),
            M = r(6857),
            D = r(7254),
            L = r(4428),
            F = r(8129),
            j = r(385),
            B = o.window.createOutputChannel("GitHub Copilot");

        function q() {
            (0, g.init)((new a.BuildInfo).getVersion())
        }

        function U(e, t, r) {
            return o.commands.registerCommand(t, (async (...n) => {
                try {
                    return await r(...n)
                } catch (r) {
                    x.telemetryException(e, r, t)
                }
            }))
        }
        let H;
        e.init = q, q(), e.activate = async function(e) {
            const r = new l.Context;
            r.set(a.ConfigProvider, new O.VSCodeConfigProvider), r.set(s.Clock, new s.Clock), r.set(a.BuildInfo, new a.BuildInfo), r.set(a.EditorAndPluginInfo, new O.VSCodeEditorInfo), r.set(m.LogVerbose, new m.LogVerbose(!1)), r.set(f.GhostTextDebounceManager, new f.GhostTextDebounceManager);
            const n = new m.MultiLog([new m.ConsoleLog(console), new m.OutputChannelLog(B)]);
            r.set(m.LogTarget, n), r.set(T.LocationFactory, new F.ExtensionLocationFactory), r.set(k.TextDocumentManager, new j.ExtensionTextDocumentManager), r.set(p.Features, new p.Features(r)), r.set(g.Fetcher, new g.HelixFetcher(r)), r.set(t.FileSystem, M.extensionFileSystem), r.set(_.NotificationSender, new A.ExtensionNotificationSender), r.set(x.TelemetryEndpointUrlOverride, x.telemetryEndpointUrlOverride), e.extensionMode === o.ExtensionMode.Test ? (r.set(i.CopilotTokenManager, (0, E.makeTestingCopilotTokenManager)()), r.set(a.VscInfo, (0, a.getTestVscInfo)()), r.set(C.RuntimeMode, C.RuntimeMode.fromEnvironment(!0)), r.set(h.ExpConfigMaker, new h.ExpConfigNone), r.set(x.TelemetryReporters, x.setupStandardReporters(r, "copilot-test")), r.set(I.UrlOpener, new S.TestUrlOpener)) : (r.set(i.CopilotTokenManager, new A.VSCodeCopilotTokenManager), r.set(a.VscInfo, (0, O.makeVscInfo)()), r.set(y.OpenAIFetcher, new y.LiveOpenAIFetcher), r.set(a.BlockModeConfig, new a.ConfigBlockModeConfig), r.set(C.RuntimeMode, C.RuntimeMode.fromEnvironment(!1)), r.set(h.ExpConfigMaker, new h.ExpConfigFromTAS), r.set(x.TelemetryReporters, L.activate(r, e)), r.set(I.UrlOpener, new I.RealUrlOpener)), "GitHub.copilot-nightly" === e.extension.id && (0, u.registerDefaultHandlers)(r, "vscode"), (0, O.setExtension)(e.extension), (0, A.setExtensionContext)(e), e.globalState.setKeysForSync([A.telemetryAcceptanceKey]);
            const q = (0, a.getBuildType)(r) === a.BuildType.DEV,
                G = "GitHub.copilot-nightly" === e.extension.id;
            if (G && o.extensions.all.find((e => "GitHub.copilot" === e.id))) return void("Uninstall" === await o.window.showWarningMessage("To use GitHub Copilot Nightly you need to uninstall GitHub Copilot extension", "Uninstall") && await o.commands.executeCommand("workbench.extensions.uninstallExtension", "GitHub.copilot"));
            (G || q) && o.commands.executeCommand("setContext", "github.copilot.nightly", !0);
            const z = function(e, t) {
                const r = new D.CopilotStatusBar(e);
                return t.subscriptions.push(U(e, N.CMDToggleCopilot, (() => {
                    r.toggleStatusBar()
                }))), t.subscriptions.push(U(e, N.CMDShowActivationErrors, (() => {
                    r.showActivationErrors(B)
                }))), t.subscriptions.push(r.getStatusBarItem()), r
            }(r, e);
            r.set(v.StatusReporter, z);
            try {
                await r.get(i.CopilotTokenManager).getCopilotToken(r)
            } catch (e) {
                const t = e.message || e;
                x.telemetryError(r, "activationFailed", x.TelemetryData.createAndMarkAsIssued({
                    reason: t
                })), r.get(x.TelemetryReporters).deactivate();
                const n = `GitHub Copilot could not connect to server. Extension activation failed: "${t}"`;
                return z.setError(n), m.logger.error(r, n), void o.commands.executeCommand("setContext", "github.copilot.activated", !1)
            }
            o.commands.executeCommand("setContext", "github.copilot.activated", !0), e.subscriptions.push(U(r, N.CMDOpenPanel, (() => {
                o.commands.executeCommand("editor.action.inlineSuggest.hide"), (0, R.commandOpenPanel)(r)
            }))), e.subscriptions.push(U(r, N.CMDOpenPanelForRange, (e => {
                (0, R.commandOpenPanel)(r, e)
            })), U(r, N.CMDAcceptPanelSolution, (async (e, t, r, n, i) => {
                const s = new o.WorkspaceEdit;
                if (s.insert(e, t, r), await o.workspace.applyEdit(s), i(), await o.commands.executeCommand("workbench.action.closeActiveEditor"), n && o.window.activeTextEditor && o.window.activeTextEditor.document.uri.toString() === e.toString()) {
                    const e = t.translate(1).with(void 0, 0),
                        r = new o.Selection(e, e);
                    o.window.activeTextEditor.selection = r
                }
            }))), e.subscriptions.push(U(r, N.CMDSendFeedback, (() => {
                o.env.openExternal(o.Uri.parse("https://github.com/github/feedback/discussions/categories/copilot-feedback"))
            })));
            const V = new $.CopilotPanel(r);
            e.subscriptions.push(o.workspace.registerTextDocumentContentProvider(c.CopilotScheme, V), o.languages.registerCodeLensProvider({
                scheme: c.CopilotScheme
            }, V));
            try {
                e.subscriptions.push(...(0, P.registerGhostText)(r));
                const t = o.workspace.getConfiguration(),
                    n = t.inspect("editor.inlineSuggest.enabled");
                void 0 === (null == n ? void 0 : n.globalValue) && t.update("editor.inlineSuggest.enabled", !0, o.ConfigurationTarget.Global)
            } catch (e) {
                o.window.showErrorMessage("GitHub Copilot requires VS Code 1.57+. Please update your VS Code")
            }
            e.subscriptions.push((0, d.registerDocumentTracker)(r)), e.subscriptions.push(o.window.onDidChangeActiveTextEditor((e => e ? e.document.isUntitled || "file" === e.document.uri.scheme && (0, w.extractRepoInfoInBackground)(r, e.document.uri.toString()) : void 0)));
            const W = e.extensionMode !== o.ExtensionMode.Development;
            b.init(r, W, new m.Logger(m.LogLevel.INFO, "promptlib proxy")), x.telemetry(r, "extension.activate"), H = r
        }, e.deactivate = function() {
            H && (x.telemetry(H, "extension.deactivate"), H.get(x.TelemetryReporters).deactivate()), b.terminate()
        }
    })(), module.exports = n
})();
//# sourceMappingURL=extension.js.map
